<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2023-07-21T11:16:18.529Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security PDF 教程来啦～</title>
    <link href="http://www.javaboy.org/2023/0504/spring_security_pdf.html"/>
    <id>http://www.javaboy.org/2023/0504/spring_security_pdf.html</id>
    <published>2023-05-04T11:00:59.000Z</published>
    <updated>2023-07-21T11:16:18.529Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列其实更完了好久了，我也做了相应的文章索引，不过之前误删了几篇文章，导致有的小伙伴在线学习的时候，文章链接打不开，索性，还是整个 PDF 吧，然后把最近更新的几篇关于 Spring Security 的文章也收录进去了，方便大家学习。</p><a id="more"></a><p>我们来看下目录：</p><p><img src="http://img.itboyhub.com/2022/08/20230428190906.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428190944.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191022.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191116.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191158.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191236.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191308.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191421.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191506.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230428191542.png" alt></p><p><strong>就不废话了，大家公众号后台回复 ss 可以直接获取 PDF 下载链接。</strong></p><p>当然，如果觉得 PDF 看不过瘾，也可以看看松哥之前在清华大学出版社出版的这本书：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列其实更完了好久了，我也做了相应的文章索引，不过之前误删了几篇文章，导致有的小伙伴在线学习的时候，文章链接打不开，索性，还是整个 PDF 吧，然后把最近更新的几篇关于 Spring Security 的文章也收录进去了，方便大家学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>说一个大家都知道的 Spring Boot 小细节！</title>
    <link href="http://www.javaboy.org/2023/0428/springboot_maven.html"/>
    <id>http://www.javaboy.org/2023/0428/springboot_maven.html</id>
    <published>2023-04-28T11:00:41.000Z</published>
    <updated>2023-07-21T11:16:11.006Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们知道，我们在创建 Spring Boot 项目的时候，默认都会有一个 parent，这个 parent 中帮我们定了项目的 JDK 版本、编码格式、依赖版本、插件版本等各种常见内容，有的小伙伴可能看过 parent 的源码，这个源码里边有这么一个配置：</p><a id="more"></a><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先小伙伴们知道，这个配置文件的目的主要是为了描述在 maven 打包的时候要不要带上这几个配置文件，但是咋一看，又感觉上面这段配置似乎有点矛盾，松哥来和大家捋一捋就不觉得矛盾了：</p><ol><li>先来看第一个 resource，directory 就是项目的 resources 目录，includes 中就是我们三种格式的配置文件，另外还有一个 filtering 属性为 true，这是啥意思呢？这其实是说我们在 maven 的 pom.xml 文件中定义的一些变量，可以在 includes 所列出的配置文件中进行引用，也就是说 includes 中列出来的文件，可以参与到项目的编译中。</li><li>第二个 resource，没有 filter，并且将这三个文件排除了，意思是项目在打包的过程中，除了这三类文件之外，其余文件直接拷贝到项目中，不会参与项目编译。</li></ol><p><strong>总结一下就是 resources 下的所有文件都会被打包到项目中，但是列出来的那三类，不仅会被打包进来，还会参与编译。</strong></p><p>这下就清晰了，上面这段配置实际上并不矛盾。</p><p>那么在 properties 或者 yaml 中，该如何引用 maven 中的变量呢？</p><p>这块原本的写法是使用 <code>$</code> 符号来引用，但是，我们在 properties 配置文件中，往往用 <code>$</code> 符号来引用当前配置文件的另外一个 key，所以，我们在 Spring Boot 的 parent 中，还会看到下面这行配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">resource.delimiter</span>&gt;</span>@<span class="hljs-tag">&lt;/<span class="hljs-name">resource.delimiter</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>&lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt;</code> 就表示将资源引用的符号改为 <code>@</code> 符号。也就是在 yaml 或者 properties 文件中，如果我们想引用 pom.xml 中定义的变量，就可以通过 <code>@</code> 符号来引用。</p><p>松哥举一个简单的例子，假设我想在项目的 yaml 文件中配置当前项目的 Java 版本，那么我就可以像下面这样写：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">app:</span></span><br><span class="line"><span class="hljs-attr">  java:</span></span><br><span class="line"><span class="hljs-attr">    version:</span> <span class="hljs-string">@java.version@</span></span><br></pre></td></tr></table></figure><p>这里的 <a href="mailto:`@java.version" target="_blank" rel="noopener">`@java.version</a>@<code>就表示引用了 pom.xml 中定义的</code>java.version` 变量。</p><p>现在我们对项目进行编译，编译之后再打开 application.yaml，内容如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230427224326.png" alt></p><p>可以看到，引用的变量已经被替换了。</p><p>按照 Spring Boot parent 中默认的配置，application<em>.yaml、application</em>.yml 以及 application*.properties 文件中可以引用 pom.xml 中定义的变量，其他文件则不可以。如果其他文件也想引用，就要额外配置一下。</p><p>例如，想让 txt 文件引用 pom.xml 中的变量，我们可以在 pom.xml 中做如下配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.txt<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>include 所有的 txt 文件，并且设置 filtering 为 true（不设置默认为 false），然后我们就可以在 resources 目录下的 txt 文件中引用 pom.xml 中的变量了，像下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/20230427230953.png" alt></p><p>编译之后，这个变量引用就会被替换成真正的值：</p><p><img src="http://img.itboyhub.com/2022/08/20230427231044.png" alt></p><p>在 yaml 中引用 pom.xml 的配置，有一个非常经典的用法，就是多环境切换。</p><p>假设我们现在项目中有开发环境、测试环境以及生产环境，对应的配置文件分别是：</p><ul><li>application-dev.yaml</li><li>application-test.yaml</li><li>application-prod.yaml</li></ul><p>我们可以在 application.yaml 中指定具体使用哪个配置文件，像下面这样：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  profiles:</span></span><br><span class="line"><span class="hljs-attr">    active:</span> <span class="hljs-string">dev</span></span><br></pre></td></tr></table></figure><p>这个表示使用开发环境的配置文件。</p><p>但是有时候我们的环境信息是配置在 pom.xml 中的，例如 pom.xml 中包含如下内容：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">package.environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">package.environment</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!-- 是否默认 true表示默认--&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">package.environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">package.environment</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">package.environment</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">package.environment</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里配置了三个环境，其中默认是 dev（activeByDefault）。那么我们在 application.yaml 中就可以使用 package.environment 来引用当前环境的名称，而不用硬编码。如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  profiles:</span></span><br><span class="line"><span class="hljs-attr">    active:</span> <span class="hljs-string">@package.environment@</span></span><br></pre></td></tr></table></figure><p>此时，我们通过 maven 命令对项目打包时，就可以指定当前环境的版本了，例如使用 test 环境，打包命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Ptest</span><br></pre></td></tr></table></figure><p>打包之后我们去看 application.yaml，就会发现里边的环境已经是 test 了。</p><p>如果你使用的是 IDEA，则也可以手动勾选环境之后点击打包按钮，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230427232105.png" alt></p><p>可以先勾选上面的环境信息，再点击下面的打包。</p><p>好啦，一个小小知识点，因为有小伙伴在微信上问这个问题，就拿出来和大家分享下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们知道，我们在创建 Spring Boot 项目的时候，默认都会有一个 parent，这个 parent 中帮我们定了项目的 JDK 版本、编码格式、依赖版本、插件版本等各种常见内容，有的小伙伴可能看过 parent 的源码，这个源码里边有这么一个配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>索引合并，能不用就不要用吧！</title>
    <link href="http://www.javaboy.org/2023/0427/mysql_index_merge.html"/>
    <id>http://www.javaboy.org/2023/0427/mysql_index_merge.html</id>
    <published>2023-04-27T11:00:27.000Z</published>
    <updated>2023-07-21T11:16:14.886Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在前面的文章中，松哥和小伙伴们分享了 MySQL 中，InnoDB 存储引擎的数据结构，小伙伴们知道，当我们使用索引进行搜索的时候，每一次的搜索都是在某一棵 B+Tree 中搜索的，如果使用了二级索引的话，可能还会涉及到回表。</p><a id="more"></a><p>那么现在问题来了，如果我们的搜索条件中包含两个字段，且这两个字段都有独立的索引，那么 MySQL 会怎么处理？今天我们就来讨论下这个话题。</p><h2 id="1-问题重现"><a href="#1-问题重现" class="headerlink" title="1. 问题重现"></a>1. 问题重现</h2><p>为了方便小伙伴们理解，我先通过 SQL 来把我的问题重复一下。</p><p>我使用的测试数据是 MySQL 官网提供的测试数据，相关的介绍文档在：</p><ul><li><a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/employee/en/</a></li></ul><p>相应的数据库脚本在：</p><ul><li><a href="https://github.com/datacharmer/test_db" target="_blank" rel="noopener">https://github.com/datacharmer/test_db</a></li></ul><p>小伙伴们可以自行下载这个数据库脚本并导入到自己的数据库之中。</p><p>在官方提供的案例中，有一个这样的表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`film_actor`</span> (</span><br><span class="line">  <span class="hljs-string">`actor_id`</span> <span class="hljs-built_in">smallint</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`film_id`</span> <span class="hljs-built_in">smallint</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`last_update`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`actor_id`</span>,<span class="hljs-string">`film_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_fk_film_id`</span> (<span class="hljs-string">`film_id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb3;</span><br></pre></td></tr></table></figure><p>在这个表中有两个索引，其中一个是主键索引，主键索引是一个联合索引，还有一个是根据 film_id 建立的普通索引。现在假设我有如下 SQL 需要执行：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> actor_id=<span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><p>那么问题来了，这个查询会用到索引吗？</p><p>想知道有没有用到索引，用 explain 关键字看一下就知道了：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> actor_id=<span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230425233021.png" alt></p><p>小伙伴们看到，此时 <code>type</code> 是 <code>index_merge</code>，<code>possible_keys</code> 和 <code>key</code> 中，都给出来了两个索引，<code>Extra</code> 中的值为 <code>Using union(idx_fk_film_id,PRIMARY); Using where</code>。</p><p>看起来是用了索引，但是具体是怎么用的，这个执行计划该如何解读呢？</p><p>这个其实就是一个索引合并，接下来我们就来看下到底什么是索引合并。</p><h2 id="2-索引合并"><a href="#2-索引合并" class="headerlink" title="2. 索引合并"></a>2. 索引合并</h2><p>index_merge 表示索引合并，当同一个表中的搜索条件中同时存在多个索引的时候，MySQL 会分别对这些索引进行扫描，然后将扫描结果进行合并，合并分三种情况：</p><ol><li>对各自扫描结果求并集（unions）。</li><li>对各自扫描结果求交集（intersections）。</li><li>前两者的组合。</li></ol><p>在官方文档中给了四个可能会用到索引合并的例子：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> key2 = <span class="hljs-number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="hljs-keyword">WHERE</span> (key1 = <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> key2 = <span class="hljs-number">20</span>) <span class="hljs-keyword">AND</span> non_key = <span class="hljs-number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="hljs-keyword">WHERE</span> (t1.key1 <span class="hljs-keyword">IN</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">OR</span> t1.key2 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'value%'</span>)</span><br><span class="line">  <span class="hljs-keyword">AND</span> t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="hljs-keyword">WHERE</span> t1.key1 = <span class="hljs-number">1</span></span><br><span class="line">  <span class="hljs-keyword">AND</span> (t2.key1 = t1.some_col <span class="hljs-keyword">OR</span> t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure><p>有的时候，我们写的 SQL，明明可以合并，但是系统却没有合并，此时我们对查询条件做一些调整，例如：</p><ul><li><code>(x AND y) OR z =&gt; (x OR z) AND (y OR z)</code></li><li><code>(x OR y) AND z =&gt; (x AND z) OR (y AND z)</code></li></ul><blockquote><p>另外需要注意的是，索引合并不适用于全文索引。</p></blockquote><p>在 explain 执行计划中，如果用到了索引合并，Extra 字段的值一般分为三种情况，分别是：</p><ul><li>Using intersect(…)</li><li>Using union(…)</li><li>Using sort_union(…)</li></ul><p>上文案例属于第二种情况。</p><p>那么接下来把这三种情况都来和小伙伴们聊一下。</p><h3 id="2-1-Using-intersect-…"><a href="#2-1-Using-intersect-…" class="headerlink" title="2.1 Using intersect(…)"></a>2.1 Using intersect(…)</h3><p>这个就是对多个扫描结果求交集。</p><p>并不是只要涉及到多个索引，且是 AND，就会触发 <code>Using intersect</code>，有两个条件：</p><ol><li>如果是二级索引，则必须是等值查询。如果二级索引是复合索引，则复合索引的每一列都必须覆盖到，不能只是其中的某几列。</li><li>主键索引可以是范围查询。</li></ol><p>我们来看官方给出的一个例子，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN</span><br></pre></td></tr></table></figure><p><code>key_part1</code> - <code>key_partN</code> 就是复合索引中的所有列（必须是所有列）。</p><p>对于第 2 点，如果涉及到主键索引，则主键索引可以是范围查询，例如下面这样（但是二级索引依然只能是等值查询）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> innodb_table <span class="hljs-keyword">WHERE</span> primary_key &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> key_col1 = <span class="hljs-number">20</span>;</span><br></pre></td></tr></table></figure><p>如果是复合索引和普通索引，那么复合索引必须覆盖到所有列且复合索引和普通索引都要是等值匹配才可以，例如下面这样：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> key1_part1 = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> key1_part2 = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> key2 = <span class="hljs-number">2</span>;</span><br></pre></td></tr></table></figure><p><code>key1_part1</code> 和 <code>key1_part2</code> 分别表示同一个复合索引的第一列和第二列（一共就两列），此时和 key2 一起作为查询条件，也有可能会用到索引合并。</p><p>上面这些情况都是在各自搜索完成之后求交集。</p><p>举一个简单的例子吧，还是 MySQL 官方的测试数据，sakila 库中有一个 actor 表，该表结构如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`actor`</span> (</span><br><span class="line">  <span class="hljs-string">`actor_id`</span> <span class="hljs-built_in">smallint</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`first_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`last_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`last_update`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`actor_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_actor_last_name`</span> (<span class="hljs-string">`last_name`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">201</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb3;</span><br></pre></td></tr></table></figure><p>可以看到，有一个主键，有一个普通索引，我执行如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> actor_id&lt;<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> last_name=<span class="hljs-string">'WAHLBERG'</span></span><br></pre></td></tr></table></figure><p>执行计划如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230426211446.png" alt></p><p>可以看到，用到了索引合并，且是 <code>Using intersect</code>。</p><h3 id="2-2-Using-union-…"><a href="#2-2-Using-union-…" class="headerlink" title="2.2 Using union(…)"></a>2.2 Using union(…)</h3><p>求并集的跟求交集的比较像，就是 AND 变成了 OR。</p><p>当二级索引是等值查询，或者是组合索引，但是要求组合索引的每一列都必须覆盖到，不能只是覆盖到部分列，例如下面这个查询条件：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = const1 OR key_part2 = const2 ... OR key_partN = constN</span><br></pre></td></tr></table></figure><p>key_part1~key_partN 就是同一个复合索引的不同列，同时在该复合索引中，也一共就只有这 N 个字段，这种情况就会用到 <code>Using union</code>。</p><p>InnoBD 表上的主键范围查询也有可能会触发 <code>Using union</code>。</p><p>符合 2.1 小节的情况，将 AND 换成 OR 之后，也有可能会触发 <code>Using union</code>。</p><p>这个例子就不用举了，文章一开始的就是。</p><h3 id="2-3-Using-sort-union-…"><a href="#2-3-Using-sort-union-…" class="headerlink" title="2.3 Using sort_union(…)"></a>2.3 Using sort_union(…)</h3><p>很明显，2.2 小节的条件比较苛刻，二级索引必须是等值查询才能触发 <code>Using union</code>，而我们日常使用的时候，范围查询也是非常常见的，所以又有了 <code>Using sort_union</code>，这个的要求就宽松一些了：</p><ul><li>二级索引也可以按照范围匹配</li><li>复合索引也不用覆盖所有列</li></ul><p>举个例子，如下面的 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="hljs-keyword">WHERE</span> key_col1 &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> key_col2 &lt; <span class="hljs-number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="hljs-keyword">WHERE</span> (key_col1 &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> key_col2 = <span class="hljs-number">20</span>) <span class="hljs-keyword">AND</span> nonkey_col = <span class="hljs-number">30</span>;</span><br></pre></td></tr></table></figure><p>二级索引范围搜索，也有可能触发 <code>Using sort_union</code> 的。</p><h3 id="2-4-索引合并原理"><a href="#2-4-索引合并原理" class="headerlink" title="2.4 索引合并原理"></a>2.4 索引合并原理</h3><p>在 2.1 小节和 2.2 小节，分别是求交集和求并集，为了 intersect 和 union 操作方便，在各个单独的索引扫描的时候，都是要获取到有序的主键值的合集，各个索引都获取到有序的主键，然后求交集或者并集就会比较方便。</p><p>因此，在 2.1 和 2.2 小节，都是主键索引可以范围搜索，因为主键索引本身主键就是有序的；二级索引则有诸多限制，这诸多限制的最终目的都是为了做到最终拿到的主键值是有序的。</p><p>例如：</p><ul><li>二级索引必须等值匹配，等值匹配意味着最终拿到的 B+Tree 的叶子上的主键值就是唯一的；二级索引如果可以按照范围查找，那么最终从二级索引的 B+Tree 的叶子结点上拿到的主键值就不是有序的了。</li><li>类似的，复合索引必须覆盖到所有列也是相似的原因，因为如果没有覆盖到所有列，意味着最终拿到的主键值也是无序的。</li></ul><p>2.3 小节允许二级索引按照范围搜索，这是因为在 <code>Using sort_union</code> 中，会先对拿到的主键值进行排序，然后才会去求交集或者并集，当然，相比于 2.1 和 2.2 小节，2.3 小节的性能也会降低一些。</p><h2 id="3-索引合并的问题"><a href="#3-索引合并的问题" class="headerlink" title="3. 索引合并的问题"></a>3. 索引合并的问题</h2><p>索引合并看着似乎提升了 MySQL 搜索的性能，然而，一般出现索引合并，大概率都是因为索引创建的不合理，我们需要重新审视自己的索引。</p><p>如上面 2.3 小节所述，这种方式在查询的过程中需要缓存临时数据、需要排序然后才能求交集或者并集，这些操作都会消耗掉大部分的 CPU 和内存资源。并且这些消耗不会被计算到查询成本中，因为 MySQL 优化器只关心随机页面的读取问题，并不会关心这里涉及到的这些额外计算问题，所以，在一些极端情况下，索引合并的性能可能还不如全表扫描。</p><p>因此，有时候如果我们确定自己不需要索引合并，那么可以通过 ignore index 来忽略掉一些索引，如下（对比 2.1 小节截图）：</p><p><img src="http://img.itboyhub.com/2022/08/20230426215824.png" alt></p><p>也可以通过 optimizer_switch 来关闭索引合并功能，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230426220124.png" alt></p><p>好啦，索引合并就和小伙伴们聊这么多吧～感兴趣的小伙伴也可以尝试下哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在前面的文章中，松哥和小伙伴们分享了 MySQL 中，InnoDB 存储引擎的数据结构，小伙伴们知道，当我们使用索引进行搜索的时候，每一次的搜索都是在某一棵 B+Tree 中搜索的，如果使用了二级索引的话，可能还会涉及到回表。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>前缀索引，在性能和空间中寻找平衡</title>
    <link href="http://www.javaboy.org/2023/0424/mysql_prefix_index.html"/>
    <id>http://www.javaboy.org/2023/0424/mysql_prefix_index.html</id>
    <published>2023-04-24T11:00:15.000Z</published>
    <updated>2023-07-21T11:16:45.697Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>我们在项目的具体实践中，有时候会遇到一些比较特殊的字段，例如身份证号码。</p><a id="more"></a><p>松哥之前有一个小伙伴做黑龙江省的政务服务网，里边有一些涉及到用户身份证存储的场景，由于存储的数据大部分都是当地的，此时如果想给身份证号码建立索引的话，小伙伴们知道，身份证前六位是地址码，在这样的场景下，给身份证字段建立索引的话，前六位的区分度是很低的，甚至前十位的区分度都很低（因为出生年份毕竟有限，一个省份上千万人口，出生年份重复率是很高的），不仅浪费存储空间，查询性能还低。</p><p>那么有没有办法解决这个问题呢？我们今天就来聊一聊前缀索引，聊完之后相信大家自己就有答案了。</p><h2 id="1-什么是前缀索引"><a href="#1-什么是前缀索引" class="headerlink" title="1.什么是前缀索引"></a>1.什么是前缀索引</h2><p>有时候为了提升索引的性能，我们只对字段的前几个字符建立索引，这样做既可以节约空间，还能减少字符串的比较时间，B+Tree 上需要存储的索引字符串更短，也能在一定程度上降低索引树的高度，提高查询效率。</p><p>MySQL 中的前缀索引有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数。</p><p>不过前缀索引有一个缺陷，就是有可能会降低索引的<strong>选择性</strong>。</p><h2 id="2-什么是索引选择性"><a href="#2-什么是索引选择性" class="headerlink" title="2.什么是索引选择性"></a>2.什么是索引选择性</h2><p>关于索引的选择性（Index Selectivity），它是指不重复的索引值（也称为基数 cardinality)和数据表的记录总数的比值，取值范围在 <code>(0,1]</code> 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</p><p>那有小伙伴要问了，是不是选择性越高的索引越好呢？当然不是！索引选择性最高为 1，如果索引选择性为 1，就是唯一索引了，搜索的时候就能直接通过搜索条件定位到具体一行记录！这个时候虽然性能最好，但是也是最费空间的，<strong>这不符合我们创建前缀索引的初衷</strong>。</p><p>我们一开始之所以要创建前缀索引而不是唯一索引，<strong>就是希望能够在索引的性能和空间之间找到一个平衡</strong>，我们希望能够选择足够长的前缀以保证较高的选择性（这样在查询的过程中就不需要扫描很多行），但是又希望索引不要太过于占用存储空间。</p><p>那么我们该如何选择一个合适的索引选择性呢？索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数。</p><p>首先我们可以通过如下 SQL 得到全列选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> column_name) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>然后再通过如下 SQL 得到某一长度前缀的选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(column_name, prefix_length)) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>在上面这条 SQL 执行的时候，我们要注意选择合适的 prefix_length，直至计算结果约等于全列选择性的时候，就是最佳结果了。</p><h2 id="3-创建前缀索引"><a href="#3-创建前缀索引" class="headerlink" title="3.创建前缀索引"></a>3.创建前缀索引</h2><h3 id="3-1-一个小案例"><a href="#3-1-一个小案例" class="headerlink" title="3.1 一个小案例"></a>3.1 一个小案例</h3><p>举个例子，我们来创建一个前缀索引看看。</p><p>松哥这里使用的数据样例是网上找的一个测试脚本，有 300W+ 条数据，做 SQL 测试优化是够用了，小伙伴们在公众号后台回复 <code>mysql-data-samples</code> 获取脚本下载链接。</p><p>我们来大致上看下这个表结构：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124203829.png" alt></p><p>这个表有一个 user_uuid 字段，我们就在这个字段上做文章。</p><blockquote><p>Git 小伙伴们应该都会用吧？不同于 Svn，Git 上的版本号不是数字而是一个 Hash 字符串，但是我们在具体应用的时候，比如你要做版本回退，此时并不需要输入完整的的版本号，只需要输入版本号前几个字符就行了，因为根据前面这一部分就能确定出版本号了。</p></blockquote><p>那么这张表里边的 user_uuid 字段也是这意思，如果我们想给 user_uuid 字段建立索引，就没有必要给完整的字符串建立索引，我们只需要给一部分字符串建立索引。</p><p>可能有小伙伴还是不太明白，我举一个例子，比如说我现在想按照 user_uuid 字段来查询，但是查询条件我没有必要写完整的 user_uuid，我只需要写前面一部分就可以区分出我想要的记录了，我们来看如下一条 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124205000.png" alt></p><p>大家看到，user_uuid 我只需要给出一部分就能唯一锁定一条记录。</p><blockquote><p>当然，上面这个 SQL 是松哥测试过的，给定的 <code>&#39;39352f%&#39;</code> 条件不能再短了，再短就会查出来两条甚至多条记录。</p></blockquote><p>通过上面这个例子我们就可以看出来，如果给 user_uuid 字段建立索引，可能并不需要给完整的字符串建立索引，只需要给一部分前缀字符串建立索引。</p><p>那么给前面几个字符串建立索引呢？这个可不是拍脑门，需要科学计算，我们继续往下看。</p><h3 id="3-2-前缀索引"><a href="#3-2-前缀索引" class="headerlink" title="3.2 前缀索引"></a>3.2 前缀索引</h3><p>首先我们通过如下 SQL 来看一下 user_uuid 全列索引选择性是多少：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_uuid) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system_user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124205705.png" alt></p><p>可以看到，结果为 1。全列选择性为 1 说明这一列的值都是唯一不重复的。</p><p>接下来我们先来试几个不同的 prefix_length，看看选择性如何。</p><p>松哥这里一共测试了 5 个不同的 prefix_length，大家来看看各自的选择性：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124210448.png" alt></p><p>8 和 9 的选择性是一样的，因为在 uuid 字符串中，第 9 个字符串是 <code>-</code>，所有的 uuid 第九个字符串都一样，所以 8 个字符和 9 个字符串的区分度就一样。</p><p>当 prefix_length 为 10 的时候，选择性就已经是 1 了，意思是，在这 300W+ 条数据中，如果我用 user_uuid 这个字段去查询的话，只需要输入前十个字符，就能唯一定位到一条具体的记录了。</p><p>那还等啥，赶紧创建前缀索引呗：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span> user_uuid_index(user_uuid(<span class="hljs-number">10</span>));</span><br></pre></td></tr></table></figure><p>查看刚刚创建的前缀索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124211058.png" alt></p><p>可以看到，第二行就是我们刚刚创建的前缀索引。</p><p>接下来我们分析查询语句中是否用到该索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">where</span> user_uuid=<span class="hljs-string">'39352f81-165e-4405-9715-75fcdf7f7068'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124215251.png" alt></p><p>可以看到，这个前缀索引已经用上了。</p><p>具体搜索流程是这样：</p><ol><li>从 <code>user_uuid_index</code> 索引中找到第一个值为 <code>39352f81-1</code> 的记录（user_uuid 的前十个字符）。</li><li>由于 user_uuid 是二级索引，叶子结点保存的是主键值，所以此时拿到了主键 id 为 1。</li><li>拿着主键 id 去回表，在主键索引上找到 id 为 1 的行的完整记录，返回给 server 层。</li><li>server 层判断其 user_uuid 是不是 <code>39352f81-165e-4405-9715-75fcdf7f7068</code>（所以执行计划的 Extra 为 Using where）。<ol><li>如果不是，这行记录丢弃。</li><li>如果是，将该记录加入结果集。</li></ol></li><li>索引叶子结点上数据之间是有单向链表维系的，所以接着第一步查找的结果，继续向后读取下一条记录，然后重复 2、3、4 步，直到在 user_uuid_index 上取到的值不为 <code>39352f81-1</code> 时，循环结束。</li></ol><p><strong>如果我们建立了前缀索引并且前缀索引的选择性为 1，那么就不需要第 5 步了，如果前缀索引选择性小于 1，就需要第五步。</strong></p><p>从上面的案例中，小伙伴们看到，我们既节省了空间，又提高了搜索效率。</p><h3 id="3-3-一个问题"><a href="#3-3-一个问题" class="headerlink" title="3.3 一个问题"></a>3.3 一个问题</h3><p>使用了前缀索引后，我们来看一个问题，大家来看如下一条查询 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> user_uuid <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">where</span> user_uuid=<span class="hljs-string">'39352f81-165e-4405-9715-75fcdf7f7068'</span>;</span><br></pre></td></tr></table></figure><p>这次不是 <code>select *</code>，而是 <code>select user_uuid</code>，小伙伴们知道，这里应该是要用到覆盖索引，我们来看看执行计划：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124230401.png" alt></p><p>咦，说好的索引覆盖呢？（注意看 Extra 是 Using where 不是 Using index）。</p><p>大家想想，前缀索引中，B+Tree 里保存的就不是完整的 <code>user_uuid</code> 字段的值，必须要回表才能拿到需要的数据。<strong>所以，用了前缀索引，就用不了覆盖索引了。</strong></p><h2 id="4-回到开始的问题"><a href="#4-回到开始的问题" class="headerlink" title="4. 回到开始的问题"></a>4. 回到开始的问题</h2><p>在本文一开始，松哥抛出了一个问题，如何给身份证建立索引更高效？</p><p>由于身份证前六位区分度太低，所以我们可以考虑将身份证倒序存储，倒序存储之后，为前六位或者前八位（可以自行计算选择性）建立前缀索引，这样的建立的索引选择性就会比较高，同时对空间的占用也会比较小。在查询的时候使用 reverse 反转身份证号码即可，像下面这样：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id_card=<span class="hljs-keyword">reverse</span>(<span class="hljs-string">'正序的身份证号码'</span>);</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，这就是前缀索引，感兴趣的小伙伴赶紧体验一把吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;我们在项目的具体实践中，有时候会遇到一些比较特殊的字段，例如身份证号码。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主键自增也有坑？</title>
    <link href="http://www.javaboy.org/2023/0420/mysql_primary_key_autoincrement.html"/>
    <id>http://www.javaboy.org/2023/0420/mysql_primary_key_autoincrement.html</id>
    <published>2023-04-20T11:00:00.000Z</published>
    <updated>2023-07-21T11:16:42.222Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，松哥和小伙伴们分享了 MySQL 的聚簇索引，也顺便和小伙伴们分析了为什么在 MySQL 中主键不应该使用随机字符串。但是主键不用随机字符串用什么？主键自增？主键自增就是最佳方案吗？有没有其他坑？今天我们就来讨论下这个话题。</p><a id="more"></a><h2 id="1-为什么不用-UUID"><a href="#1-为什么不用-UUID" class="headerlink" title="1. 为什么不用 UUID"></a>1. 为什么不用 UUID</h2><p>经过上篇文章的介绍，我们知道在 MySQL 中，主键索引就是聚簇索引，MySQL 表中的数据是根据主键值聚集在一起的，聚簇索引是一棵 B+Tree，这棵树中的数据是有序的。</p><p>所以，如果我们使用 UUID 字符串作为主键，那么就会导致每次数据插入的时候，都需要在 B+Tree 中寻找到适合它自己的位置，找到之后就<strong>有可能</strong>要挪动后面的节点（就像在数组中插入一条记录），挪动后面的节点，就有可能涉及到页分裂，插入效率就会降低。</p><p>另一方面，在非聚簇索引中，叶子结点保存的是主键值，主键如果是一个很长的 UUID 字符串，就会占据较大的存储空间（相对 int 而言），那么同一个叶子结点能够保存的主键值数量就会减少，进而可能会导致树变高，树变高，意味着查询的时候 IO 次数增加，查询效率降低。</p><p>基于上面的分析，我们在 MySQL 中尽量不使用 UUID 作为主键，不用 UUID，可能会有小伙伴想到，那我使用主键自增行不行？</p><p>对于上面提到的两个使用 UUID 作为主键的问题，使用主键自增显然都可以解决。主键自增，每次只需要往树的末尾添加就行了，基本上不会涉及到页分裂问题；主键自增意味着主键是数字，占用的存储空间相对来说就比较小，对非聚簇索引的影响也会小一些。</p><p>那么主键自增就是最佳方案吗？主键自增有没有一些需要注意的问题？</p><h2 id="2-主键自增的问题"><a href="#2-主键自增的问题" class="headerlink" title="2. 主键自增的问题"></a>2. 主键自增的问题</h2><p><strong>以下内容，有一个共同的大前提，就是我们的表设置了主键自增。</strong></p><p>一般来说，主键自增是没有什么问题的。但是，如果在高并发环境下，就会有问题了。</p><p>首先最容易想到的就是在高并发插入的时候产生的尾部热点问题，并发插入时，大家都需要去查询这个值然后计算出自己的主键值，那么主键的上界就会成为热点数据，并发插入时这里会产生锁竞争。</p><p>为了解决这个问题，我们就需要选择适合自己的 <code>innodb_autoinc_lock_mode</code>。</p><h3 id="2-1-数据插入的三种形式"><a href="#2-1-数据插入的三种形式" class="headerlink" title="2.1 数据插入的三种形式"></a>2.1 数据插入的三种形式</h3><p>首先，我们在向数据表中插入数据的时候，一般来说有三种不同的形式，分别如下：</p><ol><li><code>insert into user(name) values(&#39;javaboy&#39;)</code> 或者 <code>replace into user(name) values(&#39;javaboy&#39;)</code> ，这种没有嵌套子查询并且<strong>能够确定具体插入多少行</strong>的插入叫做 <code>simple insert</code>，不过需要注意的是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 不算是 <code>simple insert</code>。</li><li><code>load data</code> 或者 <code>insert into user select ... from ....</code>，这种都是批量插入，叫做 <code>bulk insert</code>，这种批量插入有一个特点就是插入多少条数据在一开始是未知的。</li><li><code>insert into user(id,name) values(null,&#39;javaboy&#39;),(null,&#39;江南一点雨&#39;)</code>，这种也是批量插入，但是跟第二种又不太一样，这种里边包含了一些自动生成的值（本案例中的主键自增），并且能够确定一共插入多少行，这种称之为 <code>mixed insert</code>，对于前面第一点提到的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 也算是一种 <code>mixed insert</code>。</li></ol><p>将数据插入分为这三类，主要是因为在主键自增的时候，锁的处理方案不同，我们继续往下看。</p><h3 id="2-2-innodb-autoinc-lock-mode"><a href="#2-2-innodb-autoinc-lock-mode" class="headerlink" title="2.2 innodb_autoinc_lock_mode"></a>2.2 innodb_autoinc_lock_mode</h3><p>我们可以通过控制 innodb_autoinc_lock_mode 变量的值，来控制在主键自增的时候，MySQL 锁的处理思路。</p><p>innodb_autoinc_lock_mode 变量一共有三个不同的取值：</p><ul><li>0: 这个表示 traditional，在这种模式下，我们上面提到的三种不同的插入 SQL，对于自增锁的处理方案是一致的，都是在插入 SQL 语句开始的时候，获取到一个表级的 AUTO-INC 锁，然后当插入 SQL 执行完毕之后，再释放掉这把锁，这样做的好处是可以确保在批量插入的时候，自增主键是连续的。</li><li>1: 这个表示 consecutive，在这种模式下，对 <code>simple insert</code>（能够确定具体插入行数的，对应上面 1、3 两种情况）做了一些优化，由于 <code>simple insert</code> 插入多少行这个很好计算，于是可以一次性生成几个连续的值用在对应的插入 SQL 语句上，这样就可以提前释放掉 AUTO-INC 锁，可以减少锁等待，提高并发插入效率。</li><li>2: 这个表示 interleaved，这种情况下不存在 AUTO-INC 锁，来一个处理一个，批量插入的时候，就有可能出现主键虽然自增，但是不连续的问题。</li></ul><p>从上面的介绍中小伙伴们可以看到，实际上第三种，也就是 innodb_autoinc_lock_mode 取值为 2 的情况下，并发效率是最强的，那么我们是不是就应该设置 innodb_autoinc_lock_mode=2 呢？</p><p>这得看情况。</p><p>松哥之前写过一篇文章和小伙伴们介绍 MySQL binlog 日志文件的三种格式：</p><ul><li>row：binlog 中记录的是具体的值而不是原始的 SQL，举一个简单例子，假设表中有一个字段是 UUID，用户执行的 SQL 是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,uuid())</code>，那么最终记录到 binlog 中的 SQL 是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,‘0212cfa0-de06-11ed-a026-0242ac110004’)</code>。</li><li>statement：binlog 中记录的就是原始的 SQL 了，以 row 中的为例，最终 binlog 中记录的就是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,uuid())</code>。</li><li>mixed：在这种模式下，MySQL 会根据具体的 SQL 语句来决定日志的形式，也就是在 statement 和 row 之间选择一种。</li></ul><p>对于这三种不同的模式，很明显，在主从复制的时候，statement 模式可能会导致主从数据不一致，所以现在 MySQL 默认的 binlog 格式都是 row。</p><p>回到我们的问题：</p><ul><li>如果 binlog 格式是 row，那么我们就可以设置 innodb_autoinc_lock_mode 的值为 2，这样就能尽最大程度保证数据并发插入的能力，同时不会发生主从数据不一致的问题。</li><li>如果 binlog 格式是 statement，那么我们最好设置 innodb_autoinc_lock_mode 的值为 1，这样对于 <code>simple insert</code> 的并发插入能力进行了提高，批量插入还是先获取 AUTO-INC 锁，等插入成功之后再释放，这样也能避免主从数据不一致，保证数据复制的安全性。</li><li>以上两点主要是针对 InnoDB 存储引擎，如果是 MyISAM 存储引擎，都是先获取 AUTO-INC 锁，插入完成再释放，相当于 innodb_autoinc_lock_mode 变量的取值对 MyISAM 不生效。</li></ul><h3 id="2-3-实践"><a href="#2-3-实践" class="headerlink" title="2.3 实践"></a>2.3 实践</h3><p>接下来我们来通过一个简单的 SQL 来和小伙伴们演示一下 innodb_autoinc_lock_mode 不同取值对应不同结果的情况。</p><p>首先，我们可以通过如下 SQL 查看当前 innodb_autoinc_lock_mode 的取值：</p><p><img src="http://img.itboyhub.com/2022/08/20230419005230.png" alt></p><p>可以看到，我使用的 8.0.32 这个版本目前默认值是 2。</p><p>我先把它改成 0，修改方式就是在 <code>/etc/my.cnf</code> 文件中添加一行 <code>innodb_autoinc_lock_mode=0</code>：</p><p><img src="http://img.itboyhub.com/2022/08/20230419005739.png" alt></p><p>改完之后再重启查看，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230419010011.png" alt></p><p>可以看到，现在就已经改过来了。</p><p>现在假设我有如下表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">100</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>这个自增是从 100 开始计的，现在假设我有如下插入 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-keyword">id</span>,username) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'javaboy'</span>),(<span class="hljs-literal">null</span>,<span class="hljs-string">'江南一点雨'</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">'www.javaboy.org'</span>),(<span class="hljs-literal">null</span>,<span class="hljs-string">'lisi'</span>);</span><br></pre></td></tr></table></figure><p>插入完成之后，我们来看查询结果：</p><p><img src="http://img.itboyhub.com/2022/08/20230419010756.png" alt></p><p>按照我们前文的介绍，这个情况应该是可以解释的通的，我这里不再赘述。</p><p>接下来，我把 innodb_autoinc_lock_mode 取值改为 1，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230419011034.png" alt></p><p>还是上面相同的 SQL，我们再执行一遍。执行完成之后结果也和上文相同。</p><p>但是！！！<strong>当上面的 SQL 执行完毕之后，如果我们还想再插入数据，并且新插入的 ID 不指定值，则我们发现自动生成的 ID 值为 104。</strong>这就是因为我们设置了 innodb_autoinc_lock_mode=1，此时，执行 <code>simple insert</code> 插入的时候，系统一看我要插入 4 条记录，就直接给我提前拿了 4 个 ID 出来，分别是 100、101、102 以及 103，结果该 SQL 实际上只用了两个 ID，剩下两个没用，但是下次插入还是从 104 开始了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，这就是关于主键自增的一个小小知识点，小伙伴们一定要根据实际情况来为 innodb_autoinc_lock_mode 属性取一个合适的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇文章中，松哥和小伙伴们分享了 MySQL 的聚簇索引，也顺便和小伙伴们分析了为什么在 MySQL 中主键不应该使用随机字符串。但是主键不用随机字符串用什么？主键自增？主键自增就是最佳方案吗？有没有其他坑？今天我们就来讨论下这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>再聊 MySQL 聚簇索引</title>
    <link href="http://www.javaboy.org/2023/0417/mysql_cluster_index.html"/>
    <id>http://www.javaboy.org/2023/0417/mysql_cluster_index.html</id>
    <published>2023-04-17T10:59:50.000Z</published>
    <updated>2023-07-21T11:16:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>为什么是再次理解呢？因为松哥之前写过相关的文章介绍过聚簇索引，但是感觉还不够，因此今天想再来和小伙伴们聊一聊这个话题。</p><a id="more"></a><h2 id="1-什么是聚簇索引"><a href="#1-什么是聚簇索引" class="headerlink" title="1. 什么是聚簇索引"></a>1. 什么是聚簇索引</h2><p>数据库的索引从不同的角度可以划分成不同的类型，聚簇索引便是其中一种。</p><p>聚簇索引英文是 Clustered Index，有时候小伙伴们可能也会看到有人将之称为聚集索引等，与之相对的是非聚簇索引或者二级索引。</p><p>聚簇索引并不是一种单独的索引类型，而是一种数据的存储方式。在 MySQL 的 InnoDB 存储引擎中，所谓的聚簇索引实际上就是在同一个 B+Tree 中保存了索引和数据行：<strong>此时，数据放在叶子结点中，聚簇聚簇，意思就是说数据行和对应的键值紧凑的存在一起。</strong></p><p>假设我有如下数据：</p><table><thead><tr><th style="text-align:left">id(主键)</th><th style="text-align:left">username</th><th style="text-align:left">age</th><th style="text-align:left">address</th><th style="text-align:left">gender</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">ab</td><td style="text-align:left">99</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">ac</td><td style="text-align:left">98</td><td style="text-align:left">广州</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">af</td><td style="text-align:left">88</td><td style="text-align:left">北京</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">bc</td><td style="text-align:left">80</td><td style="text-align:left">上海</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">bg</td><td style="text-align:left">85</td><td style="text-align:left">重庆</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">bw</td><td style="text-align:left">95</td><td style="text-align:left">天津</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">bw</td><td style="text-align:left">99</td><td style="text-align:left">海口</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">cc</td><td style="text-align:left">92</td><td style="text-align:left">武汉</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">ck</td><td style="text-align:left">90</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">cx</td><td style="text-align:left">93</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr></tbody></table><p>那么它的聚簇索引大概就是这个样子：</p><p><img src="http://img.itboyhub.com/2022/08/mysql8_clustered_index.png" alt></p><p>那么大家可以看到，叶子上既有主键值（索引）又有数据行，节点上则只有主键值（索引）。</p><p>小伙伴们想想，MySQL 表中的数据在磁盘中只可能保存一份，不可能保存两份，所以，在一个表中，聚簇索引只可能有一个，不可能有多个。</p><h2 id="2-聚簇索引和主键"><a href="#2-聚簇索引和主键" class="headerlink" title="2. 聚簇索引和主键"></a>2. 聚簇索引和主键</h2><p>有的小伙伴搞不清楚这两者之间的关系，甚至将两者划等号，这是一个巨大的误区。</p><p>在有的数据库中，支持开发者自由的选择使用哪一个索引作为聚簇索引，但是 MySQL 中是不支持这个特性的。</p><p>在 MySQL 中，如果表本身就有设置主键，那么主键就是聚簇索引；如果表本身没有设置主键，则会选择表中的一个唯一且非空的索引来作为聚簇索引；如果表中连唯一非空的索引都没有，那么就会自动选择表中的隐式主键来作为聚簇索引。关于 MySQL 中表的隐式主键，松哥会在将来的文章中和大家介绍。</p><blockquote><p>不过一般来说，还是建议大家自己来为表设置主键，因为隐式主键是自增的，自增的都会存在一个问题：在自增值上会存在非常高的锁竞争问题，主键的上界会称为热点数据，因为所有的插入操作都要主键自增，又不能重复，所以会发生锁竞争进而导致性能降低。</p></blockquote><p>根据上面的介绍，我们可以总结出 MySQL 中聚簇索引和主键索引的关系如下：</p><ol><li>聚簇索引不一定是主键索引。</li><li>主键索引一定是聚簇索引。</li></ol><h2 id="3-聚簇索引优缺点"><a href="#3-聚簇索引优缺点" class="headerlink" title="3. 聚簇索引优缺点"></a>3. 聚簇索引优缺点</h2><p>先来说优点：</p><ol><li>相互关联的数据我们可以将之保存在一起。例如有一个用户订单表，我们可以根据 <strong>用户 ID + 订单 ID</strong> 来聚集所有数据，用户 ID 可能会重复，订单 ID 则不会重复，这样我们就能够将一个用户相关的订单数据都保存在一起，如果需要查询一个用户的所有订单，就会非常快，只需要少量的磁盘 IO 就可以做到。</li><li>不需要回表，因此数据访问速度更快。在聚簇索引中，索引和数据都在同一棵 B+Tree 上，因此从聚簇索引中获取到的数据比从非聚簇索引上获取数据更快（非聚簇索引需要回表）。</li><li>对于第一点的案例，如果我们想根据用户 ID 查询到这个用户所有的订单 ID，那么此时都不用去到叶子结点了，因为支节点上就有我们需要的数据，所以直接利用覆盖索引的特性，就可以读取到需要的数据。</li></ol><p>这些就是聚簇索引一些常见的优点，我们在日常的表设计中，其实应该充分利用好这些优点。</p><p>再来看看缺点：</p><ol><li>小伙伴们发现，前面我们说的聚簇索引的优势主要是聚簇索引减少了 IO 次数，从而提高了数据库的性能，但是有的 IO 密集型应用，可能直接上一个足够大的内存，把数据都读取到内存中操作，此时聚簇索引就没有啥优势了。</li><li>随机主键会导致页分裂问题，主键顺序插入的话，相对来说效率会高一些，因为在 B+Tree 中只需要不断往后面追加即可；但是主键如果是非顺序插入的话，效率就会低很多，因为可能会涉及到页分裂问题。以上面那张图为例，假设每个节点可以保存三条数据，现在我们要插入一个主键是 4.5 的记录，那么就需要把主键为 5 的值往后移动，进而导致主键为 8 的节点也要往后移动。页分裂会导致数据插入效率降低并且占用更多的存储空间。</li><li>非聚簇索引（二级索引）查询的时候需要回表。因为一个索引就是一棵索引树，数据都在聚簇索引上，所以如果使用非聚簇索引进行搜索，非聚簇索引的叶子上存储的是主键值，先找到主键值，然后拿着主键值再来聚簇索引上搜索，这样一共就查询了两棵索引树，这就是回表。</li></ol><h2 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h2><p>看了上面的介绍，相信小伙伴已经了解了，在使用聚簇索引的时候，主键最好不要使用 UUID 这种随机字符串，使用 UUID 随机字符串至少存在两方面的问题：</p><ol><li>插入效率低，因为插入可能会导致页分裂，这个前面已经说过了。</li><li>UUID 字符串所占用的存储空间远远大于一个 bigint，如果使用 UUID 来做主键，意味着在二级索引中，一个叶子结点能够存储的主键值就非常有限，进而可能会导致树增高，搜索时候 IO 次数增多，性能下降。</li></ol><p>所以相对来说，主键自增会优于 UUID。那么主键自增就是最完美的方案了吗？很多小伙伴可能也听说过一句话：没有银弹！所以，主键自增其实也有问题，具体什么问题，我们下便文章继续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么是再次理解呢？因为松哥之前写过相关的文章介绍过聚簇索引，但是感觉还不够，因此今天想再来和小伙伴们聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>新版SpringSecurity如何自定义JSON登录</title>
    <link href="http://www.javaboy.org/2023/0414/spring_security_json.html"/>
    <id>http://www.javaboy.org/2023/0414/spring_security_json.html</id>
    <published>2023-04-14T10:59:39.000Z</published>
    <updated>2023-07-21T11:16:06.220Z</updated>
    
    <content type="html"><![CDATA[<p>目前最新版的 Spring Boot 已经到了 3.0.5 了，随之而来 Spring Security 目前的版本也到了 6.0.2 了，最近几次的版本升级，Spring Security 写法的变化特别多。</p><a id="more"></a><p>最近有小伙伴在  Spring Security 中自定义 JSON 登录的时候就遇到问题了，松哥看了下，感觉这个问题还特别典型，因此我拎出来和各位小伙伴一起来聊一聊这个话题。</p><h2 id="1-自定义-JSON-登录"><a href="#1-自定义-JSON-登录" class="headerlink" title="1. 自定义 JSON 登录"></a>1. 自定义 JSON 登录</h2><p>小伙伴们知道，Spring Security 中默认的登录接口数据格式是 key-value 的形式，如果我们想使用 JSON 格式来登录，那么就必须自定义过滤器或者自定义登录接口，下面松哥先来和小伙伴们展示一下这两种不同的登录形式。</p><h3 id="1-1-自定义登录过滤器"><a href="#1-1-自定义登录过滤器" class="headerlink" title="1.1 自定义登录过滤器"></a>1.1 自定义登录过滤器</h3><p>Spring Security 默认处理登录数据的过滤器是 UsernamePasswordAuthenticationFilter，在这个过滤器中，系统会通过 <code>request.getParameter(this.passwordParameter)</code> 的方式将用户名和密码读取出来，很明显这就要求前端传递参数的形式是 key-value。</p><p>如果想要使用 JSON 格式的参数登录，那么就需要从这个地方做文章了，我们自定义的过滤器如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//获取请求头，据此判断请求参数类型</span></span><br><span class="line">        String contentType = request.getContentType();</span><br><span class="line">        <span class="hljs-keyword">if</span> (MediaType.APPLICATION_JSON_VALUE.equalsIgnoreCase(contentType) || MediaType.APPLICATION_JSON_UTF8_VALUE.equalsIgnoreCase(contentType)) &#123;</span><br><span class="line">            <span class="hljs-comment">//说明请求参数是 JSON</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">            &#125;</span><br><span class="line">            String username = <span class="hljs-keyword">null</span>;</span><br><span class="line">            String password = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//解析请求体中的 JSON 参数</span></span><br><span class="line">                User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), User.class);</span><br><span class="line">                username = user.getUsername();</span><br><span class="line">                username = (username != <span class="hljs-keyword">null</span>) ? username.trim() : <span class="hljs-string">""</span>;</span><br><span class="line">                password = user.getPassword();</span><br><span class="line">                password = (password != <span class="hljs-keyword">null</span>) ? password : <span class="hljs-string">""</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//构建登录令牌</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username,</span><br><span class="line">                    password);</span><br><span class="line">            <span class="hljs-comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">            setDetails(request, authRequest);</span><br><span class="line">            <span class="hljs-comment">//执行真正的登录操作</span></span><br><span class="line">            Authentication auth = <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            <span class="hljs-keyword">return</span> auth;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过松哥之前的 Spring Security 系列文章的小伙伴，这段代码应该都是非常熟悉了。</p><ol><li>首先我们获取请求头，根据请求头的类型来判断请求参数的格式。</li><li>如果是 JSON 格式的参数，就在 if 中进行处理，否则说明是 key-value 形式的参数，那么我们就调用父类的方法进行处理即可。</li><li>JSON 格式的参数的处理逻辑和 key-value 的处理逻辑是一致的，唯一不同的是参数的提取方式不同而已。</li></ol><p>最后，我们还需要对这个过滤器进行配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JsonLoginFilter <span class="hljs-title">jsonLoginFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JsonLoginFilter filter = <span class="hljs-keyword">new</span> JsonLoginFilter();</span><br><span class="line">        filter.setAuthenticationSuccessHandler((req,resp,auth)-&gt;&#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            <span class="hljs-comment">//获取当前登录成功的用户对象</span></span><br><span class="line">            User user = (User) auth.getPrincipal();</span><br><span class="line">            user.setPassword(<span class="hljs-keyword">null</span>);</span><br><span class="line">            RespBean respBean = RespBean.ok(<span class="hljs-string">"登录成功"</span>, user);</span><br><span class="line">            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        &#125;);</span><br><span class="line">        filter.setAuthenticationFailureHandler((req,resp,e)-&gt;&#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            RespBean respBean = RespBean.error(<span class="hljs-string">"登录失败"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"用户名或者密码输入错误，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户被禁用，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"密码过期，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户过期，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户被锁定，登录失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        &#125;);</span><br><span class="line">        filter.setAuthenticationManager(authenticationManager());</span><br><span class="line">        filter.setFilterProcessesUrl(<span class="hljs-string">"/login"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider daoAuthenticationProvider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        daoAuthenticationProvider.setUserDetailsService(userService);</span><br><span class="line">        ProviderManager pm = <span class="hljs-keyword">new</span> ProviderManager(daoAuthenticationProvider);</span><br><span class="line">        <span class="hljs-keyword">return</span> pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//开启过滤器的配置</span></span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                <span class="hljs-comment">//任意请求，都要认证之后才能访问</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="hljs-comment">//开启表单登录，开启之后，就会自动配置登录页面、登录接口等信息</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                <span class="hljs-comment">//和登录相关的 URL 地址都放行</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="hljs-comment">//关闭 csrf 保护机制，本质上就是从 Spring Security 过滤器链中移除了 CsrfFilter</span></span><br><span class="line">                .csrf().disable();</span><br><span class="line">        http.addFilterBefore(jsonLoginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是配置一个 JsonLoginFilter 的 Bean，并将之添加到 Spring Security 过滤器链中即可。</p><p>在 Spring Boot3 之前（Spring Security6 之前），上面这段代码就可以实现 JSON 登录了。</p><p>但是从 Spring Boot3 开始，这段代码有点瑕疵了，直接用已经无法实现 JSON 登录了，具体原因松哥下文分析。</p><h3 id="1-2-自定义登录接口"><a href="#1-2-自定义登录接口" class="headerlink" title="1.2 自定义登录接口"></a>1.2 自定义登录接口</h3><p>另外一种自定义 JSON 登录的方式是直接自定义登录接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLogin</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken unauthenticated = UsernamePasswordAuthenticationToken.unauthenticated(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(unauthenticated);</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticate);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"error:"</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接自定义登录接口，请求参数通过 JSON 的形式来传递。拿到用户名密码之后，调用 AuthenticationManager#authenticate 方法进行认证即可。认证成功之后，将认证后的用户信息存入到 SecurityContextHolder 中。</p><p>最后再配一下登录接口就行了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        provider.setUserDetailsService(userService);</span><br><span class="line">        ProviderManager pm = <span class="hljs-keyword">new</span> ProviderManager(provider);</span><br><span class="line">        <span class="hljs-keyword">return</span> pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                <span class="hljs-comment">//表示 /doLogin 这个地址可以不用登录直接访问</span></span><br><span class="line">                .requestMatchers(<span class="hljs-string">"/doLogin"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated().and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也算是一种使用 JSON 格式参数的方案。在 Spring Boot3 之前（Spring Security6 之前），上面这个方案也是没有任何问题的。</p><p>从 Spring Boot3（Spring Security6） 开始，上面这两种方案都出现了一些瑕疵。</p><p>具体表现就是：<strong>当你调用登录接口登录成功之后，再去访问系统中的其他页面，又会跳转回登录页面，说明访问登录之外的其他接口时，系统不知道你已经登录过了。</strong></p><h2 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2. 原因分析"></a>2. 原因分析</h2><p>产生上面问题的原因，主要在于 Spring Security 过滤器链中有一个过滤器发生变化了：</p><p>在 Spring Boot3 之前，Spring Security 过滤器链中有一个名为 SecurityContextPersistenceFilter 的过滤器，这个过滤器在 Spring Boot2.7.x 中废弃了，但是还在使用，在 Spring Boot3 中则被从 Spring Security 过滤器链中移除了，取而代之的是一个名为 SecurityContextHolderFilter 的过滤器。</p><p>在第一小节和小伙伴们介绍的两种 JSON 登录方案在 Spring Boot2.x 中可以运行在 Spring Boot3.x 中无法运行，就是因为这个过滤器的变化导致的。</p><p>所以接下来我们就来分析一下这两个过滤器到底有哪些区别。</p><p>先来看 SecurityContextPersistenceFilter 的核心逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request, response);</span><br><span class="line">SecurityContext contextBeforeChainExecution = <span class="hljs-keyword">this</span>.repo.loadContext(holder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"><span class="hljs-keyword">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里只贴出来了一些关键的核心代码：</p><ol><li>首先，这个过滤器位于整个 Spring Security 过滤器链的第三个，是非常靠前的。</li><li>当登录请求经过这个过滤器的时候，首先会尝试从 SecurityContextRepository（上文中的 this.repo）中读取到 SecurityContext 对象，这个对象中保存了当前用户的信息，第一次登录的时候，这里实际上读取不到任何用户信息。</li><li>将读取到的 SecurityContext 存入到 SecurityContextHolder 中，默认情况下，SecurityContextHolder 中通过 ThreadLocal 来保存 SecurityContext 对象，也就是当前请求在后续的处理流程中，只要在同一个线程里，都可以直接从 SecurityContextHolder 中提取到当前登录用户信息。</li><li>请求继续向后执行。</li><li>在 finally 代码块中，当前请求已经结束了，此时再次获取到 SecurityContext，并清空 SecurityContextHolder 防止内存泄漏，然后调用 <code>this.repo.saveContext</code> 方法保存当前登录用户对象（实际上是保存到 HttpSession 中）。</li><li>以后其他请求到达的时候，执行前面第 2 步的时候，就读取到当前用户的信息了，在请求后续的处理过程中，Spring Security 需要知道当前用户的时候，会自动去 SecurityContextHolder 中读取当前用户信息。</li></ol><p>这就是 Spring Security 认证的一个大致流程。</p><p>然而，到了 Spring Boot3 之后，这个过滤器被 SecurityContextHolderFilter 取代了，我们来看下 SecurityContextHolderFilter 过滤器的一个关键逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">Supplier&lt;SecurityContext&gt; deferredContext = <span class="hljs-keyword">this</span>.securityContextRepository.loadDeferredContext(request);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.setDeferredContext(deferredContext);</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.clearContext();</span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，前面的逻辑基本上还是一样的，不一样的是 finally 中的代码，finally 中少了一步向 HttpSession 保存 SecurityContext 的操作。</p><p>这下就明白了，用户登录成功之后，用户信息没有保存到 HttpSession，导致下一次请求到达的时候，无法从 HttpSession 中读取到 SecurityContext 存到 SecurityContextHolder 中，在后续的执行过程中，Spring Security 就会认为当前用户没有登录。</p><p>这就是问题的原因！</p><p>找到原因，那么问题就好解决了。</p><h2 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h2><p>首先问题出在了过滤器上，直接改过滤器倒也不是不可以，但是，既然 Spring Security 在升级的过程中抛弃了之前旧的方案，我们又费劲的把之前旧的方案写回来，好像也不合理。</p><p>其实，Spring Security 提供了另外一个修改的入口，在 org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#successfulAuthentication 方法中，源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">SecurityContext context = <span class="hljs-keyword">this</span>.securityContextHolderStrategy.createEmptyContext();</span><br><span class="line">context.setAuthentication(authResult);</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.setContext(context);</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextRepository.saveContext(context, request, response);</span><br><span class="line"><span class="hljs-keyword">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当前用户登录成功之后的回调方法，小伙伴们看到，在这个回调方法中，有一句 <code>this.securityContextRepository.saveContext(context, request, response);</code>，这就表示将当前登录成功的用户信息存入到 HttpSession 中。</p><p>在当前过滤器中，securityContextRepository 的类型是 RequestAttributeSecurityContextRepository，这个表示将 SecurityContext 存入到当前请求的属性中，那很明显，在当前请求结束之后，这个数据就没了。在 Spring Security 的自动化配置类中，将 securityContextRepository 属性指向了 DelegatingSecurityContextRepository，这是一个代理的存储器，代理的对象是 RequestAttributeSecurityContextRepository 和 HttpSessionSecurityContextRepository，所以在默认的情况下，用户登录成功之后，在这里就把登录用户数据存入到 HttpSessionSecurityContextRepository 中了。</p><p>当我们自定义了登录过滤器之后，就破坏了自动化配置里的方案了，这里使用的 securityContextRepository 对象就真的是 RequestAttributeSecurityContextRepository 了，所以就导致用户后续访问时系统以为用户未登录。</p><p>那么解决方案很简单，我们只需要为自定义的过滤器指定 securityContextRepository 属性的值就可以了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">JsonLoginFilter <span class="hljs-title">jsonLoginFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    JsonLoginFilter filter = <span class="hljs-keyword">new</span> JsonLoginFilter();</span><br><span class="line">    filter.setAuthenticationSuccessHandler((req,resp,auth)-&gt;&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-comment">//获取当前登录成功的用户对象</span></span><br><span class="line">        User user = (User) auth.getPrincipal();</span><br><span class="line">          user.setPassword(<span class="hljs-keyword">null</span>);</span><br><span class="line">        RespBean respBean = RespBean.ok(<span class="hljs-string">"登录成功"</span>, user);</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationFailureHandler((req,resp,e)-&gt;&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        RespBean respBean = RespBean.error(<span class="hljs-string">"登录失败"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"用户名或者密码输入错误，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户被禁用，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"密码过期，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户过期，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户被锁定，登录失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationManager(authenticationManager());</span><br><span class="line">    filter.setFilterProcessesUrl(<span class="hljs-string">"/login"</span>);</span><br><span class="line">    filter.setSecurityContextRepository(<span class="hljs-keyword">new</span> HttpSessionSecurityContextRepository());</span><br><span class="line">    <span class="hljs-keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，最后调用 setSecurityContextRepository 方法设置一下就行。</p><blockquote><p>Spring Boot3.x 之前之所以不用设置这个属性，是因为这里虽然没保存最后还是在 SecurityContextPersistenceFilter 过滤器中保存了。</p></blockquote><p>那么对于自定义登录接口的问题，解决思路也是类似的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLogin</span><span class="hljs-params">(@RequestBody User user, HttpSession session)</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken unauthenticated = UsernamePasswordAuthenticationToken.unauthenticated(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(unauthenticated);</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticate);</span><br><span class="line">            session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, SecurityContextHolder.getContext());</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"error:"</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，在登录成功之后，开发者自己手动将数据存入到 HttpSession 中，这样就能确保下个请求到达的时候，能够从 HttpSession 中读取到有效的数据存入到 SecurityContextHolder 中了。</p><p>好啦，Spring Boot 新旧版本交替中，一个小小的问题，希望小伙伴们能够有所收获。</p><p>最后，松哥再来送 6 本松哥写的 《深入浅出 Spring Security》吧~小伙伴们随便留言，我会随机选出来六位幸运小伙伴，《深入浅出 Spring Security》包邮到家！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前最新版的 Spring Boot 已经到了 3.0.5 了，随之而来 Spring Security 目前的版本也到了 6.0.2 了，最近几次的版本升级，Spring Security 写法的变化特别多。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引数据结构入门</title>
    <link href="http://www.javaboy.org/2023/0412/mysql_index.html"/>
    <id>http://www.javaboy.org/2023/0412/mysql_index.html</id>
    <published>2023-04-12T10:59:26.000Z</published>
    <updated>2023-07-21T11:16:35.869Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥写过一个 MySQL 系列，但是当时是基于 MySQL5.7 的，最近有空在看 MySQL8 的文档，发现和 MySQL5.7 相比还是有不少变化，同时 MySQL 又是小伙伴们在面试时一个非常重要的知识点，因此松哥打算最近再抽空和小伙伴们聊一聊 MySQL，讲讲原理，讲讲优化，我会从最基本最简单的开始，和大家梳理 MySQL 中常见的面试知识点。</p><a id="more"></a><p>本文我们就先从最简单的索引开始吧～</p><h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><p>说到索引，最常见的例子就是查字典，当我们需要查询某一个字的含义时，正常操作都是先根据字典的索引，找到该字在哪一页，然后直接翻到该页就行了。如果没有这个索引的话，那么我们就得一页一页的翻字典，直到找到该字。很明显，相对于第一种方案，第二种方案效率就要低很多了。</p><p>数据库中的索引也是类似的。</p><p>索引，我们也称之为 index 或者 key，当数据量比较少的时候，索引对于查询产生的效果并不明显，所以索引常常被人所忽略，但是当数据量比较大的时候，一个优秀的索引对查询产生的影响就是非常明显的了。在我们所掌握的各种 SQL 优化策略中，索引对 SQL 优化产生的效果算是最好的了，用好索引，SQL 性能可能会提升好几个数量级。</p><blockquote><p>这里有的小伙伴可能会有一个疑惑，很多索引优化策略都是针对传统的机械硬盘的，然而现在我们大部分都是固态硬盘（SSD），很多针对机械硬盘的优化策略在 SSD 上似乎并没有必要，那还有必要去考虑索引优化吗？答案当然是有！无论是用什么样的磁盘，索引优化的整体原则都是不变的，只不过在 SSD 上，如果你的索引没有创建好，那么它对查询的影响不像对机械硬盘那么糟糕。</p></blockquote><h2 id="2-索引的数据结构"><a href="#2-索引的数据结构" class="headerlink" title="2. 索引的数据结构"></a>2. 索引的数据结构</h2><h3 id="2-1-B-Tree-和-B-Tree"><a href="#2-1-B-Tree-和-B-Tree" class="headerlink" title="2.1 B+Tree 和 B-Tree"></a>2.1 B+Tree 和 B-Tree</h3><p>小伙伴们知道，由于 MySQL 中的存储引擎设计成了可插拔的形式，任何机构和个人如果你有能力，都可以设计自己的存储引擎，而 MySQL 的索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎的索引工作方式都不一样，甚至，相同类型的索引，在不同的存储引擎中实现方案都不同。</p><p>本文松哥主要和小伙伴们介绍我们日常开发中最最常见的 InnoDB 存储引擎中的索引。</p><p>小伙伴们知道，InnoDB 存储引擎的索引数据结构是一个 B+Tree，至于什么是 B+Tree，这并非本文的重点，我这里不啰嗦，不了解 B+Tree 的小伙伴可以自行搜索一下学习一下。</p><p>假设我有如下数据：</p><table><thead><tr><th style="text-align:left">id</th><th style="text-align:left">username</th><th style="text-align:left">age</th><th style="text-align:left">address</th><th style="text-align:left">gender</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">ab</td><td style="text-align:left">99</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">ac</td><td style="text-align:left">98</td><td style="text-align:left">广州</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">af</td><td style="text-align:left">88</td><td style="text-align:left">北京</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">bc</td><td style="text-align:left">80</td><td style="text-align:left">上海</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">bg</td><td style="text-align:left">85</td><td style="text-align:left">重庆</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">bw</td><td style="text-align:left">95</td><td style="text-align:left">天津</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">bw</td><td style="text-align:left">99</td><td style="text-align:left">海口</td><td style="text-align:left">女</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">cc</td><td style="text-align:left">92</td><td style="text-align:left">武汉</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">ck</td><td style="text-align:left">90</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">cx</td><td style="text-align:left">93</td><td style="text-align:left">深圳</td><td style="text-align:left">男</td></tr></tbody></table><p>现在我给 username 和 age 字段建立联合索引，那么最终数据在磁盘上的存储结构是 B+Tree，为了小伙伴能够更好的理解 B+Tree 和 B-Tree，我画了如下两张图：</p><p><img src="http://img.itboyhub.com/2022/08/mysql8_index_b_tree.drawio-99.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/mysql8_index.drawio-99.png" alt></p><p>这两张图看懂了，InnoDB 存储引擎的索引我觉得基本上都搞懂了 80% 了，松哥来和大家稍微梳理一下这张图：</p><ol><li>首先这两张图都是一个多路平衡查找树，即，不是二叉树，是多叉树。</li><li>绿色的方块表示指向下一个节点的指针；红色的方块表示指向下一个叶子节点的指针（B-Tree 中不存在该部分）；带阴影的矩形则表示索引数据。</li><li><p>B+Tree 非叶子节点只保存关键字的索引和指向下一个节点的指针（绿色区域），所有的数据最终都会保存到叶子节点。因此在具体的搜索过程中，所有数据都必须要到叶子节点才能获取到，因此每次数据查询所需的 IO 次数都一样，这也就意味着 B+Tree 的查询速度比较稳定。</p><blockquote><p>如果是 B-Tree 则分支节点上也保存了指向具体数据的指针，并且分支节点上出现的索引数据不会再次出现在叶子节点中，所以搜索的时候可能搜索到分支节点就找到需要的数据了，搜索效率不稳定，如 af 在分支节点上就找到了，而 ac 则要到叶子节点上才能找到）。</p></blockquote></li><li><p>B+Tree 中，由于分支节点只保存索引数据和指向下一个节点的指针，所以在相同的磁盘空间中，能够指向更多的子节点，这就意味树的高度更低，搜索所需要的 IO 次数更少，搜索效率更高。</p><blockquote><p>B-Tree 中，由于分支节点不仅保存索引数据和指向下一个节点的指针，还保存了指向具体数据的指针，所以在相同的空间下能够指向的子节点数量就少于 B+Tree，这就意味着相同的数据量，B-Tree 树高更高，搜索所需的 IO 次数更多，搜索效率低。</p></blockquote></li><li><p>B+Tree 叶子节点的关键字从小到大按顺序排列，左边结尾数据都会保存右边节点开始数据的指针（红色区域），这个指针在范围搜索的时候非常有用，例如想搜索姓名在 ac～bc 之间的数据，按照树找到第一个节点 ac 之后，顺着指针一直往后找，找到第一个不满足条件的数据结束。</p><blockquote><p>如果是 B-Tree 则没有 ac 指向 bc 的指针，需要先回到分支节点 af 再继续向下搜索，效率就会低很多。</p></blockquote></li><li><p>B+Tree 的叶子节点都是有序排列的，所以 B+Tree 对于数据的排序有着更好的支持。</p><blockquote><p>B-Tree 由于有一部分数据保存在分支节点中，叶子节点并不是完整的数据，所以对于排序、范围搜索的支持并不如 B+Tree。</p></blockquote></li><li><p>B+Tree 数据划分的原则是左闭右开，以 (af,88) 这个节点为例，小于 (af,88) 节点的在左边，大于等于 (af,88) 节点的在右边。</p><blockquote><p>B-Tree 则是左开右开。</p></blockquote></li><li><p>B+Tree 全表扫描更快，因为所有数据都出现在叶子节点上，并且叶子节点之间还有指针相连，直接遍历即可。</p><blockquote><p>B-Tree 在全表扫描的时候则需要对树的每一层进行遍历才能读到所有数据。</p></blockquote></li><li><p>叶子节点指向数据的指针，如果是聚簇索引，则指向的是表中一条完整的记录；如果是非聚簇索引，则指向的是具体的主键值。在以非聚簇索引为依据进行搜索的时候，先找到记录的主键值，再根据 主键值去聚簇索引找到完整的记录，这个过程就是回表（InnoDB 中）。</p></li></ol><p>好了，相信通过上面八点的介绍，大家对于 B-Tree 和 B+Tree 已经有了基本的认知了。</p><p>当我们想要搜索一条记录的时候，顺着根节点从上往下扫描树，比直接遍历一条一条的记录显然是要快很多。</p><blockquote><p>说一个不太恰当的比喻，MySQL 中的数据存储，就像是通过一个链表把所有数据按照顺序串到一起，然后在这个链表上面又架了一个多路平衡查找树的感觉，搜索的时候，按照链表一个一个找，就是全表扫描；从树的根节点开始找，就是用索引。</p></blockquote><h3 id="2-2-树高问题"><a href="#2-2-树高问题" class="headerlink" title="2.2 树高问题"></a>2.2 树高问题</h3><p>一个经典的问题，高度为 3 的 B+Tree 大概可以保存多少条数据？</p><p>计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。但是 InnoDB 在进行磁盘操作的时候，并不是以扇区或者块为依据的，InnoDB 在进行磁盘操作的时候，是以页为单位的，有时候也称作逻辑页，每个逻辑页的大小默认是 16KB，即四个块。这就意味着，InnoDB 在实际操作磁盘的时候，每次从磁盘上读取数据，至少读取 16KB，每次向磁盘上写数据，也至少写 16KB，并不是你需要 1KB 就读取 1KB，即使你只需要 1KB 的数据，InnoDB 也会从磁盘中将 16KB 的数据读取到内存中。</p><p>通过如下命令我们可以查看 MySQL 中 InnoDB 存储引擎逻辑页的大小：</p><p><img src="http://img.itboyhub.com/2022/08/20230410224833.png" alt></p><p><code>16384/16=1024</code></p><p>前面的结论没问题。</p><p>以聚簇索引为例，现在我们假设数据库中一条记录的大小是 1KB，那么一个逻辑页就可以存 16 条数据（叶子节点）。</p><p>对于非叶子节点存储的则是主键值+指针，在 InnoDB 中，一个指针的大小是 6 个字节，假设我们的主键是 bigint ，那么主键占 8 个字节，<strong>当然还有其他一些头信息也会占用字节我们这里就不考虑了</strong>，我们大概算一下，小伙伴们心里有数即可：</p><p><code>16*1024/(8+6)=1170</code></p><p>即一个非叶子节点可以指向 1170 个子节点，那么一个三层的 B+Tree 可以存储的数据量为：</p><p><code>1170*1170*16=21902400</code></p><p>可以存储 2100万 条数据。</p><p>在 InnoDB 存储引擎中，B+Tree 的高度一般为 2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次 IO，那我们通过主键索引查询的时候，其实最多只需要 2-4 次 IO 操作就可以了。</p><h3 id="2-3-什么样的搜索可以用到索引？"><a href="#2-3-什么样的搜索可以用到索引？" class="headerlink" title="2.3 什么样的搜索可以用到索引？"></a>2.3 什么样的搜索可以用到索引？</h3><p>根据前面的介绍，我们可以得出结论，在以下类型的搜索中，会用到索引：</p><ul><li>全值匹配</li></ul><p>如上图中，如果我们要搜索 username 为 ac 且 age 为 98 的用户，就可以直接使用索引精确定位到。</p><ul><li>最左匹配</li></ul><p>如果我们只是想搜索 username 为 ac 的用户，很明显也可以使用上图索引，因为用户名是有序的。在上图中，username 和 age 组成了联合索引，其中 username 在前，age 在后，所以索引是先按照 username 进行排序，username 相同的时候，再按照 age 进行排序的（如 bw 这个用户），如果我们按照 username 进行搜索，那么没问题，可以用上索引；但是如果我们按照 age 进行搜索，很明显，age 在整个索引树中是无序的，所以当我们使用 age 作为搜索条件的时候，是没法使用上图这个联合索引的。</p><ul><li>前缀匹配</li></ul><p>如果我们搜索的关键字只是 username 字段的前半部分，那么很明显，也是可以使用索引的，例如搜索所有以 a 开始的 username。</p><ul><li>范围匹配</li></ul><p>如果我们的搜索条件是一个范围，很明显也可以使用到上述索引，例如搜索姓名介于 ab～cc 之间的用户，只需要先从索引树的根节点开始，先找到 ab，然后根据叶子节点之间的指针顺藤摸瓜，找到 cc 之后的第一个数据（不满足条件的第一个数据）结束。</p><ul><li>前面全值匹配，后面范围匹配</li></ul><p>例如查找 username 为 bw 且 age 介于 90～99 之间的用户，这种情况也可以使用到上图的索引。在上图索引树中，当 username 相同的时候，就是按照 age 排序的，所以对于 username 都为 bw 的用户，它就是按照 age 进行排序的，此时，我们当然可以按照 age 的范围进行搜索了。</p><ul><li>覆盖索引</li></ul><p>有的时候，我们搜索的数据都在索引树中了，例如上图中的索引，我们想搜索 username 为 bw 的用户的 age，由于 age 就在索引树中，直接返回即可，这就是覆盖索引了。</p><h3 id="2-4-使用限制"><a href="#2-4-使用限制" class="headerlink" title="2.4 使用限制"></a>2.4 使用限制</h3><p>毫无疑问，基于 B+Tree 的索引，其实也存在一些使用限制。例如：</p><ol><li>如果我们将 age 作为搜索条件，虽然 age 也是联合索引的一部分，但是 age 整体上在索引树中是无序的，所以将 age 作为搜索条件是没法使用上述索引的。</li><li>基于第一点，如果联合索引中还有第三、第四列等，那么凡是跳过第一列直接使用后面的列作为查询条件，索引都是不会生效的。</li><li>范围条件的右边无法使用索引直接定位。例如搜索 username 以 a 开头并且年龄为 99 的用户：<code>where username like &#39;a%&#39; and age=99</code>，此时 age=99 这个条件就无法在索引树中直接处理了（可以通过索引下推过滤）。原因很简单，当我们找到所有 username 以 a 开始的用户之后，这些用户的 age 并不是有序的，所以 age 就没法继续使用索引搜索了（但是可以通过索引下推过滤）。</li></ol><p>关于第三点，我举一个例子，假设我们还有两个用户，分别是：</p><ul><li>username 为 ad 且 age 为 80；</li><li>username 为 ae 且 age 为 88；</li></ul><p>那么我们完善一下上面 B+Tree 的图应该变成下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/mysql8_index_add_2_user.drawio.png" alt></p><p>可以看到，username 以 a 开始的用户，age 并不是有序的，所以就只能通过索引下推过滤了，而无法直接通过索引扫描定位数据。</p><p>对于第三点，如果范围搜索的字段值的可能性比较少，则可以通过多个等于比较来代替范围搜索。</p><h3 id="2-5-自适应哈希索引"><a href="#2-5-自适应哈希索引" class="headerlink" title="2.5 自适应哈希索引"></a>2.5 自适应哈希索引</h3><p>Hash 索引在 MySQL 中主要是 Memory 和 NDB 引擎支持，InnoDB 索引本身是 不支持的，但是 InnoDB 索引有一个特性叫做自适应哈希索引，<strong>自适应</strong>三个字意味着整个过程是全自动的，不需要开发者配置。</p><p>当 InnoDB 监控到某些索引值被频繁的访问时，那么它就会在 B+Tree 索引之上，构建一个 Hash 索引，进而通过 Hash 查找来快速访问数据。</p><p>默认情况下，自适应哈希索引是开启的状态，通过如下 SQL 我们可以查看：</p><p><img src="http://img.itboyhub.com/2022/08/20230411221054.png" alt></p><p>可以看到，这个默认就是开启的。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>整体上来说，使用索引有如下优点：</p><ul><li>减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和创建临时表。</li><li>索引将随机 IO 变为了顺序 IO。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前松哥写过一个 MySQL 系列，但是当时是基于 MySQL5.7 的，最近有空在看 MySQL8 的文档，发现和 MySQL5.7 相比还是有不少变化，同时 MySQL 又是小伙伴们在面试时一个非常重要的知识点，因此松哥打算最近再抽空和小伙伴们聊一聊 MySQL，讲讲原理，讲讲优化，我会从最基本最简单的开始，和大家梳理 MySQL 中常见的面试知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 系列完结～PDF 可以下载啦！</title>
    <link href="http://www.javaboy.org/2023/0407/grpc_pdf.html"/>
    <id>http://www.javaboy.org/2023/0407/grpc_pdf.html</id>
    <published>2023-04-07T10:58:59.000Z</published>
    <updated>2023-07-21T11:16:32.156Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-gRPC-入门"><a href="#1-gRPC-入门" class="headerlink" title="1 gRPC 入门"></a>1 gRPC 入门</h1><p>这篇文章本来要在年前和小伙伴们见面，但是因为我之前的 Mac 系统版本是 10.13.6，这个版本比较老，时至今天在运行一些新鲜玩意的时候有时候会有一些 BUG（例如运行最新版的 Nacos 等），运行 gRPC 的插件也有 BUG，代码总是生成有问题，但是因为系统升级是一个大事，所以一直等到过年放假，在家才慢慢折腾将 Mac 升级到目前的 13.1 版本，之前这些问题现在都没有了，gRPC 的案例现在也可以顺利跑起来了。</p><a id="more"></a><p>所以今天就来和小伙伴们简单聊一聊 gRPC。</p><h2 id="1-1-缘起"><a href="#1-1-缘起" class="headerlink" title="1.1 缘起"></a>1.1 缘起</h2><p>我为什么想写一篇 gRPC 的文章呢？其实本来我是想和小伙伴们梳理一下在微服务中都有哪些跨进城调用的方式，在梳理的过程中想到了 gRPC，发现还没写文章和小伙伴们聊过 gRPC，因此打算先来几篇文章和小伙伴们详细介绍一下 gRPC，然后再梳理微服务中的跨进程方案。</p><h2 id="1-2-什么是-gRPC"><a href="#1-2-什么是-gRPC" class="headerlink" title="1.2 什么是 gRPC"></a>1.2 什么是 gRPC</h2><p>了解 gRPC 之前先来看看什么是 RPC。</p><p>RPC 全称是 Remote Procedure Call，中文一般译作远程过程调用。RPC 是一种进程间的通信模式，程序分布在不同的地址空间里。简单来说，就是两个进程之间互相调用的一种方式。</p><p>gRPC 则是一个由 Google 发起的开源的 RPC 框架，它是一个高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。gRPC 通过对负载均衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和数据中心之间的服务。</p><p>在 gRPC 中，客户端应用程序可以直接调用部署在不同机器上的服务端应用程序中的方法，就好像它是本地对象一样，使用 gRPC 可以更容易地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定基于参数和返回类型远程调用的方法。在服务端侧，服务端实现接口，运行 gRPC 服务，处理客户端调用。在客户端侧，客户端拥有存根（Stub，在某些语言中称为客户端），它提供与服务端相同的方法。</p><p><img src="https://p3.ssl.qhimg.com/t01a1f4adda646f3a99.png" alt></p><p>gRPC 客户端和服务端可以在各种环境中运行和相互通信 – 从 Google 内部的服务器到你自己的桌面 – 并且可以使用 gRPC 支持的任何语言编写。因此，你可以轻松地用 Java 创建 gRPC 服务端，使用 Go、Python 或 Ruby 创建客户端。此外，最新的 Google API 将包含 gRPC 版本的接口，使你轻松地将 Google 功能构建到你的应用程序中。</p><p>gRPC 支持的语言版本：</p><p><img src="http://img.itboyhub.com/2022/08/20230204214656.png" alt></p><p>说了这么多，还是得整两个小案例小伙伴们可能才会清晰，所以我们也不废话了，上案例。</p><h2 id="1-3-实践"><a href="#1-3-实践" class="headerlink" title="1.3 实践"></a>1.3 实践</h2><p>先来看下我们的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── grpc-api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">├── grpc-client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">├── grpc-server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>大家看下，这里首先有一个 grpc-api，这个模块用来放我们的公共代码；grpc-server 是我们的服务端，grpc-client 则是我们的客户端，这些都是普通的 maven 项目。</p><h3 id="1-3-1-grpc-api"><a href="#1-3-1-grpc-api" class="headerlink" title="1.3.1 grpc-api"></a>1.3.1 grpc-api</h3><p>在 grpc-api 中，我们首先引入项目依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- necessary for Java 9+ --&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这些常规的依赖之外，还需要一个插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.21.7:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.51.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我来说一下这个插件的作用。</p><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 提供的一个成熟的开源的跨平台的序列化数据结构的协议，我们编写对应的 proto 文件，通过上面这个插件可以将我们编写的 proto 文件自动转为对应的 Java 类。</p><blockquote><p>多说一句，使用 Protocol Buffers 并不是必须的，也可以使用 JSON 等，但是目前来说这个场景更常用的还是 Portal Buffers。</p></blockquote><p>接下来我们在 main 目录下新建 proto 文件夹，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230204220245.png" alt></p><p>注意，这个文件夹位置是默认的。如果我们的 proto 文件不是放在 src/main/proto 位置，那么在配置插件的时候需要指定 proto 文件的位置，咱们本篇文章主要是入门，我这里就使用默认的位置。</p><p>在 proto 文件夹中，我们新建一个 product.proto 文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.demo&quot;;</span><br><span class="line">option java_outer_classname = &quot;ProductProto&quot;;</span><br><span class="line"></span><br><span class="line">package product;</span><br><span class="line"></span><br><span class="line">service ProductInfo &#123;</span><br><span class="line">  rpc addProduct (Product) returns (ProductId);</span><br><span class="line">  rpc getProduct(ProductId) returns(Product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Product &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  string name=2;</span><br><span class="line">  string description=3;</span><br><span class="line">  float price=4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ProductId &#123;</span><br><span class="line">  string value = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置算是一个比较核心的配置了，这里主要说明了负责进程传输的类、方法等到底是个啥样子：</p><ol><li><code>syntax = &quot;proto3&quot;;</code>：这个是 protocol buffers 的版本。</li><li><code>option java_multiple_files = true;</code>：这个字段是可选的，如果设置为 true，表示每一个 message 文件都会有一个单独的 class 文件；否则，message 全部定义在 outerclass 文件里。</li><li><code>option java_package = &quot;org.javaboy.grpc.demo&quot;;</code>：这个字段是可选的，用于标识生成的 java 文件的 package。如果没有指定，则使用 proto 里定义的 package，如果package 也没有指定，那就会生成在根目录下。</li><li><code>option java_outer_classname = &quot;ProductProto&quot;;</code>：这个字段是可选的，用于指定 proto 文件生成的 java 类的 outerclass 类名。什么是 outerclass？简单来说就是用一个 class 文件来定义所有的 message 对应的 Java 类，这个 class 就是 outerclass；如果没有指定，默认是 proto 文件的驼峰式；</li><li><code>package product;</code>：这个属性用来定义 message 的包名。包名的含义与平台语言无关，这个 package 仅仅被用在 proto 文件中用于区分同名的 message 类型。可以理解为 message 全名的前缀，和 message 名称合起来唯一标识一个 message 类型。当我们在 proto 文件中导入其他 proto 文件的 message，需要加上 package 前缀才行。所以包名是用来唯一标识 message 的。</li><li><code>service</code>：我们定义的跨平台方法都写在 service 中，上面的案例中我们定义了两个方法：addProduct 表示添加一件商品，参数是一个 Product 对象，返回值则是刚刚添加成功的商品的 ID；getProduct 则表示根据 ID 查询一个商品，参数是一个商品 ID，返回值则是查询到的商品对象。这里的定义相当于一个接口，将来我们要在 Java 代码中实现这个接口。</li><li><code>message</code>：这里有点像我们在 Java 中定义类，上文中我们定义了两个类，分别是 Product 和 ProductId 两个类。这两个类在 service 中被使用。</li></ol><p>message 中定义的有点像我们 Java 中定义的类，但是不能直接使用 Java 中的数据类型，毕竟这是 Protocol buffers，这个是和语言无关的，将来可以据此生成不同语言的代码，这里我们可以使用的类型和我们 Java 类型之间的对应关系如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203256.png" alt></p><p>另外我们在 message 中定义的属性的时候，都会给一个数字，例如 id=1，name=2 等，这个数字将来会在二进制消息中标识我们的字段，并且一旦我们的消息类型被使用就不应更改，这个有点像序列化的感觉。</p><p>实际上，这个 message 编译后的字节内容大概像下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/grpc-message-compile-struct-2.png" alt></p><p>这里的标签中的内容包含两部分，字段索引和字段类型，字段索引其实就是我们上面定义的数字。</p><p>定义完成之后，接下来我们就需要使用插件来生成对应的 Java 代码了，插件我们在前面已经引入了，现在只需要执行了，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203542.png" alt></p><p>注意，compile 和 compile-custom 两个指令都需要执行。其中 compile 用来编译消息对象，compile-custom 则依赖消息对象,生成接口服务。</p><p>首先我们点击 compile 看看生成的代码，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203927.png" alt></p><p>再看 compile-custom 生成的代码，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206204200.png" alt></p><p>好了，这样我们的准备工作就算完成了。</p><blockquote><p>有的小伙伴生成的代码文件夹颜色不对劲，此时有两种解决办法：1.选中目标文件夹，右键单击，选择 Mark Directory as-&gt; Generated Sources root；2.选中工程，右键单击，选择 Maven-&gt;Reload project。推荐使用第二种方案。</p></blockquote><h3 id="1-3-2-grpc-server"><a href="#1-3-2-grpc-server" class="headerlink" title="1.3.2 grpc-server"></a>1.3.2 grpc-server</h3><p>接下来我们创建 grpc-server 项目，并使该项目依赖 grpc-api，然后在 grpc-server 中，提供 ProductInfo 的具体实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProductInfoGrpc</span>.<span class="hljs-title">ProductInfoImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProduct</span><span class="hljs-params">(Product request, StreamObserver&lt;ProductId&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"request.toString() = "</span> + request.toString());</span><br><span class="line">        responseObserver.onNext(ProductId.newBuilder().setValue(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getProduct</span><span class="hljs-params">(ProductId request, StreamObserver&lt;Product&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        responseObserver.onNext(Product.newBuilder().setId(request.getValue()).setName(<span class="hljs-string">"三国演义"</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProductInfoGrpc.ProductInfoImplBase</code> 是根据我们在 proto 文件中定义的 service 自动生成的，我们的 ProductInfoImpl 继承自该类，并且提供了我们给出的方法的具体实现。</p><p>以 addProduct 方法为例，参数 request 就是将来客户端调用的时候传来的 Product 对象，返回结果则通过 responseObserver 来完成。我们的方法逻辑很简单，我就把参数传来的 Product 对象打印出来，然后构建一个 ProductId 对象并返回，最后调用 <code>responseObserver.onCompleted();</code> 表示数据返回完毕。</p><p>剩下的 getProduct 方法逻辑就很好懂了，我这里就不再赘述了。</p><p>最后，我们再把这个 grpc-server 项目启动起来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfoServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ProductInfoServer server = <span class="hljs-keyword">new</span> ProductInfoServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="hljs-keyword">new</span> ProductInfoImpl())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            ProductInfoServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们这里是一个 JavaSE 项目，为了避免项目启动之后就停止，我们这里调用了 <code>server.awaitTermination();</code> 方法，就是让服务启动成功之后不要停止。</p><h3 id="1-3-3-grpc-client"><a href="#1-3-3-grpc-client" class="headerlink" title="1.3.3 grpc-client"></a>1.3.3 grpc-client</h3><p>最后再来看看客户端的调用。首先 grpc-client 项目也是需要依赖 grpc-api 的，然后直接进行方法调用，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        ProductInfoGrpc.ProductInfoBlockingStub stub = ProductInfoGrpc.newBlockingStub(channel);</span><br><span class="line">        Product p = Product.newBuilder().setId(<span class="hljs-string">"1"</span>)</span><br><span class="line">                .setPrice(<span class="hljs-number">399.0f</span>)</span><br><span class="line">                .setName(<span class="hljs-string">"TienChin项目"</span>)</span><br><span class="line">                .setDescription(<span class="hljs-string">"SpringBoot+Vue3实战视频"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        ProductId productId = stub.addProduct(p);</span><br><span class="line">        System.out.println(<span class="hljs-string">"productId.getValue() = "</span> + productId.getValue());</span><br><span class="line">        Product product = stub.getProduct(ProductId.newBuilder().setValue(<span class="hljs-string">"99999"</span>).build());</span><br><span class="line">        System.out.println(<span class="hljs-string">"product.toString() = "</span> + product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里首先需要和服务端建立连接，给出服务端的地址和端口号即可，usePlaintext() 方法表示不使用 TLS 对连接进行加密（默认情况下会使用 TLS 对连接进行加密），生产环境建议使用加密连接。</p><p>剩下的代码就比较好懂了，创建 Product 对象，调用 addProduct 方法进行添加；创建 ProductId 对象，调用 getProduct。Product 对象和 ProductId 对象都是根据我们在 proto 中定义的 message 自动生成的。</p><h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><p>好啦，一个简单的例子，小伙伴们先对 gRPC 入个门，后面松哥会再整几篇文章跟大家介绍这里边的一些细节。</p><h1 id="2-gRPC-的四种通信模式"><a href="#2-gRPC-的四种通信模式" class="headerlink" title="2 gRPC 的四种通信模式"></a>2 gRPC 的四种通信模式</h1><blockquote><p>温馨提示：本文需要结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上一篇 gRPC 文章</a>一起食用，否则可能看不懂。</p></blockquote><p>前面一篇文章松哥和大家聊了 gRPC 的基本用法，今天我们再来稍微深入一点点，来看下 gRPC 中四种不同的通信模式。</p><p>gRPC 中四种不同的通信模式分别是：</p><ol><li>一元 RPC</li><li>服务端流 RPC</li><li>客户端流 RPC</li><li>双向流 RPC</li></ol><p>接下来松哥就通过四个完整的案例，来分别和向伙伴们演示这四种不同的通信模式。</p><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><p>关于 gRPC 的基础知识我们就不啰嗦了，咱们直接来看我今天的 proto 文件，如下：</p><p>这次我新建了一个名为 book.proto 的文件，这里主要定义了一些图书相关的方法，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.demo&quot;;</span><br><span class="line">option java_outer_classname = &quot;BookServiceProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package book;</span><br><span class="line"></span><br><span class="line">service BookService &#123;</span><br><span class="line">  rpc addBook(Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc getBook(google.protobuf.StringValue) returns (Book);</span><br><span class="line">  rpc searchBooks(google.protobuf.StringValue) returns (stream Book);</span><br><span class="line">  rpc updateBooks(stream Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc processBooks(stream google.protobuf.StringValue) returns (stream BookSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated string tags = 2;</span><br><span class="line">  string name = 3;</span><br><span class="line">  float price = 4;</span><br><span class="line">  string author = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message BookSet &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated Book bookList = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件中，有一些内容我们在<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>中都讲过了，讲过的我就不再重复了，我说一些<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有涉及到的东西：</p><ol><li>由于我们在这个文件中，引用了 Google 提供的 StringValue（<code>google.protobuf.StringValue</code>），所以这个文件上面我们首先用 import 导入相关的文件，导入之后，才可以使用。</li><li>在方法参数和返回值中出现的 stream，就表示这个方法的参数或者返回值是流的形式（其实就是数据可以多次传输）。</li><li>message 中出现了一个<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有的关键字 repeated，这个表示这个字段可以重复，可以简单理解为这就是我们 Java 中的数组。</li></ol><p>好了，和<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>相比，本文主要就是这几个地方不一样。</p><p>proto 文件写好之后，按照<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>介绍的方法进行编译，生成对应的代码，这里就不再重复了。</p><h2 id="2-2-一元-RPC"><a href="#2-2-一元-RPC" class="headerlink" title="2.2 一元 RPC"></a>2.2 一元 RPC</h2><p>一元 RPC 是一种比较简单的 RPC 模式，其实说白了我们<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>和大家介绍的就是一种一元 RPC，也就是客户端发起一个请求，服务端给出一个响应，然后请求结束。</p><p>上面我们定义的五个方法中，addBook 和 getBook 都算是一种一元 RPC。</p><h3 id="2-2-1-addBook"><a href="#2-2-1-addBook" class="headerlink" title="2.2.1 addBook"></a>2.2.1 addBook</h3><p>先来看 addBook 方法，这个方法的逻辑很简单，我们提前在服务端准备一个 Map 用来保存 Book，addBook 调用的时候，就把 book 对象存入到 Map 中，并且将 book 的 ID 返回，大家就这样一件事，来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        bookMap.put(request.getId(), request);</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>的小伙伴，我觉得这段代码应该很好理解。</p><p>客户端调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        addBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.addBook(Book.newBuilder().setPrice(<span class="hljs-number">99</span>).setId(<span class="hljs-string">"100"</span>).setName(<span class="hljs-string">"java"</span>).setAuthor(<span class="hljs-string">"javaboy"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"添加完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了 CountDownLatch 来实现线程等待，等服务端给出响应之后，客户端再结束。这里在回调的 onNext 方法中，我们就可以拿到服务端的返回值。</p><h3 id="2-2-2-getBook"><a href="#2-2-2-getBook" class="headerlink" title="2.2.2 getBook"></a>2.2.2 getBook</h3><p>getBook 跟上面的 addBook 类似，先来看服务端代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String id = request.getValue();</span><br><span class="line">        Book book = bookMap.get(id);</span><br><span class="line">        <span class="hljs-keyword">if</span> (book != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            responseObserver.onNext(book);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 getBook 就是根据客户端传来的 id，从 Map 中查询到一个 Book 并返回。</p><p>客户端调用代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        getBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.getBook(StringValue.newBuilder().setValue(<span class="hljs-string">"2"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"book = "</span> + book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们大概也能看出来，addBook 和 getBook 基本上操作套路是一模一样的。</p><h2 id="2-3-服务端流-RPC"><a href="#2-3-服务端流-RPC" class="headerlink" title="2.3 服务端流 RPC"></a>2.3 服务端流 RPC</h2><p>前面的一元 RPC，客户端发起一个请求，服务端给出一个响应，请求就结束了。服务端流则是客户端发起一个请求，服务端给一个响应序列，这个响应序列组成一个流。</p><p>上面我们给出的 searchBook 就是这样一个例子，searchBook 是传递图书的 tags 参数，然后在服务端查询哪些书的 tags 满足条件，将满足条件的书全部都返回去。</p><p>我们来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBooks</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = bookMap.keySet();</span><br><span class="line">        String tags = request.getValue();</span><br><span class="line">        <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Book book = bookMap.get(key);</span><br><span class="line">            <span class="hljs-keyword">int</span> tagsCount = book.getTagsCount();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tagsCount; i++) &#123;</span><br><span class="line">                String t = book.getTags(i);</span><br><span class="line">                <span class="hljs-keyword">if</span> (t.equals(tags)) &#123;</span><br><span class="line">                    responseObserver.onNext(book);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看下，这段 Java 代码应该很好理解：</p><ol><li>首先从 request 中提取客户端传来的 tags 参数。</li><li>遍历 bookMap，查看每一本书的 tags 是否等于客户端传来的 tags，如果相等，说明添加匹配，则通过 <code>responseObserver.onNext(book);</code> 将这本书写回到客户端。</li><li>等所有操作都完成后，执行 <code>responseObserver.onCompleted();</code>，表示服务端的响应序列结束了，这样客户端也就知道请求结束了。</li></ol><p>我们来看看客户端的代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        searchBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.searchBooks(StringValue.newBuilder().setValue(<span class="hljs-string">"明清小说"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码好理解，搜索的关键字是 <code>明清小说</code>，每当服务端返回一次数据的时候，客户端回调的 onNext 方法就会被触发一次，当服务端之行了 <code>responseObserver.onCompleted();</code> 之后，客户端的 onCompleted 方法也会被触发。</p><p>这个就是服务端流，客户端发起一个请求，服务端通过 onNext 可以多次写回数据。</p><h2 id="2-4-客户端流-RPC"><a href="#2-4-客户端流-RPC" class="headerlink" title="2.4 客户端流 RPC"></a>2.4 客户端流 RPC</h2><p>客户端流则是客户端发起多个请求，服务端只给出一个响应。</p><p>上面的 updateBooks 就是一个客户端流的案例，客户端想要修改图书，可以发起多个请求修改多本书，服务端则收集多次修改的结果，将之汇总然后一次性返回给客户端。</p><p>我们先来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;Book&gt; <span class="hljs-title">updateBooks</span><span class="hljs-params">(StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"更新的图书 ID 为："</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                bookMap.put(book.getId(), book);</span><br><span class="line">                sb.append(book.getId())</span><br><span class="line">                        .append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                responseObserver.onNext(StringValue.newBuilder().setValue(sb.toString()).build());</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端每发送一本书来，就会触发服务端的 onNext 方法，然后我们在这方法中进行图书的更新操作，并记录更新结果。最后，我们在 onCompleted 方法中，将更新结果汇总返回给客户端，基本上就是这样一个流程。</p><p>我们再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        updateBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;Book&gt; request = stub.updateBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"更新完毕"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"a"</span>).setAuthor(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"c"</span>).setAuthor(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端这块，updateBooks 方法会返回一个 StreamObserver<book> 对象，调用该对象的 onNext 方法就是给服务端传递数据了，可以传递多个数据，调用该对象的 onCompleted 方法就是告诉服务端数据传递结束了，此时也会触发服务端的 onCompleted 方法，服务端的 onCompleted 方法执行之后，进而触发了客户端的 onCompleted 方法。</book></p><h2 id="2-5-双向流-RPC"><a href="#2-5-双向流-RPC" class="headerlink" title="2.5 双向流 RPC"></a>2.5 双向流 RPC</h2><p>双向流其实就是 3、4 小节的合体。即客户端多次发送数据，服务端也多次响应数据。</p><p>我们先来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;StringValue&gt; <span class="hljs-title">processBooks</span><span class="hljs-params">(StreamObserver&lt;BookSet&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                Book b = Book.newBuilder().setId(stringValue.getValue()).build();</span><br><span class="line">                books.add(b);</span><br><span class="line">                <span class="hljs-keyword">if</span> (books.size() == <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                    BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                    responseObserver.onNext(bookSet);</span><br><span class="line">                    books.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                responseObserver.onNext(bookSet);</span><br><span class="line">                books.clear();</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有实际意义，单纯为了给小伙伴们演示双向流，我的操作逻辑是客户端传递多个 ID 到服务端，然后服务端根据这些 ID 构建对应的 Book 对象，然后三个三个一组，再返回给客户端。客户端每次发送一个请求，都会触发服务端的 onNext 方法，我们在这个方法中对请求分组返回。最后如果还有剩余的请求，我们在 onCompleted() 方法中返回。</p><p>再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        processBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;StringValue&gt; request = stub.processBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;BookSet&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(BookSet bookSet)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"bookSet = "</span> + bookSet);</span><br><span class="line">                System.out.println(<span class="hljs-string">"============="</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"处理完毕！"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"a"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"c"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端的代码跟第四小节一模一样，不再赘述了。</p><p>好啦，这就是松哥和小伙伴们介绍的 gRPC 的四种不同的通信模式，文章中只给出了一些关键代码，如果小伙伴们没看明白，建议结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>一起阅读就懂啦～</p><h1 id="3-gRPC-中的拦截器"><a href="#3-gRPC-中的拦截器" class="headerlink" title="3 gRPC 中的拦截器"></a>3 gRPC 中的拦截器</h1><p>今天我们继续 gRPC 系列。</p><p>前面松哥跟大家聊了 gRPC 的简单案例，也说了四种不同的通信模式，感兴趣的小伙伴可以戳这里：</p><ol><li><a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">一个简单的案例入门 gRPC</a></li><li><a href="https://mp.weixin.qq.com/s/c-_D2RpLksIlYJDfaWOSkA" target="_blank" rel="noopener">聊一聊 gRPC 的四种通信模式</a></li></ol><p>今天我们来继续聊一聊 gRPC 中的拦截器。</p><p>有请求的发送、处理，当然就会有拦截器的需求，例如在服务端通过拦截器统一进行请求认证等操作，这些就需要拦截器来完成，今天松哥先和小伙伴们来聊一聊 gRPC 中拦截器的基本用法，后面我再整一篇文章和小伙伴们做一个基于拦截器实现的 JWT 认证的 gRPC。</p><p>gRPC 中的拦截器整体上来说可以分为两大类：</p><ol><li>服务端拦截器</li><li>客户端拦截器</li></ol><p>我们分别来看。</p><h2 id="3-1-服务端拦截器"><a href="#3-1-服务端拦截器" class="headerlink" title="3.1 服务端拦截器"></a>3.1 服务端拦截器</h2><p>服务端拦截器的作用有点像我们 Java 中的 Filter，服务端拦截器又可以继续细分为<strong>一元拦截器</strong>和<strong>流拦截器</strong>。</p><p>一元拦截器对应我们上篇文章中所讲的一元 RPC，也就是一次请求，一次响应这种情况。</p><p>流拦截器则对应我们上篇文章中所讲的服务端流 RPC、客户端流 RPC 以及双向流 RPC。</p><p>不过，在 Java 代码中，无论是一元拦截器还是流拦截器，代码其实都是一样的。不过如果你是用 Go 实现的 gRPC，那么这块是不一样的。</p><p>所以接下来的内容我就不去区分一元拦截器和流拦截器了，我们直接来看一个服务端拦截器的例子。</p><p>这里我就不从头开始写了，我们直接在上篇文章的基础之上继续添加拦截器即可。</p><p>服务端拦截器工作位置大致如下：</p><p><img src="http://img.itboyhub.com/2022/08/grpc-server-interceptor.drawio.png" alt></p><p>从这张图中小伙伴们可以看到，我们可以在服务端处理请求之前将请求拦截下来，统一进行权限校验等操作，也可以在服务端将请求处理完毕之后，准备响应的时候将响应拦截下来，可以对响应进行二次处理。</p><p>首先我们来看请求拦截器，实际上是一个监听器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCallListener</span>&lt;<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCallListener</span>&lt;<span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCall.Listener&lt;R&gt; delegate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceCallListener</span><span class="hljs-params">(ServerCall.Listener&lt;R&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> ServerCall.<span class="hljs-function">Listener&lt;R&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(R message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是客户端发来的消息，可以在这里进行预处理："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.onMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们自定义一个类，继承自 ForwardingServerCallListener 类，在这里重写 onMessage 方法，当有请求到达的时候，就会经过这里的 onMessage 方法。如果我们需要对传入的参数进行验证等操作，就可以在这里完成。</p><p>再来看看响应拦截器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCall</span>.<span class="hljs-title">SimpleForwardingServerCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BookServiceCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> ServerCall&lt;ReqT, RespT&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.delegate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodDescriptor&lt;ReqT, RespT&gt; <span class="hljs-title">getMethodDescriptor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getMethodDescriptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(RespT message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是服务端返回给客户端的消息："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可能发现了，我这里用到了很多泛型，请求类型和响应类型都不建议指定具体类型，因为拦截器可能会拦截多种类型的请求，请求参数和响应的数据类型都不一定一样。</p><p>这里是重写 sendMessage 方法，在这个方法中我们可以对服务端准备返回给客户端的消息进行预处理。</p><p>所以这个位置就相当于<strong>响应拦截器</strong>。</p><p>最后，我们需要在启动服务的时候，将这两个拦截器配置进去，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> BookServiceImpl(), <span class="hljs-keyword">new</span> ServerInterceptor() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next)</span> </span>&#123;</span><br><span class="line">                    String fullMethodName = call.getMethodDescriptor().getFullMethodName();</span><br><span class="line">                    System.out.println(fullMethodName + <span class="hljs-string">":pre"</span>);</span><br><span class="line">                    Set&lt;String&gt; keys = headers.keys();</span><br><span class="line">                    <span class="hljs-keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                        System.out.println(key + <span class="hljs-string">"&gt;&gt;&gt;"</span> + headers.get(Metadata.Key.of(key, ASCII_STRING_MARSHALLER)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BookServiceCallListener&lt;&gt;(next.startCall(<span class="hljs-keyword">new</span> BookServiceCall(call), headers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        BookServiceServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我之前服务启动的方法，以前我们调用 addService 方法的时候，直接添加对应的服务就可以了，现在，我们除了添加之前的 BookServiceImpl 服务之外，还额外给了一个拦截器。</p><p>每当请求到达的时候，就会经过拦截器的 interceptCall 方法，这个方法有三个参数：</p><ul><li>第一个参数 call 是消费传入的 RPC 消息的一个回调。</li><li>第二个参数 headers 则是请求的消息头，如果我们通过 JWT 进行请求校验，那么就从这个 headers 中提取出请求的 JWT 令牌然后进行校验。</li><li>第三个参数 next 就类似于我们在 Java 过滤器 filter 中的 filterChain 一样，让这个请求继续向下走。</li></ul><p>在这个方法中，我们请求头的信息都打印出来给小伙伴们参考了。然后在返回值中，将我们刚刚写的请求拦截器和响应拦截器构建并返回。</p><p>好啦，这样我们的服务端拦截器就搞好啦～无论是一元的 RPC 消息还是流式的 RPC 消息，都会经过这个拦截器，响应也是一样。</p><h2 id="3-2-客户端拦截器"><a href="#3-2-客户端拦截器" class="headerlink" title="3.2 客户端拦截器"></a>3.2 客户端拦截器</h2><p>客户端拦截器就比较简单了，客户端拦截器可以将我们的请求拦截下来，例如我们如果想为所有请求添加统一的令牌 Token，那么就可以在这里来做，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .intercept(<span class="hljs-keyword">new</span> ClientInterceptor() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; <span class="hljs-function">ClientCall&lt;ReqT, RespT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, Channel next)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line">                callOptions = callOptions.withAuthority(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> next.newCall(method,callOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br></pre></td></tr></table></figure><p>当我们的请求执行的时候，这个客户端拦截器就会被触发。</p><h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>好啦，今天就和小伙伴们简单介绍一下服务端拦截器和客户端拦截器。下篇文章，松哥会通过一个 JWT 认证来和小伙伴们演示这个拦截器的具体用法。</p><h1 id="4-gRPC-JWT"><a href="#4-gRPC-JWT" class="headerlink" title="4 gRPC + JWT"></a>4 gRPC + JWT</h1><p>上篇文章松哥和小伙伴们聊了在 gRPC 中如何使用拦截器，这些拦截器有服务端拦截器也有客户端拦截器，这些拦截器的一个重要使用场景，就是可以进行身份的校验。当客户端发起请求的时候，服务端通过拦截器进行身份校验，就知道这个请求是谁发起的了。今天松哥就来通过一个具体的案例，来和小伙伴们演示一下 gRPC 如何结合 JWT 进行身份校验。</p><h2 id="4-1-JWT-介绍"><a href="#4-1-JWT-介绍" class="headerlink" title="4.1 JWT 介绍"></a>4.1 JWT 介绍</h2><h3 id="4-1-1-无状态登录"><a href="#4-1-1-无状态登录" class="headerlink" title="4.1.1 无状态登录"></a>4.1.1 无状态登录</h3><h4 id="4-1-1-1-什么是有状态"><a href="#4-1-1-1-什么是有状态" class="headerlink" title="4.1.1.1 什么是有状态"></a>4.1.1.1 什么是有状态</h4><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h4 id="4-1-1-2-什么是无状态"><a href="#4-1-1-2-什么是无状态" class="headerlink" title="4.1.1.2 什么是无状态"></a>4.1.1.2 什么是无状态</h4><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="4-1-2-如何实现无状态"><a href="#4-1-2-如何实现无状态" class="headerlink" title="4.1.2 如何实现无状态"></a>4.1.2 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="4-1-3-JWT"><a href="#4-1-3-JWT" class="headerlink" title="4.1.3 JWT"></a>4.1.3 JWT</h3><h4 id="4-1-3-1-简介"><a href="#4-1-3-1-简介" class="headerlink" title="4.1.3.1 简介"></a>4.1.3.1 简介</h4><p>JWT，全称是 Json Web Token， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="4-1-3-2-JWT数据格式"><a href="#4-1-3-2-JWT数据格式" class="headerlink" title="4.1.3.2 JWT数据格式"></a>4.1.3.2 JWT数据格式</h4><p>JWT 包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul></li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><ul><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><ul><li>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</li></ul><p>生成的数据格式如下图：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="4-1-3-3-JWT-交互流程"><a href="#4-1-3-3-JWT-交互流程" class="headerlink" title="4.1.3.3 JWT 交互流程"></a>4.1.3.3 JWT 交互流程</h4><p>流程图：</p><p> <img src="http://img.itboyhub.com/2021/springboot2/37-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如 API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了 RESTful 的无状态规范。</p><h4 id="4-1-3-4-JWT-存在的问题"><a href="#4-1-3-4-JWT-存在的问题" class="headerlink" title="4.1.3.4 JWT 存在的问题"></a>4.1.3.4 JWT 存在的问题</h4><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><blockquote><p>当然，为了解决 JWT 存在的问题，也可以将 JWT 结合 Redis 来用，服务端生成的 JWT 字符串存入到 Redis 中并设置过期时间，每次校验的时候，先看 Redis 中是否存在该 JWT 字符串，如果存在就进行后续的校验。但是这种方式有点不伦不类（又成了有状态了）。</p></blockquote><h2 id="4-2-实践"><a href="#4-2-实践" class="headerlink" title="4.2 实践"></a>4.2 实践</h2><p>我们来看下 gRPC 如何结合 JWT。</p><h3 id="4-2-1-项目创建"><a href="#4-2-1-项目创建" class="headerlink" title="4.2.1 项目创建"></a>4.2.1 项目创建</h3><p>首先我先给大家看下我的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>还是跟之前文章中的一样，三个模块，grpc_api 用来存放一些公共的代码。</p><p>grpc_server 用来放服务端的代码，我这里服务端主要提供了两个接口：</p><ol><li>登录接口，登录成功之后返回 JWT 字符串。</li><li>hello 接口，客户端拿着 JWT 字符串来访问 hello 接口。</li></ol><p>grpc_client 则是我的客户端代码。</p><h3 id="4-2-2-grpc-api"><a href="#4-2-2-grpc-api" class="headerlink" title="4.2.2 grpc_api"></a>4.2.2 grpc_api</h3><p>我将 protocol buffers 和一些依赖都放在 grpc_api 模块中，因为将来我的 grpc_server 和 grpc_client 都将依赖 grpc_api。</p><p>我们来看下这里需要的依赖和插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.21.7:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.51.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的依赖和插件松哥在本系列的第一篇文章中都已经介绍过了，唯一不同的是，这里引入了 JWT 插件，JWT 我使用了比较流行的 JJWT 这个工具。JJWT 松哥在之前的文章和视频中也都有介绍过，这里就不再啰嗦了。</p><p>先来看看我的 Protocol Buffers 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.api&quot;;</span><br><span class="line">option java_outer_classname = &quot;LoginProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package login;</span><br><span class="line"></span><br><span class="line">service LoginService &#123;</span><br><span class="line">  rpc login (LoginBody) returns (LoginResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService&#123;</span><br><span class="line">  rpc sayHello(google.protobuf.StringValue) returns (google.protobuf.StringValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginBody &#123;</span><br><span class="line">  string username = 1;</span><br><span class="line">  string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginResponse &#123;</span><br><span class="line">  string token = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过前面几篇文章的介绍，这里我就不多说啦，就是定义了两个服务：</p><ul><li>LoginService：这个登录服务，传入用户名密码，返回登录成功之后的令牌。</li><li>HelloService：这个就是一个打招呼的服务，传入字符串，返回也是字符串。</li></ul><p>定义完成之后，生成对应的代码即可。</p><p>接下来再定义一个常量类供 grpc_server 和 grcp_client 使用，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthConstant</span> </span>&#123;</span><br><span class="line">    SecretKey JWT_KEY = Keys.hmacShaKeyFor(<span class="hljs-string">"hello_javaboy_hello_javaboy_hello_javaboy_hello_javaboy_"</span>.getBytes());</span><br><span class="line">    Context.Key&lt;String&gt; AUTH_CLIENT_ID = Context.key(<span class="hljs-string">"clientId"</span>);</span><br><span class="line">    String AUTH_HEADER = <span class="hljs-string">"Authorization"</span>;</span><br><span class="line">    String AUTH_TOKEN_TYPE = <span class="hljs-string">"Bearer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的每个常量我都给大家解释下：</p><ol><li>JWT_KEY：这个是生成 JWT 字符串以及进行 JWT 字符串校验的密钥。</li><li>AUTH_CLIENT_ID：这个是客户端的 ID，即客户端发送来的请求携带了 JWT 字符串，通过 JWT 字符串确认了用户身份，就存在这个变量中。</li><li>AUTH_HEADER：这个是携带 JWT 字符串的请求头的 KEY。</li><li>AUTH_TOKEN_TYPE：这个是携带 JWT 字符串的请求头的参数前缀，通过这个可以确认参数的类型，常见取值有 Bearer 和 Basic。</li></ol><p>如此，我们的 gRPC_api 就定义好了。</p><h3 id="4-2-3-grpc-server"><a href="#4-2-3-grpc-server" class="headerlink" title="4.2.3 grpc_server"></a>4.2.3 grpc_server</h3><p>接下来我们来定义 gRPC_server。</p><p>首先来定义登录服务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(<span class="hljs-string">"login error"</span>).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省事起见，我这里没有连接数据库，用户名和密码固定为 javaboy 和 123。</p><p>登录成功之后，就生成一个 JWT 字符串返回。</p><p>登录失败，就返回一个 login error 字符串。</p><p>再来看我们的 HelloService 服务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String clientId = AuthConstant.AUTH_CLIENT_ID.get();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(clientId + <span class="hljs-string">" say hello:"</span> + request.getValue()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个服务就更简单了，不啰嗦。唯一值得说的是 <code>AuthConstant.AUTH_CLIENT_ID.get();</code> 表示获取当前访问用户的 ID，这个用户 ID 是在拦截器中存入进来的。</p><p>最后，我们来看服务端比较重要的拦截器，我们要在拦截器中从请求头中获取到 JWT 令牌并解析，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> JwtParser parser = Jwts.parser().setSigningKey(AuthConstant.JWT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler)</span> </span>&#123;</span><br><span class="line">        String authorization = metadata.get(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER));</span><br><span class="line">        Status status = Status.OK;</span><br><span class="line">        <span class="hljs-keyword">if</span> (authorization == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"miss authentication token"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authorization.startsWith(AuthConstant.AUTH_TOKEN_TYPE)) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"unknown token type"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Jws&lt;Claims&gt; claims = <span class="hljs-keyword">null</span>;</span><br><span class="line">            String token = authorization.substring(AuthConstant.AUTH_TOKEN_TYPE.length()).trim();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                claims = parser.parseClaimsJws(token);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                status = Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (claims != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                Context ctx = Context.current()</span><br><span class="line">                        .withValue(AuthConstant.AUTH_CLIENT_ID, claims.getBody().getSubject());</span><br><span class="line">                <span class="hljs-keyword">return</span> Contexts.interceptCall(ctx, serverCall, metadata, serverCallHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverCall.close(status, <span class="hljs-keyword">new</span> Metadata());</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerCall.Listener&lt;ReqT&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑应该好理解：</p><ol><li>首先从 Metadata 中提取出当前请求所携带的 JWT 字符串（相当于从请求头中提取出来）。</li><li>如果第一步提取到的值为 null 或者这个值不是以指定字符 Bearer 开始的，说明这个令牌是一个非法令牌，设置对应的响应 status 即可。</li><li>如果令牌都没有问题的话，接下来就进行令牌的校验，校验失败，则设置相应的 status 即可。</li><li>校验成功的话，我们就会获取到一个 Jws<claims> 对象，从这个对象中我们可以提取出来用户名，并存入到 Context 中，将来我们在 HelloServiceImpl 中就可以获取到这里的用户名了。</claims></li><li>最后，登录成功的话，<code>Contexts.interceptCall</code> 方法构建监听器并返回；登录失败，则构建一个空的监听器返回。</li></ol><p>最后，我们再来看看启动服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        LoginServer server = <span class="hljs-keyword">new</span> LoginServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">                .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟之前的相比就多加了一个 Service，添加 HelloServiceImpl 服务的时候，多加了一个拦截器，换言之，登录的时候，请求是不会被这个认证拦截器拦截的。</p><p>好啦，这样我们的 grpc_server 就开发完成了。</p><h3 id="4-2-4-grpc-client"><a href="#4-2-4-grpc-client" class="headerlink" title="4.2.4 grpc_client"></a>4.2.4 grpc_client</h3><p>接下来我们来看 grpc_client。</p><p>先来看登录：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法直接调用就行了，看过前面几篇 gRPC 文章的话，这里都很好理解。</p><p>再来看 hello 接口的调用，这个接口调用需要携带 JWT 字符串，而携带 JWT 字符串，则需要我们构建一个 CallCredentials 对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtCredential</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallCredentials</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtCredential</span><span class="hljs-params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyRequestMetadata</span><span class="hljs-params">(RequestInfo requestInfo, Executor executor, MetadataApplier metadataApplier)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Metadata headers = <span class="hljs-keyword">new</span> Metadata();</span><br><span class="line">                headers.put(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER),</span><br><span class="line">                        String.format(<span class="hljs-string">"%s %s"</span>, AuthConstant.AUTH_TOKEN_TYPE, subject));</span><br><span class="line">                metadataApplier.apply(headers);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                metadataApplier.fail(Status.UNAUTHENTICATED.withCause(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisUsesUnstableApi</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将请求的 JWT 令牌放入到请求头中即可。</p><p>最后来看看调用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        sayHello(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(ManagedChannel channel)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        HelloServiceGrpc.HelloServiceStub helloServiceStub = HelloServiceGrpc.newStub(channel);</span><br><span class="line">        helloServiceStub</span><br><span class="line">                .withCallCredentials(<span class="hljs-keyword">new</span> JwtCredential(<span class="hljs-string">"eyJhbGciOiJIUzM4NCJ9.eyJzdWIiOiJqYXZhYm95In0.IMMp7oh1dl_trUn7sn8qiv9GtO-COQyCGDz_Yy8VI4fIqUcRfwQddP45IoxNovxL"</span>))</span><br><span class="line">                .sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"wangwu"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable.getMessage() = "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的登录令牌就是前面调用 login 方法时获取到的令牌。</p><p>好啦，大功告成。</p><h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><p>上面的登录与校验只是松哥给小伙伴们展示的一个具体案例而已，在此案例基础之上，我们还可以扩展出来更多写法，但是万变不离其宗，其他玩法就需要小伙伴们自行探索啦～</p><h1 id="5-gRPC-请求截止时间"><a href="#5-gRPC-请求截止时间" class="headerlink" title="5 gRPC 请求截止时间"></a>5 gRPC 请求截止时间</h1><p>在 HTTP 请求中，我们发送请求的时候，可以设置一个请求超时时间-connectTimeout，即在指定的时间内，如果请求没有到达服务端，为了避免客户端一直进行不必要的等待，就会抛出一个请求超时异常。</p><p>但是在微服务系统中，我们却很少设置请求超时时间，一般都是用另外一个概念代替，那就是请求截止时间。</p><p>这是什么原因呢？今天我们就来简单聊一聊这个话题。</p><p>在微服务中我们客户端的请求在服务端往往会有比较复杂的链条，我想起来 Spring Cloud Sleuth 官方给的一个请求链路追踪的图，我们直接拿来看下：</p><p><img src="https://i.328888.xyz/2023/04/04/ijoAso.jpeg" alt></p><p>这张图中，请求从客户端发起之后，在服务端一共经历了四个 SERVICE，对于这样的请求，如果我们还是按照之前发送普通 HTTP 请求的方式，设置一个 connectTimeout 显然是不够的。</p><p>我举个例子：</p><p>假设我们发送一个请求，为该请求设置 connectTimeout 为 5s，那么这个时间只对第一个服务 SERVICE1 有效，也就是请求在 5s 之内没有到达 SERVICE1，那么就会抛出连接超时异常；请求如果在 5s 之内到达 SERVICE1，那么就不会抛出异常，但是！！！，请求到达 SERVICE1 并不意味着请求结束，后面从 SERVICE1 到 SERVICE2，从 SERVICE2 到 SERVICE3，从 SERVICE3 到 SERVICE4，还有四个 HTTP 请求待处理，这些请求超时了怎么办？很明显，connectTimeout 属性对于后面几个请求就鞭长莫及了。</p><p>所以，对于这种场景，我们一般使用截止时间来处理。</p><p>截止时间相当于设置<strong>整个请求生命周期</strong>的时间，也就是这个请求，我要多久拿到结果。很明显，这个时间应该在客户端发起请求的时候设置。</p><p>gRPC 中提供了对应的方法，我们可以非常方便的设置请求的截止时间 DeadLineTime，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过 Thread.sleep 做个简单的休眠就行了，超时之后，客户端的 onError 方法会被触发，抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable = io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 2.939621462s. [closed=[], open=[[buffered_nanos=285550823, remote_addr=localhost/127.0.0.1:50051]]]</span><br></pre></td></tr></table></figure><p>好啦，一个简单的小细节，感兴趣的小伙伴不妨去试试啦～</p><h1 id="6-gRPC-异常处理"><a href="#6-gRPC-异常处理" class="headerlink" title="6 gRPC 异常处理"></a>6 gRPC 异常处理</h1><p>今天来和小伙伴们聊一聊该如何处理 gRPC 中遇到的异常。</p><p>在之前的几篇文章中，其实我们也遇到过异常问题，只是当时没有和小伙伴们细说，只是囫囵吞枣写了一个案例而已，今天我们就来把这个话题跟小伙伴们仔细捋一捋。</p><p>我们之前写过一个登录的案例，在之前的案例中，如果用户在登录时输入了错误的用户名密码的话，那么我们是通过一个普通的数据流返回异常信息，其实，对于异常信息，我们可以通过专门的异常通道来写回到客户端。</p><h2 id="6-1-服务端处理异常"><a href="#6-1-服务端处理异常" class="headerlink" title="6.1 服务端处理异常"></a>6.1 服务端处理异常</h2><p>先来看看服务端如何处理异常。</p><p>还是以我们之前的 gRPC 登录案例为例，我们修改服务端的登录逻辑如下（完整代码小伙伴们可以参考之前的 <a href="https://mp.weixin.qq.com/s/jIZrP-H3DmS9pvRD5QaTfA" target="_blank" rel="noopener">手把手教大家在 gRPC 中使用 JWT 完成身份校验</a> 一文）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onError(Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"login error"</span>).asException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，在登录失败时我们通过 <code>responseObserver.onError</code> 方法将异常信息写回到客户端。这个方法的参数是一个 Throwable 对象，对于这个对象，在 Status 这个枚举类中定义了一些常见的值，分别如下：</p><ul><li>OK(0)：请求成功。</li><li>CANCELLED(1)：操作被取消。</li><li>UNKNOWN(2)：未知错误。</li><li>INVALID_ARGUMENT(3)：客户端给了无效的请求参数。</li><li>DEADLINE_EXCEEDED(4)：请求超过了截止时间。</li><li>NOT_FOUND(5)：请求资源未找到。</li><li>ALREADY_EXISTS(6)：添加的内容已经存在。</li><li>PERMISSION_DENIED(7)：请求权限不足。</li><li>RESOURCE_EXHAUSTED(8)：资源耗尽。</li><li>FAILED_PRECONDITION(9)：服务端上为准备好。</li><li>ABORTED(10)：请求被中止。</li><li>OUT_OF_RANGE(11)：请求超出范围。</li><li>UNIMPLEMENTED(12)：未实现的操作。</li><li>INTERNAL(13)：服务内部错误。</li><li>UNAVAILABLE(14)：服务不可用。</li><li>DATA_LOSS(15)：数据丢失或者损毁。</li><li>UNAUTHENTICATED(16)：请求未认证。</li></ul><p>系统默认给出的请求类型大致上就这些。当然，如果这些并不能满足你的需求，我们也可以扩展这个枚举类。</p><h2 id="6-2-客户端处理异常"><a href="#6-2-客户端处理异常" class="headerlink" title="6.2 客户端处理异常"></a>6.2 客户端处理异常</h2><p>当服务端给出异常信息之后，客户端的处理分为两种情况。</p><h3 id="6-2-1-异步请求"><a href="#6-2-1-异步请求" class="headerlink" title="6.2.1 异步请求"></a>6.2.1 异步请求</h3><p>如果客户端是异步请求，则直接在异常回调中处理即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，直接在 onError 回到中处理异常即可。</p><h3 id="6-2-2-同步请求"><a href="#6-2-2-同步请求" class="headerlink" title="6.2.2 同步请求"></a>6.2.2 同步请求</h3><p>如果客户端请求是同步阻塞请求，那么就要通过异常捕获的方式获取服务端返回的异常信息了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步阻塞请求就通过异常捕获去获取服务端返回的异常信息即可。</p><h2 id="6-3-题外话"><a href="#6-3-题外话" class="headerlink" title="6.3 题外话"></a>6.3 题外话</h2><p>最后，再来和小伙伴们说一个提高 gRPC 数据传输效率的小技巧，那就是传输的数据可以使用 gzip 进行压缩。</p><p>具体处理方式就是在客户端调用 <code>withCompression</code> 方法指定数据压缩，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.withCompression(<span class="hljs-string">"gzip"</span>).login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，一个关于 gRPC 的小小知识点～</p><h1 id="7-TLS、CA-证书"><a href="#7-TLS、CA-证书" class="headerlink" title="7 TLS、CA 证书"></a>7 TLS、CA 证书</h1><p>松哥最近在和小伙伴们连载 gRPC，如何确保 gRPC 通信的安全性？这就涉及到 TSL 了，但是考虑到可能有小伙伴对加密连接这一整套方案比较陌生，因此我们今天先用一篇文章跟大家捋清楚这些概念，概念搞明白了，再来看 TSL+gRPC 就很容易了。</p><h2 id="7-1-HTTP-的问题"><a href="#7-1-HTTP-的问题" class="headerlink" title="7.1 HTTP 的问题"></a>7.1 HTTP 的问题</h2><p>HTTP 协议是超文本传输协议（Hyper Text Transfer Protocol）的缩写，它是从 WEB 服务器传输超文本标记语言 HTML 到本地浏览器的传送协议。HTTP 设计之初是为了提供一种发布和接收 HTML 页面的方法，时至今日，它的作用已经不仅仅于此了。</p><p>对于我们 Java 工程师而言，HTTP 应该算是再熟悉不过的东西了，目前 HTTP 有多个版本，使用较多的是 HTTP/1.1 版本。</p><p>然而 HTTP 协议有一个缺陷那就是它是通过明文传输数据的，用户通过 HTTP 协议传输的内容很容易被恶意拦截，并且黑客可以伪装成服务端，向用户传送错误的信息，并且能轻易获取用户的隐私信息，而这些操作用户是完全无感知的。</p><p>由于存在这样的安全隐患，现在小伙伴们见到的大部分网站都在逐步转为 HTTPS，HTTP 网站会越来越少了。</p><h2 id="7-2-HTTPS"><a href="#7-2-HTTPS" class="headerlink" title="7.2 HTTPS"></a>7.2 HTTPS</h2><p>HTTPS（HyperText Transfer Protocol Secure）中文译作超文本传输安全协议，这是一种通过计算机网络进行安全通讯的传输协议。</p><p>HTTPS 本质上还是由 HTTP 进行通信，只是在 HTTP 协议和 TCP 层之间增加了一个 SSL 的安全传输协议。整个传输的加密过程都在新的安全层 SSL/TLS 中实现，而原来的 HTTP 层的传输流程保持不变，这样就很好地兼容了旧的 HTTP 协议，也沿袭了 TCP/IP 协议族的分层思想。</p><p>通过 HTTPS，客户端可以确认服务端的身份，保证数据在传输过程中不被篡改，当我们在自己的浏览器上与某一个网站建立 HTTPS 连接的时候，满足如下情况可以表示这个服务端可以被信任：</p><ol><li>首先我们的操作系统中安装了正确且受信任的证书。我们在 cmd 命令行中执行 <code>certmgr.msc</code> 命令，可以查看操作系统已经安装的证书列表。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230314195612.png" alt></p><ol start="2"><li>浏览器本身正确实现了 HTTPS。</li><li>被访问的网站提供了一个证书，这个证书是由一个操作系统所信任的证书颁发机构签发的，操作系统所信任的证书颁发机构一般都预装在操作系统中，通过第一步的方式可以查看。</li><li>被访问的网站所提供的证书被成功认证。</li></ol><p>这里边涉及到一些证书和协议的概念，接下来松哥和大家把整个过程捋一捋。</p><h2 id="7-3-TLS-SSL"><a href="#7-3-TLS-SSL" class="headerlink" title="7.3 TLS/SSL"></a>7.3 TLS/SSL</h2><p>前面我们提到，HTTPS 就是在 HTTP 的基础之上增加了 TLS/SSL，那么这两个东西该如何理解呢？</p><p>SSL/TLS 是一种密码通信方案，算是目前使用最广泛的密码通信方案了。SSL 全称是 Secure Socket Layer，中文译作安全套接层，是 1994 年由 Netscape 公司设计的一套协议，并与 1995 年发布了 3.0 版本；TLS 全称是 Transport Layer Security，中文译作传输层安全，则是 IETF 在 SSL3.0 基础上设计的协议，实际上相当于 SSL 的后续版本，目前 TLS 先后迭代了 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 和 <code>TLS 1.3</code>，目前被广泛使用的是 <code>TLS 1.2</code> 版本。</p><p>SSL/TLS 涉及到了密码学中的对称加密、非对称加密、数字签名等等，算是密码学领域里的集大成者了。</p><h3 id="7-3-1-TLS"><a href="#7-3-1-TLS" class="headerlink" title="7.3.1 TLS"></a>7.3.1 TLS</h3><p>接下来我们就来看看 TLS 如何确保 HTTP 安全。</p><p>为了确保客户端和服务端之间的数据安全，我们很容易想到一种方案就是对传输的数据进行加密，没错，这是一个办法，事实上也是这么做的。</p><p>加密又分为两种：</p><ol><li>对称加密</li><li>非对称加密</li></ol><p>那么该使用哪一种呢？</p><p>对称加密，也就是加密密钥和解密密钥是同一个，当浏览器和服务端需要进行通信的时候，约定好一个密钥，然后使用这个密钥对发送的消息进行加密，对方收到消息之后再使用相同的密钥对消息进行解密。但是，在 B/S 架构的项目中，这种方案显然不合适，一个网站把自己的密钥告诉全世界所有的浏览器，那加密和不加密还有区别吗？</p><p>有小伙伴可能又想到了不对称加密，不对称加密倒是个办法，因为不对称加密是有一个密钥对公钥和私钥，公钥可以公布出来告诉所有人，私钥只有自己知道。通信的时候，客户端首先使用公钥对消息进行加密，服务端收到之后，再通过私钥对消息进行解密，这看起来似乎挺完美的。但是！！！非对称加密存在一个问题，就是非对称加密和解密相当耗时，通过这种方式处理加解密效率太低。</p><p>那怎么办？我们可以将两者结合起来。</p><p>具体来说，就是这样：<strong>首先服务端会生成一个非对称加密的密钥对，私钥自己保存，公钥发送给客户端，客户端拿到这个公钥之后，再生成一个对称加密的密钥，然后把对称加密的密钥通过公钥进行加密，加密之后发送给服务端，服务端通过私钥进行解密，这样客户端和服务端就可以通过对称加密进行通信了。</strong></p><p>事实上，TLS 大致上的思路就是这样的。</p><p>不过上面这个方案还是有一个漏洞，那就是服务端要通过明文传输的方式把公钥发送给客户端，这个过程还是不安全的，可能被人恶意截胡，那么这个问题该如何解决呢？</p><p>这就涉及到另外一个概念叫做数字证书了。</p><h3 id="7-3-2-CA"><a href="#7-3-2-CA" class="headerlink" title="7.3.2 CA"></a>7.3.2 CA</h3><p>数字证书是一个<strong>包含了目标网站各种信息如网站域名、证书有效期、签发机构、用于生成对称密钥的公钥、上级证书签发的签名等</strong>的文件，通过数字证书我们可以确认一个用户或者服务站点的身份。</p><p>实际场景中的数字证书是一系列的，形成了一个信任链，信任链的最顶端是 CA。</p><p>CA 是 Certificate Authority 的简写，它是一个负责发放和管理数字的证书的第三方权威机构。CA 的工作流程是这样的：</p><ol><li>CA 自己给自己颁发的用自己的私钥签名的证书称为根证书，根证书的私钥安全性至关重要，根证书的私钥都是被保存在离线计算机中，有严格的操作规章，每次需要使用时，会有专人将数据通过 USB 拷贝过去，操作完了以后，再将数据带出来（这个专指 CA 根证书的私钥）。</li><li>一个用户想要获取一个证书，首先自己得有一个密钥对，私钥自己留着，公钥以及其他信息发送给 CA，向 CA 提出申请，CA 判明用户的身份之后，会将这个公钥和用户的身份信息绑定，并且为绑定后的信息进行签名（签名是通过 CA 根证书的私钥进行的），最后将签名后的证书发给申请者。</li><li>一个用户想要鉴定一个证书的真伪，就通过 CA 的公钥对证书上的数字签名进行验证，验证通过，就认为这个这个证书是有效的。</li></ol><p><strong>上面这个流程中有一个重要前提，那就是 CA 受到大家所有人的信任。</strong></p><p>然而在实际操作中，我们并不能直接去跟 CA 申请一个数字证书，因为全世界要认证的内容太多了，CA 搞不过来，而且频繁的找 CA 申请，还有可能导致私钥泄漏，这可就是一个大的灾难了。</p><p>那怎么办呢？实际操作中，我们可以基于 CA 来构建一个信任链。具体来说，步骤是这样：</p><ol><li>首先我们的手机、笔记本等操作系统中都预装了 CA 颁发的根证书，他们是所有信任构建的基石，前面松哥已经截图给大家看了 Windows 中预装的根证书了。</li><li>假设 CA 签发了一个证书 A，在这个过程中 CA 称为 Issuer，A 称为 Subject，假设 A 是一个受信任的中间证书，已经预装在我们的操作系统中了。现在由 A 利用它自己的私钥给某一个网站签发了一个证书 B。</li><li>现在当我们的电脑需要访问该网站的时候，该网站就会给我们发来一个证书 B，由于我们的浏览器并不知道 B 证书是否合法，但是我们的电脑上已经预装了 A 证书，我们可以从 A 证书中提取出 A 的公钥，然后利用 A 的公钥对 B 证书的签名进行验证（因为 B 证书的签名是 A 的私钥签的），如果验证通过了，就说明 B 是合法的。</li><li>相同的道理，B 也可以继续签发 C 证书，C 继续签发 D 证书，这样就形成了一个信任链。</li><li>如果服务端的签名是 D 证书，那么一般来说，服务器返回给浏览器的就会包含 B、C、D 三个证书（因为 A 证书已经在我们的电脑上了），即使只返回 D 证书，浏览器也可以根据 D 书中的信息，自动下载到 B、C 两个证书然后进行验证。</li></ol><blockquote><p>松哥记得以前上大学的时候，在 12306 网站上买火车票，第一次访问的时候必须要自己先手动安装一个根证书到系统中，然后才能访问。这就是因为当时 12306 所使用的证书的签发机构不被浏览器认可，类似于上面的第 3 步，12306 给我发了一个数字证书 B 回来，但是浏览器上没有合适的公钥对这个 B 证书进行验证，当我往自己的系统上安装了 12306 给的证书之后，相当于我的电脑上有了一个证书 A，现在就可以对 B 证书进行验证了。</p></blockquote><p>总结一下：</p><ol><li>CA 是一个权威的机构，是一个发证机关，CA 发出来的证书可以证明一个人或者组织的身份。</li><li>任何人都可以得到 CA 的证书（含公钥），用以验证 CA 所签发的证书。</li><li>每一个数字证书都是由上级证书的私钥来签发的，处于最顶层的就是 CA 签发的根证书了，这个根证书没有上级证书了，所以这个根证书实际上是由 CA 自己的私钥来签发的，这也叫做自签名，即 Self-Signed。</li></ol><p>当我们有了数字签名之后，就可以解决 3.1 小节最后提出的问题了。服务端将数字签名发给浏览器，浏览器利用系统已经内置的公钥验签，确认签名没问题，然后就提取出来数字签名中的公钥，开始协商对称加密的私钥了～</p><p>好啦，有了这些知识储备之后，下篇文章松哥来和大家聊一聊 TLS+gRPC 怎么玩！</p><h1 id="8-gRPC-TLS"><a href="#8-gRPC-TLS" class="headerlink" title="8 gRPC+TLS"></a>8 gRPC+TLS</h1><p>前面松哥发了一篇文章和小伙伴们仔细聊了聊 TLS、CA 证书这些问题，还没看过的小伙伴可以先戳下面了解下：</p><ul><li><a href="https://mp.weixin.qq.com/s/4c4xTp52TyLCJtJTR7y_Rw" target="_blank" rel="noopener">TLS、SSL、CA 证书、公钥、私钥。。。今天捋一捋！</a></li></ul><p>今天我们要在前文的基础之上，来和小伙伴们聊一聊如何确保 gRPC 的通信安全。</p><p>确保 gRPC 的通信安全我们有很多种不同的方式，其中一种，就是对通信过程进行加密，使用上 TLS。对于 TLS 如何加密，如何协商密钥，这些我这里就不再啰嗦了，我在之前的文章中都已经介绍过了。咱们就直接来看具体的玩法。</p><p>这块整体上可以分为两大类：</p><ul><li>启用单向安全连接</li><li>启用 mTLS 安全连接</li></ul><p>我们分别来看。</p><h2 id="8-1-启用单向安全连接"><a href="#8-1-启用单向安全连接" class="headerlink" title="8.1 启用单向安全连接"></a>8.1 启用单向安全连接</h2><p>单向安全连接其实就是说只需要客户端校验服务端，确保客户端收到的消息来自预期的服务端，整个的校验就涉及到我们前文所说的 TLS、CA 等内容了，具体流程是这样：</p><ol><li>首先我们先在自己电脑本地生成一个自签名的 CA 证书。</li><li>利用这个 CA 证书，生成一个服务证书。</li></ol><p>大致上就这两个步骤就行了，然后在客户端和服务端中分别加载相应的证书即可。</p><blockquote><p>上面我们提到了需要先有一个自签名的 CA 证书，这一步其实也可以省略，省略之后就直接生成一个自签名的服务证书即可，然后在客户端和服务端都使用这个服务证书。</p></blockquote><p>来实际操作一下。</p><p>先自己安装一下 openssl 工具，配置一下环境变量，软件安装比较简单，我这里就不啰嗦了。</p><h3 id="8-1-1-生成-CA-证书"><a href="#8-1-1-生成-CA-证书" class="headerlink" title="8.1.1 生成 CA 证书"></a>8.1.1 生成 CA 证书</h3><p>首先我们来看下如何生成 CA 证书。</p><p>一共是三个步骤：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure><ul><li>out 表示输出的文件名。</li><li>2048 表示私钥的位数。</li></ul><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><p>CSR 即证书签名申请（Certificate Signing Request），获取 SSL 证书，需要先生成 CSR 文件并提交给证书颁发机构（CA）。CSR 包含了用于签发证书的公钥、用于辨识的名称信息（Distinguished Name）（例如域名）、真实性和完整性保护（例如数字签名），通常从 Web 服务器生成 CSR，同时创建加解密的公钥私钥对。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca.key -out ca.csr  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>subj 中描述的是一些国家、城市、组织以及通用名称（域名）等信息。</li></ul><ol start="3"><li>自签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>-x509 表示是要生成自签名证书。</li><li>-days 3650 表示证书有效期是 3650 天。</li><li>-key 表示生成证书所需要的密钥。</li></ul><p>有人说公钥呢？公钥其实就在 <code>.crt</code> 证书文件中。</p><h3 id="8-1-2-生成服务证书"><a href="#8-1-2-生成服务证书" class="headerlink" title="8.1.2 生成服务证书"></a>8.1.2 生成服务证书</h3><p>再来看生成服务证书，生成服务证书和生成 CA 证书其实整个过程差不多，唯一的区别在于，CA 证书是自签名的，而服务证书是 CA 的私钥给签名的，就这个差别。</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -out server.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><ul><li>-req 和 -in 指定了 server.csr，这个是证书请求文件，这里实际上是表示签署证书请求文件。</li></ul><p>证书现在就生成完毕。</p><p>这里我们生成的私钥都是 <code>.key</code> 文件，这个用我们 Java 代码加载的时候会有问题，我们要将之转为 <code>.pem</code> 格式然后再用 Java 代码进行加载，转换的命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform pem -in server.key -outform pem -nocrypt -out server.pem</span><br></pre></td></tr></table></figure><h3 id="8-1-3-单向加密"><a href="#8-1-3-单向加密" class="headerlink" title="8.1.3 单向加密"></a>8.1.3 单向加密</h3><p>现在证书都有了，在当前项目目录下新建一个文件夹，专门用来放证书，项目目录结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── certs</span><br><span class="line">│   ├── ca.crt</span><br><span class="line">│   ├── ca.csr</span><br><span class="line">│   ├── ca.key</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   ├── server.csr</span><br><span class="line">│   ├── server.key</span><br><span class="line">│   └── server.pem</span><br><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>我们看下代码该如何改造实现单向加密通信。</p><p>先来看服务端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .useTransportSecurity(certFile,keyFile)</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大家注意，由于我生成签名的时候，使用的域名是 <code>local.javaboy.org</code> 这是我在本地 hosts 文件中配置的，指向本地地址，所以在后续的通信中，我使用的域名都将是 <code>local.javaboy.org</code>。</p></blockquote><ol><li>Paths.get 方法表示从项目的根目录下开始查找文件，参数是可变长度参数，参数共同组成文件完整路径。</li><li>服务端需要加载服务签名和服务私钥，签名证书是客户端验证服务端身份用的，私钥则是服务端解密客户端消息使用的。</li></ol><p>服务端的改造就这些。</p><p>再来看客户端的改造：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(certFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端主要是加载 CA 证书文件，服务端的证书就是 CA 私钥签发的，但是需要 CA 公钥也就是 ca.crt 进行验签，所以这里客户端加载了 ca.crt 即可。</p><p>好啦，整体上的流程差不多就是这个样子。</p><h2 id="8-2-启用-mTLS-安全连接"><a href="#8-2-启用-mTLS-安全连接" class="headerlink" title="8.2 启用 mTLS 安全连接"></a>8.2 启用 mTLS 安全连接</h2><p>上面的例子只是客户端校验了服务端的身份，服务端并没有校验客户端的身份，如果想要双向校验，那么就把上面的流程对称操作一遍就可以了。</p><p>首先我们需要为客户端生成相应的证书，步骤跟前面也基本上一直，使用 CA 进行签名，如下：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key client.key -out client.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in client.csr -out client.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><p>然后来看看代码。</p><p>先来看服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    File caFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">    server = NettyServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .sslContext(GrpcSslContexts.forServer(certFile,keyFile).trustManager(caFile).clientAuth(ClientAuth.REQUIRE).build())</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer3.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端要加载的文件多了 <code>ca.crt</code>，这是给客户端验签的时候需要用到。</p><p>再来看看客户端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File caFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.crt"</span>).toFile();</span><br><span class="line">File keyFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.pem"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(caFile)</span><br><span class="line">        .keyManager(certFile, keyFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端多了 <code>client.crt</code> 和 <code>client.pem</code>，两者的作用根服务端中这两者的作用基本一致，前文已有说明，这里就不再赘述了。</p><p>好啦，如此之后，我们的 gRPC 通信就加上了 TLS 的外壳，更加安全了。</p><h1 id="9-gRPC-两种认证方式"><a href="#9-gRPC-两种认证方式" class="headerlink" title="9 gRPC 两种认证方式"></a>9 gRPC 两种认证方式</h1><p>在之前的文章中，松哥和小伙伴们聊了 gRPC+JWT 进行认证，这也是我们常用的认证方式之一，考虑到文章内容的完整性，今天松哥再来和小伙伴们聊一聊在 gRPC 中通过 HttpBasic 进行认证，HttpBasic 认证有一些天然的缺陷，这个在接下来的文章中松哥也会和大家进行分析。</p><p>好啦，如果还没看过之前的 gRPC+JWT 的文章，戳这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/jIZrP-H3DmS9pvRD5QaTfA" target="_blank" rel="noopener">手把手教大家在 gRPC 中使用 JWT 完成身份校验</a></li></ul><p>今天我们就来看看如何在 gRPC 中进行 Http Basic 认证。</p><h2 id="9-1-什么是-Basic-认证"><a href="#9-1-什么是-Basic-认证" class="headerlink" title="9.1 什么是 Basic 认证"></a>9.1 什么是 Basic 认证</h2><p>HTTP Basic authentication 中文译作 HTTP 基本认证，在这种认证方式中，将用户的登录用户名/密码经过 Base64 编码之后，放在请求头的 Authorization 字段中，从而完成用户身份的 认证。</p><p>这是一种在 RFC7235(<a href="https://tools.ietf.org/html/rfc7235" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7235</a>) 规范中定义的认证方式，当客户端发起一个请求之后，服务端可以针对该请求返回一个质询信息，然后客户端再􏰀供用户的凭 证信息。具体的质询与应答流程如图所示：</p><p><img src="http://img.itboyhub.com/2022/08/axx-xx-x10-1.png" alt></p><p>由上图可以看出，客户端的用户名和密码只是简单做了一个 Base64 转码，然后放到请求头中就传输到服务端了。</p><p>我们在日常的开发中，其实也很少见到这种认证方式，有的读者可能在一些老旧路由器中见过这种认证方式;另外，在一些非公开访问的 Web 应用中，可能也会见到这种认证方式。为什么很少见到这种认证方式的应用场景呢?主要还是安全问题。</p><p>HTTP 基本认证没有对传输的凭证信息进行加密，仅仅只是进行了 Base64 编码，这就造成了很大的安全隐患，所以如果用到了 HTTP 基本认证，一般都是结合 HTTPS 一起使用；同 时，一旦使用 HTTP 基本认证成功后，由于令牌缺乏有效期，除非用户重启浏览器或者修改密码，否则没有办法退出登录。</p><h2 id="9-2-gRPC-中的基本认证"><a href="#9-2-gRPC-中的基本认证" class="headerlink" title="9.2 gRPC 中的基本认证"></a>9.2 gRPC 中的基本认证</h2><p>gRPC 并没有为 Http Basic 认证提供专门的 API，如果我们需要在 gRPC 中进行 Http Basic 认证，需要自己手工处理。</p><p>不过相信小伙伴们看了上面的流程图之后，对于手工处理 gRPC+Http Basic 也没啥压力。</p><p>首先我们先来看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpBasicCredential</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallCredentials</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpBasicCredential</span><span class="hljs-params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">        <span class="hljs-keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyRequestMetadata</span><span class="hljs-params">(RequestInfo requestInfo, Executor executor, MetadataApplier metadataApplier)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                String token = <span class="hljs-keyword">new</span> String(Base64.getEncoder().encode((username + <span class="hljs-string">":"</span> + password).getBytes()));</span><br><span class="line">                Metadata headers = <span class="hljs-keyword">new</span> Metadata();</span><br><span class="line">                headers.put(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER),</span><br><span class="line">                        String.format(<span class="hljs-string">"%s %s"</span>, AuthConstant.AUTH_TOKEN_TYPE, token));</span><br><span class="line">                metadataApplier.apply(headers);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                metadataApplier.fail(Status.UNAUTHENTICATED.withCause(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisUsesUnstableApi</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当客户端发起一个请求的时候，我们构建一个 HttpBasicCredential 对象，并传入用户名和密码。</li><li>该对象核心的处理逻辑在 applyRequestMetadata 方法中，我们先按照 <code>username + &quot;:&quot; + password</code> 的形式将用户名和密码拼接成一个字符串，并对这个字符串进行 Base64 编码。</li><li>最后将编码结果放在请求头中，请求头的 KEY 就是 <code>AuthConstant.AUTH_HEADER</code> 变量，对应的具体值是 Authorization，请求头的 value 是通过 <code>String.format</code> 函数拼接出来的，实际上就是在 Base64 的编码的字符串上加上了 <code>Basic</code> 前缀。</li></ul><p>这块就是纯手工操作，技术原理跟我们之前讲的 JWT+gRPC 没有任何差别，基本上是一模一样的，所以我就不啰嗦了。</p><p>来看下前端请求该如何发起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, SSLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">        SslContext sslContext = GrpcSslContexts.forClient().trustManager(certFile).build();</span><br><span class="line"></span><br><span class="line">        ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .useTransportSecurity()</span><br><span class="line">                .sslContext(sslContext)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        sayHello(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(ManagedChannel channel)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        HelloServiceGrpc.HelloServiceStub helloServiceStub = HelloServiceGrpc.newStub(channel);</span><br><span class="line">        helloServiceStub</span><br><span class="line">                .withCallCredentials(<span class="hljs-keyword">new</span> HttpBasicCredential(<span class="hljs-string">"javaboy"</span>, <span class="hljs-string">"123"</span>))</span><br><span class="line">                .sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"wangwu"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable.getMessage() = "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 withCallCredentials 方法，在客户端发起请求的时候，把这段认证信息携带上。</p><p>再来看看服务端的处理。</p><p>服务端通过一个拦截器来统一处理，从请求头中提取出来认证信息并解析判断，逻辑如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> JwtParser parser = Jwts.parser().setSigningKey(AuthConstant.JWT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler)</span> </span>&#123;</span><br><span class="line">        String authorization = metadata.get(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER));</span><br><span class="line">        Status status = Status.OK;</span><br><span class="line">        <span class="hljs-keyword">if</span> (authorization == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"miss authentication token"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authorization.startsWith(AuthConstant.AUTH_TOKEN_TYPE)) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"unknown token type"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                String token = authorization.substring(AuthConstant.AUTH_TOKEN_TYPE.length()).trim();</span><br><span class="line">                String[] split = <span class="hljs-keyword">new</span> String(Base64.getDecoder().decode(token)).split(<span class="hljs-string">":"</span>);</span><br><span class="line">                String username = split[<span class="hljs-number">0</span>];</span><br><span class="line">                String password = split[<span class="hljs-number">1</span>];</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">                    Context ctx = Context.current()</span><br><span class="line">                            .withValue(AuthConstant.AUTH_CLIENT_ID, username);</span><br><span class="line">                    <span class="hljs-keyword">return</span> Contexts.interceptCall(ctx, serverCall, metadata, serverCallHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                status = Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverCall.close(status, <span class="hljs-keyword">new</span> Metadata());</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerCall.Listener&lt;ReqT&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先从请求头中取出 Base64 编码之后的令牌。</li><li>如果取出的值为 null，则返回 <code>miss authentication token</code>。</li><li>如果取出的令牌的起始字符不对，则返回 <code>unknown token type</code>。</li><li>如果前面都没问题，则开始对拿到的字符串进行 Base64 解码，解码之后做字符串拆分，然后分别判断用户名和密码是否正确，如果正确，则将用户名存入到 Context 中，在后续的业务逻辑中就可以使用了。</li></ol><p>服务端的启动代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        LoginServer server = <span class="hljs-keyword">new</span> LoginServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">        File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">                .useTransportSecurity(certFile,keyFile)</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看下，就是用了下这个拦截器而已。</p><p>最后，在业务代码中，也可以直接访问到刚刚认证成功的用户名：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String clientId = AuthConstant.AUTH_CLIENT_ID.get();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(clientId + <span class="hljs-string">" say hello:"</span> + request.getValue()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，大功告成。</p><h2 id="9-3-小结"><a href="#9-3-小结" class="headerlink" title="9.3 小结"></a>9.3 小结</h2><p>和之前的 JWT 相比，Http Basic 认证的缺点还是非常明显的，但是从认证流程来说，感觉两者差别不大，只是创建令牌和解析令牌的方式不同而已。</p><p>感兴趣的小伙伴可以尝试一下哦。</p><p>本文松哥只贴出来了一些关键代码，完整的代码小伙伴们可以从 GitHub 上下载：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p><h1 id="10-Spring-Boot-Nacos-gRPC"><a href="#10-Spring-Boot-Nacos-gRPC" class="headerlink" title="10 Spring Boot+Nacos+gRPC"></a>10 Spring Boot+Nacos+gRPC</h1><p>gRPC 的基础知识前面跟小伙伴们分享了很多了，今天再写一篇给这个小小的系列收个尾。</p><p>我们前面介绍的都是 gRPC 的基本用法，最终目的当然是希望能够在 Spring Boot 中用上这个东西，相信大部分小伙伴对于微服务的通信方案如 OpenFeign、Dubbo、消息驱动都有所了解，但是对于这三种方案之外的其他方案，可能听的多用的少，今天我们就来实践一下 gRPC 这种方案。</p><blockquote><p>顺便说一下我为什么会想到写 gRPC 教程呢，是因为之前我想给小伙伴们总结一下常见的各种微服务通信方案。整理到 gRPC 的时候发现我还没写过 gRPC 相关的教程，因此就有了一个小系列。</p></blockquote><h2 id="10-1-依赖选择"><a href="#10-1-依赖选择" class="headerlink" title="10.1 依赖选择"></a>10.1 依赖选择</h2><p>Spring Boot 整合 gRPC，官方其实并没有提供相应的依赖，不过目前有一个比较流行的第三方库可以使用：</p><ul><li><a href="https://github.com/yidongnan/grpc-spring-boot-starter" target="_blank" rel="noopener">https://github.com/yidongnan/grpc-spring-boot-starter</a></li></ul><p>接下来松哥就结合这个库，来和小伙伴们演示一下 Spring Boot+Nacos+gRPC 的用法。</p><p>可能有小伙伴也会见到一些其他的第三方库，这个其实都可以，只要稳定可靠就行，本文就以上面这个库为例来和小伙伴们介绍。</p><h2 id="10-2-准备工作"><a href="#10-2-准备工作" class="headerlink" title="10.2 准备工作"></a>10.2 准备工作</h2><p>这里我采用了 Nacos 来做服务注册中心，使用的 Nacos 版本是 2.0.2 这个版本。Nacos 简单安装一下就行了，为了省事，数据持久化啥的可以先不配置。也就是 Nacos 下载解压之后，直接执行如下命令单体运行就行了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>这块没啥好说的，松哥在 vhr 系列里也有相关的视频教程，这里就不啰嗦了。</p><h2 id="10-3-代码实践"><a href="#10-3-代码实践" class="headerlink" title="10.3 代码实践"></a>10.3 代码实践</h2><p>首先我们来看看我们的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─grpc-api</span><br><span class="line">│  └─src</span><br><span class="line">│      └─main</span><br><span class="line">│          └─proto</span><br><span class="line">├─grpc-client</span><br><span class="line">│  └─src</span><br><span class="line">│      ├─main</span><br><span class="line">│      │  ├─java</span><br><span class="line">│      │  └─resources</span><br><span class="line">│      └─test</span><br><span class="line">└─grpc-server</span><br><span class="line">    └─src</span><br><span class="line">        ├─main</span><br><span class="line">        │  ├─java</span><br><span class="line">        │  └─resources</span><br><span class="line">        └─test</span><br></pre></td></tr></table></figure><p>首先有一个公共的模块 grpc-api，这个模块用来放我们的公共代码和依赖，包括 Protocol Buffers 文件也放在这里。</p><p>grpc-client 和 grpc-server 就不用多说了，分别是我们的客户端和服务端。</p><h3 id="10-3-1-grpc-api"><a href="#10-3-1-grpc-api" class="headerlink" title="10.3.1 grpc-api"></a>10.3.1 grpc-api</h3><p>grpc-api 中主要是处理 grpc 相关的事情，包括添加需要的依赖、插件等，编写 Protocol Buffers 文件等。</p><p>我们先来看看该项目的 pom.xml 文件中的依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">protobuf.version</span>&gt;</span>3.21.7<span class="hljs-tag">&lt;/<span class="hljs-name">protobuf.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">protobuf-plugin.version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">protobuf-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">grpc.version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">grpc.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!-- Java 9+ compatibility - Do NOT update to 2.0.0 --&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;protobuf-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这块的依赖跟我们之前的 gRPC 文章中案例的依赖基本上都是一致的，没有区别，再来看看我们的 Protocol Buffers 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.api&quot;;</span><br><span class="line">option java_outer_classname = &quot;LoginProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package login;</span><br><span class="line"></span><br><span class="line">service HelloService&#123;</span><br><span class="line">  rpc sayHello(google.protobuf.StringValue) returns (google.protobuf.StringValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个 HelloService 服务。</p><h3 id="10-3-2-grpc-server"><a href="#10-3-2-grpc-server" class="headerlink" title="10.3.2 grpc-server"></a>10.3.2 grpc-server</h3><p>grpc-server 则是我们的服务端，这是一个 Spring Boot 工程，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.devh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-server-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于第三方库 <code>grpc-server-spring-boot-starter</code> 在支持 Spring Boot3 上还有一些瑕疵，因此我这里使用了 Spring Boot2.7.7 这个版本。</p><p>这里需要注意的是就是添加了 gRPC 的依赖 <code>grpc-server-spring-boot-starter</code> 和 nacos 的依赖。其他都是常规配置。</p><p>接下来我们来在服务端提供 gRPC 方法的实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GrpcService</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String value = request.getValue();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"hello "</span> + value).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，通过 <code>@GrpcService</code> 注解去标记我们的一个服务即可。</p><p>最后，在 application.yaml 中进行配置，将当前服务注册到 nacos 容器中：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">grpc:</span></span><br><span class="line"><span class="hljs-attr">  server:</span></span><br><span class="line"><span class="hljs-attr">    port:</span> <span class="hljs-number">9099</span></span><br><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  cloud:</span></span><br><span class="line"><span class="hljs-attr">    nacos:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        server-addr:</span> <span class="hljs-string">hc.javaboy.org:8848</span></span><br><span class="line"><span class="hljs-attr">        username:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        password:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">  application:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">grpc_server</span></span><br></pre></td></tr></table></figure><p>OK，服务端搞定。</p><h3 id="10-3-3-grpc-client"><a href="#10-3-3-grpc-client" class="headerlink" title="10.3.3 grpc-client"></a>10.3.3 grpc-client</h3><p>最后再来看看客户端。</p><p>先来看依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.devh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-client-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，客户端 grpc 的依赖是 <code>grpc-client-spring-boot-starter</code>，其他的基本上和服务端一致。</p><p>然后配置客户端，将之注册到 nacos 上，如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">server:</span></span><br><span class="line"><span class="hljs-attr">  port:</span> <span class="hljs-number">8088</span></span><br><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  cloud:</span></span><br><span class="line"><span class="hljs-attr">    nacos:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">        server-addr:</span> <span class="hljs-string">hc.javaboy.org:8848</span></span><br><span class="line"><span class="hljs-attr">        username:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        password:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">  application:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">grpc_client</span></span><br><span class="line"><span class="hljs-attr">grpc:</span></span><br><span class="line"><span class="hljs-attr">  client:</span></span><br><span class="line"><span class="hljs-attr">    grpc_server:</span></span><br><span class="line"><span class="hljs-attr">      negotiation-type:</span> <span class="hljs-string">plaintext</span></span><br></pre></td></tr></table></figure><p>最后面有一个 grpc_server，这个是固定的（依据就是 grpc_server 注册到 nacos 上的名称），表示这个服务的通信不使用 TLS 加密。</p><p>最后再来看看调用代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    GrpcClientService grpcClientService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        grpcClientService.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrpcClientService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GrpcClient</span>(<span class="hljs-string">"grpc_server"</span>)</span><br><span class="line">    HelloServiceGrpc.HelloServiceBlockingStub helloServiceBlockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        StringValue s = helloServiceBlockingStub.sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"javaboy"</span>).build());</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心其实就是通过 <code>@GrpcClient</code> 注解注入一个 HelloServiceBlockingStub 实例，其中 <code>@GrpcClient</code> 注解中的参数就是注册到 nacos 上服务的名字，将来会自动根据服务的名字查找到服务的具体地址进行调用。</p><p>好啦，大功告成。</p><p>接下来我们启动 grpc_server 和 grpc_client 就可以进行测试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;1-gRPC-入门&quot;&gt;&lt;a href=&quot;#1-gRPC-入门&quot; class=&quot;headerlink&quot; title=&quot;1 gRPC 入门&quot;&gt;&lt;/a&gt;1 gRPC 入门&lt;/h1&gt;&lt;p&gt;这篇文章本来要在年前和小伙伴们见面，但是因为我之前的 Mac 系统版本是 10.13.6，这个版本比较老，时至今天在运行一些新鲜玩意的时候有时候会有一些 BUG（例如运行最新版的 Nacos 等），运行 gRPC 的插件也有 BUG，代码总是生成有问题，但是因为系统升级是一个大事，所以一直等到过年放假，在家才慢慢折腾将 Mac 升级到目前的 13.1 版本，之前这些问题现在都没有了，gRPC 的案例现在也可以顺利跑起来了。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Nacos+gRPC，一个区别于 OpenFeign 的微服务通信方案！</title>
    <link href="http://www.javaboy.org/2023/0403/gprc_nacos_springboot.html"/>
    <id>http://www.javaboy.org/2023/0403/gprc_nacos_springboot.html</id>
    <published>2023-04-03T10:58:45.000Z</published>
    <updated>2023-07-21T11:16:25.285Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 的基础知识前面跟小伙伴们分享了很多了，今天再写一篇给这个小小的系列收个尾。</p><a id="more"></a><p>我们前面介绍的都是 gRPC 的基本用法，最终目的当然是希望能够在 Spring Boot 中用上这个东西，相信大部分小伙伴对于微服务的通信方案如 OpenFeign、Dubbo、消息驱动都有所了解，但是对于这三种方案之外的其他方案，可能听的多用的少，今天我们就来实践一下 gRPC 这种方案。</p><blockquote><p>顺便说一下我为什么会想到写 gRPC 教程呢，是因为之前我想给小伙伴们总结一下常见的各种微服务通信方案。整理到 gRPC 的时候发现我还没写过 gRPC 相关的教程，因此就有了一个小系列。</p></blockquote><h2 id="1-依赖选择"><a href="#1-依赖选择" class="headerlink" title="1. 依赖选择"></a>1. 依赖选择</h2><p>Spring Boot 整合 gRPC，官方其实并没有提供相应的依赖，不过目前有一个比较流行的第三方库可以使用：</p><ul><li><a href="https://github.com/yidongnan/grpc-spring-boot-starter" target="_blank" rel="noopener">https://github.com/yidongnan/grpc-spring-boot-starter</a></li></ul><p>接下来松哥就结合这个库，来和小伙伴们演示一下 Spring Boot+Nacos+gRPC 的用法。</p><p>可能有小伙伴也会见到一些其他的第三方库，这个其实都可以，只要稳定可靠就行，本文就以上面这个库为例来和小伙伴们介绍。</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><p>这里我采用了 Nacos 来做服务注册中心，使用的 Nacos 版本是 2.0.2 这个版本。Nacos 简单安装一下就行了，为了省事，数据持久化啥的可以先不配置。也就是 Nacos 下载解压之后，直接执行如下命令单体运行就行了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>这块没啥好说的，松哥在 vhr 系列里也有相关的视频教程，这里就不啰嗦了。</p><h2 id="3-代码实践"><a href="#3-代码实践" class="headerlink" title="3. 代码实践"></a>3. 代码实践</h2><p>首先我们来看看我们的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─grpc-api</span><br><span class="line">│  └─src</span><br><span class="line">│      └─main</span><br><span class="line">│          └─proto</span><br><span class="line">├─grpc-client</span><br><span class="line">│  └─src</span><br><span class="line">│      ├─main</span><br><span class="line">│      │  ├─java</span><br><span class="line">│      │  └─resources</span><br><span class="line">│      └─test</span><br><span class="line">└─grpc-server</span><br><span class="line">    └─src</span><br><span class="line">        ├─main</span><br><span class="line">        │  ├─java</span><br><span class="line">        │  └─resources</span><br><span class="line">        └─test</span><br></pre></td></tr></table></figure><p>首先有一个公共的模块 grpc-api，这个模块用来放我们的公共代码和依赖，包括 Protocol Buffers 文件也放在这里。</p><p>grpc-client 和 grpc-server 就不用多说了，分别是我们的客户端和服务端。</p><h3 id="3-1-grpc-api"><a href="#3-1-grpc-api" class="headerlink" title="3.1 grpc-api"></a>3.1 grpc-api</h3><p>grpc-api 中主要是处理 grpc 相关的事情，包括添加需要的依赖、插件等，编写 Protocol Buffers 文件等。</p><p>我们先来看看该项目的 pom.xml 文件中的依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">protobuf.version</span>&gt;</span>3.21.7<span class="hljs-tag">&lt;/<span class="hljs-name">protobuf.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">protobuf-plugin.version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">protobuf-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">grpc.version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">grpc.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;grpc.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!-- Java 9+ compatibility - Do NOT update to 2.0.0 --&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;protobuf-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这块的依赖跟我们之前的 gRPC 文章中案例的依赖基本上都是一致的，没有区别，再来看看我们的 Protocol Buffers 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.api&quot;;</span><br><span class="line">option java_outer_classname = &quot;LoginProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package login;</span><br><span class="line"></span><br><span class="line">service HelloService&#123;</span><br><span class="line">  rpc sayHello(google.protobuf.StringValue) returns (google.protobuf.StringValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个 HelloService 服务。</p><h3 id="3-2-grpc-server"><a href="#3-2-grpc-server" class="headerlink" title="3.2 grpc-server"></a>3.2 grpc-server</h3><p>grpc-server 则是我们的服务端，这是一个 Spring Boot 工程，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>grpc-server<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.devh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-server-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于第三方库 <code>grpc-server-spring-boot-starter</code> 在支持 Spring Boot3 上还有一些瑕疵，因此我这里使用了 Spring Boot2.7.7 这个版本。</p><p>这里需要注意的是就是添加了 gRPC 的依赖 <code>grpc-server-spring-boot-starter</code> 和 nacos 的依赖。其他都是常规配置。</p><p>接下来我们来在服务端提供 gRPC 方法的实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GrpcService</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String value = request.getValue();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"hello "</span> + value).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，通过 <code>@GrpcService</code> 注解去标记我们的一个服务即可。</p><p>最后，在 application.yaml 中进行配置，将当前服务注册到 nacos 容器中：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">grpc:</span></span><br><span class="line"><span class="hljs-attr">  server:</span></span><br><span class="line"><span class="hljs-attr">    port:</span> <span class="hljs-number">9099</span></span><br><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  cloud:</span></span><br><span class="line"><span class="hljs-attr">    nacos:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        server-addr:</span> <span class="hljs-string">hc.javaboy.org:8848</span></span><br><span class="line"><span class="hljs-attr">        username:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        password:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">  application:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">grpc_server</span></span><br></pre></td></tr></table></figure><p>OK，服务端搞定。</p><h3 id="3-3-grpc-client"><a href="#3-3-grpc-client" class="headerlink" title="3.3 grpc-client"></a>3.3 grpc-client</h3><p>最后再来看看客户端。</p><p>先来看依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>grpc-client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.devh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-client-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，客户端 grpc 的依赖是 <code>grpc-client-spring-boot-starter</code>，其他的基本上和服务端一致。</p><p>然后配置客户端，将之注册到 nacos 上，如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">server:</span></span><br><span class="line"><span class="hljs-attr">  port:</span> <span class="hljs-number">8088</span></span><br><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  cloud:</span></span><br><span class="line"><span class="hljs-attr">    nacos:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">        server-addr:</span> <span class="hljs-string">hc.javaboy.org:8848</span></span><br><span class="line"><span class="hljs-attr">        username:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        password:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">  application:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">grpc_client</span></span><br><span class="line"><span class="hljs-attr">grpc:</span></span><br><span class="line"><span class="hljs-attr">  client:</span></span><br><span class="line"><span class="hljs-attr">    grpc_server:</span></span><br><span class="line"><span class="hljs-attr">      negotiation-type:</span> <span class="hljs-string">plaintext</span></span><br></pre></td></tr></table></figure><p>最后面有一个 grpc_server，这个是固定的（依据就是 grpc_server 注册到 nacos 上的名称），表示这个服务的通信不使用 TLS 加密。</p><p>最后再来看看调用代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    GrpcClientService grpcClientService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        grpcClientService.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrpcClientService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GrpcClient</span>(<span class="hljs-string">"grpc_server"</span>)</span><br><span class="line">    HelloServiceGrpc.HelloServiceBlockingStub helloServiceBlockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        StringValue s = helloServiceBlockingStub.sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"javaboy"</span>).build());</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心其实就是通过 <code>@GrpcClient</code> 注解注入一个 HelloServiceBlockingStub 实例，其中 <code>@GrpcClient</code> 注解中的参数就是注册到 nacos 上服务的名字，将来会自动根据服务的名字查找到服务的具体地址进行调用。</p><p>好啦，大功告成。</p><p>接下来我们启动 grpc_server 和 grpc_client 就可以进行测试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gRPC 的基础知识前面跟小伙伴们分享了很多了，今天再写一篇给这个小小的系列收个尾。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 的两种不同认证方式</title>
    <link href="http://www.javaboy.org/2023/0329/grpc_authentication.html"/>
    <id>http://www.javaboy.org/2023/0329/grpc_authentication.html</id>
    <published>2023-03-29T10:58:30.000Z</published>
    <updated>2023-07-21T11:16:21.941Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，松哥和小伙伴们聊了 gRPC+JWT 进行认证，这也是我们常用的认证方式之一，考虑到文章内容的完整性，今天松哥再来和小伙伴们聊一聊在 gRPC 中通过 HttpBasic 进行认证，HttpBasic 认证有一些天然的缺陷，这个在接下来的文章中松哥也会和大家进行分析。</p><a id="more"></a><p>好啦，如果还没看过之前的 gRPC+JWT 的文章，戳这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/jIZrP-H3DmS9pvRD5QaTfA" target="_blank" rel="noopener">手把手教大家在 gRPC 中使用 JWT 完成身份校验</a></li></ul><p>今天我们就来看看如何在 gRPC 中进行 Http Basic 认证。</p><h2 id="1-什么是-Basic-认证"><a href="#1-什么是-Basic-认证" class="headerlink" title="1. 什么是 Basic 认证"></a>1. 什么是 Basic 认证</h2><p>HTTP Basic authentication 中文译作 HTTP 基本认证，在这种认证方式中，将用户的登录用户名/密码经过 Base64 编码之后，放在请求头的 Authorization 字段中，从而完成用户身份的 认证。</p><p>这是一种在 RFC7235(<a href="https://tools.ietf.org/html/rfc7235" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7235</a>) 规范中定义的认证方式，当客户端发起一个请求之后，服务端可以针对该请求返回一个质询信息，然后客户端再􏰀供用户的凭 证信息。具体的质询与应答流程如图所示：</p><p><img src="http://img.itboyhub.com/2022/08/axx-xx-x10-1.png" alt></p><p>由上图可以看出，客户端的用户名和密码只是简单做了一个 Base64 转码，然后放到请求头中就传输到服务端了。</p><p>我们在日常的开发中，其实也很少见到这种认证方式，有的读者可能在一些老旧路由器中见过这种认证方式;另外，在一些非公开访问的 Web 应用中，可能也会见到这种认证方式。为什么很少见到这种认证方式的应用场景呢?主要还是安全问题。</p><p>HTTP 基本认证没有对传输的凭证信息进行加密，仅仅只是进行了 Base64 编码，这就造成了很大的安全隐患，所以如果用到了 HTTP 基本认证，一般都是结合 HTTPS 一起使用；同 时，一旦使用 HTTP 基本认证成功后，由于令牌缺乏有效期，除非用户重启浏览器或者修改密码，否则没有办法退出登录。</p><h2 id="2-gRPC-中的基本认证"><a href="#2-gRPC-中的基本认证" class="headerlink" title="2. gRPC 中的基本认证"></a>2. gRPC 中的基本认证</h2><p>gRPC 并没有为 Http Basic 认证提供专门的 API，如果我们需要在 gRPC 中进行 Http Basic 认证，需要自己手工处理。</p><p>不过相信小伙伴们看了上面的流程图之后，对于手工处理 gRPC+Http Basic 也没啥压力。</p><p>首先我们先来看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpBasicCredential</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallCredentials</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpBasicCredential</span><span class="hljs-params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">        <span class="hljs-keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyRequestMetadata</span><span class="hljs-params">(RequestInfo requestInfo, Executor executor, MetadataApplier metadataApplier)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                String token = <span class="hljs-keyword">new</span> String(Base64.getEncoder().encode((username + <span class="hljs-string">":"</span> + password).getBytes()));</span><br><span class="line">                Metadata headers = <span class="hljs-keyword">new</span> Metadata();</span><br><span class="line">                headers.put(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER),</span><br><span class="line">                        String.format(<span class="hljs-string">"%s %s"</span>, AuthConstant.AUTH_TOKEN_TYPE, token));</span><br><span class="line">                metadataApplier.apply(headers);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                metadataApplier.fail(Status.UNAUTHENTICATED.withCause(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisUsesUnstableApi</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当客户端发起一个请求的时候，我们构建一个 HttpBasicCredential 对象，并传入用户名和密码。</li><li>该对象核心的处理逻辑在 applyRequestMetadata 方法中，我们先按照 <code>username + &quot;:&quot; + password</code> 的形式将用户名和密码拼接成一个字符串，并对这个字符串进行 Base64 编码。</li><li>最后将编码结果放在请求头中，请求头的 KEY 就是 <code>AuthConstant.AUTH_HEADER</code> 变量，对应的具体值是 Authorization，请求头的 value 是通过 <code>String.format</code> 函数拼接出来的，实际上就是在 Base64 的编码的字符串上加上了 <code>Basic</code> 前缀。</li></ul><p>这块就是纯手工操作，技术原理跟我们之前讲的 JWT+gRPC 没有任何差别，基本上是一模一样的，所以我就不啰嗦了。</p><p>来看下前端请求该如何发起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, SSLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">        SslContext sslContext = GrpcSslContexts.forClient().trustManager(certFile).build();</span><br><span class="line"></span><br><span class="line">        ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .useTransportSecurity()</span><br><span class="line">                .sslContext(sslContext)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        sayHello(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(ManagedChannel channel)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        HelloServiceGrpc.HelloServiceStub helloServiceStub = HelloServiceGrpc.newStub(channel);</span><br><span class="line">        helloServiceStub</span><br><span class="line">                .withCallCredentials(<span class="hljs-keyword">new</span> HttpBasicCredential(<span class="hljs-string">"javaboy"</span>, <span class="hljs-string">"123"</span>))</span><br><span class="line">                .sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"wangwu"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable.getMessage() = "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 withCallCredentials 方法，在客户端发起请求的时候，把这段认证信息携带上。</p><p>再来看看服务端的处理。</p><p>服务端通过一个拦截器来统一处理，从请求头中提取出来认证信息并解析判断，逻辑如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> JwtParser parser = Jwts.parser().setSigningKey(AuthConstant.JWT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler)</span> </span>&#123;</span><br><span class="line">        String authorization = metadata.get(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER));</span><br><span class="line">        Status status = Status.OK;</span><br><span class="line">        <span class="hljs-keyword">if</span> (authorization == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"miss authentication token"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authorization.startsWith(AuthConstant.AUTH_TOKEN_TYPE)) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"unknown token type"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                String token = authorization.substring(AuthConstant.AUTH_TOKEN_TYPE.length()).trim();</span><br><span class="line">                String[] split = <span class="hljs-keyword">new</span> String(Base64.getDecoder().decode(token)).split(<span class="hljs-string">":"</span>);</span><br><span class="line">                String username = split[<span class="hljs-number">0</span>];</span><br><span class="line">                String password = split[<span class="hljs-number">1</span>];</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">                    Context ctx = Context.current()</span><br><span class="line">                            .withValue(AuthConstant.AUTH_CLIENT_ID, username);</span><br><span class="line">                    <span class="hljs-keyword">return</span> Contexts.interceptCall(ctx, serverCall, metadata, serverCallHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                status = Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverCall.close(status, <span class="hljs-keyword">new</span> Metadata());</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerCall.Listener&lt;ReqT&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先从请求头中取出 Base64 编码之后的令牌。</li><li>如果取出的值为 null，则返回 <code>miss authentication token</code>。</li><li>如果取出的令牌的起始字符不对，则返回 <code>unknown token type</code>。</li><li>如果前面都没问题，则开始对拿到的字符串进行 Base64 解码，解码之后做字符串拆分，然后分别判断用户名和密码是否正确，如果正确，则将用户名存入到 Context 中，在后续的业务逻辑中就可以使用了。</li></ol><p>服务端的启动代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        LoginServer server = <span class="hljs-keyword">new</span> LoginServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">        File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">                .useTransportSecurity(certFile,keyFile)</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看下，就是用了下这个拦截器而已。</p><p>最后，在业务代码中，也可以直接访问到刚刚认证成功的用户名：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String clientId = AuthConstant.AUTH_CLIENT_ID.get();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(clientId + <span class="hljs-string">" say hello:"</span> + request.getValue()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，大功告成。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>和之前的 JWT 相比，Http Basic 认证的缺点还是非常明显的，但是从认证流程来说，感觉两者差别不大，只是创建令牌和解析令牌的方式不同而已。</p><p>感兴趣的小伙伴可以尝试一下哦。</p><p>本文松哥只贴出来了一些关键代码，完整的代码小伙伴们可以从 GitHub 上下载：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，松哥和小伙伴们聊了 gRPC+JWT 进行认证，这也是我们常用的认证方式之一，考虑到文章内容的完整性，今天松哥再来和小伙伴们聊一聊在 gRPC 中通过 HttpBasic 进行认证，HttpBasic 认证有一些天然的缺陷，这个在接下来的文章中松哥也会和大家进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>TLS+gRPC怎么玩？如何让自己的RPC通信更加安全？</title>
    <link href="http://www.javaboy.org/2023/0323/tls_grpc.html"/>
    <id>http://www.javaboy.org/2023/0323/tls_grpc.html</id>
    <published>2023-03-23T13:30:06.000Z</published>
    <updated>2023-07-20T13:47:44.092Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥发了一篇文章和小伙伴们仔细聊了聊 TLS、CA 证书这些问题，还没看过的小伙伴可以先戳下面了解下：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/4c4xTp52TyLCJtJTR7y_Rw" target="_blank" rel="noopener">TLS、SSL、CA 证书、公钥、私钥。。。今天捋一捋！</a></li></ul><p>今天我们要在前文的基础之上，来和小伙伴们聊一聊如何确保 gRPC 的通信安全。</p><p>确保 gRPC 的通信安全我们有很多种不同的方式，其中一种，就是对通信过程进行加密，使用上 TLS。对于 TLS 如何加密，如何协商密钥，这些我这里就不再啰嗦了，我在之前的文章中都已经介绍过了。咱们就直接来看具体的玩法。</p><p>这块整体上可以分为两大类：</p><ul><li>启用单向安全连接</li><li>启用 mTLS 安全连接</li></ul><p>我们分别来看。</p><h2 id="1-启用单向安全连接"><a href="#1-启用单向安全连接" class="headerlink" title="1. 启用单向安全连接"></a>1. 启用单向安全连接</h2><p>单向安全连接其实就是说只需要客户端校验服务端，确保客户端收到的消息来自预期的服务端，整个的校验就涉及到我们前文所说的 TLS、CA 等内容了，具体流程是这样：</p><ol><li>首先我们先在自己电脑本地生成一个自签名的 CA 证书。</li><li>利用这个 CA 证书，生成一个服务证书。</li></ol><p>大致上就这两个步骤就行了，然后在客户端和服务端中分别加载相应的证书即可。</p><blockquote><p>上面我们提到了需要先有一个自签名的 CA 证书，这一步其实也可以省略，省略之后就直接生成一个自签名的服务证书即可，然后在客户端和服务端都使用这个服务证书。</p></blockquote><p>来实际操作一下。</p><p>先自己安装一下 openssl 工具，配置一下环境变量，软件安装比较简单，我这里就不啰嗦了。</p><h3 id="1-1-生成-CA-证书"><a href="#1-1-生成-CA-证书" class="headerlink" title="1.1 生成 CA 证书"></a>1.1 生成 CA 证书</h3><p>首先我们来看下如何生成 CA 证书。</p><p>一共是三个步骤：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure><ul><li>out 表示输出的文件名。</li><li>2048 表示私钥的位数。</li></ul><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><p>CSR 即证书签名申请（Certificate Signing Request），获取 SSL 证书，需要先生成 CSR 文件并提交给证书颁发机构（CA）。CSR 包含了用于签发证书的公钥、用于辨识的名称信息（Distinguished Name）（例如域名）、真实性和完整性保护（例如数字签名），通常从 Web 服务器生成 CSR，同时创建加解密的公钥私钥对。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca.key -out ca.csr  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>subj 中描述的是一些国家、城市、组织以及通用名称（域名）等信息。</li></ul><ol start="3"><li>自签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>-x509 表示是要生成自签名证书。</li><li>-days 3650 表示证书有效期是 3650 天。</li><li>-key 表示生成证书所需要的密钥。</li></ul><p>有人说公钥呢？公钥其实就在 <code>.crt</code> 证书文件中。</p><h3 id="1-2-生成服务证书"><a href="#1-2-生成服务证书" class="headerlink" title="1.2 生成服务证书"></a>1.2 生成服务证书</h3><p>再来看生成服务证书，生成服务证书和生成 CA 证书其实整个过程差不多，唯一的区别在于，CA 证书是自签名的，而服务证书是 CA 的私钥给签名的，就这个差别。</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -out server.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><ul><li>-req 和 -in 指定了 server.csr，这个是证书请求文件，这里实际上是表示签署证书请求文件。</li></ul><p>证书现在就生成完毕。</p><p>这里我们生成的私钥都是 <code>.key</code> 文件，这个用我们 Java 代码加载的时候会有问题，我们要将之转为 <code>.pem</code> 格式然后再用 Java 代码进行加载，转换的命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform pem -in server.key -outform pem -nocrypt -out server.pem</span><br></pre></td></tr></table></figure><h3 id="1-3-单向加密"><a href="#1-3-单向加密" class="headerlink" title="1.3 单向加密"></a>1.3 单向加密</h3><p>现在证书都有了，在当前项目目录下新建一个文件夹，专门用来放证书，项目目录结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── certs</span><br><span class="line">│   ├── ca.crt</span><br><span class="line">│   ├── ca.csr</span><br><span class="line">│   ├── ca.key</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   ├── server.csr</span><br><span class="line">│   ├── server.key</span><br><span class="line">│   └── server.pem</span><br><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>我们看下代码该如何改造实现单向加密通信。</p><p>先来看服务端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .useTransportSecurity(certFile,keyFile)</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大家注意，由于我生成签名的时候，使用的域名是 <code>local.javaboy.org</code> 这是我在本地 hosts 文件中配置的，指向本地地址，所以在后续的通信中，我使用的域名都将是 <code>local.javaboy.org</code>。</p></blockquote><ol><li>Paths.get 方法表示从项目的根目录下开始查找文件，参数是可变长度参数，参数共同组成文件完整路径。</li><li>服务端需要加载服务签名和服务私钥，签名证书是客户端验证服务端身份用的，私钥则是服务端解密客户端消息使用的。</li></ol><p>服务端的改造就这些。</p><p>再来看客户端的改造：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(certFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端主要是加载 CA 证书文件，服务端的证书就是 CA 私钥签发的，但是需要 CA 公钥也就是 ca.crt 进行验签，所以这里客户端加载了 ca.crt 即可。</p><p>好啦，整体上的流程差不多就是这个样子。</p><h2 id="2-启用-mTLS-安全连接"><a href="#2-启用-mTLS-安全连接" class="headerlink" title="2. 启用 mTLS 安全连接"></a>2. 启用 mTLS 安全连接</h2><p>上面的例子只是客户端校验了服务端的身份，服务端并没有校验客户端的身份，如果想要双向校验，那么就把上面的流程对称操作一遍就可以了。</p><p>首先我们需要为客户端生成相应的证书，步骤跟前面也基本上一直，使用 CA 进行签名，如下：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key client.key -out client.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in client.csr -out client.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><p>然后来看看代码。</p><p>先来看服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    File caFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">    server = NettyServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .sslContext(GrpcSslContexts.forServer(certFile,keyFile).trustManager(caFile).clientAuth(ClientAuth.REQUIRE).build())</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer3.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端要加载的文件多了 <code>ca.crt</code>，这是给客户端验签的时候需要用到。</p><p>再来看看客户端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File caFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.crt"</span>).toFile();</span><br><span class="line">File keyFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.pem"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(caFile)</span><br><span class="line">        .keyManager(certFile, keyFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端多了 <code>client.crt</code> 和 <code>client.pem</code>，两者的作用根服务端中这两者的作用基本一致，前文已有说明，这里就不再赘述了。</p><p>好啦，如此之后，我们的 gRPC 通信就加上了 TLS 的外壳，更加安全了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥发了一篇文章和小伙伴们仔细聊了聊 TLS、CA 证书这些问题，还没看过的小伙伴可以先戳下面了解下：&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>手把手教小伙伴们使用 Nginx 部署 TienChin 项目！</title>
    <link href="http://www.javaboy.org/2023/0320/tienchin_nginx_deploy.html"/>
    <id>http://www.javaboy.org/2023/0320/tienchin_nginx_deploy.html</id>
    <published>2023-03-20T13:29:55.000Z</published>
    <updated>2023-07-20T13:47:36.384Z</updated>
    
    <content type="html"><![CDATA[<p>TienChin 项目视频已经杀青啦！戳这里<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p><a id="more"></a><p>今天我就来手把手教小伙伴们部署 TienChin 项目，一起把这个项目跑起来，看看到底是个什么样的项目。</p><p>小伙伴们知道，对于这种前后端分离的项目，我们在实际部署的时候，可以按照前后端分离的方式来部署，也可以按照前后端不分的方式来部署。接下来两种不同的部署方式我都和小伙伴们来分享一下。</p><h2 id="1-前后端分离部署"><a href="#1-前后端分离部署" class="headerlink" title="1. 前后端分离部署"></a>1. 前后端分离部署</h2><h3 id="1-1-部署架构图"><a href="#1-1-部署架构图" class="headerlink" title="1.1 部署架构图"></a>1.1 部署架构图</h3><p>前后端分离部署的话，我们一般是需要一个 Nginx 服务器，我先画一个简单的部署示意图给大家参考下：</p><p><img src="http://img.itboyhub.com/2022/08/前后端分离部署架构图-2222.png" alt></p><p>简单解释一下就是这样：</p><ol><li>浏览器发出请求。</li><li>请求首先到达 Nginx 服务器，Nginx 服务器，由 Nginx 服务器进行请求分发。</li><li>如果是一个静态资源请求，则 Nginx 将之转发到静态资源服务器上，一般可能由 Nginx 自己兼任静态资源服务器，也就是直接从 Nginx 自己硬盘上将数据读取出来。</li><li>如果是一个动态资源，则 Nginx 将之转发到 Tomcat 上，对于我们这里就是我们的 Spring Boot 服务上了，当然，如果你没有这么多服务器，我们可以将 Nginx 和 Spring Boot 部署到同一台服务器上。</li></ol><p>好了，这就是我们的大致的一个部署架构图了，很简单。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2 准备工作"></a>1.2 准备工作</h3><p>接下来有几个事情是需要我们提前准备的。</p><p>首先我们先在服务器上安装好 MySQL 和 Redis，这个具体怎么安装我这里就不啰嗦了，基操而已。</p><blockquote><p>MySQL 建议大家用 Docker 安装，省事。如果不懂 Docker，可以在公众号后台回复 Docker 有松哥写的入门教程；Redis 可以直接安装，松哥在之前的 vhr 系列教程中包含有 Redis 教程，可以公众号后台回复 vhr 查看详情。</p></blockquote><p>这样我们的准备工作就完成了。</p><h3 id="1-3-开始部署"><a href="#1-3-开始部署" class="headerlink" title="1.3 开始部署"></a>1.3 开始部署</h3><h4 id="1-3-1-拉取项目"><a href="#1-3-1-拉取项目" class="headerlink" title="1.3.1 拉取项目"></a>1.3.1 拉取项目</h4><p>首先我们需要从 GitHub 上拉取我们的项目，TienChin 项目的源代码是开源的，大家可以直接 Clone：</p><ul><li><a href="https://github.com/lenve/tienchin" target="_blank" rel="noopener">https://github.com/lenve/tienchin</a></li></ul><p>直接执行 git clone 即可。</p><p><img src="http://img.itboyhub.com/2022/08/20230319204309.png" alt></p><p>拉取下来之后，有两个文件夹：</p><p><img src="http://img.itboyhub.com/2022/08/20230319204407.png" alt></p><ul><li>tienchin 是服务端代码。</li><li>tienchin-ui 是前端代码。</li></ul><h4 id="1-3-2-修改配置"><a href="#1-3-2-修改配置" class="headerlink" title="1.3.2 修改配置"></a>1.3.2 修改配置</h4><p>首先我们创建一个名为 tienchin 的数据库，这个好说。</p><p>接下来，我们找到 <code>tienchin/sql/tienchin-video_2023-03-13.sql</code> 文件，在 tienchin 数据库中执行该脚本。</p><p>接下来，我们找到 <code>tienchin/tienchin-admin/src/main/resources/application-druid.yml</code> 文件，在该文件中，根据自己的实际情况，修改数据库连接地址、数据库名称、用户名和密码。</p><p>继续打开 <code>tienchin/tienchin-admin/src/main/resources/application.yml</code> 文件，在该文件中配置 Redis 的地址、密码等信息。</p><p>另外还有一个非常重要的配置也需要修改，就是在 <code>tienchin/tienchin-admin/src/main/resources/application.yml</code> 文件中，将 <code>server.servlet.context-path</code> 的值改为 <code>/prod-api</code>。</p><h4 id="1-3-3-服务端打包"><a href="#1-3-3-服务端打包" class="headerlink" title="1.3.3 服务端打包"></a>1.3.3 服务端打包</h4><p>接下来我们进行服务端打包。小伙伴们需要在自己电脑上安装好 Maven 并且配置好环境变量，这也是基本操作，我就不啰嗦了。</p><blockquote><p>如果电脑上还没有配置 Maven 的话，建议使用 IDEA 自带的 Maven 插件，就不用额外下载了。IDEA 自带的 Maven 插件在安装目录下的 <code>plugins/maven</code> 目录下，可以直接配置这里的 bin 目录到环境变量中即可。</p></blockquote><p>服务端打包我们就进入到 tienchin 目录下，然后执行如下代码即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>看到如下代码就表示编译成功了：</p><p><img src="http://img.itboyhub.com/2022/08/20230319205042.png" alt></p><p>编译成功之后，在 <code>tienchin/tienchin-admin/target</code> 目录下，可以看到一个名为 <code>tienchin-admin.jar</code> 的 jar 文件，这就是我们所需要的服务端代码。</p><h4 id="1-3-4-前端打包"><a href="#1-3-4-前端打包" class="headerlink" title="1.3.4 前端打包"></a>1.3.4 前端打包</h4><p>接下来进入到 <code>tienchin-ui</code> 目录下，执行如下命令安装依赖（注意，前端需要 NodeJS 至少 14 往上的版本）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后再执行如下命令进行编译打包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 目录，里边的文件就是我们所需要的静态资源文件：</p><p><img src="http://img.itboyhub.com/2022/08/20230319213219.png" alt></p><p>这样，前端代码就打包完成了。</p><h4 id="1-3-5-安装-Nginx"><a href="#1-3-5-安装-Nginx" class="headerlink" title="1.3.5 安装 Nginx"></a>1.3.5 安装 Nginx</h4><p>接下来我们来安装 Nginx，我这里直接下载 Nginx 源码进行编译安装，步骤如下：</p><ol><li>首先安装如下两个编译工具</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib-devel</span><br><span class="line">yum -y install pcre pcre-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>下载 Nginx 源码并解压。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>编译安装</li></ol><p>进入到 nginx 解压目录中，分别执行如下命令进行编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>如此之后，我们的 Nginx 就安装好了。</p><h4 id="1-3-6-配置-Nginx"><a href="#1-3-6-配置-Nginx" class="headerlink" title="1.3.6 配置 Nginx"></a>1.3.6 配置 Nginx</h4><p>接下来我们首先通过命令或者文件上传工具，先把刚刚打包的后端的 tienchin-admin.jar 和前端的 dist 目录上传到服务器上面来。</p><p>接下来，我们首先启动服务端这个 <code>tienchin-admin.jar</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar tienchin-admin.jar &gt; tienchin.log &amp;</span><br></pre></td></tr></table></figure><p>有的小伙伴在服务端部署的时候，会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20230319220500.png" alt></p><p>这个是因为服务端缺乏相应的字体，而 Flowable 在自动生成部署图片的时候，需要用到这些字体，所以我们安装需要的字体即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install fontconfig</span><br><span class="line">fc-cache --force</span><br></pre></td></tr></table></figure><p>服务端启动成功之后，我们先用 postman 测试一下登录接口，确保能运行，就说明服务端部署成功：</p><p><img src="http://img.itboyhub.com/2022/08/20230319220933.png" alt></p><p>能成功登录，就说明服务端部署成功。</p><p>接下来部署前端。</p><p>前端部署很简单，我们只需要将 dist 中的内容拷贝到 nginx 的 html 目录下即可，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp dist/* /usr/local/nginx/html/</span><br></pre></td></tr></table></figure><p>接下来执行如下命令启动 nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>nginx 启动成功之后，就可以浏览器中访问页面了：</p><p><img src="http://img.itboyhub.com/2022/08/20230319221933.png" alt></p><p>当然，现在还登录不了，因为还缺少 Nginx 的请求转发，现在当我们请求 Nginx 的时候可以看到前端页面，但是服务端的数据请求，Nginx 并不会自动转发到 Spring Boot 上面去，所以还需要我们继续配置 Nginx，Nginx 配置文件的位置在 <code>/usr/local/nginx/conf/nginx.conf</code>，我们增加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /prod-api &#123;</span><br><span class="line">       proxy_pass http://127.0.0.1:8080;</span><br><span class="line">       tcp_nodelay     on;</span><br><span class="line">       proxy_set_header Host            $host;</span><br><span class="line">       proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">       root /usr/local/nginx/html/;</span><br><span class="line">       expires 30d;</span><br><span class="line">       try_files $uri $uri/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个配置参数的含义，我给大家稍微解释下：</p><ul><li>try_files：由于我们的前端 Vue 导航是 history 模式，这个不同于 vhr 的 hash 模式，history 模式会把请求路径发到 Nginx 上去找，很明显 Ngnix 找不到这样的路径，所以 try_files 就是说如果 404 了，就默认展示 index.html 页面即可，然后具体的路由导航由 vue-router 去完成。</li><li>tcp_nodelay：启动 TCP_NODELAY，其实就是禁用 Nagle 算法，允许小包的发送。对于延时敏感型，同时数据传输量比较小的应用，开启 TCP_NODELAY 选项无疑是一个正确的选择。Nagle 算法是先把数据缓存起来，攒到一块发送。</li></ul><p>配置完成后，重启 Nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>好啦，这次重启之后，就可以顺利玩耍啦～</p><p><img src="http://img.itboyhub.com/2022/08/20230319225414.png" alt></p><h2 id="2-前后端不分部署"><a href="#2-前后端不分部署" class="headerlink" title="2. 前后端不分部署"></a>2. 前后端不分部署</h2><p>前后端不分部署相对就简单一些，不需要 Nginx 了，不过前面 <code>1.3.1-1.3.4</code> 也是需要的。</p><p>1.3.4 小节中，我们拿到前端编译打包后的内容后，直接放到 tienchin-admin 模块的 static 静态资源目录下，然后继续将服务端打成 jar 包，将 jar 包上传到服务器并启动即可，启动命令和 1.3.6 小节介绍的 jar 包启动命令一致，这个过程比较简单，涉及到的相关命令前面都有介绍，我就不重复展示了。</p><p>最后，对 TienChin 项目感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TienChin 项目视频已经杀青啦！戳这里&lt;a href=&quot;https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TienChin 项目配套视频来啦&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>TienChin 项目视频完结啦~</title>
    <link href="http://www.javaboy.org/2023/0316/tienchin_video_finish.html"/>
    <id>http://www.javaboy.org/2023/0316/tienchin_video_finish.html</id>
    <published>2023-03-16T13:29:43.000Z</published>
    <updated>2023-07-20T13:47:40.046Z</updated>
    
    <content type="html"><![CDATA[<p>感谢小伙伴们长时间的等待，上周末我们的 TienChin 项目视频终于迎来了大结局~</p><a id="more"></a><p>一年时间，周末都不能好好休息，出去玩心里也总是惦记个事，现在好啦，更完啦，一共 433 集约 87 个小时，跟小伙伴们在网上看到的其他同类课程相比，性价比应该都是比较高的了。</p><p>跟大家再来介绍一下 TienChin 项目：</p><p>TienChin 项目是一个健身会员管理系统，基于 RuoYi-Vue 脚手架来做，使用 Spring Boot + Vue3 开发，不同于之前的 vhr 是一个脚手架，TienChin 项目的业务完成度会超过 90%。这个项目的视频教程整体上分为两大块：第一块主要是解剖 RuoYi-Vue 脚手架，让小伙伴们能够熟练掌握这个脚手架的使用，在这个过程中，我会讲许多技术点，前面列出来的视频目录都属于这一部分的内容，这个过程中我不会带领大家从头敲一遍 RuoYi-Vue 脚手架，但是对项目里边的一些技术点，会有针对性的讲解，也会写一些案例来帮助大家理解这些技术点。第二块内容则主要是业务功能的完成了，业务功能涉及到的技术点主要有：SpringBoot、Vue、MyBatis Plus、MySQL、Redis、Flowable、EasyExcel 等。</p><p>因为视频已经杀青了，按照之前的约定，价格要稍微调整一下，毕竟现在买的是现货不是期货了，从今天开始，我们的视频要打八折销售啦~八折就是 ￥319，另外，凡是购买过 vhr 的小伙伴，无论何时入手 TienChin，都在现价的基础上再优惠 30。</p><p>视频更完了，这么好的事情，我们也做一个小小的活动吧：<strong>今明两天购买视频的小伙伴（时间截止到 2023.03.17 23:59:59），可以参与松哥发起的一个抽奖活动，奖品是技术图书，包邮到家，中奖率是 20%。</strong></p><blockquote><p>奖品池有一半是我的签名图书，即《Spring Boot+Vue全栈开发实战》和《深入浅出 Spring Security》；另一半不是我写的书，但都是全新未拆封的技术相关的新书，即奖品是从我列出的书中选择。</p></blockquote><p>TienChin 项目视频基本上都是工作之余录制的，一开始是早上 6-8 点之间录的，时间久了起太早有点吃不消就改成了周末录，牺牲了太多休息时间，所以是付费视频，视频定价是 399，目前可以 8 折上车，也就是 319，之前买过 vhr 的小伙伴可在此基础上再优惠 30。</p><p>录视频还是蛮辛苦的，一方面赚点小钱养家糊口，另一方面也是小伙伴们的认可在支撑着我把这件事做下去，得瑟一下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/996.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/995.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/013.jpeg" alt></p><p><strong>有时候看小伙伴们发的，我真的特别动容。虽然大家看我天天写文章聊技术，其实我在生活中除了工作之外很少和人交流，真的特别想给这些爱学习会说话的小伙伴们点赞，他们肯定会混的比我好。</strong></p><hr><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在 TienChin 项目视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。和 vhr 视频相比，现在的 TienChin 项目视频音质是杠杠滴，下面三个视频是我最近发过的，小伙伴们可以当作试看的视频：</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过）。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>其实如果单纯带着大家写业务功能，这个项目不会花太多时间，这样虽然大家完整的做了一个项目，但是技术却不会有太多长进，而我则希望在这个过程中多整点活，能让小伙伴们技术也有一些提升，这样内容一加，最终何时更完就不确定了。不过，有一点是可以保证的，每周至少一次，每周至少更一个半小时精品视频。</p><p><strong>Q6：知识星球是什么？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问，小伙伴们购买视频后，我会拉你进星球。</p><p><strong>Q7：这套视频适合哪些人看？</strong></p><p>学习这套视频，首先需要有 SSM 基础，如果没有，可以在公众号后台回复 SSM，有我录制的免费视频教程；另外也需要一些 Spring Boot 基础和 Vue 基础，要是没接触过 Spring Boot 和 Vue 的话，那么建议先看看 vhr，戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频我能学到啥？</strong></p><p>TienChin 项目基于 RuoYi-Vue 脚手架（Spring Boot+Vue3），这套视频学完后，小伙伴们对 RuoYi-Vue 脚手架基本上就融会贯通了，并能在 RuoYi-Vue 脚手架上随心所欲的开发常规的企业后台应用。并且对于分布式事务 seata、Flowable 流程引擎等框架也能熟练使用并掌握其原理，对于 Redis 在项目中的各种实际应用场景也会有较好的掌握。</p><hr><p><strong>好啦，8 折 319 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，转账 319 上车吧（买过 vhr 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢小伙伴们长时间的等待，上周末我们的 TienChin 项目视频终于迎来了大结局~&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>TLS、SSL、CA 证书、公钥、私钥。。。今天捋一捋！</title>
    <link href="http://www.javaboy.org/2023/0315/tls_ssl_ca.html"/>
    <id>http://www.javaboy.org/2023/0315/tls_ssl_ca.html</id>
    <published>2023-03-15T13:29:29.000Z</published>
    <updated>2023-07-20T13:47:47.148Z</updated>
    
    <content type="html"><![CDATA[<p>松哥最近在和小伙伴们连载 gRPC，如何确保 gRPC 通信的安全性？这就涉及到 TSL 了，但是考虑到可能有小伙伴对加密连接这一整套方案比较陌生，因此我们今天先用一篇文章跟大家捋清楚这些概念，概念搞明白了，再来看 TSL+gRPC 就很容易了。</p><a id="more"></a><h2 id="1-HTTP-的问题"><a href="#1-HTTP-的问题" class="headerlink" title="1. HTTP 的问题"></a>1. HTTP 的问题</h2><p>HTTP 协议是超文本传输协议（Hyper Text Transfer Protocol）的缩写，它是从 WEB 服务器传输超文本标记语言 HTML 到本地浏览器的传送协议。HTTP 设计之初是为了提供一种发布和接收 HTML 页面的方法，时至今日，它的作用已经不仅仅于此了。</p><p>对于我们 Java 工程师而言，HTTP 应该算是再熟悉不过的东西了，目前 HTTP 有多个版本，使用较多的是 HTTP/1.1 版本。</p><p>然而 HTTP 协议有一个缺陷那就是它是通过明文传输数据的，用户通过 HTTP 协议传输的内容很容易被恶意拦截，并且黑客可以伪装成服务端，向用户传送错误的信息，并且能轻易获取用户的隐私信息，而这些操作用户是完全无感知的。</p><p>由于存在这样的安全隐患，现在小伙伴们见到的大部分网站都在逐步转为 HTTPS，HTTP 网站会越来越少了。</p><h2 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2. HTTPS"></a>2. HTTPS</h2><p>HTTPS（HyperText Transfer Protocol Secure）中文译作超文本传输安全协议，这是一种通过计算机网络进行安全通讯的传输协议。</p><p>HTTPS 本质上还是由 HTTP 进行通信，只是在 HTTP 协议和 TCP 层之间增加了一个 SSL 的安全传输协议。整个传输的加密过程都在新的安全层 SSL/TLS 中实现，而原来的 HTTP 层的传输流程保持不变，这样就很好地兼容了旧的 HTTP 协议，也沿袭了 TCP/IP 协议族的分层思想。</p><p>通过 HTTPS，客户端可以确认服务端的身份，保证数据在传输过程中不被篡改，当我们在自己的浏览器上与某一个网站建立 HTTPS 连接的时候，满足如下情况可以表示这个服务端可以被信任：</p><ol><li>首先我们的操作系统中安装了正确且受信任的证书。我们在 cmd 命令行中执行 <code>certmgr.msc</code> 命令，可以查看操作系统已经安装的证书列表。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230314195612.png" alt></p><ol start="2"><li>浏览器本身正确实现了 HTTPS。</li><li>被访问的网站提供了一个证书，这个证书是由一个操作系统所信任的证书颁发机构签发的，操作系统所信任的证书颁发机构一般都预装在操作系统中，通过第一步的方式可以查看。</li><li>被访问的网站所提供的证书被成功认证。</li></ol><p>这里边涉及到一些证书和协议的概念，接下来松哥和大家把整个过程捋一捋。</p><h2 id="3-TLS-SSL"><a href="#3-TLS-SSL" class="headerlink" title="3. TLS/SSL"></a>3. TLS/SSL</h2><p>前面我们提到，HTTPS 就是在 HTTP 的基础之上增加了 TLS/SSL，那么这两个东西该如何理解呢？</p><p>SSL/TLS 是一种密码通信方案，算是目前使用最广泛的密码通信方案了。SSL 全称是 Secure Socket Layer，中文译作安全套接层，是 1994 年由 Netscape 公司设计的一套协议，并与 1995 年发布了 3.0 版本；TLS 全称是 Transport Layer Security，中文译作传输层安全，则是 IETF 在 SSL3.0 基础上设计的协议，实际上相当于 SSL 的后续版本，目前 TLS 先后迭代了 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 和 <code>TLS 1.3</code>，目前被广泛使用的是 <code>TLS 1.2</code> 版本。</p><p>SSL/TLS 涉及到了密码学中的对称加密、非对称加密、数字签名等等，算是密码学领域里的集大成者了。</p><h3 id="3-1-TLS"><a href="#3-1-TLS" class="headerlink" title="3.1 TLS"></a>3.1 TLS</h3><p>接下来我们就来看看 TLS 如何确保 HTTP 安全。</p><p>为了确保客户端和服务端之间的数据安全，我们很容易想到一种方案就是对传输的数据进行加密，没错，这是一个办法，事实上也是这么做的。</p><p>加密又分为两种：</p><ol><li>对称加密</li><li>非对称加密</li></ol><p>那么该使用哪一种呢？</p><p>对称加密，也就是加密密钥和解密密钥是同一个，当浏览器和服务端需要进行通信的时候，约定好一个密钥，然后使用这个密钥对发送的消息进行加密，对方收到消息之后再使用相同的密钥对消息进行解密。但是，在 B/S 架构的项目中，这种方案显然不合适，一个网站把自己的密钥告诉全世界所有的浏览器，那加密和不加密还有区别吗？</p><p>有小伙伴可能又想到了不对称加密，不对称加密倒是个办法，因为不对称加密是有一个密钥对公钥和私钥，公钥可以公布出来告诉所有人，私钥只有自己知道。通信的时候，客户端首先使用公钥对消息进行加密，服务端收到之后，再通过私钥对消息进行解密，这看起来似乎挺完美的。但是！！！非对称加密存在一个问题，就是非对称加密和解密相当耗时，通过这种方式处理加解密效率太低。</p><p>那怎么办？我们可以将两者结合起来。</p><p>具体来说，就是这样：<strong>首先服务端会生成一个非对称加密的密钥对，私钥自己保存，公钥发送给客户端，客户端拿到这个公钥之后，再生成一个对称加密的密钥，然后把对称加密的密钥通过公钥进行加密，加密之后发送给服务端，服务端通过私钥进行解密，这样客户端和服务端就可以通过对称加密进行通信了。</strong></p><p>事实上，TLS 大致上的思路就是这样的。</p><p>不过上面这个方案还是有一个漏洞，那就是服务端要通过明文传输的方式把公钥发送给客户端，这个过程还是不安全的，可能被人恶意截胡，那么这个问题该如何解决呢？</p><p>这就涉及到另外一个概念叫做数字证书了。</p><h3 id="3-2-CA"><a href="#3-2-CA" class="headerlink" title="3.2 CA"></a>3.2 CA</h3><p>数字证书是一个<strong>包含了目标网站各种信息如网站域名、证书有效期、签发机构、用于生成对称密钥的公钥、上级证书签发的签名等</strong>的文件，通过数字证书我们可以确认一个用户或者服务站点的身份。</p><p>实际场景中的数字证书是一系列的，形成了一个信任链，信任链的最顶端是 CA。</p><p>CA 是 Certificate Authority 的简写，它是一个负责发放和管理数字的证书的第三方权威机构。CA 的工作流程是这样的：</p><ol><li>CA 自己给自己颁发的用自己的私钥签名的证书称为根证书，根证书的私钥安全性至关重要，根证书的私钥都是被保存在离线计算机中，有严格的操作规章，每次需要使用时，会有专人将数据通过 USB 拷贝过去，操作完了以后，再将数据带出来（这个专指 CA 根证书的私钥）。</li><li>一个用户想要获取一个证书，首先自己得有一个密钥对，私钥自己留着，公钥以及其他信息发送给 CA，向 CA 提出申请，CA 判明用户的身份之后，会将这个公钥和用户的身份信息绑定，并且为绑定后的信息进行签名（签名是通过 CA 根证书的私钥进行的），最后将签名后的证书发给申请者。</li><li>一个用户想要鉴定一个证书的真伪，就通过 CA 的公钥对证书上的数字签名进行验证，验证通过，就认为这个这个证书是有效的。</li></ol><p><strong>上面这个流程中有一个重要前提，那就是 CA 受到大家所有人的信任。</strong></p><p>然而在实际操作中，我们并不能直接去跟 CA 申请一个数字证书，因为全世界要认证的内容太多了，CA 搞不过来，而且频繁的找 CA 申请，还有可能导致私钥泄漏，这可就是一个大的灾难了。</p><p>那怎么办呢？实际操作中，我们可以基于 CA 来构建一个信任链。具体来说，步骤是这样：</p><ol><li>首先我们的手机、笔记本等操作系统中都预装了 CA 颁发的根证书，他们是所有信任构建的基石，前面松哥已经截图给大家看了 Windows 中预装的根证书了。</li><li>假设 CA 签发了一个证书 A，在这个过程中 CA 称为 Issuer，A 称为 Subject，假设 A 是一个受信任的中间证书，已经预装在我们的操作系统中了。现在由 A 利用它自己的私钥给某一个网站签发了一个证书 B。</li><li>现在当我们的电脑需要访问该网站的时候，该网站就会给我们发来一个证书 B，由于我们的浏览器并不知道 B 证书是否合法，但是我们的电脑上已经预装了 A 证书，我们可以从 A 证书中提取出 A 的公钥，然后利用 A 的公钥对 B 证书的签名进行验证（因为 B 证书的签名是 A 的私钥签的），如果验证通过了，就说明 B 是合法的。</li><li>相同的道理，B 也可以继续签发 C 证书，C 继续签发 D 证书，这样就形成了一个信任链。</li><li>如果服务端的签名是 D 证书，那么一般来说，服务器返回给浏览器的就会包含 B、C、D 三个证书（因为 A 证书已经在我们的电脑上了），即使只返回 D 证书，浏览器也可以根据 D 书中的信息，自动下载到 B、C 两个证书然后进行验证。</li></ol><blockquote><p>松哥记得以前上大学的时候，在 12306 网站上买火车票，第一次访问的时候必须要自己先手动安装一个根证书到系统中，然后才能访问。这就是因为当时 12306 所使用的证书的签发机构不被浏览器认可，类似于上面的第 3 步，12306 给我发了一个数字证书 B 回来，但是浏览器上没有合适的公钥对这个 B 证书进行验证，当我往自己的系统上安装了 12306 给的证书之后，相当于我的电脑上有了一个证书 A，现在就可以对 B 证书进行验证了。</p></blockquote><p>总结一下：</p><ol><li>CA 是一个权威的机构，是一个发证机关，CA 发出来的证书可以证明一个人或者组织的身份。</li><li>任何人都可以得到 CA 的证书（含公钥），用以验证 CA 所签发的证书。</li><li>每一个数字证书都是由上级证书的私钥来签发的，处于最顶层的就是 CA 签发的根证书了，这个根证书没有上级证书了，所以这个根证书实际上是由 CA 自己的私钥来签发的，这也叫做自签名，即 Self-Signed。</li></ol><p>当我们有了数字签名之后，就可以解决 3.1 小节最后提出的问题了。服务端将数字签名发给浏览器，浏览器利用系统已经内置的公钥验签，确认签名没问题，然后就提取出来数字签名中的公钥，开始协商对称加密的私钥了～</p><p>好啦，有了这些知识储备之后，下篇文章松哥来和大家聊一聊 TLS+gRPC 怎么玩！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥最近在和小伙伴们连载 gRPC，如何确保 gRPC 通信的安全性？这就涉及到 TSL 了，但是考虑到可能有小伙伴对加密连接这一整套方案比较陌生，因此我们今天先用一篇文章跟大家捋清楚这些概念，概念搞明白了，再来看 TSL+gRPC 就很容易了。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 中的异常该如何处理？</title>
    <link href="http://www.javaboy.org/2023/0303/grpc_exception.html"/>
    <id>http://www.javaboy.org/2023/0303/grpc_exception.html</id>
    <published>2023-03-03T13:29:17.000Z</published>
    <updated>2023-07-20T13:47:50.355Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和小伙伴们聊一聊该如何处理 gRPC 中遇到的异常。</p><a id="more"></a><p>在之前的几篇文章中，其实我们也遇到过异常问题，只是当时没有和小伙伴们细说，只是囫囵吞枣写了一个案例而已，今天我们就来把这个话题跟小伙伴们仔细捋一捋。</p><p>我们之前写过一个登录的案例，在之前的案例中，如果用户在登录时输入了错误的用户名密码的话，那么我们是通过一个普通的数据流返回异常信息，其实，对于异常信息，我们可以通过专门的异常通道来写回到客户端。</p><h2 id="1-服务端处理异常"><a href="#1-服务端处理异常" class="headerlink" title="1. 服务端处理异常"></a>1. 服务端处理异常</h2><p>先来看看服务端如何处理异常。</p><p>还是以我们之前的 gRPC 登录案例为例，我们修改服务端的登录逻辑如下（完整代码小伙伴们可以参考之前的 <a href="https://mp.weixin.qq.com/s/jIZrP-H3DmS9pvRD5QaTfA" target="_blank" rel="noopener">手把手教大家在 gRPC 中使用 JWT 完成身份校验</a> 一文）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onError(Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"login error"</span>).asException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，在登录失败时我们通过 <code>responseObserver.onError</code> 方法将异常信息写回到客户端。这个方法的参数是一个 Throwable 对象，对于这个对象，在 Status 这个枚举类中定义了一些常见的值，分别如下：</p><ul><li>OK(0)：请求成功。</li><li>CANCELLED(1)：操作被取消。</li><li>UNKNOWN(2)：未知错误。</li><li>INVALID_ARGUMENT(3)：客户端给了无效的请求参数。</li><li>DEADLINE_EXCEEDED(4)：请求超过了截止时间。</li><li>NOT_FOUND(5)：请求资源未找到。</li><li>ALREADY_EXISTS(6)：添加的内容已经存在。</li><li>PERMISSION_DENIED(7)：请求权限不足。</li><li>RESOURCE_EXHAUSTED(8)：资源耗尽。</li><li>FAILED_PRECONDITION(9)：服务端上为准备好。</li><li>ABORTED(10)：请求被中止。</li><li>OUT_OF_RANGE(11)：请求超出范围。</li><li>UNIMPLEMENTED(12)：未实现的操作。</li><li>INTERNAL(13)：服务内部错误。</li><li>UNAVAILABLE(14)：服务不可用。</li><li>DATA_LOSS(15)：数据丢失或者损毁。</li><li>UNAUTHENTICATED(16)：请求未认证。</li></ul><p>系统默认给出的请求类型大致上就这些。当然，如果这些并不能满足你的需求，我们也可以扩展这个枚举类。</p><h2 id="2-客户端处理异常"><a href="#2-客户端处理异常" class="headerlink" title="2. 客户端处理异常"></a>2. 客户端处理异常</h2><p>当服务端给出异常信息之后，客户端的处理分为两种情况。</p><h3 id="2-1-异步请求"><a href="#2-1-异步请求" class="headerlink" title="2.1 异步请求"></a>2.1 异步请求</h3><p>如果客户端是异步请求，则直接在异常回调中处理即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，直接在 onError 回到中处理异常即可。</p><h3 id="2-2-同步请求"><a href="#2-2-同步请求" class="headerlink" title="2.2 同步请求"></a>2.2 同步请求</h3><p>如果客户端请求是同步阻塞请求，那么就要通过异常捕获的方式获取服务端返回的异常信息了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步阻塞请求就通过异常捕获去获取服务端返回的异常信息即可。</p><h2 id="3-题外话"><a href="#3-题外话" class="headerlink" title="3. 题外话"></a>3. 题外话</h2><p>最后，再来和小伙伴们说一个提高 gRPC 数据传输效率的小技巧，那就是传输的数据可以使用 gzip 进行压缩。</p><p>具体处理方式就是在客户端调用 <code>withCompression</code> 方法指定数据压缩，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.withCompression(<span class="hljs-string">"gzip"</span>).login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，一个关于 gRPC 的小小知识点～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和小伙伴们聊一聊该如何处理 gRPC 中遇到的异常。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC为什么使用截止时间而不是超时时间？</title>
    <link href="http://www.javaboy.org/2023/0301/grpc_deadline.html"/>
    <id>http://www.javaboy.org/2023/0301/grpc_deadline.html</id>
    <published>2023-03-01T13:29:03.000Z</published>
    <updated>2023-07-20T13:47:53.324Z</updated>
    
    <content type="html"><![CDATA[<p>在 HTTP 请求中，我们发送请求的时候，可以设置一个请求超时时间-connectTimeout，即在指定的时间内，如果请求没有到达服务端，为了避免客户端一直进行不必要的等待，就会抛出一个请求超时异常。</p><a id="more"></a><p>但是在微服务系统中，我们却很少设置请求超时时间，一般都是用另外一个概念代替，那就是请求截止时间。</p><p>这是什么原因呢？今天我们就来简单聊一聊这个话题。</p><p>在微服务中我们客户端的请求在服务端往往会有比较复杂的链条，我想起来 Spring Cloud Sleuth 官方给的一个请求链路追踪的图，我们直接拿来看下：</p><p><img src="https://i.328888.xyz/2023/04/04/ijoAso.jpeg" alt></p><p>这张图中，请求从客户端发起之后，在服务端一共经历了四个 SERVICE，对于这样的请求，如果我们还是按照之前发送普通 HTTP 请求的方式，设置一个 connectTimeout 显然是不够的。</p><p>我举个例子：</p><p>假设我们发送一个请求，为该请求设置 connectTimeout 为 5s，那么这个时间只对第一个服务 SERVICE1 有效，也就是请求在 5s 之内没有到达 SERVICE1，那么就会抛出连接超时异常；请求如果在 5s 之内到达 SERVICE1，那么就不会抛出异常，但是！！！，请求到达 SERVICE1 并不意味着请求结束，后面从 SERVICE1 到 SERVICE2，从 SERVICE2 到 SERVICE3，从 SERVICE3 到 SERVICE4，还有四个 HTTP 请求待处理，这些请求超时了怎么办？很明显，connectTimeout 属性对于后面几个请求就鞭长莫及了。</p><p>所以，对于这种场景，我们一般使用截止时间来处理。</p><p>截止时间相当于设置<strong>整个请求生命周期</strong>的时间，也就是这个请求，我要多久拿到结果。很明显，这个时间应该在客户端发起请求的时候设置。</p><p>gRPC 中提供了对应的方法，我们可以非常方便的设置请求的截止时间 DeadLineTime，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过 Thread.sleep 做个简单的休眠就行了，超时之后，客户端的 onError 方法会被触发，抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable = io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 2.939621462s. [closed=[], open=[[buffered_nanos=285550823, remote_addr=localhost/127.0.0.1:50051]]]</span><br></pre></td></tr></table></figure><p>好啦，一个简单的小细节，感兴趣的小伙伴不妨去试试啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 HTTP 请求中，我们发送请求的时候，可以设置一个请求超时时间-connectTimeout，即在指定的时间内，如果请求没有到达服务端，为了避免客户端一直进行不必要的等待，就会抛出一个请求超时异常。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>手把手教大家在 gRPC 中使用 JWT 完成身份校验</title>
    <link href="http://www.javaboy.org/2023/0222/grpc_jwt.html"/>
    <id>http://www.javaboy.org/2023/0222/grpc_jwt.html</id>
    <published>2023-02-22T13:28:52.000Z</published>
    <updated>2023-07-20T13:49:12.944Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上篇文章松哥和小伙伴们聊了在 gRPC 中如何使用拦截器，这些拦截器有服务端拦截器也有客户端拦截器，这些拦截器的一个重要使用场景，就是可以进行身份的校验。当客户端发起请求的时候，服务端通过拦截器进行身份校验，就知道这个请求是谁发起的了。今天松哥就来通过一个具体的案例，来和小伙伴们演示一下 gRPC 如何结合 JWT 进行身份校验。</p><a id="more"></a><h2 id="1-JWT-介绍"><a href="#1-JWT-介绍" class="headerlink" title="1. JWT 介绍"></a>1. JWT 介绍</h2><h3 id="1-1-无状态登录"><a href="#1-1-无状态登录" class="headerlink" title="1.1 无状态登录"></a>1.1 无状态登录</h3><h4 id="1-1-1-什么是有状态"><a href="#1-1-1-什么是有状态" class="headerlink" title="1.1.1 什么是有状态"></a>1.1.1 什么是有状态</h4><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h4 id="1-1-2-什么是无状态"><a href="#1-1-2-什么是无状态" class="headerlink" title="1.1.2 什么是无状态"></a>1.1.2 什么是无状态</h4><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-2-如何实现无状态"><a href="#1-2-如何实现无状态" class="headerlink" title="1.2 如何实现无状态"></a>1.2 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-3-JWT"><a href="#1-3-JWT" class="headerlink" title="1.3 JWT"></a>1.3 JWT</h3><h4 id="1-3-1-简介"><a href="#1-3-1-简介" class="headerlink" title="1.3.1 简介"></a>1.3.1 简介</h4><p>JWT，全称是 Json Web Token， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-3-2-JWT数据格式"><a href="#1-3-2-JWT数据格式" class="headerlink" title="1.3.2 JWT数据格式"></a>1.3.2 JWT数据格式</h4><p>JWT 包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul></li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><ul><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><ul><li>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</li></ul><p>生成的数据格式如下图：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-3-3-JWT-交互流程"><a href="#1-3-3-JWT-交互流程" class="headerlink" title="1.3.3 JWT 交互流程"></a>1.3.3 JWT 交互流程</h4><p>流程图：</p><p> <img src="http://img.itboyhub.com/2021/springboot2/37-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如 API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了 RESTful 的无状态规范。</p><h4 id="1-3-4-JWT-存在的问题"><a href="#1-3-4-JWT-存在的问题" class="headerlink" title="1.3.4 JWT 存在的问题"></a>1.3.4 JWT 存在的问题</h4><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><blockquote><p>当然，为了解决 JWT 存在的问题，也可以将 JWT 结合 Redis 来用，服务端生成的 JWT 字符串存入到 Redis 中并设置过期时间，每次校验的时候，先看 Redis 中是否存在该 JWT 字符串，如果存在就进行后续的校验。但是这种方式有点不伦不类（又成了有状态了）。</p></blockquote><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>我们来看下 gRPC 如何结合 JWT。</p><h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><p>首先我先给大家看下我的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>还是跟之前文章中的一样，三个模块，grpc_api 用来存放一些公共的代码。</p><p>grpc_server 用来放服务端的代码，我这里服务端主要提供了两个接口：</p><ol><li>登录接口，登录成功之后返回 JWT 字符串。</li><li>hello 接口，客户端拿着 JWT 字符串来访问 hello 接口。</li></ol><p>grpc_client 则是我的客户端代码。</p><h3 id="2-2-grpc-api"><a href="#2-2-grpc-api" class="headerlink" title="2.2 grpc_api"></a>2.2 grpc_api</h3><p>我将 protocol buffers 和一些依赖都放在 grpc_api 模块中，因为将来我的 grpc_server 和 grpc_client 都将依赖 grpc_api。</p><p>我们来看下这里需要的依赖和插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.21.7:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.51.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的依赖和插件松哥在本系列的第一篇文章中都已经介绍过了，唯一不同的是，这里引入了 JWT 插件，JWT 我使用了比较流行的 JJWT 这个工具。JJWT 松哥在之前的文章和视频中也都有介绍过，这里就不再啰嗦了。</p><p>先来看看我的 Protocol Buffers 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.api&quot;;</span><br><span class="line">option java_outer_classname = &quot;LoginProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package login;</span><br><span class="line"></span><br><span class="line">service LoginService &#123;</span><br><span class="line">  rpc login (LoginBody) returns (LoginResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService&#123;</span><br><span class="line">  rpc sayHello(google.protobuf.StringValue) returns (google.protobuf.StringValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginBody &#123;</span><br><span class="line">  string username = 1;</span><br><span class="line">  string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginResponse &#123;</span><br><span class="line">  string token = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过前面几篇文章的介绍，这里我就不多说啦，就是定义了两个服务：</p><ul><li>LoginService：这个登录服务，传入用户名密码，返回登录成功之后的令牌。</li><li>HelloService：这个就是一个打招呼的服务，传入字符串，返回也是字符串。</li></ul><p>定义完成之后，生成对应的代码即可。</p><p>接下来再定义一个常量类供 grpc_server 和 grcp_client 使用，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthConstant</span> </span>&#123;</span><br><span class="line">    SecretKey JWT_KEY = Keys.hmacShaKeyFor(<span class="hljs-string">"hello_javaboy_hello_javaboy_hello_javaboy_hello_javaboy_"</span>.getBytes());</span><br><span class="line">    Context.Key&lt;String&gt; AUTH_CLIENT_ID = Context.key(<span class="hljs-string">"clientId"</span>);</span><br><span class="line">    String AUTH_HEADER = <span class="hljs-string">"Authorization"</span>;</span><br><span class="line">    String AUTH_TOKEN_TYPE = <span class="hljs-string">"Bearer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的每个常量我都给大家解释下：</p><ol><li>JWT_KEY：这个是生成 JWT 字符串以及进行 JWT 字符串校验的密钥。</li><li>AUTH_CLIENT_ID：这个是客户端的 ID，即客户端发送来的请求携带了 JWT 字符串，通过 JWT 字符串确认了用户身份，就存在这个变量中。</li><li>AUTH_HEADER：这个是携带 JWT 字符串的请求头的 KEY。</li><li>AUTH_TOKEN_TYPE：这个是携带 JWT 字符串的请求头的参数前缀，通过这个可以确认参数的类型，常见取值有 Bearer 和 Basic。</li></ol><p>如此，我们的 gRPC_api 就定义好了。</p><h3 id="2-3-grpc-server"><a href="#2-3-grpc-server" class="headerlink" title="2.3 grpc_server"></a>2.3 grpc_server</h3><p>接下来我们来定义 gRPC_server。</p><p>首先来定义登录服务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(<span class="hljs-string">"login error"</span>).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省事起见，我这里没有连接数据库，用户名和密码固定为 javaboy 和 123。</p><p>登录成功之后，就生成一个 JWT 字符串返回。</p><p>登录失败，就返回一个 login error 字符串。</p><p>再来看我们的 HelloService 服务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String clientId = AuthConstant.AUTH_CLIENT_ID.get();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(clientId + <span class="hljs-string">" say hello:"</span> + request.getValue()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个服务就更简单了，不啰嗦。唯一值得说的是 <code>AuthConstant.AUTH_CLIENT_ID.get();</code> 表示获取当前访问用户的 ID，这个用户 ID 是在拦截器中存入进来的。</p><p>最后，我们来看服务端比较重要的拦截器，我们要在拦截器中从请求头中获取到 JWT 令牌并解析，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> JwtParser parser = Jwts.parser().setSigningKey(AuthConstant.JWT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler)</span> </span>&#123;</span><br><span class="line">        String authorization = metadata.get(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER));</span><br><span class="line">        Status status = Status.OK;</span><br><span class="line">        <span class="hljs-keyword">if</span> (authorization == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"miss authentication token"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authorization.startsWith(AuthConstant.AUTH_TOKEN_TYPE)) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"unknown token type"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Jws&lt;Claims&gt; claims = <span class="hljs-keyword">null</span>;</span><br><span class="line">            String token = authorization.substring(AuthConstant.AUTH_TOKEN_TYPE.length()).trim();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                claims = parser.parseClaimsJws(token);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                status = Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (claims != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                Context ctx = Context.current()</span><br><span class="line">                        .withValue(AuthConstant.AUTH_CLIENT_ID, claims.getBody().getSubject());</span><br><span class="line">                <span class="hljs-keyword">return</span> Contexts.interceptCall(ctx, serverCall, metadata, serverCallHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverCall.close(status, <span class="hljs-keyword">new</span> Metadata());</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerCall.Listener&lt;ReqT&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑应该好理解：</p><ol><li>首先从 Metadata 中提取出当前请求所携带的 JWT 字符串（相当于从请求头中提取出来）。</li><li>如果第一步提取到的值为 null 或者这个值不是以指定字符 Bearer 开始的，说明这个令牌是一个非法令牌，设置对应的响应 status 即可。</li><li>如果令牌都没有问题的话，接下来就进行令牌的校验，校验失败，则设置相应的 status 即可。</li><li>校验成功的话，我们就会获取到一个 Jws<claims> 对象，从这个对象中我们可以提取出来用户名，并存入到 Context 中，将来我们在 HelloServiceImpl 中就可以获取到这里的用户名了。</claims></li><li>最后，登录成功的话，<code>Contexts.interceptCall</code> 方法构建监听器并返回；登录失败，则构建一个空的监听器返回。</li></ol><p>最后，我们再来看看启动服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        LoginServer server = <span class="hljs-keyword">new</span> LoginServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">                .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟之前的相比就多加了一个 Service，添加 HelloServiceImpl 服务的时候，多加了一个拦截器，换言之，登录的时候，请求是不会被这个认证拦截器拦截的。</p><p>好啦，这样我们的 grpc_server 就开发完成了。</p><h3 id="2-4-grpc-client"><a href="#2-4-grpc-client" class="headerlink" title="2.4 grpc_client"></a>2.4 grpc_client</h3><p>接下来我们来看 grpc_client。</p><p>先来看登录：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法直接调用就行了，看过前面几篇 gRPC 文章的话，这里都很好理解。</p><p>再来看 hello 接口的调用，这个接口调用需要携带 JWT 字符串，而携带 JWT 字符串，则需要我们构建一个 CallCredentials 对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtCredential</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallCredentials</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtCredential</span><span class="hljs-params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyRequestMetadata</span><span class="hljs-params">(RequestInfo requestInfo, Executor executor, MetadataApplier metadataApplier)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Metadata headers = <span class="hljs-keyword">new</span> Metadata();</span><br><span class="line">                headers.put(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER),</span><br><span class="line">                        String.format(<span class="hljs-string">"%s %s"</span>, AuthConstant.AUTH_TOKEN_TYPE, subject));</span><br><span class="line">                metadataApplier.apply(headers);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                metadataApplier.fail(Status.UNAUTHENTICATED.withCause(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisUsesUnstableApi</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将请求的 JWT 令牌放入到请求头中即可。</p><p>最后来看看调用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        sayHello(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(ManagedChannel channel)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        HelloServiceGrpc.HelloServiceStub helloServiceStub = HelloServiceGrpc.newStub(channel);</span><br><span class="line">        helloServiceStub</span><br><span class="line">                .withCallCredentials(<span class="hljs-keyword">new</span> JwtCredential(<span class="hljs-string">"eyJhbGciOiJIUzM4NCJ9.eyJzdWIiOiJqYXZhYm95In0.IMMp7oh1dl_trUn7sn8qiv9GtO-COQyCGDz_Yy8VI4fIqUcRfwQddP45IoxNovxL"</span>))</span><br><span class="line">                .sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"wangwu"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable.getMessage() = "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的登录令牌就是前面调用 login 方法时获取到的令牌。</p><p>好啦，大功告成。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>上面的登录与校验只是松哥给小伙伴们展示的一个具体案例而已，在此案例基础之上，我们还可以扩展出来更多写法，但是万变不离其宗，其他玩法就需要小伙伴们自行探索啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上篇文章松哥和小伙伴们聊了在 gRPC 中如何使用拦截器，这些拦截器有服务端拦截器也有客户端拦截器，这些拦截器的一个重要使用场景，就是可以进行身份的校验。当客户端发起请求的时候，服务端通过拦截器进行身份校验，就知道这个请求是谁发起的了。今天松哥就来通过一个具体的案例，来和小伙伴们演示一下 gRPC 如何结合 JWT 进行身份校验。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 gRPC 中的拦截器</title>
    <link href="http://www.javaboy.org/2023/0215/grpc_interceptor.html"/>
    <id>http://www.javaboy.org/2023/0215/grpc_interceptor.html</id>
    <published>2023-02-15T13:28:39.000Z</published>
    <updated>2023-07-20T13:49:19.142Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们继续 gRPC 系列。</p><p>前面松哥跟大家聊了 gRPC 的简单案例，也说了四种不同的通信模式，感兴趣的小伙伴可以戳这里：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">一个简单的案例入门 gRPC</a></li><li><a href="https://mp.weixin.qq.com/s/c-_D2RpLksIlYJDfaWOSkA" target="_blank" rel="noopener">聊一聊 gRPC 的四种通信模式</a></li></ol><p>今天我们来继续聊一聊 gRPC 中的拦截器。</p><p>有请求的发送、处理，当然就会有拦截器的需求，例如在服务端通过拦截器统一进行请求认证等操作，这些就需要拦截器来完成，今天松哥先和小伙伴们来聊一聊 gRPC 中拦截器的基本用法，后面我再整一篇文章和小伙伴们做一个基于拦截器实现的 JWT 认证的 gRPC。</p><p>gRPC 中的拦截器整体上来说可以分为两大类：</p><ol><li>服务端拦截器</li><li>客户端拦截器</li></ol><p>我们分别来看。</p><h2 id="1-服务端拦截器"><a href="#1-服务端拦截器" class="headerlink" title="1. 服务端拦截器"></a>1. 服务端拦截器</h2><p>服务端拦截器的作用有点像我们 Java 中的 Filter，服务端拦截器又可以继续细分为<strong>一元拦截器</strong>和<strong>流拦截器</strong>。</p><p>一元拦截器对应我们上篇文章中所讲的一元 RPC，也就是一次请求，一次响应这种情况。</p><p>流拦截器则对应我们上篇文章中所讲的服务端流 RPC、客户端流 RPC 以及双向流 RPC。</p><p>不过，在 Java 代码中，无论是一元拦截器还是流拦截器，代码其实都是一样的。不过如果你是用 Go 实现的 gRPC，那么这块是不一样的。</p><p>所以接下来的内容我就不去区分一元拦截器和流拦截器了，我们直接来看一个服务端拦截器的例子。</p><p>这里我就不从头开始写了，我们直接在上篇文章的基础之上继续添加拦截器即可。</p><p>服务端拦截器工作位置大致如下：</p><p><img src="http://img.itboyhub.com/2022/08/grpc-server-interceptor.drawio.png" alt></p><p>从这张图中小伙伴们可以看到，我们可以在服务端处理请求之前将请求拦截下来，统一进行权限校验等操作，也可以在服务端将请求处理完毕之后，准备响应的时候将响应拦截下来，可以对响应进行二次处理。</p><p>首先我们来看请求拦截器，实际上是一个监听器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCallListener</span>&lt;<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCallListener</span>&lt;<span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCall.Listener&lt;R&gt; delegate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceCallListener</span><span class="hljs-params">(ServerCall.Listener&lt;R&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> ServerCall.<span class="hljs-function">Listener&lt;R&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(R message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是客户端发来的消息，可以在这里进行预处理："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.onMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们自定义一个类，继承自 ForwardingServerCallListener 类，在这里重写 onMessage 方法，当有请求到达的时候，就会经过这里的 onMessage 方法。如果我们需要对传入的参数进行验证等操作，就可以在这里完成。</p><p>再来看看响应拦截器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCall</span>.<span class="hljs-title">SimpleForwardingServerCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BookServiceCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> ServerCall&lt;ReqT, RespT&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.delegate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodDescriptor&lt;ReqT, RespT&gt; <span class="hljs-title">getMethodDescriptor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getMethodDescriptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(RespT message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是服务端返回给客户端的消息："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可能发现了，我这里用到了很多泛型，请求类型和响应类型都不建议指定具体类型，因为拦截器可能会拦截多种类型的请求，请求参数和响应的数据类型都不一定一样。</p><p>这里是重写 sendMessage 方法，在这个方法中我们可以对服务端准备返回给客户端的消息进行预处理。</p><p>所以这个位置就相当于<strong>响应拦截器</strong>。</p><p>最后，我们需要在启动服务的时候，将这两个拦截器配置进去，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> BookServiceImpl(), <span class="hljs-keyword">new</span> ServerInterceptor() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next)</span> </span>&#123;</span><br><span class="line">                    String fullMethodName = call.getMethodDescriptor().getFullMethodName();</span><br><span class="line">                    System.out.println(fullMethodName + <span class="hljs-string">":pre"</span>);</span><br><span class="line">                    Set&lt;String&gt; keys = headers.keys();</span><br><span class="line">                    <span class="hljs-keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                        System.out.println(key + <span class="hljs-string">"&gt;&gt;&gt;"</span> + headers.get(Metadata.Key.of(key, ASCII_STRING_MARSHALLER)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BookServiceCallListener&lt;&gt;(next.startCall(<span class="hljs-keyword">new</span> BookServiceCall(call), headers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        BookServiceServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我之前服务启动的方法，以前我们调用 addService 方法的时候，直接添加对应的服务就可以了，现在，我们除了添加之前的 BookServiceImpl 服务之外，还额外给了一个拦截器。</p><p>每当请求到达的时候，就会经过拦截器的 interceptCall 方法，这个方法有三个参数：</p><ul><li>第一个参数 call 是消费传入的 RPC 消息的一个回调。</li><li>第二个参数 headers 则是请求的消息头，如果我们通过 JWT 进行请求校验，那么就从这个 headers 中提取出请求的 JWT 令牌然后进行校验。</li><li>第三个参数 next 就类似于我们在 Java 过滤器 filter 中的 filterChain 一样，让这个请求继续向下走。</li></ul><p>在这个方法中，我们请求头的信息都打印出来给小伙伴们参考了。然后在返回值中，将我们刚刚写的请求拦截器和响应拦截器构建并返回。</p><p>好啦，这样我们的服务端拦截器就搞好啦～无论是一元的 RPC 消息还是流式的 RPC 消息，都会经过这个拦截器，响应也是一样。</p><h2 id="2-客户端拦截器"><a href="#2-客户端拦截器" class="headerlink" title="2. 客户端拦截器"></a>2. 客户端拦截器</h2><p>客户端拦截器就比较简单了，客户端拦截器可以将我们的请求拦截下来，例如我们如果想为所有请求添加统一的令牌 Token，那么就可以在这里来做，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .intercept(<span class="hljs-keyword">new</span> ClientInterceptor() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; <span class="hljs-function">ClientCall&lt;ReqT, RespT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, Channel next)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line">                callOptions = callOptions.withAuthority(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> next.newCall(method,callOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br></pre></td></tr></table></figure><p>当我们的请求执行的时候，这个客户端拦截器就会被触发。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和小伙伴们简单介绍一下服务端拦截器和客户端拦截器。下篇文章，松哥会通过一个 JWT 认证来和小伙伴们演示这个拦截器的具体用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们继续 gRPC 系列。&lt;/p&gt;
&lt;p&gt;前面松哥跟大家聊了 gRPC 的简单案例，也说了四种不同的通信模式，感兴趣的小伙伴可以戳这里：&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 gRPC 的四种通信模式</title>
    <link href="http://www.javaboy.org/2023/0209/grpc_4_channel.html"/>
    <id>http://www.javaboy.org/2023/0209/grpc_4_channel.html</id>
    <published>2023-02-09T13:28:28.000Z</published>
    <updated>2023-07-20T13:48:06.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>温馨提示：本文需要结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上一篇 gRPC 文章</a>一起食用，否则可能看不懂。</p></blockquote><p>前面一篇文章松哥和大家聊了 gRPC 的基本用法，今天我们再来稍微深入一点点，来看下 gRPC 中四种不同的通信模式。</p><a id="more"></a><p>gRPC 中四种不同的通信模式分别是：</p><ol><li>一元 RPC</li><li>服务端流 RPC</li><li>客户端流 RPC</li><li>双向流 RPC</li></ol><p>接下来松哥就通过四个完整的案例，来分别和向伙伴们演示这四种不同的通信模式。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>关于 gRPC 的基础知识我们就不啰嗦了，咱们直接来看我今天的 proto 文件，如下：</p><p>这次我新建了一个名为 book.proto 的文件，这里主要定义了一些图书相关的方法，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.demo&quot;;</span><br><span class="line">option java_outer_classname = &quot;BookServiceProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package book;</span><br><span class="line"></span><br><span class="line">service BookService &#123;</span><br><span class="line">  rpc addBook(Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc getBook(google.protobuf.StringValue) returns (Book);</span><br><span class="line">  rpc searchBooks(google.protobuf.StringValue) returns (stream Book);</span><br><span class="line">  rpc updateBooks(stream Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc processBooks(stream google.protobuf.StringValue) returns (stream BookSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated string tags = 2;</span><br><span class="line">  string name = 3;</span><br><span class="line">  float price = 4;</span><br><span class="line">  string author = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message BookSet &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated Book bookList = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件中，有一些内容我们在<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>中都讲过了，讲过的我就不再重复了，我说一些<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有涉及到的东西：</p><ol><li>由于我们在这个文件中，引用了 Google 提供的 StringValue（<code>google.protobuf.StringValue</code>），所以这个文件上面我们首先用 import 导入相关的文件，导入之后，才可以使用。</li><li>在方法参数和返回值中出现的 stream，就表示这个方法的参数或者返回值是流的形式（其实就是数据可以多次传输）。</li><li>message 中出现了一个<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有的关键字 repeated，这个表示这个字段可以重复，可以简单理解为这就是我们 Java 中的数组。</li></ol><p>好了，和<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>相比，本文主要就是这几个地方不一样。</p><p>proto 文件写好之后，按照<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>介绍的方法进行编译，生成对应的代码，这里就不再重复了。</p><h2 id="2-一元-RPC"><a href="#2-一元-RPC" class="headerlink" title="2. 一元 RPC"></a>2. 一元 RPC</h2><p>一元 RPC 是一种比较简单的 RPC 模式，其实说白了我们<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>和大家介绍的就是一种一元 RPC，也就是客户端发起一个请求，服务端给出一个响应，然后请求结束。</p><p>上面我们定义的五个方法中，addBook 和 getBook 都算是一种一元 RPC。</p><h3 id="2-1-addBook"><a href="#2-1-addBook" class="headerlink" title="2.1 addBook"></a>2.1 addBook</h3><p>先来看 addBook 方法，这个方法的逻辑很简单，我们提前在服务端准备一个 Map 用来保存 Book，addBook 调用的时候，就把 book 对象存入到 Map 中，并且将 book 的 ID 返回，大家就这样一件事，来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        bookMap.put(request.getId(), request);</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>的小伙伴，我觉得这段代码应该很好理解。</p><p>客户端调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        addBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.addBook(Book.newBuilder().setPrice(<span class="hljs-number">99</span>).setId(<span class="hljs-string">"100"</span>).setName(<span class="hljs-string">"java"</span>).setAuthor(<span class="hljs-string">"javaboy"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"添加完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了 CountDownLatch 来实现线程等待，等服务端给出响应之后，客户端再结束。这里在回调的 onNext 方法中，我们就可以拿到服务端的返回值。</p><h3 id="2-2-getBook"><a href="#2-2-getBook" class="headerlink" title="2.2 getBook"></a>2.2 getBook</h3><p>getBook 跟上面的 addBook 类似，先来看服务端代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String id = request.getValue();</span><br><span class="line">        Book book = bookMap.get(id);</span><br><span class="line">        <span class="hljs-keyword">if</span> (book != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            responseObserver.onNext(book);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 getBook 就是根据客户端传来的 id，从 Map 中查询到一个 Book 并返回。</p><p>客户端调用代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        getBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.getBook(StringValue.newBuilder().setValue(<span class="hljs-string">"2"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"book = "</span> + book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们大概也能看出来，addBook 和 getBook 基本上操作套路是一模一样的。</p><h2 id="3-服务端流-RPC"><a href="#3-服务端流-RPC" class="headerlink" title="3. 服务端流 RPC"></a>3. 服务端流 RPC</h2><p>前面的一元 RPC，客户端发起一个请求，服务端给出一个响应，请求就结束了。服务端流则是客户端发起一个请求，服务端给一个响应序列，这个响应序列组成一个流。</p><p>上面我们给出的 searchBook 就是这样一个例子，searchBook 是传递图书的 tags 参数，然后在服务端查询哪些书的 tags 满足条件，将满足条件的书全部都返回去。</p><p>我们来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBooks</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = bookMap.keySet();</span><br><span class="line">        String tags = request.getValue();</span><br><span class="line">        <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Book book = bookMap.get(key);</span><br><span class="line">            <span class="hljs-keyword">int</span> tagsCount = book.getTagsCount();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tagsCount; i++) &#123;</span><br><span class="line">                String t = book.getTags(i);</span><br><span class="line">                <span class="hljs-keyword">if</span> (t.equals(tags)) &#123;</span><br><span class="line">                    responseObserver.onNext(book);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看下，这段 Java 代码应该很好理解：</p><ol><li>首先从 request 中提取客户端传来的 tags 参数。</li><li>遍历 bookMap，查看每一本书的 tags 是否等于客户端传来的 tags，如果相等，说明添加匹配，则通过 <code>responseObserver.onNext(book);</code> 将这本书写回到客户端。</li><li>等所有操作都完成后，执行 <code>responseObserver.onCompleted();</code>，表示服务端的响应序列结束了，这样客户端也就知道请求结束了。</li></ol><p>我们来看看客户端的代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        searchBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.searchBooks(StringValue.newBuilder().setValue(<span class="hljs-string">"明清小说"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码好理解，搜索的关键字是 <code>明清小说</code>，每当服务端返回一次数据的时候，客户端回调的 onNext 方法就会被触发一次，当服务端之行了 <code>responseObserver.onCompleted();</code> 之后，客户端的 onCompleted 方法也会被触发。</p><p>这个就是服务端流，客户端发起一个请求，服务端通过 onNext 可以多次写回数据。</p><h2 id="4-客户端流-RPC"><a href="#4-客户端流-RPC" class="headerlink" title="4. 客户端流 RPC"></a>4. 客户端流 RPC</h2><p>客户端流则是客户端发起多个请求，服务端只给出一个响应。</p><p>上面的 updateBooks 就是一个客户端流的案例，客户端想要修改图书，可以发起多个请求修改多本书，服务端则收集多次修改的结果，将之汇总然后一次性返回给客户端。</p><p>我们先来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;Book&gt; <span class="hljs-title">updateBooks</span><span class="hljs-params">(StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"更新的图书 ID 为："</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                bookMap.put(book.getId(), book);</span><br><span class="line">                sb.append(book.getId())</span><br><span class="line">                        .append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                responseObserver.onNext(StringValue.newBuilder().setValue(sb.toString()).build());</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端每发送一本书来，就会触发服务端的 onNext 方法，然后我们在这方法中进行图书的更新操作，并记录更新结果。最后，我们在 onCompleted 方法中，将更新结果汇总返回给客户端，基本上就是这样一个流程。</p><p>我们再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        updateBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;Book&gt; request = stub.updateBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"更新完毕"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"a"</span>).setAuthor(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"c"</span>).setAuthor(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端这块，updateBooks 方法会返回一个 StreamObserver<book> 对象，调用该对象的 onNext 方法就是给服务端传递数据了，可以传递多个数据，调用该对象的 onCompleted 方法就是告诉服务端数据传递结束了，此时也会触发服务端的 onCompleted 方法，服务端的 onCompleted 方法执行之后，进而触发了客户端的 onCompleted 方法。</book></p><h2 id="5-双向流-RPC"><a href="#5-双向流-RPC" class="headerlink" title="5. 双向流 RPC"></a>5. 双向流 RPC</h2><p>双向流其实就是 3、4 小节的合体。即客户端多次发送数据，服务端也多次响应数据。</p><p>我们先来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;StringValue&gt; <span class="hljs-title">processBooks</span><span class="hljs-params">(StreamObserver&lt;BookSet&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                Book b = Book.newBuilder().setId(stringValue.getValue()).build();</span><br><span class="line">                books.add(b);</span><br><span class="line">                <span class="hljs-keyword">if</span> (books.size() == <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                    BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                    responseObserver.onNext(bookSet);</span><br><span class="line">                    books.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                responseObserver.onNext(bookSet);</span><br><span class="line">                books.clear();</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有实际意义，单纯为了给小伙伴们演示双向流，我的操作逻辑是客户端传递多个 ID 到服务端，然后服务端根据这些 ID 构建对应的 Book 对象，然后三个三个一组，再返回给客户端。客户端每次发送一个请求，都会触发服务端的 onNext 方法，我们在这个方法中对请求分组返回。最后如果还有剩余的请求，我们在 onCompleted() 方法中返回。</p><p>再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        processBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;StringValue&gt; request = stub.processBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;BookSet&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(BookSet bookSet)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"bookSet = "</span> + bookSet);</span><br><span class="line">                System.out.println(<span class="hljs-string">"============="</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"处理完毕！"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"a"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"c"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端的代码跟第四小节一模一样，不再赘述了。</p><p>好啦，这就是松哥和小伙伴们介绍的 gRPC 的四种不同的通信模式，文章中只给出了一些关键代码，如果小伙伴们没看明白，建议结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>一起阅读就懂啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;温馨提示：本文需要结合&lt;a href=&quot;https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇 gRPC 文章&lt;/a&gt;一起食用，否则可能看不懂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面一篇文章松哥和大家聊了 gRPC 的基本用法，今天我们再来稍微深入一点点，来看下 gRPC 中四种不同的通信模式。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
</feed>
