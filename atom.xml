<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-03-24T03:28:32.423Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringMVC 源码分析之 DispatcherServlet</title>
    <link href="http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html"/>
    <id>http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html</id>
    <published>2021-03-24T03:27:25.000Z</published>
    <updated>2021-03-24T03:28:32.423Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">SpringMVC 源码分析之 FrameworkServlet</a>。</p><a id="more"></a><p>即使你没看过 DispatcherServlet 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>经过<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">上篇文章</a>的分析，大家已经知道 DispatcherServlet 的入口方法是 doService，所以今天我们就从 doService 方法开始看起，松哥将带领大家，一步一步揭开 DispatcherServlet 的面纱。</p><h2 id="doService"><a href="#doService" class="headerlink" title="doService"></a>doService</h2><p>先来看 doService，把源码先贴上来，然后我们逐步分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">logRequest(request);</span><br><span class="line"><span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line"><span class="hljs-comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line">RequestPath previousRequestPath = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parseRequestPath) &#123;</span><br><span class="line">previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码并不长，我们来稍微分析一下：</p><ol><li>首先判断当前请求是不是 include 请求，如果是 include，则对 request 的 attribute 做一个快照备份，在最后的 finally 中再对备份的属性进行还原。</li><li>接下来对 request 设置一些常见属性，例如应用上下文、国际化的解析器、主题解析器等等，这些东西在初始化的时候已经准备好了，这里只是应用（初始化过程参见<a href="https://mp.weixin.qq.com/s/IeMOfnXhOX5RCf4i5Xsdzw" target="_blank" rel="noopener">SpringMVC 初始化流程分析</a>一文）。</li><li>接下来处理 flashMap，如果存在 flashMap 则进行复原，这一块松哥在之前的文章中和小伙伴们已经分享过了，传送门<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</li><li>接下来处理 RequestPath，将请求路径对象化以备后续使用（在后面的请求映射匹配时会用到）。</li><li>调用 doDispatch 方法进行下一步处理。</li><li>还原快照属性、还原 RequestPath。</li></ol><p>所以说这段代码并不难理解，它的核心在于 doDispatch 方法，所以接下来我们就来看看 doDispatch 方法。</p><h2 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h2><p>doDispatch 方法所做的事情就比较多了，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="hljs-keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"><span class="hljs-comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，涉及到很多组件的处理，这里松哥先和大家把思路梳理畅通，各个组件的详细用法松哥将在以后的文章中和大家仔细分享。</p><p>doDispatch 方法其实主要做了两方面的事情：请求处理以及页面渲染，我们先来看看初始变量的含义：</p><ol><li>processedRequest：这个用来保存实际上所用的 request 对象，在后面的流程中会对当前 request 对象进行检查，如果是文件上传请求，则会对请求重新进行封装，如果不是文件上传请求，则继续使用原来的请求。</li><li>mappedHandler：这是具体处理请求的处理器链，处理器链包含两方面的东西：请求处理器和对应的 Interceptor。</li><li>multipartRequestParsed：表示是否是文件上传请求的标记。</li><li>asyncManager：这是一个异步请求管理器。</li><li>mv：这是最终渲染返回的 ModelAndView 对象。</li><li>dispatchException：表示请求处理过程中所抛出的异常，这个异常不包括渲染过程抛出的异常。</li></ol><p>接下来再来看看具体的处理逻辑：</p><ol><li>首先通过 checkMultipart 检查是不是文件上传请求，如果是，则对当前 request 重新进行包装，如果不是，则直接将参数返回。</li><li>如果 processedRequest 不等于 request，则说明当前请求是文件上传请求（request 在 checkMultipart 方法中被重新封装了），否则说明当前请求不是文件上传请求。</li><li>根据当前请求，调用 getHandler 方法获取请求处理器，如果没找到对应的请求处理器，则调用 noHandlerFound 方法抛出异常或者给出 404。</li><li>接下来再调用 getHandlerAdapter 方法，根据当前的处理器找到处理器适配器。</li><li>然后处理 GET 和 HEAD 请求头的 Last_Modified 字段。当浏览器第一次发起 GET 或者 HEAD 请求时，请求的响应头中包含一个 Last-Modified 字段，这个字段表示该资源最后一次修改时间，以后浏览器再次发送 GET、HEAD 请求时，都会携带上该字段，服务端收到该字段之后，和资源的最后一次修改时间进行对比，如果资源还没有过期，则直接返回 304 告诉浏览器之前的资源还是可以继续用的，如果资源已经过期，则服务端会返回新的资源以及新的 Last-Modified。</li><li>接下来调用拦截器的 preHandle 方法，如果该方法返回 false，则直接 return 掉当前请求（拦截器的用法大家可以参考松哥之前录的免费的 SpringMVC 视频教程，里边有讲，传送门<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</li><li>接下来执行 <code>ha.handle</code> 去调用真正的请求，获取到返回结果 mv。</li><li>接下来判断当前请求是否需要异步处理，如果需要，则直接 return 掉。</li><li>如果不需要异步处理，则执行 applyDefaultViewName 方法，检查当前 mv 是否没有视图，如果没有（例如方法返回值为 void），则给一个默认的视图名。</li><li>接下来调用 applyPostHandle 方法执行拦截器里边的 postHandle 方法。</li><li>接下来调用 processDispatchResult 方法对执行结果进行处理，包括异常处理、渲染页面以及执行拦截器的 afterCompletion 方法都在这里完成。</li><li>最后在 finally 代码块中判断是否开启了异步处理，如果开启了，则调用相应的拦截器；如果请求是文件上传请求，则再调用 cleanupMultipart 方法清除文件上传过程产生的一些临时文件。</li></ol><p>这是 doDispatch 方法的一个大致执行逻辑，doDispatch 里边的 try-catch 有两层，最里边那一层，抛出来的异常会被赋值给 dispatchException 变量，这些异常最终在 processDispatchResult 方法中被处理掉，外面的异常则是 processDispatchResult 方法在执行的过程中抛出的异常，一般来说主要是页面渲染时候的异常。</p><h2 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult"></a>processDispatchResult</h2><p>最后我们再来看下 processDispatchResult 方法的执行逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Exception exception)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> errorView = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);</span><br><span class="line">mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">errorView = (mv != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Did the handler return a view to render?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">render(mv, request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (errorView) &#123;</span><br><span class="line">WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Concurrent handling started during a forward</span></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Exception (if any) is already handled..</span></span><br><span class="line">mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 processDispatchResult 方法中首先对异常进行了处理，配置好异常对应的 ModelAndView，然后调用 render 方法对页面进行渲染，最后通过 triggerAfterCompletion 方法去触发拦截器的 afterCompletion 方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们就把一个请求的大致流程和大家梳理完了，松哥画了一张流程图我们一起来看下：</p><p><img src="http://img.itboyhub.com/2021/02/jkdfajkldfjkl74857829djnfklsk.png" alt></p><p>这下相信大家对 doDispatch 方法比较熟悉了，当然这里还涉及到很多组件，这些组件松哥将在后面的文章中和大家逐一进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门&lt;a href=&quot;https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringMVC 源码分析之 FrameworkServlet&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 源码分析之 FrameworkServlet</title>
    <link href="http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html"/>
    <id>http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html</id>
    <published>2021-03-23T00:37:53.000Z</published>
    <updated>2021-03-23T00:39:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。</p><a id="more"></a><p>很多小伙伴都知道 SpringMVC 的核心是 DispatcherServlet，而 DispatcherServlet 的父类就是 FrameworkServlet，因此我们先来看看 FrameworkServlet，这有助于我们理解 DispatcherServlet。</p><h2 id="1-FrameworkServlet"><a href="#1-FrameworkServlet" class="headerlink" title="1.FrameworkServlet"></a>1.FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，而 HttpServletBean 继承自 HttpServlet，HttpServlet 就是 JavaEE 里边的东西了，这里我们不做讨论，从 HttpServletBean 开始就是框架的东西了，但是 HttpServletBean 比较特殊，它的特殊在于它没有进行任何的请求处理，只是参与了一些初始化的操作，这些比较简单，而且我们在上篇文章中也已经分析过了，所以这里我们对 HttpServletBean 不做分析，就直接从它的子类 FrameworkServlet 开始看起。</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>和所有的 Servlet 一样，FrameworkServlet 对请求的处理也是从 service 方法开始，我们先来看看该方法 FrameworkServlet#service：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在该方法中，首先获取到当前请求方法，然后对 patch 请求额外关照了下，其他类型的请求统统都是 super.service 进行处理。</p><p>然而在 HttpServlet 中并未对 doGet、doPost 等请求进行实质性处理，所以 FrameworkServlet 中还重写了各种请求对应的方法，如 doDelete、doGet、doOptions、doPost、doPut、doTrace 等，其实就是除了 doHead 之外的其他方法都重写了。</p><p>我们先来看看 doDelete、doGet、doPost 以及 doPut 四个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDelete</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里又把请求交给 processRequest 去处理了，在 processRequest 方法中则会进一步调用到 doService，对不同类型的请求分类处理。</p><p>doOptions 和 doTrace 则稍微有些差异，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOptions</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (response.containsHeader(<span class="hljs-string">"Allow"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doOptions(request, <span class="hljs-keyword">new</span> HttpServletResponseWrapper(response) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String name, String value)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"Allow"</span>.equals(name)) &#123;</span><br><span class="line">value = (StringUtils.hasLength(value) ? value + <span class="hljs-string">", "</span> : <span class="hljs-string">""</span>) + HttpMethod.PATCH.name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.setHeader(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrace</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchTraceRequest) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"message/http"</span>.equals(response.getContentType())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doTrace(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个方法的处理多了一层逻辑，就是去选择是在当前方法中处理对应的请求还是交给父类去处理，由于 dispatchOptionsRequest 和 dispatchTraceRequest 变量默认都是 false，因此默认情况下，这两种类型的请求都是交给了父类去处理。</p><h2 id="2-processRequest"><a href="#2-processRequest" class="headerlink" title="2.processRequest"></a>2.processRequest</h2><p>我们再来看 processRequest，这算是 FrameworkServlet 的核心方法了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Throwable failureCause = <span class="hljs-keyword">null</span>;</span><br><span class="line">LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line">RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doService(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Request processing failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"><span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">requestAttributes.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">logResult(request, response, failureCause, asyncManager);</span><br><span class="line">publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然比较长，但是其实它的核心就是最中间的 doService 方法，以 doService 为界，我们可以将该方法的内容分为三部分：</p><ol><li>doService 之前主要是一些准备工作，准备工作主要干了两件事，第一件事就是从 LocaleContextHolder 和 RequestContextHolder 中分别获取它们原来保存的 LocaleContext 和 RequestAttributes 对象存起来，然后分别调用 buildLocaleContext 和 buildRequestAttributes 方法获取到当前请求的 LocaleContext 和 RequestAttributes 对象，再通过 initContextHolders 方法将当前请求的 LocaleContext 和 RequestAttributes 对象分别设置到 LocaleContextHolder 和 RequestContextHolder 对象中；第二件事则是获取到异步管理器并设置拦截器。</li><li>接下来就是 doService 方法，这是一个抽象方法，具体的实现在 DispatcherServlet 中，这个松哥放到 DispatcherServlet 中再和大家分析。</li><li>第三部分就是 finally 中，这个里边干了两件事：第一件事就是将 LocaleContextHolder 和 RequestContextHolder 中对应的对象恢复成原来的样子（参考第一步）；第二件事就是通过 publishRequestHandledEvent 方法发布一个 ServletRequestHandledEvent 类型的消息。</li></ol><p>经过上面的分析，大家发现，processRequest 其实主要做了两件事，第一件事就是对 LocaleContext 和 RequestAttributes 的处理，第二件事就是发布事件。我们对这两件事分别来研究。</p><h3 id="2-1-LocaleContext-和-RequestAttributes"><a href="#2-1-LocaleContext-和-RequestAttributes" class="headerlink" title="2.1 LocaleContext 和 RequestAttributes"></a>2.1 LocaleContext 和 RequestAttributes</h3><p>LocaleContext 和 RequestAttributes 都是接口，不同的是里边存放的对象不同。</p><h4 id="2-1-1-LocaleContext"><a href="#2-1-1-LocaleContext" class="headerlink" title="2.1.1 LocaleContext"></a>2.1.1 LocaleContext</h4><p>LocaleContext 里边存放着 Locale，也就是本地化信息，如果我们需要支持国际化，就会用到 Locale。</p><p>国际化的时候，如果我们需要用到 Locale 对象，第一反应就是从 HttpServletRequest 中获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = req.getLocale();</span><br></pre></td></tr></table></figure><p>但是大家知道，HttpServletRequest 只存在于 Controller 中，如果我们想要在 Service 层获取 HttpServletRequest，就得从 Controller 中传参数过来，这样就比较麻烦，特别是有的时候 Service 中相关方法都已经定义好了再去修改，就更头大了。</p><p>所以 SpringMVC 中还给我们提供了 LocaleContextHolder，这个工具就是用来保存当前请求的 LocaleContext 的。当大家看到 LocaleContextHolder 时不知道有没有觉得眼熟，松哥在之前的 Spring Security 系列教程中和大家聊过 SecurityContextHolder，这两个的原理基本一致，都是基于 ThreadLocal 来保存变量，进而确保不同线程之间互不干扰，对 ThreadLocal 不熟悉的小伙伴，可以看看松哥的 Spring Security 系列，之前有详细分析过（公号后台回复 ss）。</p><p>有了 LocaleContextHolder 之后，我们就可以在任何地方获取 Locale 了，例如在 Service 中我们可以通过如下方式获取 Locale：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = LocaleContextHolder.getLocale();</span><br></pre></td></tr></table></figure><p>上面这个 Locale 对象实际上就是从 LocaleContextHolder 中的 LocaleContext 里边取出来的。</p><blockquote><p>需要注意的是，SpringMVC 中还有一个 LocaleResolver 解析器，所以前面 req.getLocale() 并不总是获取到 Locale 的值，这个松哥在以后的文章中再和小伙伴们细聊。</p></blockquote><h4 id="2-1-2-RequestAttributes"><a href="#2-1-2-RequestAttributes" class="headerlink" title="2.1.2 RequestAttributes"></a>2.1.2 RequestAttributes</h4><p>RequestAttributes 是一个接口，这个接口可以用来 get/set/remove 某一个属性。</p><p>RequestAttributes 有诸多实现类，默认使用的是 ServletRequestAttributes，通过 ServletRequestAttributes，我们可以 getRequest、getResponse 以及 getSession。</p><p>在 ServletRequestAttributes 的具体实现中，会通过 scope 参数判断操作 request 还是操作 session（如果小伙伴们不记得 Spring 中的作用域问题，可以公号后台回复 spring，看看松哥录制的免费的 Spring 入门教程，里边有讲），我们来看一下 ServletRequestAttributes#setAttribute 方法（get/remove 方法执行逻辑类似）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, Object value, <span class="hljs-keyword">int</span> scope)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (scope == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isRequestActive()) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot set request attribute - request is not active anymore!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.request.setAttribute(name, value);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        HttpSession session = <span class="hljs-keyword">this</span>.obtainSession();</span><br><span class="line">        <span class="hljs-keyword">this</span>.sessionAttributesToUpdate.remove(name);</span><br><span class="line">        session.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里会先判断 scope，scope 为 0 就操作 request，scope 为 1 就操作 session。如果操作的是 request，则需要首先通过 isRequestActive 方法判断当前 request 是否执行完毕，如果执行完毕，就不可以再对其进行其他操作了（当执行了 finally 代码块中的 requestAttributes.requestCompleted 方法后，isRequestActive 就会返回 false）。</p><p>和 LocaleContext 类似，RequestAttributes 被保存在 RequestContextHolder 中，RequestContextHolder 的原理也和 SecurityContextHolder 类似，这里不再赘述。</p><p>看了上面的讲解，大家应该发现了，在 SpringMVC 中，如果我们需要在 Controller 之外的其他地方使用 request、response 以及 session，其实不用每次都从 Controller 中传递 request、response 以及 session 等对象，我们完全可以直接通过 RequestContextHolder 来获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">HttpServletResponse response = servletRequestAttributes.getResponse();</span><br></pre></td></tr></table></figure><p>是不是非常 easy！</p><h3 id="2-2-事件发布"><a href="#2-2-事件发布" class="headerlink" title="2.2 事件发布"></a>2.2 事件发布</h3><p>最后就是 processRequest 方法中的事件发布了。</p><p>在 finally 代码块中会调用 publishRequestHandledEvent 方法发送一个 ServletRequestHandledEvent 类型的事件，具体发送代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishRequestHandledEvent</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> startTime, @Nullable Throwable failureCause)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishEvents &amp;&amp; <span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Whether or not we succeeded, publish an event.</span></span><br><span class="line"><span class="hljs-keyword">long</span> processingTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext.publishEvent(</span><br><span class="line"><span class="hljs-keyword">new</span> ServletRequestHandledEvent(<span class="hljs-keyword">this</span>,</span><br><span class="line">request.getRequestURI(), request.getRemoteAddr(),</span><br><span class="line">request.getMethod(), getServletConfig().getServletName(),</span><br><span class="line">WebUtils.getSessionId(request), getUsernameForRequest(request),</span><br><span class="line">processingTime, failureCause, response.getStatus()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，事件的发送需要 publishEvents 为 true，而该变量默认就是 true。如果需要修改该变量的值，可以在 web.xml 中配置 DispatcherServlet 时，通过 init-param 节点顺便配置一下该变量的值。正常情况下，这个事件总是会被发送出去，如果项目有需要，我们可以监听该事件，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletRequestHandleListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ServletRequestHandledEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ServletRequestHandledEvent servletRequestHandledEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"请求执行完毕-"</span>+servletRequestHandledEvent.getRequestUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个请求执行完毕时，该事件就会被触发。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>这篇文章主要和小伙伴们分享了 SpringMVC 中 DispatcherServlet 的父类 FrameworkServlet，FrameworkServlet 的功能其实比较简单，主要就是在 service 方法中增加了对 PATCH 的处理，然后其他类型的请求都被归类到 processRequest 方法中进行统一处理，processRequest 方法则又分了三部分，首先是对 LocaleContext 和 RequestAttributes 的处理，然后执行 doService，最后在 finally 代码块中对 LocaleContext 和 RequestAttributes 属性进行复原，同时发布一个请求结束的事件。</p><p>doService 是重头戏，松哥将在下篇文章中和大家分享。好啦，今天就先和小伙伴们聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中如何统一 API 接口响应格式？</title>
    <link href="http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html"/>
    <id>http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html</id>
    <published>2021-03-19T05:56:09.000Z</published>
    <updated>2021-03-22T05:58:54.797Z</updated>
    
    <content type="html"><![CDATA[<p>今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。</p><a id="more"></a><p>在前面的文章中（<a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>），松哥已经和大家介绍过如何对请求/响应数据进行预处理/二次处理，当时我们使用了 ResponseBodyAdvice 和 RequestBodyAdvice。其中 ResponseBodyAdvice 可以实现对响应数据的二次处理，可以在这里对响应数据进行加密/包装等等操作。不过这不是唯一的方案，今天松哥要和大家介绍一种更加灵活的方案–HandlerMethodReturnValueHandler，我们一起来看看下。</p><h2 id="1-HandlerMethodReturnValueHandler"><a href="#1-HandlerMethodReturnValueHandler" class="headerlink" title="1.HandlerMethodReturnValueHandler"></a>1.HandlerMethodReturnValueHandler</h2><p>HandlerMethodReturnValueHandler 的作用是对处理器的处理结果再进行一次二次加工，这个接口里边有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：这个处理器是否支持相应的返回值类型。</li><li>handleReturnValue：对方法返回值进行处理。</li></ul><p>HandlerMethodReturnValueHandler 有很多默认的实现类，我们来看下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317092534.png" alt></p><p>接下来我们来把这些实现类的作用捋一捋：</p><p><strong>ViewNameMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 void 和 String 的情况。如果返回值为 void，则不做任何处理。如果返回值为 String，则将 String 设置给 mavContainer 的 viewName 属性，同时判断这个 String 是不是重定向的 String，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>ViewMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 View 的情况。如果返回值为 View，则将 View 设置给 mavContainer 的 view 属性，同时判断这个 View 是不是重定向的 View，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>MapMethodProcessor</strong></p><p>这个处理器用来处理返回值类型为 Map 的情况，具体的处理方案就是将 map 添加到 mavContainer 的 model 属性中。</p><p><strong>StreamingResponseBodyReturnValueHandler</strong></p><p>这个用来处理 StreamingResponseBody 或者 <code>ResponseEntity&lt;StreamingResponseBody&gt;</code> 类型的返回值。</p><p><strong>DeferredResultMethodReturnValueHandler</strong></p><p>这个用来处理 DeferredResult、ListenableFuture 以及 CompletionStage 类型的返回值，用于异步请求。</p><p><strong>CallableMethodReturnValueHandler</strong></p><p>处理 Callable 类型的返回值，也是用于异步请求。</p><p><strong>HttpHeadersReturnValueHandler</strong></p><p>这个用来处理 HttpHeaders 类型的返回值，具体处理方式就是将 mavContainer 中的 requestHandled 属性设置为 true，该属性是请求是否已经处理完成的标志（如果处理完了，就到此为止，后面不会再去找视图了），然后将 HttpHeaders 添加到响应头中。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理返回值类型为 Model 的情况，具体的处理方式就是将 Model 添加到 mavContainer 的 model 上。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ModelAttribute</code> 注解的返回值类型，如果 annotaionNotRequired 属性为 true，也可以用来处理其他非通用类型的返回值。</p><p><strong>ServletModelAttributeMethodProcessor</strong></p><p>同上，该类只是修改了参数解析方式。</p><p><strong>ResponseBodyEmitterReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ResponseBodyEmitter</code> 的情况。</p><p><strong>ModelAndViewMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ModelAndView</code> 的情况，将返回值中的 Model 和 View 分别设置到 mavContainer 的相应属性上去。</p><p><strong>ModelAndViewResolverMethodReturnValueHandler</strong></p><p>这个的 supportsReturnType 方法返回 true，即可以处理所有类型的返回值，这个一般放在最后兜底。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个抽象类，当返回值需要通过 HttpMessageConverter 进行转化的时候会用到它的子类。这个抽象类主要是定义了一些工具方法。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ResponseBody</code> 注解的返回值类型。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理返回值类型是 HttpEntity 并且不是 RequestEntity 的情况。</p><p><strong>AsyncHandlerMethodReturnValueHandler</strong></p><p>这是一个空接口，暂未发现典型使用场景。</p><p><strong>AsyncTaskMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 WebAsyncTask 的情况。</p><p><strong>HandlerMethodReturnValueHandlerComposite</strong></p><p>看 Composite 就知道，这是一个组合处理器，没啥好说的。</p><p>这个就是系统默认定义的 HandlerMethodReturnValueHandler。</p><p>那么在上面的介绍中，大家看到反复涉及到一个组件 mavContainer，这个我也要和大家介绍一下。</p><h2 id="2-ModelAndViewContainer"><a href="#2-ModelAndViewContainer" class="headerlink" title="2.ModelAndViewContainer"></a>2.ModelAndViewContainer</h2><p>ModelAndViewContainer 就是一个数据穿梭巴士，在整个请求的过程中承担着数据传送的工作，从它的名字上我们可以看出来它里边保存着 Model 和 View 两种类型的数据，但是实际上可不止两种，我们来看下 ModelAndViewContainer 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelAndViewContainer</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ignoreDefaultModelOnRedirect = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object view;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ModelMap defaultModel = <span class="hljs-keyword">new</span> BindingAwareModelMap();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> ModelMap redirectModel;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> redirectModelScenario = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> HttpStatus status;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; noBinding = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; bindingDisabled = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SessionStatus sessionStatus = <span class="hljs-keyword">new</span> SimpleSessionStatus();</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> requestHandled = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这几个属性理解了，基本上也就整明白 ModelAndViewContainer 的作用了：</p><ul><li>defaultModel：默认使用的 Model。当我们在接口参数重使用 Model、ModelMap 或者 Map 时，最终使用的实现类都是 BindingAwareModelMap，对应的也都是 defaultModel。</li><li>redirectModel：重定向时候的 Model，如果我们在接口参数中使用了 RedirectAttributes 类型的参数，那么最终会传入 redirectModel。</li></ul><p>可以看到，一共有两个 Model，两个 Model 到底用哪个呢？这个在 getModel 方法中根据条件返回合适的 Model：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelMap <span class="hljs-title">getModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (useDefaultModel()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultModel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.redirectModel = <span class="hljs-keyword">new</span> ModelMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redirectModel;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">useDefaultModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (!<span class="hljs-keyword">this</span>.redirectModelScenario || (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 redirectModelScenario 表示处理器是否返回 redirect 视图；ignoreDefaultModelOnRedirect 表示是否在重定向时忽略 defaultModel，所以这块的逻辑是这样：</p><ol><li>如果 redirectModelScenario 为 true，即处理器返回的是一个重定向视图，那么使用 redirectModel。如果 redirectModelScenario 为 false，即处理器返回的不是一个重定向视图，那么使用 defaultModel。</li><li>如果 redirectModel 为 null，并且 ignoreDefaultModelOnRedirect 为 false，则使用 redirectModel，否则使用 defaultModel。</li></ol><p>接下来还剩下如下一些参数：</p><ul><li>view：返回的视图。</li><li>status：HTTP 状态码。</li><li>noBinding：是否对 @ModelAttribute(binding=true/false) 声明的数据模型的相应属性进行绑定。</li><li>bindingDisabled：不需要进行数据绑定的属性。</li><li>sessionStatus：SessionAttribute 使用完成的标识。</li><li>requestHandled：请求处理完成的标识（例如添加了 <code>@ResponseBody</code> 注解的接口，这个属性为 true，请求就不会再去找视图了）。</li></ul><blockquote><p>这个 ModelAndViewContainer 小伙伴们权且做一个了解，松哥在后面的源码分析中，还会和大家再次聊到这个组件。</p></blockquote><p>接下来我们也来自定义一个 HandlerMethodReturnValueHandler，来感受一下 HandlerMethodReturnValueHandler 的基本用法。</p><h2 id="3-API-接口数据包装"><a href="#3-API-接口数据包装" class="headerlink" title="3.API 接口数据包装"></a>3.API 接口数据包装</h2><p>假设我有这样一个需求：我想在原始的返回数据外面再包裹一层，举个简单例子，本来接口是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的数据格式是下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;</span><br></pre></td></tr></table></figure><p>现在我希望返回的数据格式变成下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"status"</span>:<span class="hljs-string">"ok"</span>,<span class="hljs-attr">"data"</span>:&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>就这样一个简单需求，我们一起来看下怎么实现。</p><h3 id="3-1-RequestResponseBodyMethodProcessor"><a href="#3-1-RequestResponseBodyMethodProcessor" class="headerlink" title="3.1 RequestResponseBodyMethodProcessor"></a>3.1 RequestResponseBodyMethodProcessor</h3><p>在开始定义之前，先给大家介绍一下 RequestResponseBodyMethodProcessor，这是 HandlerMethodReturnValueHandler 的实现类之一，这个主要用来处理返回 JSON 的情况。</p><p>我们来稍微看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：从这个方法中可以看到，这里支持有 <code>@ResponseBody</code> 注解的接口。</li><li>handleReturnValue：这是具体的处理逻辑，首先 mavContainer 中设置 requestHandled 属性为 true，表示这里处理完成后就完了，以后不用再去找视图了，然后分别获取 inputMessage 和 outputMessage，调用 writeWithMessageConverters 方法进行输出，writeWithMessageConverters 方法是在父类中定义的方法，这个方法比较长，核心逻辑就是调用确定输出数据、确定 MediaType，然后通过 HttpMessageConverter 将 JSON 数据写出去即可。</li></ul><p>有了上面的知识储备之后，接下来我们就可以自己实现了。</p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>首先自定义一个 HandlerMethodReturnValueHandler：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> HandlerMethodReturnValueHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span><span class="hljs-params">(HandlerMethodReturnValueHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> handler.supportsReturnType(returnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="hljs-string">"status"</span>, <span class="hljs-string">"ok"</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"data"</span>, returnValue);</span><br><span class="line">        handler.handleReturnValue(map, returnType, mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们要做的功能其实是在 RequestResponseBodyMethodProcessor 基础之上实现的，因为支持 <code>@ResponseBody</code>，输出 JSON 那些东西都不变，我们只是在输出之前修改一下数据而已。所以我这里直接定义了一个属性 HandlerMethodReturnValueHandler，这个属性的实例就是 RequestResponseBodyMethodProcessor，supportsReturnType 方法就按照 RequestResponseBodyMethodProcessor 的要求来，在 handleReturnValue 方法中，我们先对返回值进行一个预处理，然后调用 RequestResponseBodyMethodProcessor#handleReturnValue 方法继续输出 JSON 即可。</p><p>接下来就是配置 MyHandlerMethodReturnValueHandler 使之生效了。由于 SpringMVC 中 HandlerAdapter 在加载的时候已经配置了 HandlerMethodReturnValueHandler（这块松哥以后会和大家分析相关源码），所以我们可以通过如下方式对已经配置好的 RequestMappingHandlerAdapter 进行修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReturnValueConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; originHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(originHandlers.size());</span><br><span class="line">        <span class="hljs-keyword">for</span> (HandlerMethodReturnValueHandler originHandler : originHandlers) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (originHandler <span class="hljs-keyword">instanceof</span> RequestResponseBodyMethodProcessor) &#123;</span><br><span class="line">                newHandlers.add(<span class="hljs-keyword">new</span> MyHandlerMethodReturnValueHandler(originHandler));</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 ReturnValueConfig 实现 InitializingBean 接口，afterPropertiesSet 方法会被自动调用，在该方法中，我们将 RequestMappingHandlerAdapter 中已经配置好的 HandlerMethodReturnValueHandler 拎出来挨个检查，如果类型是 RequestResponseBodyMethodProcessor，则重新构建，用我们自定义的 MyHandlerMethodReturnValueHandler 代替它，最后给 requestMappingHandlerAdapter 重新设置 HandlerMethodReturnValueHandler 即可。</p><p>最后再提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，就可以启动项目啦。</p><p>项目启动成功后，访问 <code>/user</code> 接口，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317203148.png" alt></p><p>完美。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>其实统一 API 接口响应格式办法很多，可以参考松哥之前分享的 <a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>，也可以使用本文中的方案，甚至也可以自定义过滤器实现。</p><p>本文的内容稍微有点多，不知道大家有没有发现松哥最近发了很多 SpringMVC 源码相关的东西，没错，本文其实是松哥 SpringMVC 源码解析的一部分，为了源码解析不那么枯燥，所以强行加了一个案例进来，祝小伙伴们学习愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>深入分析 SpringMVC 参数解析器</title>
    <link href="http://www.javaboy.org/2021/0318/springmvc-argument-resolver.html"/>
    <id>http://www.javaboy.org/2021/0318/springmvc-argument-resolver.html</id>
    <published>2021-03-18T05:55:53.000Z</published>
    <updated>2021-03-22T05:58:52.770Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家聊了自定义 SpringMVC 参数解析器，同时我们也分析了几个比较简单的参数解析器，相信大家对于 SpringMVC 中的参数解析器应该已经有了一定的了解，如果还没看过的小伙伴可以先看看：<a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a>。</p><a id="more"></a><p>不过我相信很多小伙伴真正疑惑的是像下面这种接口，参数是怎么解析的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抑或者像下面这种接口，参数是怎么解析的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;id&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"id = "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们日常中最常见的参数定义方式，相信很多小伙伴对此很感兴趣。由于这块涉及到一个非常庞大的类 AbstractNamedValueMethodArgumentResolver，因此这里我单独写了一篇文章来和大家分享这个问题。</p><p>在正式分享之前，我们先来整体看看参数解析器都有哪些。</p><h2 id="1-参数解析器"><a href="#1-参数解析器" class="headerlink" title="1.参数解析器"></a>1.参数解析器</h2><p>HandlerMethodArgumentResolver 就是我们口口声声说的参数解析器，它的实现类还是蛮多的，因为每一种类型的参数都对应了一个参数解析器：</p><p><img src="http://img.itboyhub.com/2021/02/20210315143417.png" alt></p><p>为了理解方便，我们可以将这些参数解析器分为四大类：</p><ul><li>xxxMethodArgumentResolver：这就是一个普通的参数解析器。</li><li>xxxMethodProcessor：不仅可以当作参数解析器，还可以处理对应类型的返回值。</li><li>xxxAdapter：这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</li><li>HandlerMethodArgumentResolverComposite：这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</li></ul><p>大致上可以分为这四类，其中最重要的当然就是前两种了。</p><h2 id="2-参数解析器概览"><a href="#2-参数解析器概览" class="headerlink" title="2.参数解析器概览"></a>2.参数解析器概览</h2><p>接下来我们来先来大概看看这些参数解析器分别都是用来干什么的。</p><p><strong>MapMethodProcessor</strong></p><p>这个用来处理 Map/ModelMap 类型的参数，解析完成后返回 model。</p><p><strong>PathVariableMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@PathVariable</code> 注解并且参数类型不为 Map 的参数，参数类型为 Map 则使用 <code>PathVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>PathVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>ErrorsMethodArgumentResolver</strong></p><p>这个用来处理 Error 参数，例如我们做参数校验时的 BindingResult。</p><p><strong>AbstractNamedValueMethodArgumentResolver</strong></p><p>这个用来处理 key/value 类型的参数，如请求头参数、使用了 <code>@PathVariable</code> 注解的参数以及 Cookie 等。</p><p><strong>RequestHeaderMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestHeader</code> 注解，并且参数类型不是 Map 的参数（参数类型是 Map 的使用 <code>RequestHeaderMapMethodArgumentResolver</code>）。</p><p><strong>RequestHeaderMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>RequestAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestAttribute</code> 注解的参数。</p><p><strong>RequestParamMethodArgumentResolver</strong></p><p>这个功能就比较广了。使用了 <code>@RequestParam</code> 注解的参数、文件上传的类型 MultipartFile、或者一些没有使用任何注解的基本类型（Long、Integer）以及 String 等，都使用该参数解析器处理。需要注意的是，如果 <code>@RequestParam</code> 注解的参数类型是 Map，则该注解必须有 name 值，否则解析将由 <code>RequestParamMapMethodArgumentResolver</code> 完成。</p><p><strong>RequestParamMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>AbstractCookieValueMethodArgumentResolver</strong></p><p>这个是一个父类，处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>ServletCookieValueMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>MatrixVariableMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@MatrixVariable</code> 注解并且参数类型不是 Map 的参数，如果参数类型是 Map，则使用 <code>MatrixVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>MatrixVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>SessionAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@SessionAttribute</code> 注解的参数。</p><p><strong>ExpressionValueMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@Value</code> 注解的参数。</p><p><strong>ServletResponseMethodArgumentResolver</strong></p><p>这个用来处理 ServletResponse、OutputStream 以及 Writer 类型的参数。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理 Model 类型参数，并返回 model。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理使用了 <code>@ModelAttribute</code> 注解的参数。</p><p><strong>SessionStatusMethodArgumentResolver</strong></p><p>这个用来处理 SessionStatus 类型的参数。</p><p><strong>PrincipalMethodArgumentResolver</strong></p><p>这个用来处理 Principal 类型参数，这个松哥在前面的文章中和大家介绍过了（<a href>SpringBoot 中如何自定义参数解析器？</a>）。</p><p><strong>AbstractMessageConverterMethodArgumentResolver</strong></p><p>这是一个父类，当使用 HttpMessageConverter 解析 requestbody 类型参数时，相关的处理类都会继承自它。</p><p><strong>RequestPartMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestPart</code> 注解、MultipartFile 以及 Part 类型的参数。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个工具类，不承担参数解析任务。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@RequestBody</code> 注解的参数。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理 HttpEntity 和 RequestEntity 类型的参数。</p><p><strong>ContinuationHandlerMethodArgumentResolver</strong></p><p><strong>AbstractWebArgumentResolverAdapter</strong></p><p>这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</p><p><strong>ServletWebArgumentResolverAdapter</strong></p><p>这个给父类提供 request。</p><p><strong>UriComponentsBuilderMethodArgumentResolver</strong></p><p>这个用来处理 UriComponentsBuilder 类型的参数。</p><p><strong>ServletRequestMethodArgumentResolver</strong></p><p>这个用来处理 WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 类型的参数。</p><p><strong>HandlerMethodArgumentResolverComposite</strong></p><p>这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</p><p><strong>RedirectAttributesMethodArgumentResolver</strong></p><p>这个用来处理 RedirectAttributes 类型的参数，RedirectAttributes 松哥在之前的文章中和大家介绍过：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</p><p>好了，各个参数解析器的大致功能就给大家介绍完了，接下来我们选择其中一种，来具体说说它的源码。</p><h2 id="3-AbstractNamedValueMethodArgumentResolver"><a href="#3-AbstractNamedValueMethodArgumentResolver" class="headerlink" title="3.AbstractNamedValueMethodArgumentResolver"></a>3.AbstractNamedValueMethodArgumentResolver</h2><p>AbstractNamedValueMethodArgumentResolver 是一个抽象类，一些键值对类型的参数解析器都是通过继承它实现的，它里边定义了很多这些键值对类型参数解析器的公共操作。</p><p>AbstractNamedValueMethodArgumentResolver 中也是应用了很多模版模式，例如它没有实现 supportsParameter 方法，该方法的具体实现在不同的子类中，resolveArgument 方法它倒是实现了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span><br><span class="line">MethodParameter nestedParameter = parameter.nestedIfOptional();</span><br><span class="line">Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"Specified name must not resolve to null: ["</span> + namedValueInfo.name + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (binderFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="hljs-keyword">null</span>, namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先根据当前请求获取一个 NamedValueInfo 对象，这个对象中保存了参数的三个属性：参数名、参数是否必须以及参数默认值。具体的获取过程就是先去缓存中拿，缓存中如果有，就直接返回，缓存中如果没有，则调用 createNamedValueInfo 方法去创建，将创建结果缓存起来并返回。createNamedValueInfo 方法是一个模版方法，具体的实现在子类中。</li><li>接下来处理 Optional 类型参数。</li><li>resolveEmbeddedValuesAndExpressions 方法是为了处理注解中使用了 SpEL 表达式的情况，例如如下接口：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"$&#123;aa.bb&#125;"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数名使用了表达式，那么 resolveEmbeddedValuesAndExpressions 方法的目的就是解析出表达式的值，如果没用到表达式，那么该方法会将原参数原封不动返回。</p><ol start="4"><li>接下来调用 resolveName 方法解析出参数的具体值，这个方法也是一个模版方法，具体的实现在子类中。</li><li>如果获取到的参数值为 null，先去看注解中有没有默认值，然后再去看参数值是否是必须的，如果是，则抛异常出来，否则就设置为 null 即可。</li><li>如果解析出来的参数值为空字符串 <code>&quot;&quot;</code>，则也去 resolveEmbeddedValuesAndExpressions 方法中走一遭。</li><li>最后则是 WebDataBinder 的处理，解决一些全局参数的问题，WebDataBinder 松哥在之前的文章中也有介绍过，传送门：<a href="https://mp.weixin.qq.com/s/Qd0BAUdUtBuBUBmy1G0Z4w" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a>。</li></ol><p>大致的流程就是这样。</p><p>在这个流程中，我们看到主要有如下两个方法是在子类中实现的：</p><ul><li>createNamedValueInfo</li><li>resolveName</li></ul><p>在加上 supportsParameter 方法，子类中一共有三个方法需要我们重点分析。</p><p>那么接下来我们就以 RequestParamMethodArgumentResolver 为例，来看下这三个方法。</p><h2 id="4-RequestParamMethodArgumentResolver"><a href="#4-RequestParamMethodArgumentResolver" class="headerlink" title="4.RequestParamMethodArgumentResolver"></a>4.RequestParamMethodArgumentResolver</h2><h3 id="4-1-supportsParameter"><a href="#4-1-supportsParameter" class="headerlink" title="4.1 supportsParameter"></a>4.1 supportsParameter</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="hljs-keyword">if</span> (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useDefaultResolution) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> BeanUtils.isSimpleProperty(parameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleProperty</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> isSimpleValueType(type) || (type.isArray() &amp;&amp; isSimpleValueType(type.getComponentType()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleValueType</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (Void.class != type &amp;&amp; <span class="hljs-keyword">void</span>.class != type &amp;&amp;</span><br><span class="line">(ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">Enum.class.isAssignableFrom(type) ||</span><br><span class="line">CharSequence.class.isAssignableFrom(type) ||</span><br><span class="line">Number.class.isAssignableFrom(type) ||</span><br><span class="line">Date.class.isAssignableFrom(type) ||</span><br><span class="line">Temporal.class.isAssignableFrom(type) ||</span><br><span class="line">URI.class == type ||</span><br><span class="line">URL.class == type ||</span><br><span class="line">Locale.class == type ||</span><br><span class="line">Class.class == type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 supportsParameter 方法中可以非常方便的看出支持的参数类型：</p><ol><li>首先参数如果有 <code>@RequestParam</code> 注解的话，则分两种情况：参数类型如果是 Map，则 <code>@RequestParam</code> 注解必须配置 name 属性，否则不支持；如果参数类型不是 Map，则直接返回 true，表示总是支持（想想自己平时使用的时候是不是这样）。</li><li>参数如果含有 <code>@RequestPart</code> 注解，则不支持。</li><li>检查下是不是文件上传请求，如果是，返回 true 表示支持。</li><li>如果前面都没能返回，则使用默认的解决方案，判断是不是简单类型，主要就是 Void、枚举、字符串、数字、日期等等。</li></ol><p>这块代码其实很简单，支持谁不支持谁，一目了然。</p><h3 id="4-2-createNamedValueInfo"><a href="#4-2-createNamedValueInfo" class="headerlink" title="4.2 createNamedValueInfo"></a>4.2 createNamedValueInfo</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> NamedValueInfo <span class="hljs-title">createNamedValueInfo</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (ann != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> RequestParamNamedValueInfo(ann) : <span class="hljs-keyword">new</span> RequestParamNamedValueInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamNamedValueInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedValueInfo</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-string">""</span>, <span class="hljs-keyword">false</span>, ValueConstants.DEFAULT_NONE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">(RequestParam annotation)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(annotation.name(), annotation.required(), annotation.defaultValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取注解，读取注解中的属性，构造 RequestParamNamedValueInfo 对象返回。</p><h3 id="4-3-resolveName"><a href="#4-3-resolveName" class="headerlink" title="4.3 resolveName"></a>4.3 resolveName</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object arg = <span class="hljs-keyword">null</span>;</span><br><span class="line">MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">arg = (files.size() == <span class="hljs-number">1</span> ? files.get(<span class="hljs-number">0</span>) : files);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] paramValues = request.getParameterValues(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (paramValues != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = (paramValues.length == <span class="hljs-number">1</span> ? paramValues[<span class="hljs-number">0</span>] : paramValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法思路也比较清晰：</p><ol><li>前面两个 if 主要是为了处理文件上传请求。</li><li>如果不是文件上传请求，则调用 <code>request.getParameterValues</code> 方法取出参数返回即可。</li></ol><p>整个过程还是比较 easy 的。小伙伴们可以在此基础之上自行分析 PathVariableMethodArgumentResolver 的原理，也很容易。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>今天主要和小伙伴们梳理了 SpringMVC 参数解析器的整个体系，关于这些解析器在何时被配置，在何时被调用，松哥在后面的文章中会和大家继续分析。好啦，今天就说这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家聊了自定义 SpringMVC 参数解析器，同时我们也分析了几个比较简单的参数解析器，相信大家对于 SpringMVC 中的参数解析器应该已经有了一定的了解，如果还没看过的小伙伴可以先看看：&lt;a href=&quot;https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringBoot 中如何自定义参数解析器？&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 中如何自定义参数解析器？</title>
    <link href="http://www.javaboy.org/2021/0316/springmvc-param-resolver.html"/>
    <id>http://www.javaboy.org/2021/0316/springmvc-param-resolver.html</id>
    <published>2021-03-16T08:48:03.000Z</published>
    <updated>2021-03-16T08:51:16.790Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。</p><a id="more"></a><p>放在地址栏中，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>放在请求体中，如果是 key/value 形式，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>如果是 JSON 形式，我们则通过如果如下方式获取到输入流，然后解析成 JSON 字符串，再通过 JSON 工具转为对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(request.getInputStream()));</span><br><span class="line">String json = reader.readLine();</span><br><span class="line">reader.close();</span><br><span class="line">User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(json, User.class);</span><br></pre></td></tr></table></figure><p>如果参数放在请求头中，我们可以通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getHeader(<span class="hljs-string">"name"</span>);</span><br></pre></td></tr></table></figure><p>如果你用的是 Jsp/Servlet 那一套技术栈，那么参数获取无外乎这几种方式。</p><p>如果用了 SpringMVC 框架，有的小伙伴们可能会觉得参数获取方式太丰富了，各种注解如 <code>@RequestParam</code>、<code>@RequestBody</code>、<code>@RequestHeader</code>、<code>@PathVariable</code>，参数可以是 key/value 形式，也可以是 JSON 形式，非常丰富！但是，<strong>无论多么丰富，最底层获取参数的方式无外乎上面几种。</strong></p><p>那有小伙伴要问了，SpringMVC 到底是怎么样从 request 中把参数提取出来直接给我们用的呢？例如下面这个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 name 参数是从 HttpServletRequest 中提取出来的，到底是怎么提取出来的？这就是松哥今天要和大家分享的话题。</p><h2 id="1-自定义参数解析器"><a href="#1-自定义参数解析器" class="headerlink" title="1.自定义参数解析器"></a>1.自定义参数解析器</h2><p>为了搞清楚这个问题，我们先来自定义一个参数解析器看看。</p><p>自定义参数解析器需要实现 HandlerMethodArgumentResolver 接口，我们先来看看该接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就两个方法：</p><ul><li>supportsParameter：该方法表示是否启用这个参数解析器，返回 true 表示启用，返回 false 表示不启用。</li><li>resolveArgument：这是具体的解析过程，就是从 request 中取出参数的过程，方法的返回值就对应了接口中参数的值。</li></ul><p>自定义参数解析器只需要实现该接口即可。</p><p>假设我现在有这样一个需求（实际上在 Spring Security 中获取当前登录用户名非常方便，这里只是为了该案例而做，勿抬杠）：</p><p>假设我现在系统安全框架使用了 Spring Security（对 Spring Security 不熟悉的小伙伴，可以在公众号江南一点雨后台回复 ss，有教程），如果我在接口的参数上添加了 @CurrentUserName 注解，那么该参数的值就是当前登录的用户名，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@CurrentUserName String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现这个功能，非常 easy，首先我们自定义一个 <code>@CurrentUserName</code> 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CurrentUserName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解没啥好解释的。</p><p>接下来我们自定义参数解析器 CurrentUserNameHandlerMethodArgumentResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentUserNameHandlerMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> parameter.getParameterType().isAssignableFrom(String.class)&amp;&amp;parameter.hasParameterAnnotation(CurrentUserName.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="hljs-keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：如果参数类型是 String，并且参数上有 <code>@CurrentUserName</code> 注解，则使用该参数解析器。</li><li>resolveArgument：该方法的返回值就是参数的具体值，当前登录用户名从 SecurityContextHolder 中获取即可（具体参数松哥的 Spring Security 教程，公号后台回复 ss）。</li></ul><p>最后，我们再将自定义的参数解析器配置到 HandlerAdapter 中，配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(<span class="hljs-keyword">new</span> CurrentUserNameHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就算配置完成了。</p><p>接下来启动项目，用户登录成功后，访问 <code>/hello</code> 接口，就可以看到返回当前登录用户数据了。</p><p>这就是我们自定义的一个参数类型解析器。可以看到，非常 Easy。</p><p>在 SpringMVC 中，默认也有很多 HandlerMethodArgumentResolver 的实现类，他们处理的问题也都类似，松哥再给大家举个例子。</p><h2 id="2-PrincipalMethodArgumentResolver"><a href="#2-PrincipalMethodArgumentResolver" class="headerlink" title="2.PrincipalMethodArgumentResolver"></a>2.PrincipalMethodArgumentResolver</h2><p>如果我们在项目中使用了 Spring Security，我们可以通过如下方式获取当前登录用户信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Principal principal)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + principal.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即直接在当前接口的参数中添加 Principal 类型的参数即可，该参数描述了当前登录用户信息，这个用过 Spring Security 的小伙伴应该都知道（不熟悉 Spring Security 的小伙伴可以在公众号【江南一点雨】后台回复 ss）。</p><p>那么这个功能是怎么实现的呢？当然就是 PrincipalMethodArgumentResolver 在起作用了！</p><p>我们一起来看下这个参数解析器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrincipalMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Principal.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current request is not of type HttpServletRequest: "</span> + webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Principal principal = request.getUserPrincipal();</span><br><span class="line"><span class="hljs-keyword">if</span> (principal != <span class="hljs-keyword">null</span> &amp;&amp; !parameter.getParameterType().isInstance(principal)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current user principal is not of type ["</span> +</span><br><span class="line">parameter.getParameterType().getName() + <span class="hljs-string">"]: "</span> + principal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> principal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：这个方法主要是判断参数类型是不是 Principal，如果参数类型是 Principal，就支持。</li><li>resolveArgument：这个方法的逻辑很简单，首先获取原生的请求，再从请求中获取 Principal 对象返回即可。</li></ul><p>是不是很简单，有了这个，我们就可以随时加载到当前登录用户信息了。</p><h2 id="3-RequestParamMapMethodArgumentResolver"><a href="#3-RequestParamMapMethodArgumentResolver" class="headerlink" title="3.RequestParamMapMethodArgumentResolver"></a>3.RequestParamMapMethodArgumentResolver</h2><p>松哥再给大家举个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam MultiValueMap map)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很多小伙伴可能都写过，使用 Map 去接收前端传来的参数，那么这里用到的参数解析器就是 RequestParamMapMethodArgumentResolver。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamMapMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">!StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) &#123;</span><br><span class="line"><span class="hljs-comment">// MultiValueMap</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.as(MultiValueMap.class).getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getMultiFileMap() : <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedMultiValueMap&lt;String, Part&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">result.add(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String value : values) &#123;</span><br><span class="line">result.add(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Regular Map</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.asMap().getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getFileMap() : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedHashMap&lt;String, Part&gt; result = CollectionUtils.newLinkedHashMap(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!result.containsKey(part.getName())) &#123;</span><br><span class="line">result.put(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">Map&lt;String, String&gt; result = CollectionUtils.newLinkedHashMap(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (values.length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">result.put(key, values[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：参数类型是 Map，并且使用了 <code>@RequestParam</code> 注解，并且 <code>@RequestParam</code> 注解中没有配置 name 属性，就可以使用该参数解析器。</li><li>resolveArgument：具体解析分为两种情况：MultiValueMap 和其他 Map，前者中又分三种情况：MultipartFile、Part 或者其他普通请求，前两者可以处理文件上传，第三个就是普通参数。如果是普通 Map，则直接获取到原始请求参数放到一个 Map 集合中返回即可。</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>前面和大家聊的都是几种简单的情况，还有复杂的如 PathVariableMethodArgumentResolver 和 RequestParamMethodArgumentResolver 松哥以后再和大家详细聊。同时还有一个问题就是这些参数解析器具体是在哪里调用的，这个也会在松哥近期的 SpringMVC 源码解析系列文章中和大家分享，好啦，今天周末，就这点简单的小知识祝大家周末愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 初始化流程分析</title>
    <link href="http://www.javaboy.org/2021/0315/springmvc-init.html"/>
    <id>http://www.javaboy.org/2021/0315/springmvc-init.html</id>
    <published>2021-03-15T08:47:50.000Z</published>
    <updated>2021-03-16T08:51:54.332Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。</p><a id="more"></a><p>即使你没看过 SpringMVC 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>然而 DispatcherServlet 继承自 FrameworkServlet，FrameworkServlet 又继承自 HttpServletBean，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>因此我们的分析就从 HttpServletBean 开始。</p><h2 id="1-HttpServletBean"><a href="#1-HttpServletBean" class="headerlink" title="1.HttpServletBean"></a>1.HttpServletBean</h2><p><code>HttpServletBean</code> 继承自 <code>HttpServlet</code>，它负责将 <code>init-param</code> 中的参数注入到当前 <code>Servlet</code> 实例的属性中，同时也为子类提供了增加 <code>requiredProperties</code> 的能力，需要注意的是 <code>HttpServletBean</code> 并不依赖于 <code>Spring</code> 容器。</p><p>大家知道，HttpServlet 的初始化是从 init 方法开始的，所以我们就先从 HttpServletBean 的 init 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Set bean properties from init parameters.</span></span><br><span class="line">PropertyValues pvs = <span class="hljs-keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="hljs-keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="hljs-keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="hljs-keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="hljs-keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="hljs-string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="hljs-string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里，首先获取到 Servlet 的所有配置并转为 PropertyValues，然后通过 BeanWrapper 修改目标 Servlet 的相关属性。BeanWrapper 是 Spring 中提供一个工具，使用它可以修改一个对象的属性，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        beanWrapper.setPropertyValue(<span class="hljs-string">"username"</span>, <span class="hljs-string">"itboyhub"</span>);</span><br><span class="line">        PropertyValue pv = <span class="hljs-keyword">new</span> PropertyValue(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.itboyhub.com"</span>);</span><br><span class="line">        beanWrapper.setPropertyValue(pv);</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=&apos;itboyhub&apos;, address=&apos;www.itboyhub.com&apos;&#125;</span><br></pre></td></tr></table></figure><p>所以前面的 bw 实际上就代表当前 DispatcherServlet 对象。</p><p>通过 BeanWrapper 修改目标 Servlet 的相关属性时，有一个 initBeanWrapper 方法是空方法，开发者如有需要可以在子类中实现该方法，并且完成一些初始化操作。</p><p>属性配置完成后，最终调用 initServletBean 方法进行 Servlet 初始化，然而该方法也是一个空方法，在子类中实现。</p><p>这就是 HttpServletBean 所做的事情，比较简单，加载 Servlet 相关属性并设置给当前 Servlet 对象，然后调用 initServletBean 方法继续完成 Servlet 的初始化操作。</p><h2 id="2-FrameworkServlet"><a href="#2-FrameworkServlet" class="headerlink" title="2.FrameworkServlet"></a>2.FrameworkServlet</h2><p>从前面的介绍可知，FrameworkServlet 初始化的入口方法就是 initServletBean，因此我们就从 FrameworkServlet#initServletBean 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法原本挺长的，但是抛开日志打印异常抛出，剩下的核心代码其实就两行：</p><ol><li>initWebApplicationContext 方法用来初始化 WebApplicationContext。</li><li>initFrameworkServlet 方法用来初始化 FrameworkServlet，但是这个方法是一个空方法，没有具体的实现。本来子类可以重写该方法做一些初始化操作，但是实际上子类并没有重写该方法，所以这个方法我们就暂且忽略之，不去分析了。</li></ol><p>那么这里最为重要的其实就是 initWebApplicationContext 方法了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">initWebApplicationContext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = <span class="hljs-keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishContext) &#123;</span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也比较清晰：</p><ol><li>首先获取 rootContext。在默认情况下，Spring 会将容器设置为 ServletContext 的一个属性，属性的 key 为 <code>org.springframework.web.context.WebApplicationContext.ROOT</code>，所以根据这个 key 就可以调用 ServletContext#getAttribute 方法获取到 rootContext 了。</li><li>获取 WebApplicationContext 实例，也就是给 wac 变量赋值的过程，这里存在三种可能性：1.如果已经通过构造方法给 webApplicationContext 赋值了，则直接将其赋给 wac 变量，同时，如果需要设置 parent 就设置，需要刷新就刷新。这种方式适用于 Servlet3.0 以后的环境，因为从 Servlet3.0 开始，才支持直接调用 ServletContext.addServlet 方法去注册 Servlet，手动注册的时候就可以使用自己提前准备好的 WebApplicationContext 了，这块松哥在我录制的 Spring Boot 视频中也讲过，感兴趣的小伙伴可以在公众号后台回复 vhr 查看视频详情；2.如果第一步没能成功给 wac 赋值，那么调用 findWebApplicationContext 方法尝试去 ServletContext 中查找 WebApplicationContext 对象，找到了就赋值给 wac；3.如果第二步没能成功给 wac 赋值，那么调用 createWebApplicationContext 方法创建一个 WebApplicationContext 对象并赋值给 wac，一般来说都是通过这种方式创建的 WebApplicationContext。这三套组合拳下来，wac 肯定是有值了。</li><li>当 ContextRefreshedEvent 事件没有触发时，调用 onRefresh 方法完成容器刷新（由于第一种和第三种获取 WebApplicationContext 的方式最终都会调用 configureAndRefreshWebApplicationContext 方法，然后发布事件，再将 refreshEventReceived 变量标记为 true，所以实际上只有第二种方式获取 wac 实例的时候，这里才会刷新，具体可以看下文分析）。</li><li>最后将 wac 保存到到 ServletContext 中。保存的时候会根据 publishContext 变量的值来决定是否保存，publishContext 可以在 web.xml 中配置 Servlet 时通过 init-param 进行配置，保存的目的是为了方便获取。</li></ol><p>上面的这些步骤中，通过 createWebApplicationContext 方法创建 WebApplicationContext 对象需要和大家细说下，因为一般情况下就是通过这种方式创建的 WebApplicationContext。我们来看一下相关的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createWebApplicationContext</span><span class="hljs-params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="hljs-string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line"><span class="hljs-string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line">ConfigurableWebApplicationContext wac =</span><br><span class="line">(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">wac.setEnvironment(getEnvironment());</span><br><span class="line">wac.setParent(parent);</span><br><span class="line">String configLocation = getContextConfigLocation();</span><br><span class="line"><span class="hljs-keyword">if</span> (configLocation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setConfigLocation(configLocation);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureAndRefreshWebApplicationContext</span><span class="hljs-params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="hljs-comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="hljs-comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contextId != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setId(<span class="hljs-keyword">this</span>.contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="hljs-string">'/'</span> + getServletName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">wac.setServletConfig(getServletConfig());</span><br><span class="line">wac.setNamespace(getNamespace());</span><br><span class="line">wac.addApplicationListener(<span class="hljs-keyword">new</span> SourceFilteringListener(wac, <span class="hljs-keyword">new</span> ContextRefreshListener()));</span><br><span class="line"><span class="hljs-comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="hljs-comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="hljs-comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="hljs-keyword">if</span> (env <span class="hljs-keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">&#125;</span><br><span class="line">postProcessWebApplicationContext(wac);</span><br><span class="line">applyInitializers(wac);</span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共涉及到两个方法：</p><p><strong>createWebApplicationContext</strong></p><p>首先获取到创建类型，并检查创建类型，没问题的话调用 instantiateClass 方法完成创建工作，然后给创建好的 wac 对象配置各种属性，配置的 configLocation 就是我们在 web.xml 文件中配置的 SpringMVC 配置文件路径，默认的文件路径是 <code>/WEB-INF/[servletName]-servlet.xml</code>。</p><p><strong>configureAndRefreshWebApplicationContext</strong></p><p>configureAndRefreshWebApplicationContext 方法主要也是配置&amp;刷新 WebApplicationContext，在这个方法里会调用 addApplicationListener 为 wac 添加一个监听器，监听的是 ContextRefreshedEvent 事件，当收到该事件后，会调用 FrameworkServlet 的 onApplicationEvent 方法，并在该方法中调用 onRefresh 方法完成刷新，刷新之后，会将 refreshEventReceived 变量标记为 true。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.refreshEventReceived = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(event.getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 FrameworkServlet#initServletBean 方法的大致工作逻辑。这里涉及到了 onRefresh 方法，但是这是一个空方法，在子类 DispatcherServlet 中实现了，所以接下来我们就来看 DispatcherServlet。</p><h2 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3.DispatcherServlet"></a>3.DispatcherServlet</h2><p>这里我们就不废话了，直接来看 onRefresh 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 onRefresh 方法中调用了 initStrategies 进行初始化操作。initStrategies 的内容其实很简单，就是九个组件的初始化。九个的初始化流程比较类似，这里我们以常见的视图解析器的初始化方法 initViewResolvers 为例，来一起看看初始化流程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No ViewResolvers declared for servlet '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始的 viewResolvers 变量是一个集合，解析出来的视图解析器对象都将放入这个集合中。</p><p>首先判断 detectAllViewResolvers 变量是否为 true，如果为 true，则直接去查找 Spring 容器中的所有视图解析器，将查找结果赋值给 viewResolvers，然后进行排序。默认情况下 detectAllViewResolvers 变量的值为 true，如果有需要，可以在 web.xml 中进行配置，像下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>detectAllViewResolvers<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 detectAllViewResolvers 的值为 false，那么接下来就会去 Spring 容器中查找一个名为 viewResolver 的视图解析器，此时查找到的就是一个单独的视图解析器。</p><p>一般来说，我们并不需要在 web.xml 中去配置 detectAllViewResolvers 的值，视图解析器有多少个就加载多少个。</p><p>举个简单例子，我们在 SpringMVC 的配置文件中可能像下面这样配置视图解析器：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，这个 bean 的 id 有没有都行，如果有，取什么值都可以，反正最终都是通过类型而不是 id 去查找的视图解析器。但是如果你在 web.xml 中将 detectAllViewResolvers 修改为 false，那么这个 bean 的 id 取值就比较重要了，就一定要是 viewResolver。</p><p>如果在 Spring 容器中通过这两种方式（通过类型查找或通过 id 查找）都没有找到 ViewResolver 实例，那么会调用 getDefaultStrategies 方法去获取一个默认的 ViewResolver 实例。默认实例的获取方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getDefaultStrategies</span><span class="hljs-params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultStrategies == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Load default strategy implementations from properties file.</span></span><br><span class="line"><span class="hljs-comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line"><span class="hljs-comment">// by application developers.</span></span><br><span class="line">ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="hljs-string">"': "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String key = strategyInterface.getName();</span><br><span class="line">String value = defaultStrategies.getProperty(key);</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">List&lt;T&gt; strategies = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span><br><span class="line"><span class="hljs-keyword">for</span> (String className : classNames) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">Object strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">strategies.add((T) strategy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line"><span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> +</span><br><span class="line">className + <span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> strategies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实也比较简单，就是通过反射去获取默认的视图解析器。</p><p>首先给 defaultStrategies 赋值，defaultStrategies 的值实际上就是从 DispatcherServlet.properties 文件中加载到的，我们来看下这个文件内容：</p><p><img src="http://img.itboyhub.com/2021/02/20210303202947.png" alt></p><p>可以看到，这里一共定义了 8 个默认的键值对，有的值是一个，有的值是多个。前面 initStrategies 方法中一共要初始化九个组件，这里默认只定义了 8 个，少了一个 MultipartResolver，这也好理解，并非所有的项目都有文件上传，而且即使有文件上传，用哪一个具体的 MultipartResolver 也不好确定，还是要开发者自己决定。</p><p>defaultStrategies 其实加载到的就是这 8 个键值对，其中视图解析器对应的是 org.springframework.web.servlet.view.InternalResourceViewResolver，通过反射创建该类的实例，当 Spring 容器中不存在任何视图解析器的时候，默认的视图解析器即此。</p><p>这就是 initViewResolvers 的工作流程，另外 8 个也和它差不多，唯一不同的是 initMultipartResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMultipartResolver</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它只是根据 bean 的名字去查找 bean 实例，没有去查找默认的 MultipartResolver。</p><p>说到这里，松哥和大家多说一句 SpringMVC 配置中的小细节，</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个关于视图解析器和文件上传解析器的配置，不知道小伙伴们有没有注意过，视图解析器的 id 可有可无，而文件上传解析器的 id 必须是 multipartResolver，回顾我们上面的源码分析，你就知道为啥了！</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，这就是松哥和小伙伴们分享的 SpringMVC 的初始化流程，主要涉及到了 HttpServletBean、FrameworkServlet 以及 DispatcherServlet 三个实例，HttpServletBean 主要是加载 Servlet 配置的各种属性并设置到 Servlet 上；FrameworkServlet 则主要是初始化了 WebApplicationContext；DispatcherServlet 则主要是初始化了自身的九个组件。</p><p>这只是初始化的流程，那么当请求到来之后，请求的流程又是怎么样的呢？这个松哥下篇文章来和大家分享～好啦，今天就先和小伙伴们聊这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的实现 Spring Boot 接口参数加密解密?</title>
    <link href="http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html"/>
    <id>http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html</id>
    <published>2021-03-09T06:15:49.000Z</published>
    <updated>2021-03-09T06:16:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。</p><a id="more"></a><p>加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便。</p><p>所以今天这篇文章有两个目的：</p><ul><li>分享参数/响应加解密的思路。</li><li>分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法。</li></ul><p>好了，那么接下来就不废话了，我们一起来看下。</p><h2 id="1-开发加解密-starter"><a href="#1-开发加解密-starter" class="headerlink" title="1.开发加解密 starter"></a>1.开发加解密 starter</h2><p>为了让我们开发的这个工具更加通用，也为了复习一下自定义 Spring Boot Starter，这里我们就将这个工具做成一个 stater，以后在 Spring Boot 项目中直接引用就可以。</p><p>首先我们创建一个 Spring Boot 项目，引入 spring-boot-starter-web 依赖：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为我们这个工具是为 Web 项目开发的，以后必然使用在 Web 环境中，所以这里添加依赖时 scope 设置为 provided。</p><p>依赖添加完成后，我们先来定义一个加密工具类备用，加密这块有多种方案可以选择，对称加密、非对称加密，其中对称加密又可以使用 AES、DES、3DES 等不同算法，这里我们使用 Java 自带的 Cipher 来实现对称加密，使用 AES 算法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AES_ALGORITHM = <span class="hljs-string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 获取 cipher</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cipher <span class="hljs-title">getCipher</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">int</span> model)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key, <span class="hljs-string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model, secretKeySpec);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES加密</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.ENCRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES解密</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.DECRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher.doFinal(Base64.getDecoder().decode(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类比较简单，不需要多解释。需要说明的是，加密后的数据可能不具备可读性，因此我们一般需要对加密后的数据再使用 Base64 算法进行编码，获取可读字符串。换言之，上面的 AES 加密方法的返回值是一个 Base64 编码之后的字符串，AES 解密方法的参数也是一个 Base64 编码之后的字符串，先对该字符串进行解码，然后再解密。</p><p>接下来我们封装一个响应工具类备用，这个大家如果经常看松哥视频已经很了解了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RespBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer status;</span><br><span class="line">    <span class="hljs-keyword">private</span> String msg;</span><br><span class="line">    <span class="hljs-keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">(Integer status, String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setStatus</span><span class="hljs-params">(Integer status)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setObj</span><span class="hljs-params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义两个注解 <code>@Decrypt</code> 和 <code>@Encrypt</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Decrypt &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解就是两个标记，在以后使用的过程中，哪个接口方法添加了 @Encrypt 注解就对哪个接口的数据加密返回，哪个接口/参数添加了 @Decrypt 注解就对哪个接口/参数进行解密。这个定义也比较简单，没啥好说的，需要注意的是 <code>@Decrypt</code> 比 <code>@Encrypt</code> 多了一个使用场景就是 <code>@Decrypt</code> 可以用在参数上。</p><p>考虑到用户可能会自己配置加密的 key，因此我们再来定义一个 EncryptProperties 类来读取用户配置的 key：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.encrypt"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DEFAULT_KEY = <span class="hljs-string">"www.itboyhub.com"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我设置了默认的 key 是 <code>www.itboyhub.com</code>，key 是 16 位字符串，松哥这个网站地址刚好满足。以后如果用户想自己配置 key，只需要在 application.properties 中配置 <code>spring.encrypt.key=xxx</code> 即可。</p><p>所有准备工作做完了，接下来就该正式加解密了。</p><p>因为松哥这篇文章一个很重要的目的是想和大家分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，RequestBodyAdvice 在做解密的时候倒是没啥问题，而 ResponseBodyAdvice 在做加密的时候则会有一些局限，不过影响不大，还是我前面说的，如果想非常灵活的掌控一切，那还是自定义过滤器吧。这里我就先用这两个工具来实现了。</p><p>另外还有一点需要注意，ResponseBodyAdvice 在你使用了 @ResponseBody 注解的时候才会生效，RequestBodyAdvice 在你使用了 @RequestBody 注解的时候才会生效，换言之，前后端都是 JSON 交互的时候，这两个才有用。不过一般来说接口加解密的场景也都是前后端分离的时候才可能有的事。</p><p>先来看接口加密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptResponse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseBodyAdvice</span>&lt;<span class="hljs-title">RespBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">beforeBodyWrite</span><span class="hljs-params">(RespBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] keyBytes = encryptProperties.getKey().getBytes();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getMsg()!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setMsg(AESUtils.encrypt(body.getMsg().getBytes(),keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getObj() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setObj(AESUtils.encrypt(om.writeValueAsBytes(body.getObj()), keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义 EncryptResponse 类实现 ResponseBodyAdvice<respbean> 接口，泛型表示接口的返回类型，这里一共要实现两个方法：</respbean></p><ol><li>supports：这个方法用来判断什么样的接口需要加密，参数 returnType 表示返回类型，我们这里的判断逻辑就是方法是否含有 <code>@Encrypt</code> 注解，如果有，表示该接口需要加密处理，如果没有，表示该接口不需要加密处理。</li><li>beforeBodyWrite：这个方法会在数据响应之前执行，也就是我们先对响应数据进行二次处理，处理完成后，才会转成 json 返回。我们这里的处理方式很简单，RespBean 中的 status 是状态码就不用加密了，另外两个字段重新加密后重新设置值即可。</li><li>另外需要注意，自定义的 ResponseBodyAdvice 需要用 <code>@ControllerAdvice</code> 注解来标记。</li></ol><p>再来看接口解密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecryptRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestBodyAdviceAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> methodParameter.hasMethodAnnotation(Decrypt.class) || methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpInputMessage <span class="hljs-title">beforeBodyRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] decrypt = AESUtils.decrypt(body, encryptProperties.getKey().getBytes());</span><br><span class="line">            <span class="hljs-keyword">final</span> ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(decrypt);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpInputMessage() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getBody</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title">getHeaders</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先大家注意，DecryptRequest 类我们没有直接实现 <code>RequestBodyAdvice</code> 接口，而是继承自 RequestBodyAdviceAdapter 类，该类是 RequestBodyAdvice 接口的子类，并且实现了接口中的一些方法，这样当我们继承自 RequestBodyAdviceAdapter 时，就只需要根据自己实际需求实现某几个方法即可。</li><li>supports：该方法用来判断哪些接口需要处理接口解密，我们这里的判断逻辑是方法上或者参数上含有 <code>@Decrypt</code> 注解的接口，处理解密问题。</li><li>beforeBodyRead：这个方法会在参数转换成具体的对象之前执行，我们先从流中加载到数据，然后对数据进行解密，解密完成后再重新构造 HttpInputMessage 对象返回。</li></ol><p>接下来，我们再来定义一个自动化配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"org.javaboy.encrypt.starter"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也没啥好说的，比较简单。</p><p>最后，resources 目录下定义 META-INF，然后再定义 spring.factories 文件，内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.javaboy.encrypt.starter.autoconfig.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样当项目启动时，就会自动加载该配置类。</p><p>至此，我们的 starter 就开发完成啦。</p><h2 id="2-打包发布"><a href="#2-打包发布" class="headerlink" title="2.打包发布"></a>2.打包发布</h2><p>我们可以将项目安装到本地仓库，也可以发布到线上供他人使用。</p><h3 id="2-1-安装到本地仓库"><a href="#2-1-安装到本地仓库" class="headerlink" title="2.1 安装到本地仓库"></a>2.1 安装到本地仓库</h3><p>安装到本地仓库比较简单，直接 <code>mvn install</code>，或者在 IDEA 中，点击右边的 Maven，然后双击 install，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309110308.png" alt></p><h3 id="2-2-发布到线上"><a href="#2-2-发布到线上" class="headerlink" title="2.2 发布到线上"></a>2.2 发布到线上</h3><p>发不到线上我们可以使用 JitPack 来做。</p><p>首先我们在 GitHub 上创建一个仓库，将我们的代码上传上去，这个过程应该不用我多说吧。</p><p>上传成功后，点击右边的 <code>Create a new release</code> 按钮，发布一个正式版，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111015.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/20210309115344.png" alt></p><p>发布成功后，打开 jitpack，输入仓库的完整路径，点击 lookup 按钮，查找到之后，再点击 <code>Get it</code> 按钮完成构建，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309115450.png" alt></p><p>构建成功后，JitPack 上会给出项目引用方式：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111839.png" alt></p><p>注意引用时将 tag 改成你具体的版本号。</p><p>至此，我们的工具就已经成功发布了！小伙伴们可以通过如下方式引用这个 starter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.lenve<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>encrypt-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>我们创建一个普通的 Spring Boot 项目，引入 web 依赖，再引入我们刚刚的 starter 依赖，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.lenve&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;jitpack.io&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="hljs-comment">//jitpack.io&lt;/url&gt;</span></span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>然后再创建一个实体类备用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-meta">@Encrypt</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setId((<span class="hljs-keyword">long</span>) <span class="hljs-number">99</span>);</span><br><span class="line">        user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addUser</span><span class="hljs-params">(@RequestBody @Decrypt User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个接口使用了 <code>@Encrypt</code> 注解，所以会对该接口的数据进行加密（如果不使用该注解就不加密），第二个接口使用了 <code>@Decrypt</code> 所以会对上传的参数进行解密，注意 <code>@Decrypt</code> 注解既可以放在方法上也可以放在参数上。</p><p>接下来启动项目进行测试。</p><p>首先测试 get 请求接口：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120433.png" alt></p><p>可以看到，返回的数据已经加密。</p><p>再来测试 post 请求：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120520.png" alt></p><p>可以看到，参数中的加密数据已经被还原了。</p><p>如果用户想要修改加密密钥，可以在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.encrypt.key=1234567890123456</span><br></pre></td></tr></table></figure><p>加密数据到了前端，前端也有一些 js 工具来处理加密数据，这个松哥后面有空再和大家说说 js 的加解密。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天这篇文章主要是想和大家聊聊 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，一些加密思路，当然 ResponseBodyAdvice 和 RequestBodyAdvice 还有很多其他的使用场景，小伙伴们可以自行探索～本文使用了对称加密中的 AES 算法，大家也可以尝试改成非对称加密。</p><p>好啦，今天就聊这么多，小伙伴们可以去试试啦～公号后台回复 20210309 可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring5 里边的新玩法！这种 URL 请求让我涨见识了！</title>
    <link href="http://www.javaboy.org/2021/0307/springmvc-pathpattern.html"/>
    <id>http://www.javaboy.org/2021/0307/springmvc-pathpattern.html</id>
    <published>2021-03-07T14:41:20.000Z</published>
    <updated>2021-03-07T15:16:07.570Z</updated>
    
    <content type="html"><![CDATA[<p>Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">initLookupPath</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);</span><br><span class="line">RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">String lookupPath = requestPath.pathWithinApplication().value();</span><br><span class="line"><span class="hljs-keyword">return</span> UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getUrlPathHelper().resolveAndCacheLookupPath(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是 Spring5 里边出来的，以前是没有这个方法的。在旧的 SpringMVC 中，当我们需要获取当前请求地址的时候，直接通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = <span class="hljs-keyword">this</span>.getUrlPathHelper().getLookupPathForRequest(request);</span><br></pre></td></tr></table></figure><p>但是现在变了，现在获取当前请求 URL 地址时，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = initLookupPath(request);</span><br></pre></td></tr></table></figure><p>两种方式相比，主要是 initLookupPath 方法中多了 usesPathPatterns 选项，这是 Spring5 中的新玩意，所以今天松哥就通过一篇简单的文章来和大家分享一下 usesPathPatterns 到底是什么，该怎么玩！</p><p>这可不是一个小变化哦！特别是如果你在项目中使用了 WebFlux，那么这个东西就显得尤为重要了！</p><h2 id="AntPathMatcher"><a href="#AntPathMatcher" class="headerlink" title="AntPathMatcher"></a>AntPathMatcher</h2><p>当我们使用 @RequestMapping 注解去标记请求接口的时候（或者使用它的类似方法如 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping），我们可以使用一些通配符去匹配 URL 地址，举个简单例子，假设我有下面五个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/**/hello"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/**/hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/h?llo"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/h?llo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/**/*.html"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/**/*.html"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello4</span><span class="hljs-params">(@PathVariable String p1, @PathVariable String p2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"p1 = "</span> + p1);</span><br><span class="line">    System.out.println(<span class="hljs-string">"p2 = "</span> + p2);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@PathVariable String name, @PathVariable String version, @PathVariable String ext)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    System.out.println(<span class="hljs-string">"version = "</span> + version);</span><br><span class="line">    System.out.println(<span class="hljs-string">"ext = "</span> + ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释接口的含义之前，先来说说这几个通配符的含义：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">匹配0个或者多个目录</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配0个或者多个字符</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>了解了通配符的含义，我们再来说说各个接口都能接收哪些请求：</p><ul><li>第一个接口，可以接收诸如 <code>/hello/123/123/hello</code>、<code>/hello/a/hello</code> 以及 <code>/hello/hello</code> 这样的请求，因为中间的 <code>**</code> 代表 0 个或者多个目录。</li><li>第二个接口，可以接收诸如 <code>/hallo</code>、<code>/hello</code>、<code>/hMllo</code> 之类的请求，注意它不能接收 <code>/haallo</code> 或者 <code>/hllo</code>，因为 <code>?</code> 表示一个字符。</li><li>第三个接口可以接收任意以 <code>.html</code> 为后缀的请求，例如 <code>/aaa/bb/cc.html</code>、<code>/aa.html</code> 或者 <code>/aa/aa.html</code>。</li><li>第四个接口估计大家都比较熟悉，在 RESTful 风格的接口设计中估计大家都用过，它接收的请求格式类似于 <code>/hello/aa/bb</code>，其中参数 p1 就对应 aa，参数 p2 对应 bb。</li><li>第五个接口则用到了正则，name、version 以及 ext 三个参数格式用正则表达出来，它可以接收诸如 <code>/spring-web-3.0.5.jar</code> 格式的请求，最终的参数 name 就是 <code>spring-web</code>，version 就是 <code>3.0.5</code>，ext 则是 <code>.jar</code>。</li></ul><p>这是 SpringMVC 中之前就存在的功能，不管你用没用过，反正它一致存在。</p><p>那么是谁支撑了这个功能呢？那就是 AntPathMatcher。</p><p>AntPathMatcher 是一个实现了 Ant 风格的路径匹配器，Ant 风格的路径规则实际上就是我们前面给大家介绍的那三种路径匹配符，很 Easy。这种路径匹配规则源自 Apache Ant 项目（<a href="https://ant.apache.org），Apache" target="_blank" rel="noopener">https://ant.apache.org），Apache</a> Ant 我们现在其实已经很少会用到了，它的替代品就是大家所熟知的 Maven，如果你有幸维护一些 2010 年之前的老项目的话，有可能会接触到 Ant。</p><p>AntPathMatcher 实际上在 SpringMVC 中有非常广泛的应用，不仅仅是在 @RequestMapping 中定义接口用到，在其他一些涉及到地址匹配的地方也会用到，例如我们在 SpringMVC 的配置文件中配置静态资源过滤时，也是 Ant 风格路径匹配：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/**"</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>另外像拦截器里的拦截路径注册、跨域处理时的路径匹配等等，都会用到 Ant 风格的路径匹配符。</p><p>整体上来说，AntPathMatcher 是 Spring 中一种比较原始的路径匹配解决方案，虽然比较简单，但是它的效率很低，并且在处理 URL 编码的时候也很不方便。</p><p>因此，才有了 Spring5 中的 PathPattern。</p><h2 id="PathPattern"><a href="#PathPattern" class="headerlink" title="PathPattern"></a>PathPattern</h2><p>PathPattern 专为 Web 应用设计，它与之前的 AntPathMatcher 功能大部分比较类似，当然也有一些细微差异，这个松哥后面会说。</p><p>如果是 Servlet 应用，目前官方推荐的 URL 匹配解决方案就是 PathPattern（当然你也可以选择较早的 AntPathMatcher），虽然官方推荐的是 PathPattern，但实际上默认使用的依然是 AntPathMatcher；如果你用的是 WebFlux，PathPattern 就是唯一解决方案了。</p><blockquote><p>注意，PathPattern 是一个非常新鲜的玩艺，目前 Spring 最新版是 5.3.4，在 Spring5.3 之前，我们在 Servlet 应用中，也只能选择 AntPathMatcher，从 Spring5.3 之后，我们才可以使用 PathPattern 了。</p></blockquote><p>PathPattern 会将 URL 规则预解析为 PathContainer，它对 URL 地址匹配的处理更加快速，PathPattern 与 AntPathMatcher 的差异主要体现在两个方面：</p><p>第一，PathPattern 只支持结尾部分使用 <code>**</code>，如果在路径的中间使用 <code>**</code> 就会报错，上文中第一个和第三个接口，在 PathPattern 模式下会报错，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210306174530.png" alt></p><p>因为在中间或者开始使用 <code>**</code> 极易造成混乱，因此 PathPattern 只支持在结尾使用 <code>**</code>。</p><p>第二，PathPattern 支持使用诸如 <code>{*path}</code> 的方式进行路径匹配，这种写法也可以匹配到多层路径，并且将匹配到的值赋值给 path 变量，例如如下一个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/javaboy/&#123;*path&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello6</span><span class="hljs-params">(@PathVariable String path)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"path = "</span> + path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa</code>，那么参数 path 的值就是 <code>/aa</code>；</p><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa/bb/cc/dd</code>，那么参数 path 的值就是 <code>/aa/bb/cc/dd</code>；</p><p>这个写法也比较新颖，因为之前的 AntPathMatcher 里边没有这个。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>默认情况下，SpringMVC 中使用的还是 AntPathMatcher，那么如何开启 PathPattern 呢？很简单，在 SpringBoot 项目中只需要添加如下配置即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setPatternParser(<span class="hljs-keyword">new</span> PathPatternParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了这个配置后，在我们文章一开始贴出来的代码里，就会进入到 if 分支中，进而使用 PathPattern 去解析请求 URL。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好啦，今天就和小伙伴们聊这么多，大家可以体验一把这个东东，不过注意选择 Spring 的版本哦，一定选择 5.3 之上的版本～大家周末愉快哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>来啦来啦，松哥的免费视频教程来啦！</title>
    <link href="http://www.javaboy.org/2021/0304/mybatis-video.html"/>
    <id>http://www.javaboy.org/2021/0304/mybatis-video.html</id>
    <published>2021-03-04T14:41:04.000Z</published>
    <updated>2021-03-07T15:08:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。</p><a id="more"></a><p>不说了，看干货吧，松哥最近加班加点录的，自认为讲的还比较详细，除了 MyBatis 最基本的用法，还带手把手教大家开发 MyBatis 插件，除了教大家用开源的 MyBatis 逆向工程，还手把手教大家自己开发 MyBatis 逆向工程，不废话了，赶紧来看看目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">├── 01.MyBatis 视频介绍.mp4</span><br><span class="line">├── 02.MyBatis 简单介绍.mp4</span><br><span class="line">├── 03.HelloWorld.mp4</span><br><span class="line">├── 04.SqlSessionFactory单例模式.mp4</span><br><span class="line">├── 05.通过 Log4j 查看 MyBatis 运行日志.mp4</span><br><span class="line">├── 06.MyBatis 增删改查.mp4</span><br><span class="line">├── 07.MyBatis 引入 Mapper.mp4</span><br><span class="line">├── 08.# 和 $ 的区别.mp4</span><br><span class="line">├── 09.Mapper 中多个参数如何处理.mp4</span><br><span class="line">├── 10.@Param 注解源码解析.mp4</span><br><span class="line">├── 11.Mapper 中使用实体类做参数.mp4</span><br><span class="line">├── 12.Mapper 中使用 Map 做参数.mp4</span><br><span class="line">├── 13.MyBatis 两种主键回填方式.mp4</span><br><span class="line">├── 14.resultType 玩法.mp4</span><br><span class="line">├── 15.resultMap 使用详解.mp4</span><br><span class="line">├── 16.【动态 SQL】之 if.mp4</span><br><span class="line">├── 17.【动态 SQL】之 choose.mp4</span><br><span class="line">├── 18.【动态 SQL】之 where.mp4</span><br><span class="line">├── 19.【动态 SQL】之 set.mp4</span><br><span class="line">├── 20.【动态 SQL】之 trim.mp4</span><br><span class="line">├── 21.【动态 SQL】之 foreach.mp4</span><br><span class="line">├── 22.【动态 SQL】之 bind.mp4</span><br><span class="line">├── 23.MyBatis 多数据库支持.mp4</span><br><span class="line">├── 24.查询结果一对一映射【1】.mp4</span><br><span class="line">├── 25.查询结果一对一映射【2】.mp4</span><br><span class="line">├── 26.查询结果一对一映射【3】.mp4</span><br><span class="line">├── 27.查询结果一对一映射【懒加载】.mp4</span><br><span class="line">├── 28.查询结果一对多映射.mp4</span><br><span class="line">├── 29.查询结果一对多映射【懒加载】.mp4</span><br><span class="line">├── 30.鉴别映射器.mp4</span><br><span class="line">├── 31.自定义类型转换器.mp4</span><br><span class="line">├── 32.MyBatis 一级缓存.mp4</span><br><span class="line">├── 33.MyBatis 二级缓存.mp4</span><br><span class="line">├── 34.MyBatis 使用 Redis 做缓存.mp4</span><br><span class="line">├── 35.MyBatis 内存分页.mp4</span><br><span class="line">├── 36.自定义 MyBatis 插件【1】.mp4</span><br><span class="line">├── 37.自定义 MyBatis 插件【2】.mp4</span><br><span class="line">├── 38.自定义 MyBatis 分页插件.mp4</span><br><span class="line">├── 39.MyBatis 逆向工程使用.mp4</span><br><span class="line">└── 40.SSM 整合.mp4</span><br><span class="line">├── 41.【自定义逆向工具】项目介绍.mp4</span><br><span class="line">├── 42.【自定义逆向工具】数据库连接.mp4</span><br><span class="line">├── 43.【自定义逆向工具】加载数据表信息.mp4</span><br><span class="line">├── 44.【自定义逆向工具】生成 Model.mp4</span><br><span class="line">├── 45.【自定义逆向工具】生成其他类.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次也会一并分享给大家，小伙伴们在公众号【江南一点雨】后台回复 <strong>mybatis</strong>，获取视频播放链接以及笔记、案例的下载链接。</p><p>Spring 和 SpringMVC 的免费视频松哥之前也已经发过了，大家可以在公众号【江南一点雨】后台回复 <strong>ssm</strong> 获取整个系列的学习资料～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 中的参数还能这么传递？涨姿势了！</title>
    <link href="http://www.javaboy.org/2021/0302/springmvc-flashmap.html"/>
    <id>http://www.javaboy.org/2021/0302/springmvc-flashmap.html</id>
    <published>2021-03-02T14:40:10.000Z</published>
    <updated>2021-03-07T15:08:16.098Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！</p><a id="more"></a><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>说到 Web 请求参数传递，大家能想到哪些参数传递方式？</p><p>参数可以放在地址栏中，不过地址栏参数的长度有限制，并且在有的场景下我们可能不希望参数暴漏在地址栏中。参数可以放在请求体中，这个没啥好说的。</p><p>小伙伴们试想这样一个场景：</p><p>在一个电商项目中，有一个提交订单的请求，这个请求是一个 POST 请求，请求参数都在请求体中。当用户提交成功后，为了防止用户刷新浏览器页面造成订单请求重复提交，我们一般会将用户重定向到一个显示订单的页面，这样即使用户刷新页面，也不会造成订单请求重复提交。</p><p>大概的代码就像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(OrderInfo orderInfo)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//其他处理逻辑</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码我相信大家都懂吧！如果不懂可以看看松哥录制的免费的 SpringMVC 入门教程（<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</p><p>但是这里有一个问题：如果我想传递参数怎么办？</p><p>如果是服务器端跳转，我们可以将参数放在 request 对象中，跳转完成后还能拿到参数，但是如果是客户端跳转我们就只能将参数放在地址栏中了，像上面这个方法的返回值我们可以写成：<code>return &quot;redirect:/orderlist?xxx=xxx&quot;;</code>，这种传参方式有两个缺陷：</p><ul><li>地址栏的长度是有限的，也就意味着能够放在地址栏中的参数是有限的。</li><li>不想将一些特殊的参数放在地址栏中。</li></ul><p>那该怎么办？还有办法传递参数吗？</p><p>有！这就是今天松哥要和大家介绍的 flashMap，专门用来解决重定向时参数的传递问题。</p><h2 id="2-flashMap"><a href="#2-flashMap" class="headerlink" title="2.flashMap"></a>2.flashMap</h2><p>在重定向时，如果需要传递参数，但是又不想放在地址栏中，我们就可以通过 flashMap 来传递参数，松哥先来一个简单的例子大家看看效果：</p><p>首先我们定义一个简单的页面，里边就一个 post 请求提交按钮，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/order"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在服务端接收该请求，并完成重定向：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        FlashMap flashMap = (FlashMap) req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE);</span><br><span class="line">        flashMap.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在 order 接口中，获取到 flashMap 属性，然后存入需要传递的参数，这些参数最终会被 SpringMVC 自动放入重定向接口的 Model 中，这样我们在 orderlist 接口中，就可以获取到该属性了。</p><p>当然，这是一个比较粗糙的写法，我们还可以通过 RedirectAttributes 来简化这一步骤：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(RedirectAttributes attr)</span> </span>&#123;</span><br><span class="line">        attr.addFlashAttribute(<span class="hljs-string">"site"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        attr.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"微信公众号：江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"site"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedirectAttributes 中有两种添加参数的方式：</p><ul><li>addFlashAttribute：将参数放到 flashMap 中。</li><li>addAttribute：将参数放到 URL 地址中。</li></ul><p>经过前面的讲解，现在小伙伴们应该大致明白了 flashMap 的作用了，就是在你进行重定向的时候，不通过地址栏传递参数。</p><p>很多小伙伴可能会有疑问，重定向其实就是浏览器发起了一个新的请求，这新的请求怎么就获取到上一个请求保存的参数呢？这我们就要来看看 SpringMVC 的源码了。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>首先这里涉及到一个关键类叫做 FlashMapManager，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlashMapManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法含义一眼就能看出来：</p><ul><li>retrieveAndUpdate：这个方法用来恢复参数，并将恢复过的的参数和超时的参数从保存介质中删除。</li><li>saveOutputFlashMap：将参数保存保存起来。</li></ul><p>FlashMapManager 的实现类如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210301173455.png" alt></p><p>从这个继承类中，我们基本上就能确定默认的保存介质时 session。具体的保存逻辑则是在 AbstractFlashMapManager 类中。</p><p>整个参数传递的过程可以分为三大步：</p><p>第一步，首先我们将参数设置到 outputFlashMap 中，有两种设置方式：我们前面的代码 <code>req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)</code> 就是直接获取 outputFlashMap 对象然后把参数放进去；第二种方式就是通过在接口中添加 RedirectAttributes 参数，然后把需要传递的参数放入 RedirectAttributes 中，这样当处理器处理完毕后，会自动将其设置到 outputFlashMap 中，具体逻辑在 RequestMappingHandlerAdapter#getModelAndView 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">getModelAndView</span><span class="hljs-params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果 model 是 RedirectAttributes 的实例的话，则通过 getOutputFlashMap 方法获取到 outputFlashMap 属性，然后相关的属性设置进去。</p><p>这是第一步，就是将需要传递的参数，先保存到 flashMap 中。</p><p>第二步，重定向对应的视图是 RedirectView，在它的 renderMergedOutputModel 方法中，会调用 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存到 session 中，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String targetUrl = createTargetUrl(model, request);</span><br><span class="line">targetUrl = updateTargetUrl(targetUrl, model, request, response);</span><br><span class="line"><span class="hljs-comment">// Save flash attributes</span></span><br><span class="line">RequestContextUtils.saveOutputFlashMap(targetUrl, request, response);</span><br><span class="line"><span class="hljs-comment">// Redirect</span></span><br><span class="line">sendRedirect(request, response, targetUrl, <span class="hljs-keyword">this</span>.http10Compatible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestContextUtils.saveOutputFlashMap 方法最终就会调用到 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存下来。我们来大概看一下保存逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(flashMap)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String path = decodeAndNormalizePath(flashMap.getTargetRequestPath(), request);</span><br><span class="line">flashMap.setTargetRequestPath(path);</span><br><span class="line">flashMap.startExpirationPeriod(getFlashMapTimeout());</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;());</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>));</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑也很简单，保存之前会给 flashMap 设置两个属性，一个是重定向的 url 地址，另一个则是过期时间，过期时间默认 180 秒，这两个属性在第三步加载 flashMap 的时候会用到。然后将 flashMap 放入集合中，并调用 updateFlashMaps 方法存入 session 中。</p><p>第三步，当重定向请求到达 DispatcherServlet#doService 方法后，此时会调用 FlashMapManager#retrieveAndUpdate 方法从 Session 中获取 outputFlashMap 并设置到 Request 属性中备用（最终会被转化到 Model 中的属性），相关代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里获取出来的 outputFlashMap 换了一个名字，变成了 inputFlashMap，其实是同一个东西。</p><p>我们可以大概看一下获取的逻辑 AbstractFlashMapManager#retrieveAndUpdate：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(allFlashMaps)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;FlashMap&gt; mapsToRemove = getExpiredFlashMaps(allFlashMaps);</span><br><span class="line">FlashMap match = getMatchingFlashMap(allFlashMaps, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (match != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mapsToRemove.add(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mapsToRemove.isEmpty()) &#123;</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (allFlashMaps != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用 retrieveFlashMaps 方法从 session 中获取到所有的 FlashMap。</li><li>调用 getExpiredFlashMaps 方法获取所有过期的 FlashMap，FlashMap 默认的过期时间是 180s。</li><li>获取和当前请求匹配的 getMatchingFlashMap，具体的匹配逻辑就两点：重定向地址要和当前请求地址相同；预设参数要相同。一般来说我们不需要配置预设参数，所以这一条可以忽略。如果想要设置，则首先给 flashMap 设置，像这样：<code>flashMap.addTargetRequestParam(&quot;aa&quot;, &quot;bb&quot;);</code>，然后在重定向的地址栏也加上这个参数：<code>return &quot;redirect:/orderlist?aa=bb&quot;;</code> 即可。</li><li>将获取到的匹配的 FlashMap 对象放入 mapsToRemove 集合中（这个匹配到的 FlashMap 即将失效，放入集合中一会被清空）。</li><li>将 allFlashMaps 集合中的所有 mapsToRemove 数据清空，同时调用 updateFlashMaps 方法更新 session 中的 FlashMap。</li><li>最终将匹配到的 flashMap 返回。</li></ul><p>这就是整个获取 flashMap 的方法，整体来看还是非常 easy 的，并没有什么难点。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们分享了一下 SpringMVC 中的 flashMap，不知道大家有没有在工作中用到这个东西？如果刚好碰到松哥前面所说的需求，用 FlashMap 真的还是蛮方便的。如果需要下载本文案例，小伙伴们可以在公众号后台回复 <code>20210302</code>，好啦，今天就和大家聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你开发 MyBatis 插件</title>
    <link href="http://www.javaboy.org/2021/0226/mybatis-plugin.html"/>
    <id>http://www.javaboy.org/2021/0226/mybatis-plugin.html</id>
    <published>2021-02-26T14:39:55.000Z</published>
    <updated>2021-03-07T15:08:01.401Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们元宵节快乐，记得吃元宵哦～</p><a id="more"></a><p>在日常开发中，小伙伴们多多少少都有用过 MyBatis 插件，松哥猜测大家用的最多的就是 MyBatis 的分页插件！不知道小伙伴们有没有想过有一天自己也来开发一个 MyBatis 插件？</p><p>其实自己动手撸一个 MyBatis 插件并不难，今天松哥就把手带大家撸一个 MyBatis 插件！</p><h2 id="1-MyBatis-插件接口"><a href="#1-MyBatis-插件接口" class="headerlink" title="1.MyBatis 插件接口"></a>1.MyBatis 插件接口</h2><p>即使你没开发过 MyBatis 插件，估计也能猜出来，MyBatis 插件是通过拦截器来起作用的，MyBatis 框架在设计的时候，就已经为插件的开发预留了相关接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就三个方法，第一个方法必须实现，后面两个方法都是可选的。三个方法作用分别如下：</p><ol><li><p>intercept：这个就是具体的拦截方法，我们自定义 MyBatis 插件时，一般都需要重写该方法，我们插件所完成的工作也都是在该方法中完成的。</p></li><li><p>plugin：这个方法的参数 target 就是拦截器要拦截的对象，一般来说我们不需要重写该方法。Plugin.wrap 方法会自动判断拦截器的签名和被拦截对象的接口是否匹配，如果匹配，才会通过动态代理拦截目标对象。</p></li><li><p>setProperties：这个方法用来传递插件的参数，可以通过参数来改变插件的行为。我们定义好插件之后，需要对插件进行配置，在配置的时候，可以给插件设置相关属性，设置的属性可以通过该方法获取到。插件属性设置像下面这样：</p></li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.CamelInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-MyBatis-拦截器签名"><a href="#2-MyBatis-拦截器签名" class="headerlink" title="2.MyBatis 拦截器签名"></a>2.MyBatis 拦截器签名</h2><p>拦截器定义好了后，拦截谁？</p><p>这个就需要拦截器签名来完成了！</p><p>拦截器签名是一个名为 @Intercepts 的注解，该注解中可以通过 @Signature 配置多个签名。@Signature 注解中则包含三个属性：</p><ul><li>type: 拦截器需要拦截的接口，有 4 个可选项，分别是：Executor、ParameterHandler、ResultSetHandler 以及 StatementHandler。</li><li>method: 拦截器所拦截接口中的方法名，也就是前面四个接口中的方法名，接口和方法要对应上。</li><li>args: 拦截器所拦截方法的参数类型，通过方法名和参数类型可以锁定唯一一个方法。</li></ul><p>一个简单的签名可能像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = ResultSetHandler.class,</span><br><span class="line">        method = <span class="hljs-string">"handleResultSets"</span>,</span><br><span class="line">        args = &#123;Statement.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CamelInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-被拦截的对象"><a href="#3-被拦截的对象" class="headerlink" title="3.被拦截的对象"></a>3.被拦截的对象</h2><p>根据前面的介绍，被拦截的对象主要有如下四个：</p><p><strong>Executor</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">List&lt;BatchResult&gt; <span class="hljs-title">flushStatements</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">CacheKey <span class="hljs-title">createCacheKey</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCached</span><span class="hljs-params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearLocalCache</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deferLoad</span><span class="hljs-params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Transaction <span class="hljs-title">getTransaction</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isClosed</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setExecutorWrapper</span><span class="hljs-params">(Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>update：该方法会在所有的 INSERT、 UPDATE、 DELETE 执行时被调用，如果想要拦截这些操作，可以通过该方法实现。</li><li>query：该方法会在 SELECT 查询方法执行时被调用，方法参数携带了很多有用的信息，如果需要获取，可以通过该方法实现。</li><li>queryCursor：当 SELECT 的返回类型是 Cursor 时，该方法会被调用。</li><li>flushStatements：当 SqlSession 方法调用 flushStatements 方法或执行的接口方法中带有 @Flush 注解时该方法会被触发。</li><li>commit：当 SqlSession 方法调用 commit 方法时该方法会被触发。</li><li>rollback：当 SqlSession 方法调用 rollback 方法时该方法会被触发。</li><li>getTransaction：当 SqlSession 方法获取数据库连接时该方法会被触发。</li><li>close：该方法在懒加载获取新的 Executor 后会被触发。</li><li>isClosed：该方法在懒加载执行查询前会被触发。</li></ul><p><strong>ParameterHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">getParameterObject</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParameters</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>getParameterObject：在执行存储过程处理出参的时候该方法会被触发。</li><li>setParameters：设置 SQL 参数时该方法会被触发。</li></ul><p><strong>ResultSetHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">handleCursorResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleOutputParameters</span><span class="hljs-params">(CallableStatement cs)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>handleResultSets：该方法会在所有的查询方法中被触发（除去返回值类型为 Cursor<e> 的查询方法），一般来说，如果我们想对查询结果进行二次处理，可以通过拦截该方法实现。</e></li><li>handleCursorResultSets：当查询方法的返回值类型为 Cursor<e> 时，该方法会被触发。</e></li><li>handleOutputParameters：使用存储过程处理出参的时候该方法会被调用。</li></ul><p><strong>StatementHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parameterize</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">batch</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">BoundSql <span class="hljs-title">getBoundSql</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">ParameterHandler <span class="hljs-title">getParameterHandler</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>prepare：该方法在数据库执行前被触发。</li><li>parameterize：该方法在 prepare 方法之后执行，用来处理参数信息。</li><li>batch：如果 MyBatis 的全剧配置中配置了 <code>defaultExecutorType=”BATCH”</code>，执行数据操作时该方法会被调用。</li><li>update：更新操作时该方法会被触发。</li><li>query：该方法在 SELECT 方法执行时会被触发。</li><li>queryCursor：该方法在 SELECT 方法执行时，并且返回值为 Cursor 时会被触发。</li></ul><p>在开发一个具体的插件时，我们应当根据自己的需求来决定到底拦截哪个方法。</p><h2 id="4-开发分页插件"><a href="#4-开发分页插件" class="headerlink" title="4.开发分页插件"></a>4.开发分页插件</h2><h3 id="4-1-内存分页"><a href="#4-1-内存分页" class="headerlink" title="4.1 内存分页"></a>4.1 内存分页</h3><p>MyBatis 中提供了一个不太好用的内存分页功能，就是一次性把所有数据都查询出来，然后在内存中进行分页处理，这种分页方式效率很低，基本上没啥用，但是如果我们想要自定义分页插件，就需要对这种分页方式有一个简单了解。</p><p>内存分页的使用方式如下，首先在 Mapper 中添加 RowBounds 参数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中定义相关 SQL：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 SQL 定义时，压根不用管分页的事情，MyBatis 会查询到所有的数据，然后在内存中进行分页处理。</p><p>Mapper 中方法的调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    RowBounds rowBounds = <span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(rowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建 RowBounds 时传入两个参数，分别是 offset 和 limit，对应分页 SQL 中的两个参数。也可以通过 RowBounds.DEFAULT 的方式构建一个 RowBounds 实例，这种方式构建出来的 RowBounds 实例，offset 为 0，limit 则为 Integer.MAX_VALUE，也就相当于不分页。</p><p>这就是 MyBatis 中提供的一个很不实用的内存分页功能。</p><p>了解了 MyBatis 自带的内存分页之后，接下来我们就可以来看看如何自定义分页插件了。</p><h3 id="4-2-自定义分页插件"><a href="#4-2-自定义分页插件" class="headerlink" title="4.2 自定义分页插件"></a>4.2 自定义分页插件</h3><p>首先要声明一下，这里松哥带大家自定义 MyBatis 分页插件，主要是想通过这个东西让小伙伴们了解自定义 MyBatis 插件的一些条条框框，了解整个自定义插件的流程，分页插件并不是我们的目的，自定义分页插件只是为了让大家的学习过程变得有趣一些而已。</p><p>接下来我们就来开启自定义分页插件之旅。</p><p>首先我们需要自定义一个 RowBounds，因为 MyBatis 原生的 RowBounds 是内存分页，并且没有办法获取到总记录数（一般分页查询的时候我们还需要获取到总记录数），所以我们自定义 PageRowBounds，对原生的 RowBounds 功能进行增强，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageRowBounds</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RowBounds</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们自定义的 PageRowBounds 中增加了 total 字段，用来保存查询的总记录数。</p><p>接下来我们自定义拦截器 PageInterceptor，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="hljs-string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement ms = (MappedStatement) args[<span class="hljs-number">0</span>];</span><br><span class="line">        Object parameterObject = args[<span class="hljs-number">1</span>];</span><br><span class="line">        RowBounds rowBounds = (RowBounds) args[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (rowBounds != RowBounds.DEFAULT) &#123;</span><br><span class="line">            Executor executor = (Executor) invocation.getTarget();</span><br><span class="line">            BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">            Field additionalParametersField = BoundSql.class.getDeclaredField(<span class="hljs-string">"additionalParameters"</span>);</span><br><span class="line">            additionalParametersField.setAccessible(<span class="hljs-keyword">true</span>);</span><br><span class="line">            Map&lt;String, Object&gt; additionalParameters = (Map&lt;String, Object&gt;) additionalParametersField.get(boundSql);</span><br><span class="line">            <span class="hljs-keyword">if</span> (rowBounds <span class="hljs-keyword">instanceof</span> PageRowBounds) &#123;</span><br><span class="line">                MappedStatement countMs = newMappedStatement(ms, Long.class);</span><br><span class="line">                CacheKey countKey = executor.createCacheKey(countMs, parameterObject, RowBounds.DEFAULT, boundSql);</span><br><span class="line">                String countSql = <span class="hljs-string">"select count(*) from ("</span> + boundSql.getSql() + <span class="hljs-string">") temp"</span>;</span><br><span class="line">                BoundSql countBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">                Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">                <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                    countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Object&gt; countQueryResult = executor.query(countMs, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], countKey, countBoundSql);</span><br><span class="line">                Long count = (Long) countQueryResult.get(<span class="hljs-number">0</span>);</span><br><span class="line">                ((PageRowBounds) rowBounds).setTotal(count);</span><br><span class="line">            &#125;</span><br><span class="line">            CacheKey pageKey = executor.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">            pageKey.update(<span class="hljs-string">"RowBounds"</span>);</span><br><span class="line">            String pageSql = boundSql.getSql() + <span class="hljs-string">" limit "</span> + rowBounds.getOffset() + <span class="hljs-string">","</span> + rowBounds.getLimit();</span><br><span class="line">            BoundSql pageBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), pageSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">            Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            List list = executor.query(ms, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], pageKey, pageBoundSql);</span><br><span class="line">            <span class="hljs-keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//不需要分页，直接返回结果</span></span><br><span class="line">        <span class="hljs-keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> MappedStatement <span class="hljs-title">newMappedStatement</span><span class="hljs-params">(MappedStatement ms, Class&lt;Long&gt; longClass)</span> </span>&#123;</span><br><span class="line">        MappedStatement.Builder builder = <span class="hljs-keyword">new</span> MappedStatement.Builder(</span><br><span class="line">                ms.getConfiguration(), ms.getId() + <span class="hljs-string">"_count"</span>, ms.getSqlSource(), ms.getSqlCommandType()</span><br><span class="line">        );</span><br><span class="line">        ResultMap resultMap = <span class="hljs-keyword">new</span> ResultMap.Builder(ms.getConfiguration(), ms.getId(), longClass, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">0</span>)).build();</span><br><span class="line">        builder.resource(ms.getResource())</span><br><span class="line">                .fetchSize(ms.getFetchSize())</span><br><span class="line">                .statementType(ms.getStatementType())</span><br><span class="line">                .timeout(ms.getTimeout())</span><br><span class="line">                .parameterMap(ms.getParameterMap())</span><br><span class="line">                .resultSetType(ms.getResultSetType())</span><br><span class="line">                .cache(ms.getCache())</span><br><span class="line">                .flushCacheRequired(ms.isFlushCacheRequired())</span><br><span class="line">                .useCache(ms.isUseCache())</span><br><span class="line">                .resultMaps(Arrays.asList(resultMap));</span><br><span class="line">        <span class="hljs-keyword">if</span> (ms.getKeyProperties() != <span class="hljs-keyword">null</span> &amp;&amp; ms.getKeyProperties().length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            StringBuilder keyProperties = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String keyProperty : ms.getKeyProperties()) &#123;</span><br><span class="line">                keyProperties.append(keyProperty).append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            keyProperties.delete(keyProperties.length() - <span class="hljs-number">1</span>, keyProperties.length());</span><br><span class="line">            builder.keyProperty(keyProperties.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们今天定义的核心代码，涉及到的知识点松哥来给大家一个一个剖析。</p><ol><li>首先通过 @Intercepts 注解配置拦截器签名，从 @Signature 的定义中我们可以看到，拦截的是 Executor#query 方法，该方法有一个重载方法，通过 args 指定了方法参数，进而锁定了重载方法（实际上该方法的另一个重载方法我们没法拦截，那个是 MyBatis 内部调用的，这里不做讨论）。</li><li>将查询操作拦截下来之后，接下来我们的操作主要在 PageInterceptor#intercept 方法中完成，该方法的参数重包含了拦截对象的诸多信息。</li><li>通过 <code>invocation.getArgs()</code> 获取拦截方法的参数，获取到的是一个数组，正常来说这个数组的长度为 4。数组第一项是一个 MappedStatement，我们在 Mapper.xml 中定义的各种操作节点和 SQL，都被封装成一个个的 MappedStatement 对象了；数组第二项就是所拦截方法的具体参数，也就是你在 Mapper 接口中定义的方法参数；数组的第三项是一个 RowBounds 对象，我们在 Mapper 接口中定义方法时不一定使用了 RowBounds 对象，如果我们没有定义 RowBounds 对象，系统会给我们提供一个默认的 RowBounds.DEFAULT；数组第四项则是一个处理返回值的 ResultHandler。</li><li>接下来判断上一步提取到的 rowBounds 对象是否不为 RowBounds.DEFAULT，如果为 RowBounds.DEFAULT，说明用户不想分页；如果不为 RowBounds.DEFAULT，则说明用户想要分页，如果用户不想分页，则直接执行最后的 <code>return invocation.proceed();</code>，让方法继续往下走就行了。</li><li>如果需要进行分页，则先从 invocation 对象中取出执行器 Executor、BoundSql 以及通过反射拿出来 BoundSql 中保存的额外参数（如果我们使用了动态 SQL，可能会存在该参数）。BoundSql 中封装了我们执行的 Sql 以及相关的参数。</li><li>接下来判断 rowBounds 是否是 PageRowBounds 的实例，如果是，说明除了分页查询，还想要查询总记录数，如果不是，则说明 rowBounds 可能是 RowBounds 实例，此时只要分页即可，不用查询总记录数。</li><li>如果需要查询总记录数，则首先调用 newMappedStatement 方法构造出一个新的 MappedStatement 对象出来，这个新的 MappedStatement 对象的返回值是 Long 类型的。然后分别创建查询的 CacheKey、拼接查询的 countSql，再根据 countSql 构建出 countBoundSql，再将额外参数添加进 countBoundSql 中。最后通过 executor.query 方法完成查询操作，并将查询结果赋值给 PageRowBounds 中的 total 属性。</li><li>接下来进行分页查询，有了第七步的介绍之后，分页查询就很简单了，这里就不细说了，唯一需要强调的是，当我们启动了这个分页插件之后，MyBatis 原生的 RowBounds 内存分页会变成物理分页，原因就在这里我们修改了查询 SQL。</li><li>最后将查询结果返回。</li></ol><p>在前面的代码中，我们一共在两个地方重新组织了 SQL，一个是查询总记录数的时候，另一个则是分页的时候，都是通过 boundSql.getSql() 获取到 Mapper.xml 中的 SQL 然后进行改装，有的小伙伴在 Mapper.xml 中写 SQL 的时候不注意，结尾可能加上了 <code>;</code>，这会导致分页插件重新组装的 SQL 运行出错，这点需要注意。松哥在 GitHub 上看到的其他 MyBatis 分页插件也是一样的，Mapper.xml 中 SQL 结尾不能有 <code>;</code>。</p><p>如此之后，我们的分页插件就算是定义成功了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们对我们的分页插件进行一个简单测试。</p><p>首先我们需要在全局配置中配置分页插件，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.PageInterceptor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们在 Mapper 中定义查询接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义 UserMapper.xml，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后我们进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(<span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在查询时，我们使用了 RowBounds 对象，就只会进行分页，而不会统计总记录数。需要注意的时，此时的分页已经不是内存分页，而是物理分页了，这点我们从打印出来的 SQL 中也能看到，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210224164138.png" alt></p><p>可以看到，查询的时候就已经进行了分页了。</p><p>当然，我们也可以使用 PageRowBounds 进行测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    PageRowBounds pageRowBounds = <span class="hljs-keyword">new</span> PageRowBounds(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(pageRowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="hljs-string">"pageRowBounds.getTotal() = "</span> + pageRowBounds.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时通过 pageRowBounds.getTotal() 方法我们就可以获取到总记录数。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天主要和小伙伴们分享了我们如何自己开发一个 MyBatis 插件，插件功能其实都是次要的，最主要是希望小伙伴们能够理解 MyBatis 的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们元宵节快乐，记得吃元宵哦～&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
      <category term="Plugin" scheme="http://www.javaboy.org/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>硬核！松哥又整了一套免费视频，搞起！</title>
    <link href="http://www.javaboy.org/2021/0223/springmvc-video.html"/>
    <id>http://www.javaboy.org/2021/0223/springmvc-video.html</id>
    <published>2021-02-23T14:39:41.000Z</published>
    <updated>2021-03-07T15:09:02.697Z</updated>
    
    <content type="html"><![CDATA[<p>不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套<strong>免费的</strong> SSM 视频。</p><a id="more"></a><p>松哥从大二开始自学 Java，大学毕业后顺利入坑，自学之路还是蛮艰辛的。所以我深知大家在自学时面临的两个问题：</p><ol><li>学习顺序</li><li>学习资料</li></ol><p>首先是不知道学什么，这个我之前已经总结了 Java 升级路线图（<a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图</a>），大家可以参考。</p><p>第二个就是学习资料的问题，虽然现在网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，<strong>我们缺的是一个从头到尾连贯的、系统的资料</strong>，经常是这个人讲的看了一点，那个人讲的看了一点，想头到尾看一个人讲，发现几乎没有这样的资源。</p><p>如果是一个人来讲，知识是连贯的，什么东西讲过，什么东西没讲过，他心里有数，这样大家的学习的时候就不会觉得突兀，比如突然蹦出来一个你从来没听说过的知识点，一个人讲的话，就不会发生这种事情，学习体验也会好很多，也会更加容易构建自己的知识体系。</p><p>所以松哥很早就想根据自己整理的 Java 学习路线图（公号后台回复 <code>进阶路线</code> 获取 Java 进阶路线图）录一套 Java 视频教程，可是由于拖延症一直进展缓慢。在 2021 年，希望能把这项工作扎实推进，也希望小伙伴们对继续保持关注，录制好的视频我会第一时间在公众号上告诉大家。</p><p>现在这套 SSM 视频，在去年 6 月份已经发布了 Spring 部分，相关链接参见：</p><p><a href="https://mp.weixin.qq.com/s/aj9Bt1TE1pb8ZPVCpDKI8A" target="_blank" rel="noopener">我为什么要出一套免费视频教程</a></p><p>这次休假期间，我主要是录制了 SpringMVC 部分，一共录制了三十多集约 6 个小时的视频教程，教程目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">├── 01.SpringMVC 免费视频录制计划.mp4</span><br><span class="line">├── 02.SpringMVC 简单介绍.mp4</span><br><span class="line">├── 03.SpringMVC 之 HelloWorld.mp4</span><br><span class="line">├── 04.SpringMVC 组件简单介绍.mp4</span><br><span class="line">├── 05.DispatcherServlet 配置细节.mp4</span><br><span class="line">├── 06.Spring+SpringMVC 分开配置.mp4</span><br><span class="line">├── 07.Spring 容器和 SpringMVC 容器.mp4</span><br><span class="line">├── 08.处理器映射器与处理器适配器.mp4</span><br><span class="line">├── 09.处理器映射器与处理器适配器最佳实践.mp4</span><br><span class="line">├── 10.@RequestMapping 注解使用细节.mp4</span><br><span class="line">├── 11.Controller 中接口方法各种返回值类型.mp4</span><br><span class="line">├── 12.【Spring MVC参数绑定】默认参数.mp4</span><br><span class="line">├── 13.【Spring MVC参数绑定】基本类型参数.mp4</span><br><span class="line">├── 14.【Spring MVC参数绑定】对象参数.mp4</span><br><span class="line">├── 15.【Spring MVC参数绑定】自定义参数类型转换器.mp4</span><br><span class="line">├── 16.【Spring MVC参数绑定】数组类型.mp4</span><br><span class="line">├── 17.【Spring MVC参数绑定】List 集合类型.mp4</span><br><span class="line">├── 18.【Spring MVC参数绑定】Map 集合类型.mp4</span><br><span class="line">├── 19.SpringMVC 文件上传【上古方案】.mp4</span><br><span class="line">├── 20.SpringMVC 文件上传【最新方案】.mp4</span><br><span class="line">├── 21.SpringMVC 多文件上传.mp4</span><br><span class="line">├── 22.SpringMVC 全局异常处理.mp4</span><br><span class="line">├── 23.SpringMVC 数据校验.mp4</span><br><span class="line">├── 24.SpringMVC 数据分组校验.mp4</span><br><span class="line">├── 25.手动数据回显.mp4</span><br><span class="line">├── 26.自动数据回显.mp4</span><br><span class="line">├── 27.@ModelAttribute注解用法.mp4</span><br><span class="line">├── 28.SpringMVC+Jackson生成 JSON 数据.mp4</span><br><span class="line">├── 29.SpringMVC+Gson生成 JSON 数据.mp4</span><br><span class="line">├── 30.SpringMVC+FastJson生成 JSON 数据.mp4</span><br><span class="line">├── 31.SpringMVC 接收 JSON 类型参数.mp4</span><br><span class="line">├── 32.SpringMVC 开发 RESTful 接口.mp4</span><br><span class="line">├── 33.SpringMVC 静态资源访问.mp4</span><br><span class="line">└── 34.SpringMVC 中使用拦截器.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次我都一并分享给小伙伴们，大家在公众号后台回复 <code>springmvc</code> 就可以获取视频播放链接、视频笔记以及视频案例。</p><p>下一步就是 MyBatis 了，最近也在抽空录制了，估计很快会和小伙伴们见面，敬请期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套&lt;strong&gt;免费的&lt;/strong&gt; SSM 视频。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>小伙伴们提的这个问题，我今天必须解决了！</title>
    <link href="http://www.javaboy.org/2021/0221/itboyhub.html"/>
    <id>http://www.javaboy.org/2021/0221/itboyhub.html</id>
    <published>2021-02-21T14:39:27.000Z</published>
    <updated>2021-03-07T15:08:58.059Z</updated>
    
    <content type="html"><![CDATA[<p>hello 小伙伴们新年好～给大家拜个晚年～</p><a id="more"></a><p>今年虽然倡导就地过年，松哥还是溜回家过年去了，回家那是真舒服啊，公众号都荒废了两周了～</p><p>不过过年期间也不是一点事没干，过年期间终于抽空把小伙伴们反映很久的一个问题解决了～</p><p><img src="http://img.itboyhub.com/2021/02/20210220-181045.jpg" alt></p><p>每次小伙伴们反映 <code>www.javaboy.org</code> 很慢，我都很焦虑，但是这个网站我暂时没办法解决慢的问题，我说说原因。</p><p><code>javaboy.org</code> 是我从国外服务商那里买的域名，当时选择这个的原因是不用备案，当天买当天网站就能上线，很快。服务器我也没有自己搭建，选择了 GitHub Pages 的服务再结合 Hexo 做的网站，所以这个网站肯定是不会挂的，除非 GitHub Pages 自己挂掉了。</p><p>刚开始的时候网站访问量不大也没发现啥弊端，后来慢慢访问的人多了，小伙伴们就开始反映网站访问慢。</p><p>刚开始收到小伙伴们的反馈的时候，我最直观的想法就是把 <code>javaboy.org</code> 这个域名转回到国内，然后买服务器，备案，走正常的流程，后来一查才发现，国内 <code>.org</code> 域名在国内无法备案，这就意味着我要是把这个域名转回到国内连用都用不了了。所以导致这个网站目前处于一个比较尴尬的位置，当然如果你能顺利访问 Google，那么可以把这个域名也添加到代理名单中，这样访问速度会略微好一点。</p><p>既然 <code>www.javaboy.org</code> 的问题没法根治，那就只能另起炉灶，我又重新在国内的服务商处买了个 <code>itboyhub.com</code> 的域名，又买了服务器，然后重新搭建网站。重新搭建的网站依然采用了 Hexo+Nginx 来做，但是效果并不好，为此我还专门又买了 CDN 加速服务，但是感觉提速效果都不太明显，再后来工作比较忙就懒得折腾了。</p><p>过年期间，我想把这个问题好好梳理一下，彻底解决小伙伴们一直反映的访问慢的问题。首先确认了服务器的配置没问题，因为我有一个相同配置的服务器跑着另外的服务，网速就很好。既然不是服务器的配置问题，那就应该是我采用的技术栈的问题了，网上搜了下，果然看到很多人反映 Hexo 加载慢的问题，用了两年的 Hexo 也有点腻了，换个新玩意试试。于是瞄准了 wordpress，三下五除二用 wordpress 重新搭建了一个站点，速度还不错。</p><p><img src="http://img.itboyhub.com/2021/02/20210220193819.png" alt></p><p>这次没上 CDN 加速服务了，用工具测了一下网速基本上也都是全绿，nice！</p><p>到目前为止，我已经把之前发过的大部分系列教程腾挪上去了，并且进行了分类，小伙伴们都可以很方便的查看：</p><p><img src="http://img.itboyhub.com/2021/02/20210220200037.png" alt></p><p>可以在右边的分类目录中查看不同分类下的文章。</p><p>这个问题解决了总算了却了一桩心事，小伙伴们可以畅快的访问 <a href="http://www.itboyhub.com" target="_blank" rel="noopener">www.itboyhub.com</a> 了，松哥所有的文章/教程都会同步上去，小伙伴也可以点击阅读原文体验一把新网站加载速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 小伙伴们新年好～给大家拜个晚年～&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>这得多老的项目才会有这么奇葩的需求</title>
    <link href="http://www.javaboy.org/2021/0204/springmvc-resolver.html"/>
    <id>http://www.javaboy.org/2021/0204/springmvc-resolver.html</id>
    <published>2021-02-04T14:39:12.000Z</published>
    <updated>2021-03-07T15:09:56.325Z</updated>
    
    <content type="html"><![CDATA[<p>维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。</p><a id="more"></a><p>这不，最近就有小伙伴问了这样一个问题：</p><p><img src="http://img.itboyhub.com/2021/02/20210202172051.png" alt></p><p>这个小伙伴想在 Spring Boot 中同时使用多个视图解析器，一般来说我们正常设计一个项目时，肯定不会搞成这样，要么前后端分离不需要视图解析器，要么前后端不分需要视图解析器，但是即使需要一般也只会使用一种视图解析器，而不会多种视图解析器混在一起使用。</p><p>不过现在既然小伙伴提出了这个问题，我们就来看看这个需求能不能做！先说结论：技术上来说这个当然是可以实现的，而且实现方式不难。</p><p>不过要把这个问题理解透彻，这就涉及到到 SpringMVC 的工作原理了，今天松哥就来和大家把这个问题稍微梳理下。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>在 SpringMVC 中我们可以配置多个视图解析器，这些视图解析器最终会在 DispatcherServlet#initViewResolvers 方法中完成加载，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑很清楚：</p><ul><li>首先将 viewResolvers 变量置空，这个变量将存储所有的视图解析器。</li><li>接下来根据 detectAllViewResolvers 的变量值来决定是否要加载所有的视图解析器，该变量默认为 true，表示加载所有的视图解析器，加载所有的视图解析器就是去 Spring 容器中查找到所有的 ViewResolver 实例，然后给这些 ViewResolver 实例按照 Order 优先级进行排序。如果 detectAllViewResolvers 的变量值为 false，表示只加载名为 viewResolver 的视图解析器。</li><li>经过前面的步骤，如果 viewResolvers 还是为 null，表示用户压根就没有配置视图解析器，此时调用 getDefaultStrategies 方法加载一个默认的视图解析器，以确保我们的系统中至少有一个视图解析器。</li></ul><p>一般来说，在一个 SSM 项目中，如果我们在 SpringMVC 的配置文件中，没有做任何关于视图解析器的配置，那么就会走入第三步。</p><p>initViewResolvers 方法的主要目的就是初始化视图解析器，并对视图解析器进行排序。从这里我们也可以大概看出来 SpringMVC 中是支持多个视图解析器同时存在的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>上面是视图解析器的初始化过程。</p><p>接下来我们来看看视图解析器具体是如何发挥作用的。</p><p>小伙伴们知道，一个请求进入 DispatcherServlet 之后，执行的方法流程依次是 service-&gt;processRequest-&gt;doService-&gt;doDispatch-&gt;processDispatchResult-&gt;render-&gt;resolveViewName-&gt;…</p><p>进入 render 方法就差不多进入正题了，我们的页面渲染将在这个方法中完成。render 方法中包含如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">View view;</span><br><span class="line">String viewName = mv.getViewName();</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We need to resolve the view name.</span></span><br><span class="line">view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line"><span class="hljs-string">"' in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">view = mv.getView();</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"ModelAndView ["</span> + mv + <span class="hljs-string">"] neither contains a view name nor a "</span> +</span><br><span class="line"><span class="hljs-string">"View object in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里获取到视图的名字之后，接下来调用 resolveViewName 方法去获取一个具体的视图。在 resolveViewName 方法中，将根据视图名称以及现有的视图解析器找到对应的视图。</p><p>那么这里就存在一个问题，现有的视图解析器如果有多个，究竟该以哪个为准呢？</p><p>我们来看下 resolveViewName 方法中的执行逻辑。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, @Nullable Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Locale locale, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是遍历所有的 ViewResolver，调用其 resolveViewName 方法去找到对应的 View，找到后就返回了。</p><p>ViewResolver 就是我们常说的视图解析器，我们用 JSP、Thymeleaf、Freemarker 等，都有对应的视图解析器，从下面一张图中就可以看出 ViewResolver 的继承类：</p><p><img src="http://img.itboyhub.com/2021/02/20210202193709.png" alt></p><p>不过在 Spring Boot 中，我们并不会直接使用这些视图解析器，而是使用一个名为 ContentNegotiatingViewResolver 的视图解析器，这个是 Spring3.0 中引入的的视图解析器，它不负责具体的视图解析，而是根据当前请求的 MIME 类型，从上下文中选择一个合适的视图解析器，并将请求工作委托给它。</p><p>所以这里我们就先来看看 ContentNegotiatingViewResolver#resolveViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());</span><br><span class="line"><span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line"><span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bestView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useNotAcceptableStatusCode) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> NOT_ACCEPTABLE_VIEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑也比较简单：</p><ul><li>首先是获取到当前的请求对象，可以直接从 RequestContextHolder 中获取。然后从当前请求对象中提取出 MediaType。</li><li>如果 MediaType 不为 null，则根据 MediaType，找到合适的视图解析器，并将解析出来的 View 返回。</li><li>如果 MediaType 为 null，则为两种情况，如果 useNotAcceptableStatusCode 为 true，则返回 NOT_ACCEPTABLE_VIEW 视图，这个视图其实是一个 406 响应，表示客户端错误，服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应；如果 useNotAcceptableStatusCode 为 false，则返回 null。</li></ul><p>现在问题的核心其实就变成 getCandidateViews 方法和 getBestView 方法了，看名字就知道，前者是获取所有的候选 View，后者则是从这些候选 View 中选择一个最佳的 View，我们一个一个来看。</p><p>先来看 getCandidateViews：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;View&gt; <span class="hljs-title">getCandidateViews</span><span class="hljs-params">(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;View&gt; candidateViews = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (MediaType requestedMediaType : requestedMediaTypes) &#123;</span><br><span class="line">List&lt;String&gt; extensions = <span class="hljs-keyword">this</span>.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</span><br><span class="line"><span class="hljs-keyword">for</span> (String extension : extensions) &#123;</span><br><span class="line">String viewNameWithExtension = viewName + <span class="hljs-string">'.'</span> + extension;</span><br><span class="line">view = viewResolver.resolveViewName(viewNameWithExtension, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.defaultViews)) &#123;</span><br><span class="line">candidateViews.addAll(<span class="hljs-keyword">this</span>.defaultViews);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有的候选 View 分为两个步骤：</p><ol><li>调用各个 ViewResolver 中的 resolveViewName 方法去加载出对应的 View 对象。</li><li>根据 MediaType 提取出扩展名，再根据扩展名去加载 View 对象，在实际应用中，这一步我们都很少去配置，所以一步基本上是加载不出来 View 对象的，主要靠第一步。</li></ol><p>第一步去加载 View 对象，其实就是根据你的 viewName，再结合 ViewResolver 中配置的 prefix、suffix、templateLocation 等属性，找到对应的 View，方法执行流程依次是 resolveViewName-&gt;createView-&gt;loadView。</p><p>具体执行的方法我就不一一贴出来了，<strong>唯一需要说的一个重点就是最后的 loadView 方法</strong>，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = buildView(viewName);</span><br><span class="line">View result = applyLifecycleMethods(viewName, view);</span><br><span class="line"><span class="hljs-keyword">return</span> (view.checkResource(locale) ? result : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，View 加载出来后，会调用其 checkResource 方法判断 View 是否存在，如果存在就返回 View，不存在就返回 null。</p><p>这是一个非常关键的步骤，但是我们常用的视图对此的处理却不尽相同：</p><ul><li>FreeMarkerView：会老老实实检查。</li><li>ThymeleafView：没有检查这个环节（Thymeleaf 的整个 View 体系不同于 FreeMarkerView 和 JstlView）。</li><li>JstlView：检查结果总是返回 true。</li></ul><p>至此，我们就找到了所有的候选 View，但是大家需要注意，这个候选 View 不一定存在，在有 Thymeleaf 的情况下，返回的候选 View 不一定可用，在 JstlView 中，候选 View 也不一定真的存在。</p><p>接下来调用 getBestView 方法，从所有的候选 View 中找到最佳的 View。getBestView 方法的逻辑比较简单，就是查找看所有 View 的 MediaType，然后和请求的 MediaType 数组进行匹配，第一个匹配上的就是最佳 View，这个过程它不会检查视图是否真的存在，所以就有可能选出来一个压根没有的视图，最终导致 404。</p><p>这就是整个 View 的加载过程。</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>如果是单个视图，这套加载流程没什么问题，但是如果是多个视图解析器同时存在，就可能会有问题。</p><p>松哥一个一个来说明。</p><p>第一种情况：</p><p>FreeMarkerView、ThymeleafView 以及 JstlView 在项目中只存在任意一个，这种情况没任何问题，这也是小伙伴们日常常见的使用场景。</p><p>第二种情况：</p><p>FreeMarkerView+ThymeleafView 组合。如果项目中同时存在这两种视图解析器，由于 FreeMarkerView 会老老实实检查视图是否存在，而 ThymeleafView 不会检查，所以需要确保 FreeMarkerViewResolver 的优先级高于 ThymeleafViewResolver 的优先级。这样就能够确保视图加载的时候先去加载 FreeMarkerView（FreeMarkerView 如果不存在，则不会列为候选 View），再去加载 ThymeleafView，这样无论是 FreeMarkerView 还是 ThymeleafView，都能够正常加载到（回顾前面所讲 getBestView 方法逻辑）。假如 ThymeleafViewResolver 的优先级高于 FreeMarkerViewResolver，那么就会出现如下情况：用户请求一个 Freemarker 视图，结果在 getCandidateViews 方法中返回了两个视图，依次是 ThymeleafView 和 FreeMarkerView，但是实际上 ThymeleafView 中的视图是不存在的，结果在 getBestView 方法中，按顺序直接匹配到 ThymeleafView，最终导致运行出错。</p><p>在 Spring Boot 中，如果我们引入了 Freemarker 和 Thyemeleaf 的 starter，默认情况下，Freemarker 和 Thymeleaf 的优先级相同，都是 <code>Ordered.LOWEST_PRECEDENCE - 5</code>，但是由于 Freemarker 总是被优先加载，而排序时由于两者优先级相同所以位置不变，所以在具体代码实践中，FreeMarkerViewResolver 总是排在 ThymeleafViewResolver 前面，FreeMarkerView 会自动检查视图是否存在，所以这样的排序刚刚恰到好处。在具体代码实践中，如果我们在项目中同时引入了 Freemarker 和 Thymeleaf，可以不用做任何配置直接同时使用这两种视图解析器。</p><p>这里要吐槽一下，网上看多人说默认情况下 Freemarker 优先级高于 Thymeleaf，不知道谁抄谁的，反正都说错了，还是要严谨呀！</p><p>第三种情况：</p><p>Freemarker+Jsp 组合，如果项目中同时使用了这两种视图解析器，则只需要对 jsp 进行常规配置即可，不需要额外配置。所谓的常规配置就是首先引入所需依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置一下 jsp 视图的前缀后缀啥的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以了。</p><p>为什么这个组合这么简单呢？原因如下：</p><ol><li>在 Spring 设计中，InternalResourceView 其实就是兜底的，所以它不会检查视图是否真的存在，它的优先级也是最低的。</li><li>由于 InternalResourceView 的优先级最低，排在 Freemarker 后面，而 Freemarker 会自动检查视图是否存在，所以对于这个组合我们不需要额外配置。</li></ol><p>第四种情况：</p><p>Thymeleaf+Jsp 组合。这个组合稍微有点麻烦，因为 Thymeleaf 和 InternalResourceView 都不会去检查视图是否存在，而 Thymeleaf 的优先级高于 Jsp，所以 Thymeleaf 会“吞掉” Jsp 视图的请求。</p><p>想要这两个视图解析器同时存在，必须要有一个视图解析器具备检查视图是否存在的能力。Jsp 在这块的配置相对容易一些，所以我们选择对 InternalResourceView 做一些定制。</p><p>具体办法如下，首先定义类继承自 InternalResourceView 并重写 checkResource 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleResourceViewExists</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InternalResourceView</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkResource</span><span class="hljs-params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">this</span>.getServletContext().getRealPath(<span class="hljs-string">"/"</span>) + getUrl());</span><br><span class="line">        <span class="hljs-comment">//判断页面是否存在</span></span><br><span class="line">        <span class="hljs-keyword">return</span> file.exists();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalResourceView 默认的 checkResource 方法总是返回 true，现在我们稍微修改一下，让它去判断一下视图文件是否存在，如果存在，返回 true，否则返回 false。</p><p>配置完成后，将新的 HandleResourceViewExists 重新配置，同时修改优先级，使之优先级大于 ThymeleafViewResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>).viewClass(HandleResourceViewExists.class);</span><br><span class="line">        registry.order(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，这两个视图解析器就可以同时存在了。</p><p>第五种情况：</p><p>Freemarker+Thymeleaf+Jsp，看了前面四种，第五种情况应该就不用我多说了吧～</p><p>好啦，这个问题从原理到应用，都给大伙捋了一遍了，感兴趣的小伙伴赶紧试试哦～</p><p>对了，这个问题松哥也录制了相关的视频，感兴趣的小伙伴可以在公众号后台回复 <strong>vhr</strong> 查看视频详情。</p><p><img src="http://img.itboyhub.com/2021/02/20210204083251.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="ViewResolver" scheme="http://www.javaboy.org/tags/ViewResolver/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 应用监控常见方案梳理</title>
    <link href="http://www.javaboy.org/2021/0203/springboot-actuator.html"/>
    <id>http://www.javaboy.org/2021/0203/springboot-actuator.html</id>
    <published>2021-02-03T14:38:58.000Z</published>
    <updated>2021-03-07T15:09:50.227Z</updated>
    
    <content type="html"><![CDATA[<p>应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。</p><a id="more"></a><p>Spring Boot 中也提供了生产级的应用监控方案，对于单体应用、微服务应用都有相应的解决方案，今天松哥就想来和大家捋一捋 Spring Boot 中的应用监控方案都有哪些。</p><p>首先我们来捋一下应用监控都需要哪些东西？其实就两点：</p><ol><li>信息采集器</li><li>数据可视化 UI</li></ol><p>信息采集器会收集应用的健康、审计、指标、HTTP 请求等信息，并将之暴露出来，数据可视化 UI 则会通过仪表盘、图形等展示这些数据，并对数据进行分析、报警等处理。我们分别来看。</p><h2 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h2><p>在 Spring Boot 项目中，我们使用的信息采集器主要就是 Spring Boot Actuator，这个模块由 Spring Boot 官方提供，它包含了许多生产级别的功能，例如健康检查、审计、指标收集、HTTP 请求追踪等，Spring Boot Actuator 将这些信息收集起来后，通过 HTTP 和 JMX 两种方式暴露给外部模块。例如 Spring Boot Actuator 通过 <code>/health</code> 端点（endpoints）提供了应用的健康信息，开发者只需要访问该端点就可以看到应用的健康信息，但是这些端点返回的数据是 JSON 格式的，不方便查看，也不方便分析，所以一般情况下，Spring Boot Actuator 都是和一些外部模块一起使用。</p><p>Spring Boot Actuator 支持的端点主要有如下一些：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202406.png" alt></p><p>如果是 Web 应用，则再次基础上还支持如下端点：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202855.png" alt></p><p>提到 Spring Boot Actuator，就还有一个东西需要和大家介绍，那就是 Micrometer，从 Spring Boot2.0 开始，Actuator 底层改为了 Micrometer。</p><p>当我们在一个 Spring Boot 项目中引入 Actuator 依赖之后，我们会发现它里边包含了 Micrometer：</p><p><img src="http://img.itboyhub.com/2021/01/spring-cloud/20210201162644.png" alt></p><p>这个依赖又是干什么的呢？</p><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可，而 Micrometer 则会负责完成与不同监控系统的适配工作，类似于一个 Adapter，有了这个 Adapter，切换监控系统就变得非常容易。同时 Micrometer 还支持推送数据到多个不同的监控系统。</p><p>而 Spring Boot Actuator 使用 Micrometer 与外部应用监视系统进行集成，这样一来，开发者只需要稍微配置一下就可以使其和外部应用监视系统进行整合了。Micrometer 支持的监控系统有：</p><ul><li>AppOptics</li><li>Atlas</li><li>Datadog</li><li>Dynatrace</li><li>Elastic</li><li>Ganglia</li><li>Graphite</li><li>Humio</li><li>Influx</li><li>JMX</li><li>KairosDB</li><li>New Relic</li><li>Prometheus</li><li>SignalFx</li><li>Simple (in-memory)</li><li>StatsD</li><li>Wavefront</li></ul><p>信息采集器这块，老实说松哥见到的大部分项目都是用的 Spring Boot Actuator，似乎没有其他更好的选择。如果小伙伴们有用到其他方案，也可以留言讨论。</p><p>接下来我们来看看一些常用的应用监控可视化工具。</p><h2 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h2><p>这个算是 Spring Boot 中最最正宗的应用监控可视化工具了，看名字就知道有多正宗，当我们创建一个 Spring Boot 项目时，选择依赖时候就有这个选项：</p><p><img src="http://img.itboyhub.com/2021/02/20210201173448.png" alt></p><p>如果是<strong>单体应用</strong>很多人可能会选择 Spring Boot Admin 作为监控数据可视化工具，不过它也支持微服务应用的(可以通过 Eureka、Consul 等注册中心获取应用信息)，只不过在微服务中，我们可能会更多的选择 Grafana+Prometheus 组合。</p><p>Spring Boot Admin 主要包含如下功能：</p><ul><li>显示应用健康信息。</li><li>显示应用运行的详细信息，例如 JVM 和内存指标、数据源指标、缓存指标等等。</li><li>显示应用的构建信息。</li><li>查看 JVM 系统和环境属性</li><li>查看 Spring Boot 配置属性</li><li>支持 Spring Cloud 中的端点刷新功能 /refresh-endpoint</li><li>方便的日志级别管理功能</li><li>可以与 JMX-beans 进行交互</li><li>查看 Thread dump</li><li>查看 http 请求</li><li>查看计划任务</li><li>查看和删除活动会话</li><li>查看 Flyway/Liquibase 数据库迁移</li><li>下载 heapdump</li><li>状态更改通知</li><li>…</li></ul><p>可以看到，Spring Boot Admin 不仅仅是将 Actuator 接口中的数据进行可视化，还在此基础上提供了分析、报警等功能。</p><p>Spring Boot Admin 的显示界面如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201181913.png" alt></p><h2 id="Grafana-Prometheus"><a href="#Grafana-Prometheus" class="headerlink" title="Grafana+Prometheus"></a>Grafana+Prometheus</h2><p>这个组合在微服务项目中比较常见，松哥之前录制的 Spring Cloud 视频里边也有讲到（公号后台回复 vhr 有视频详细介绍）。</p><p><img src="http://img.itboyhub.com/2021/02/20210201182618.png" alt></p><p>Prometheus 是一款开源的监控 + 时序数据库 + 报警软件，由SoundCloud 公司开发的，在 CNCF 基金会托管并已成功孵化，不过这个 Prometheus 的 UI 比较简单，用户体验不怎么好，现在都流行大屏监控页面，上面展示各种炫酷的图表。所以在实际应用中，Prometheus 一般都是结合 Grafana 一起来使用，Grafana 也是一个开源的跨平台度量分析和可视化 + 告警工具，它支持多种数据源，包括 Prometheus，Grafana 的 UI 就比较炫酷，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201200600.png" alt></p><p>当然，使用这套组合也离不开 Spring Boot Actuator。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>前面跟小伙伴们分享了 Spring Boot 应用监控的主流方案，没说具体用法，后面抽空松哥会和大家聊一聊具体用法。除了这些主流的方案之后，还有很多小众的方案，松哥也见到有极少数项目团队自研应用监控方案。不过对于大多数的项目而言，这些现成的成熟方案无疑是最佳选择。</p><p>好啦，今天就先和小伙伴们聊这么多，后面我们再来看具体用法～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Actuator" scheme="http://www.javaboy.org/tags/Actuator/"/>
    
  </entry>
  
  <entry>
    <title>Swagger3.0，你所不知道的新变化！</title>
    <link href="http://www.javaboy.org/2021/0129/springboot-swagger3.html"/>
    <id>http://www.javaboy.org/2021/0129/springboot-swagger3.html</id>
    <published>2021-01-29T14:38:24.000Z</published>
    <updated>2021-03-07T15:09:45.200Z</updated>
    
    <content type="html"><![CDATA[<p>在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/01/docker/20210128112402.png" alt></p><p>新版本还是有很多好玩的地方，我们一起来看下。</p><h2 id="支持-OpenAPI"><a href="#支持-OpenAPI" class="headerlink" title="支持 OpenAPI"></a>支持 OpenAPI</h2><p>什么是 OpenAPI？</p><p>OpenAPI 规范其实就是以前的 Swagger 规范，它是一种 REST API 的描述格式，通过既定的规范来描述文档接口，它是业界真正的 API 文档标准，可以通过 YAML 或者 JSON 来描述。它包括如下内容：</p><ul><li>接口（/users）和每个接口的操作（GET /users，POST /users）</li><li>输入参数和响应内容</li><li>认证方法</li><li>一些必要的联系信息、license 等。</li></ul><p>关于 OpenAPI 的更多内容，感兴趣的小伙伴可以在 GitHub 上查看：<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md" target="_blank" rel="noopener">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>以前在使用 2.9.2 这个版本的时候，一般来说我们可能需要添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个，一个用来生成接口文档（JSON 数据），另一个用来展示将 JSON 可视化。</p><p>在 3.0 版本中，我们不需要这么麻烦了，一个 starter 就可以搞定：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 Spring Boot 中的其他 starter 一样，springfox-boot-starter 依赖可以实现零配置以及自动配置支持。也就是说，如果你没有其他特殊需求，加一个这个依赖就行了，接口文档就自动生成了。</p><h2 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h2><p>3.0 中的接口地址也和之前有所不同，以前在 2.9.2 中我们主要访问两个地址：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v2/api-docs" target="_blank" rel="noopener">http://localhost:8080/v2/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></li></ul><p>现在在 3.0 中，这两个地址也发生了变化：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v3/api-docs" target="_blank" rel="noopener">http://localhost:8080/v3/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui/index.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui/index.html</a></li></ul><p>特别是文档页面地址，如果用了 3.0，而去访问之前的页面，会报 404。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>旧的注解还可以继续使用，不过在 3.0 中还提供了一些其他注解。</p><p>例如我们可以使用 @EnableOpenApi 代替以前旧版本中的 @EnableSwagger2。</p><p>话是这么说，不过松哥在实际体验中，感觉 @EnableOpenApi 注解的功能不明显，加不加都行。翻了下源码，@EnableOpenApi 注解主要功能是为了导入 OpenApiDocumentationConfiguration 配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(OpenApiDocumentationConfiguration.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOpenApi &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我又看了下自动化配置类 OpenApiAutoConfiguration，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(SpringfoxConfigurationProperties.class)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(value = <span class="hljs-string">"springfox.documentation.enabled"</span>, havingValue = <span class="hljs-string">"true"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123;</span><br><span class="line">    OpenApiDocumentationConfiguration.class,</span><br><span class="line">    SpringDataRestConfiguration.class,</span><br><span class="line">    BeanValidatorPluginsConfiguration.class,</span><br><span class="line">    Swagger2DocumentationConfiguration.class,</span><br><span class="line">    SwaggerUiWebFluxConfiguration.class,</span><br><span class="line">    SwaggerUiWebMvcConfiguration.class</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span><br><span class="line">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自动化配置类里边也导入了 OpenApiDocumentationConfiguration。</p><p>所以在正常情况下，实际上不需要添加 @EnableOpenApi 注解。</p><p>根据 OpenApiAutoConfiguration 上的 @ConditionalOnProperty 条件注解中的定义，我们发现，如果在 application.properties 中设置 <code>springfox.documentation.enabled=false</code>，即关闭了 swagger 功能，此时自动化配置类就不执行了，这个时候可以通过 @EnableOpenApi 注解导入 OpenApiDocumentationConfiguration 配置类。技术上来说逻辑是这样，不过应用中暂未发现这样的需求（即在 application.properties 中关闭 swagger，再通过 @EnableOpenApi 注解开启）。</p><p>对于 @EnableOpenApi 注解的使用场景，小伙伴们要是有自己的见解，欢迎留言讨论。</p><p>另外，以前我们用的 @ApiResponses/@ApiResponse 注解，在 3.0 中名字没变，但是所在的包变了，小伙伴们使用时注意导包问题哦。</p><p>另外，我们之前用的 @ApiOperation 注解在 3.0 中可以使用 @Operation 代替。</p><p>另外还有一些新注解如 @Parameter、Parameters、@Schema 等，松哥尝试了下，感觉不太好用，不如旧的用的舒服，这些新注解小伙伴们可以自行尝试下。</p><p>好啦，今天主要和小伙伴们分享了 Swagger3.0 带来的一些新变化，如果还没用过 Swagger，可以在公众号后台回复 666，有一个松哥原创的 Spring Boot 入门教程，里边有讲 Swagger 的用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Swagger3" scheme="http://www.javaboy.org/tags/Swagger3/"/>
    
  </entry>
  
  <entry>
    <title>Maven 聚合工程的几个小细节</title>
    <link href="http://www.javaboy.org/2021/0127/maven.html"/>
    <id>http://www.javaboy.org/2021/0127/maven.html</id>
    <published>2021-01-27T14:38:10.000Z</published>
    <updated>2021-03-07T15:10:01.015Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。</p><a id="more"></a><h2 id="为什么需要分模块"><a href="#为什么需要分模块" class="headerlink" title="为什么需要分模块"></a>为什么需要分模块</h2><p>松哥在 vhr(<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>) 项目中也用到了聚合工程，那么为什么用聚合工程？直接一个工程分包不行吗？</p><p>如果只是一个小 case，分包当然是可以的，但是如果项目越来越大，分包的弊端就会逐步展现出来：</p><ul><li>pom.xml 中引用的依赖非常多以至于难以维护。</li><li>同时在修改 dao 层的代码，结果改错了，你在 service 层编译不通过，烦躁。</li><li>项目越来越大，build 等待时间也越来越长。</li><li>有一个新的项目想要复用你的 utils 工具包，结果你只能去拷贝代码。</li></ul><p>这样高度耦和的代码实际上并不符合我们的设计规范，所以我们需要对代码进行拆分，做成不同的模块。</p><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>经过模块划分后，我们的 Maven 项目结构可能是这样的：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">└── vhr-parent</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        └── src</span><br><span class="line">            ├── main</span><br><span class="line">            │   ├── java</span><br><span class="line">            │   └── resources</span><br><span class="line">            └── test</span><br><span class="line">                └── java</span><br></pre></td></tr></table></figure><p>先说下代码组织形式，可以是父子形式，就像上面这样，父工程是一个目录，子工程的目录在父工程目录中。也可以是平铺的形式，即父子工程在同一目录下。两种形式皆可，但是在配置上会略有差异，这个松哥后面会说，这里我们先按照上面这种代码组织形式来讲。</p><p>service 依赖 dao，web 依赖 service，默认情况下，依赖是可以传递的，所以你在 web 中也可以使用 dao。一些特殊的情况下，如果我们不希望依赖传递，则可以使用 scope 节点进行配置。</p><p>一般来说，dao、service 都是打包成 jar、web 打包成 war，parent 的 packaging 类型则是一个 pom。</p><p>按照模块划分之后，上面我们所提到的问题，现在都解决了：</p><ul><li>首先，项目变大之后，build 等待时间并不会飞速增长，各个模块都可以独自 build。</li><li>拆分之后，pom.xml 文件中的依赖也不再凌乱。</li><li>如果其他项目有需要，可以方便的将某一个模块提供给其他项目使用。</li><li>依赖版本可以使用 depencencyManagement 节点进行统一管理。spring-boot 中的 parent 就是这么干的。</li></ul><h2 id="配置细节"><a href="#配置细节" class="headerlink" title="配置细节"></a>配置细节</h2><p>首先我们来看下 vhr-parent 中的配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面我们说过了，parent 的 packaging 节点要为 pom，这个是固定的，只要有子模块，packaging 就是 pom。</p><p>另外我们还在 parent 的 pom.xml 中配置了 modules，将其所包含的所有子模块都列出来，当我们在 parent 处进行打包时，Maven 会自动梳理子模块之间的依赖关系，整理出来一个 build 顺序，然后进行编译打包。</p><p>再来看看子模块的 pom.xml 配置，以 vhr-service 为例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块中需要配置 parent，这样 vhr-service 就继承了 parent 的一切，包括依赖、插件、坐标、版本号等等，有了来自 parent 的一大堆东西之后，vhr-service 自己的 pom.xml 中只需要简单配置一下 artifactId 即可。依赖的版本号则可以通过 ${project.version} 变量引用项目的版本号。</p><p>这里没有配置 packaging，默认就是 jar，所以可以省略，如果是 web 模块，则还需要配置 packaging 为 war。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>聚合工程，听名字就知道是很多工程聚在一起组成一个完整的项目，所以打包的时候，也是一起打包。直接在 parent 处执行 <code>mvn package</code> 命令，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sang-3:vhr-parent sang$ mvn package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Build Order:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent                                                         [pom]</span><br><span class="line">[INFO] vhr-dao                                                            [jar]</span><br><span class="line">[INFO] vhr-service                                                        [jar]</span><br><span class="line">[INFO] vhr-web                                                            [jar]</span><br><span class="line">[INFO] </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary for vhr-parent 1.0-SNAPSHOT:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent ......................................... SUCCESS [  0.004 s]</span><br><span class="line">[INFO] vhr-dao ............................................ SUCCESS [  0.867 s]</span><br><span class="line">[INFO] vhr-service ........................................ SUCCESS [  0.038 s]</span><br><span class="line">[INFO] vhr-web ............................................ SUCCESS [  0.025 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.021 s</span><br><span class="line">[INFO] Finished at: 2021-01-26T12:50:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到整个打包过程，各个聚合工程都被打包了。打包完成后，在不同模块的目录下都可以看到一个 target 目录，里边就有刚刚打包好的 jar 或者 war。</p><p>如果你使用的是 IntelliJ IDEA，也可以在工具右侧找到 Maven-&gt;LifeCycle-&gt;Package，双击进行打包。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210126125328.png" alt></p><h2 id="目录问题"><a href="#目录问题" class="headerlink" title="目录问题"></a>目录问题</h2><p>在前面的案例中，我们的代码结构使用了父子目录的形式，但是在实际应用中，有的时候我们可能会采用平铺的形式，像下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">└── vhr</span><br><span class="line">    ├── parent</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        ├── src</span><br><span class="line">        │   ├── main</span><br><span class="line">        │   │   ├── java</span><br><span class="line">        │   │   └── resources</span><br><span class="line">        │   └── test</span><br><span class="line">        │       └── java</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/springboot2/20210126132625.png" alt></p><p>可以看到，parent 和各个子模块处于同一目录下，这个时候，无论是 parent 的 pom.xml 还是子模块的 pom.xml，写法都会和之前略有差异。</p><p>先来看 parent 的 pom.xml：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 module 中定义的是子模块名称，所以，当子模块和父模块处于同一目录下时，需要明确指出子模块的位置，因此这里用到了相对路径。</p><p>同理，在子模块中也需要明确指定父模块的 pom.xml，以 vhr-service 为例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 parnet 节点中多了 relativePath 用来指定父模块的 pom.xml。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://www.javaboy.org/categories/Maven/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>我要再吹一把 Docker</title>
    <link href="http://www.javaboy.org/2021/0125/docker.html"/>
    <id>http://www.javaboy.org/2021/0125/docker.html</id>
    <published>2021-01-25T14:37:56.000Z</published>
    <updated>2021-03-07T15:08:53.492Z</updated>
    
    <content type="html"><![CDATA[<p>临近年底，最近工作中又折腾上 Docker 了，用完之后，不得不说，真香！</p><a id="more"></a><p>事情的起因很简单，有个刚入行不久小伙伴需要在一个现有的 Java 服务器上部署一个 PHP 应用，这个 Java 服务器上目前就跑了一个 Spring Boot 应用，然后用 Nginx 做了反向代理。部署 PHP 其实也没什么难度，但是如果你运气不好，那就有的折腾了。</p><p>我大概跟他说了下思路：</p><p>首先安装 PHP 环境，这块注意兼容性问题即可。然后就是 PHP 服务器的选择，可以选择 Nginx 也可以选择 Apache。</p><p>如果使用 Nginx 做服务器，Nginx 本身没有解析 PHP 脚本的功能，还需要安装 php-fpm 去解析 PHP，然后配置 Nginx 作为反向代理，将请求的 PHP 脚本交给 php-fpm 去解析。Nginx 和 php-fpm 通信有两种方式，直接配置一个 <a href="http://www.sock" target="_blank" rel="noopener">www.sock</a> 或者使用 tcp 通信，前者需要注意权限问题。</p><p>如果使用 Apache 做服务器就没有这么多事，Apache 服务器自己可以搞定 PHP 脚本的解析问题，我们只需要将 PHP 脚本放在 Apache 服务器正确的位置上即可。</p><p>由于服务器上已经安装了 Nginx，因此建议采用第一种方案。</p><p>大概就是这样的思路，说完之后小伙伴就自己去搞了。</p><p>两天之后，小伙伴又哼哧哼哧的找来了，还没部署成功，各种方案都试了，各种 BUG 都遇到了，搞的很头大，问我还有没有其他好办法。</p><p>我手头上事情多忙不开，没法帮他排查问题，于是顺手扔给他一个 Docker 命令去试下。几分钟后，小伙伴说你怎么不早说 Docker 命令，这也太爽了，一个命令就搞定了。</p><p>老实说，Docker 确实很香。特别是在当下云原生技术火热的情况下，容器技术作为云原生中的重要一环，作用异常重要。</p><p>松哥大概是在三年前开始接触容器技术，Docker、Docker-Compose 到后来的 K8s 都有涉猎。不过老实说，如果你只是做常规的企业应用开发，工作中用到 Docker 的场景可能并不多，最常见的场景可能就是安装一些环境而已。对运维来说这些可就是神器了，容器技术极大的简化了运维的工作量，如果公司里上了 DevOps，你可能会看到一个整天无所事事的运维在到处晃悠，再看看自己还在苦逼的搬砖，真是人比人气死人呀。松哥身边有个小伙伴不止一次的说想去搞运维，开发太累了。上了 DevOps 之后，大部分情况下运维的工作是挺爽的。</p><p>现在我 Mac 上的 MySql、Redis、RabbitMQ、MongoDB 等等都是使用 Docker 来安装，方便省事，用完了不想要了，一个命令就删除了，不留任何痕迹。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210125111206.png" alt></p><p>当然作为 Java 工程师，我们还是有必要学习一下 Docker 容器技术的，无论是追赶时髦的云原生还是自己平时安装个环境啥的，会点 Docker 总是没错的。松哥之前在学习 Docker 时，还写了一个 Docker 入门教程，有的小伙伴已经下载了，还有小伙伴可能还不知道，今天再给大家安利一下，在公众号后台回复 <strong>docker</strong> 可以下载这个教程。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210125095506.png" alt></p><p>这个文字的教程我也写的蛮久了，最近还在想要是有空录制一个 Docker 入门的视频教程，等录好了会告诉大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;临近年底，最近工作中又折腾上 Docker 了，用完之后，不得不说，真香！&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.javaboy.org/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://www.javaboy.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>年底小偷也要冲业绩，小伙伴们看好自己的手机呀！</title>
    <link href="http://www.javaboy.org/2021/0119/life.html"/>
    <id>http://www.javaboy.org/2021/0119/life.html</id>
    <published>2021-01-19T14:37:34.000Z</published>
    <updated>2021-03-07T15:08:49.345Z</updated>
    
    <content type="html"><![CDATA[<p>在一线城市呆久了，或者在学校里呆久了，可能会有一种错觉，这年头还有人偷手机吗？</p><a id="more"></a><p>当然有！</p><p>老母亲最近就在西安的一个菜市场丢了一部华为手机，冬天穿的衣服厚，小偷偷手机时不易察觉，口袋里的东西就容易被人顺走。</p><p>小偷各个地方都会有，就是多与少的问题。如果一个地方没有能够吸引大量就业人口的低端产业，类似于盗窃这样的治安问题发生频率就要高一些。特别是过年前这段时间，小偷也要冲业绩回家过年，小伙伴们一定要看好自己的手机。</p><p>2012 年冬天在海口，有一个周末，女票的笔记本坏了我帮忙送去售后维修，在返程的时候，从海口明珠广场那里的天桥上下来后，感觉右边上衣的口袋怪怪的，一回头，发现小偷的夹子已经伸到我的口袋了，第一次遇到这种事我都懵了。看到我回头，小偷自己也愣了一下，忙收回夹子，悻悻离去。我回过神来，发现天桥底下一众摆摊的小贩都在静静地观赏着刚才发生的事情，我理解他们不吭声提醒的难处，自己的东西还是要靠自己保管好。</p><p>要是我没有回头，那真是光天化日众目睽睽之下，钱包被小偷夹走了。想想真是后怕，那时候也没什么钱，但是钱包里有身份证，要是丢了就麻烦了。</p><p>2015 年春招的时候，我在西安呆了十多天，小偷和骗子都被我遇上了。</p><p>先说小偷，有一次我在路上接到面试官的电话，面试完了手机随手放在口袋里，然后继续走路，突然感觉身后有很急促的呼吸声，持续时间有点长，我感到奇怪，一回头，好家伙，小偷跟在我身后都快踩到我的脚了，空旷的路上就我们俩人，可以断定是小偷无疑，不知道是我走路有点快他跟不上还是即将得手内心有点激动，他急促的呼吸出卖了他！感觉这个小偷的业务水平比我在海口遇到的小偷业务水平稍逊一筹。</p><p>再说骗子，骗子是我在大学城参加完招聘后，回家路上遇到的。一个胖胖的中年男子，旁边跟着一个女的抱着小孩，男子表示来西安找朋友，但是现在没找到，钱也没了。。。吧啦吧啦，我没听他说完就走开了。整个过程有一个细节比较有意思，男的说话的时候故意抬起他的右手捏鼻子，亮出了一个黄灿灿的大戒指，我觉得他的潜台词是你看我其实不差钱，就是当前缺点钱而已。这样的伎俩我当然不会上当，大学城附近这样的骗子太多了，2016 年我去西北工大找女票的时候，校门口也遇到了类似的骗子，套路都差不多。</p><p>当然我也并非总是这么幸运，大学的时候丢过自行车，这个估计很多小伙伴们都有类似经历，大学里边最容易丢的就是自行车了，反而手机不易丢。个人猜测是因为学校里学生都善恶分明，要是有人把手伸到你口袋里准备偷手机，被其他人看到肯定会喊出来，不会像社会上看到了也装作没看到。而偷自行车就不会这么麻烦（个人瞎猜）。</p><p>现在临近过年，各路小偷骗子也要冲业绩了，小伙伴们要看好自己的手机呀～手机可能不值几个钱，但是丢了真的很麻烦，丢了之后要赶紧号码挂失、补卡、找回各种账号，真的头大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一线城市呆久了，或者在学校里呆久了，可能会有一种错觉，这年头还有人偷手机吗？&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>腾讯程序员怎么写代码？看看读者麻瓜大佬怎么说！</title>
    <link href="http://www.javaboy.org/2021/0109/tencent.html"/>
    <id>http://www.javaboy.org/2021/0109/tencent.html</id>
    <published>2021-01-09T14:37:10.000Z</published>
    <updated>2021-03-07T15:07:57.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由读者 muggle 投稿，muggle 是一位具备极客精神的 90 后单身老实猿，目前在腾讯云担任研发工程师。</p></blockquote><a id="more"></a><h1 id="代码混乱的常见问题"><a href="#代码混乱的常见问题" class="headerlink" title="代码混乱的常见问题"></a>代码混乱的常见问题</h1><p>很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病</p><h2 id="代码又臭又长"><a href="#代码又臭又长" class="headerlink" title="代码又臭又长"></a>代码又臭又长</h2><p>我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。</p><p>好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。</p><h2 id="代码逻辑不明所以"><a href="#代码逻辑不明所以" class="headerlink" title="代码逻辑不明所以"></a>代码逻辑不明所以</h2><p>代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。</p><h1 id="规划代码的核心思想"><a href="#规划代码的核心思想" class="headerlink" title="规划代码的核心思想"></a>规划代码的核心思想</h1><p>吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。</p><h2 id="花叶论"><a href="#花叶论" class="headerlink" title="花叶论"></a>花叶论</h2><p>就我个人而言，这个理解是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：</p><ul><li>数据校验</li><li>业务逻辑</li><li>数据转换</li><li>数据库交互（查询与持久化）</li></ul><p>大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。</p><p>隐藏叶子代码，突出主干逻辑的一些手法</p><p>1）Converter（转换器）</p><p>大部分时候我们使用 bean 拷贝使用的是 <code>BeanUtils</code> 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 <code>1）Converter</code> 这个角色来专门负责数据的传递与转换。</p><p>2）manager 层</p><p>无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。</p><p>3）方法简单封装<br>假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 <code>java.util.function</code> 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：</p><ul><li>Function 类型：传入一个bean 返回另外一个bean</li><li>Consumer 类型：传入一个bean 无返回值</li><li>Predicate 类型：传入一个bean 返回布尔值</li><li>Supplier 类型：没有入参，有出参</li></ul><p>以 Consumer 的使用为例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(Consumer&lt;User&gt; consumer)</span></span>&#123;</span><br><span class="line">    User user=<span class="hljs-keyword">new</span> User();</span><br><span class="line">    consumer.accept(user);</span><br><span class="line">    user=userMapper.getUser(user);</span><br><span class="line">    <span class="hljs-keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething1</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    User user=getUser(user-&gt;&#123;user.setId(<span class="hljs-number">1L</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething2</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    User user=getUser(user-&gt;&#123;user.setName(<span class="hljs-string">"xxx"</span>)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。</p><h2 id="日志和注释的一些个人经验"><a href="#日志和注释的一些个人经验" class="headerlink" title="日志和注释的一些个人经验"></a>日志和注释的一些个人经验</h2><p>1）日志</p><p>首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：</p><ul><li>数据更新：我们有必要知道写库的数据是不是正确的数据；</li><li>条件分支：便于我们分析业务走的哪一条逻辑；</li><li>批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。</li></ul><p>并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。</p><p>2）注释</p><p>最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。<br>方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。</p><p>代码注释我分享一个我偷师来的小技巧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">pulic <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">/** 1. 从excel 获取 vo*/</span></span><br><span class="line">    Workbook workBook = getWorkBook(wookbookStream);</span><br><span class="line">    <span class="hljs-comment">//获取成员信息</span></span><br><span class="line">    Sheet userSheet = workBook.getSheetAt(<span class="hljs-number">3</span>);</span><br><span class="line">     Map&lt;String, UserVO&gt; userVOMap = getUserForExcel(file, userSheet);</span><br><span class="line">    <span class="hljs-comment">// 获取项目vo</span></span><br><span class="line">    Sheet projectSheet = workBook.getSheetAt(<span class="hljs-number">0</span>);</span><br><span class="line">    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);</span><br><span class="line">    <span class="hljs-comment">// 获取任务vo</span></span><br><span class="line">    Sheet taskSheet = workBook.getSheetAt(<span class="hljs-number">1</span>);</span><br><span class="line">    Map&lt;String, TaskVO&gt; taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);</span><br><span class="line">    <span class="hljs-comment">/** 2. 插入数据 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (isInsert.get())&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="hljs-comment">/** 3.写入异常信息 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isInsert.get()) &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，对于主干的步骤 我用 <code>/** 1. */</code>  <code>/** 2. */</code> javadoc的注释来标注了，而普通的注释我用 <code>//</code> 标注，因为idea 在纯黑主题下会给 <code>/**</code> 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。</p><h2 id="六大基本原则"><a href="#六大基本原则" class="headerlink" title="六大基本原则"></a>六大基本原则</h2><p>对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。</p><p>对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。</p><h2 id="方法命名-‘潜规则’"><a href="#方法命名-‘潜规则’" class="headerlink" title="方法命名 ‘潜规则’"></a>方法命名 ‘潜规则’</h2><p>很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   <a href="https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA" target="_blank" rel="noopener">设计模式杂谈</a></p><p>介绍过部分命名规则，感兴趣的小伙伴可以去看看。</p><h2 id="代码提交及版本控制"><a href="#代码提交及版本控制" class="headerlink" title="代码提交及版本控制"></a>代码提交及版本控制</h2><p>正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：</p><ul><li>Header Header部分有3个字段： type(必需), scope(可选), subject(必需)</li><li>Body 部分是对本次 commit 的详细描述，可以分成多行。</li><li>Footer不常用，可为空 包括不兼容变动、关闭issue。</li></ul><p>这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。</p><p>对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧</p><p><img src="http://img.itboyhub.com/2020/20210108160529.png" alt></p><h1 id="帮助代码规范的工具"><a href="#帮助代码规范的工具" class="headerlink" title="帮助代码规范的工具"></a>帮助代码规范的工具</h1><p>本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。</p><h2 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h2><p>对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 <code>converter</code> 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。</p><h2 id="checkStyle"><a href="#checkStyle" class="headerlink" title="checkStyle"></a>checkStyle</h2><p>idea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。</p><h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：</p><p><img src="http://img.itboyhub.com/2020/20210108160614.png" alt></p><p>开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。</p><h2 id="Git-Commit-Template"><a href="#Git-Commit-Template" class="headerlink" title="Git Commit Template"></a>Git Commit Template</h2><p>这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。</p><p>代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由读者 muggle 投稿，muggle 是一位具备极客精神的 90 后单身老实猿，目前在腾讯云担任研发工程师。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="Tencent" scheme="http://www.javaboy.org/tags/Tencent/"/>
    
      <category term="腾讯" scheme="http://www.javaboy.org/tags/%E8%85%BE%E8%AE%AF/"/>
    
  </entry>
  
</feed>
