<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2023-07-20T13:47:44.092Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TLS+gRPC怎么玩？如何让自己的RPC通信更加安全？</title>
    <link href="http://www.javaboy.org/2023/0323/tls_grpc.html"/>
    <id>http://www.javaboy.org/2023/0323/tls_grpc.html</id>
    <published>2023-03-23T13:30:06.000Z</published>
    <updated>2023-07-20T13:47:44.092Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥发了一篇文章和小伙伴们仔细聊了聊 TLS、CA 证书这些问题，还没看过的小伙伴可以先戳下面了解下：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/4c4xTp52TyLCJtJTR7y_Rw" target="_blank" rel="noopener">TLS、SSL、CA 证书、公钥、私钥。。。今天捋一捋！</a></li></ul><p>今天我们要在前文的基础之上，来和小伙伴们聊一聊如何确保 gRPC 的通信安全。</p><p>确保 gRPC 的通信安全我们有很多种不同的方式，其中一种，就是对通信过程进行加密，使用上 TLS。对于 TLS 如何加密，如何协商密钥，这些我这里就不再啰嗦了，我在之前的文章中都已经介绍过了。咱们就直接来看具体的玩法。</p><p>这块整体上可以分为两大类：</p><ul><li>启用单向安全连接</li><li>启用 mTLS 安全连接</li></ul><p>我们分别来看。</p><h2 id="1-启用单向安全连接"><a href="#1-启用单向安全连接" class="headerlink" title="1. 启用单向安全连接"></a>1. 启用单向安全连接</h2><p>单向安全连接其实就是说只需要客户端校验服务端，确保客户端收到的消息来自预期的服务端，整个的校验就涉及到我们前文所说的 TLS、CA 等内容了，具体流程是这样：</p><ol><li>首先我们先在自己电脑本地生成一个自签名的 CA 证书。</li><li>利用这个 CA 证书，生成一个服务证书。</li></ol><p>大致上就这两个步骤就行了，然后在客户端和服务端中分别加载相应的证书即可。</p><blockquote><p>上面我们提到了需要先有一个自签名的 CA 证书，这一步其实也可以省略，省略之后就直接生成一个自签名的服务证书即可，然后在客户端和服务端都使用这个服务证书。</p></blockquote><p>来实际操作一下。</p><p>先自己安装一下 openssl 工具，配置一下环境变量，软件安装比较简单，我这里就不啰嗦了。</p><h3 id="1-1-生成-CA-证书"><a href="#1-1-生成-CA-证书" class="headerlink" title="1.1 生成 CA 证书"></a>1.1 生成 CA 证书</h3><p>首先我们来看下如何生成 CA 证书。</p><p>一共是三个步骤：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure><ul><li>out 表示输出的文件名。</li><li>2048 表示私钥的位数。</li></ul><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><p>CSR 即证书签名申请（Certificate Signing Request），获取 SSL 证书，需要先生成 CSR 文件并提交给证书颁发机构（CA）。CSR 包含了用于签发证书的公钥、用于辨识的名称信息（Distinguished Name）（例如域名）、真实性和完整性保护（例如数字签名），通常从 Web 服务器生成 CSR，同时创建加解密的公钥私钥对。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca.key -out ca.csr  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>subj 中描述的是一些国家、城市、组织以及通用名称（域名）等信息。</li></ul><ol start="3"><li>自签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt  -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ul><li>-x509 表示是要生成自签名证书。</li><li>-days 3650 表示证书有效期是 3650 天。</li><li>-key 表示生成证书所需要的密钥。</li></ul><p>有人说公钥呢？公钥其实就在 <code>.crt</code> 证书文件中。</p><h3 id="1-2-生成服务证书"><a href="#1-2-生成服务证书" class="headerlink" title="1.2 生成服务证书"></a>1.2 生成服务证书</h3><p>再来看生成服务证书，生成服务证书和生成 CA 证书其实整个过程差不多，唯一的区别在于，CA 证书是自签名的，而服务证书是 CA 的私钥给签名的，就这个差别。</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -out server.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><ul><li>-req 和 -in 指定了 server.csr，这个是证书请求文件，这里实际上是表示签署证书请求文件。</li></ul><p>证书现在就生成完毕。</p><p>这里我们生成的私钥都是 <code>.key</code> 文件，这个用我们 Java 代码加载的时候会有问题，我们要将之转为 <code>.pem</code> 格式然后再用 Java 代码进行加载，转换的命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform pem -in server.key -outform pem -nocrypt -out server.pem</span><br></pre></td></tr></table></figure><h3 id="1-3-单向加密"><a href="#1-3-单向加密" class="headerlink" title="1.3 单向加密"></a>1.3 单向加密</h3><p>现在证书都有了，在当前项目目录下新建一个文件夹，专门用来放证书，项目目录结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── certs</span><br><span class="line">│   ├── ca.crt</span><br><span class="line">│   ├── ca.csr</span><br><span class="line">│   ├── ca.key</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   ├── server.csr</span><br><span class="line">│   ├── server.key</span><br><span class="line">│   └── server.pem</span><br><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>我们看下代码该如何改造实现单向加密通信。</p><p>先来看服务端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .useTransportSecurity(certFile,keyFile)</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大家注意，由于我生成签名的时候，使用的域名是 <code>local.javaboy.org</code> 这是我在本地 hosts 文件中配置的，指向本地地址，所以在后续的通信中，我使用的域名都将是 <code>local.javaboy.org</code>。</p></blockquote><ol><li>Paths.get 方法表示从项目的根目录下开始查找文件，参数是可变长度参数，参数共同组成文件完整路径。</li><li>服务端需要加载服务签名和服务私钥，签名证书是客户端验证服务端身份用的，私钥则是服务端解密客户端消息使用的。</li></ol><p>服务端的改造就这些。</p><p>再来看客户端的改造：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(certFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端主要是加载 CA 证书文件，服务端的证书就是 CA 私钥签发的，但是需要 CA 公钥也就是 ca.crt 进行验签，所以这里客户端加载了 ca.crt 即可。</p><p>好啦，整体上的流程差不多就是这个样子。</p><h2 id="2-启用-mTLS-安全连接"><a href="#2-启用-mTLS-安全连接" class="headerlink" title="2. 启用 mTLS 安全连接"></a>2. 启用 mTLS 安全连接</h2><p>上面的例子只是客户端校验了服务端的身份，服务端并没有校验客户端的身份，如果想要双向校验，那么就把上面的流程对称操作一遍就可以了。</p><p>首先我们需要为客户端生成相应的证书，步骤跟前面也基本上一直，使用 CA 进行签名，如下：</p><ol><li>生成 <code>.key</code> 私钥文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成 <code>.csr</code> 证书签名请求文件：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key client.key -out client.csr -subj &quot;/C=CN/L=GuangZhou/O=javaboy/CN=local.javaboy.org&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>签名生成 <code>.crt</code> 证书文件</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in client.csr -out client.crt -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure><p>然后来看看代码。</p><p>先来看服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.crt"</span>).toFile();</span><br><span class="line">    File keyFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"server.pem"</span>).toFile();</span><br><span class="line">    File caFile = Paths.get(<span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">    server = NettyServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">            .sslContext(GrpcSslContexts.forServer(certFile,keyFile).trustManager(caFile).clientAuth(ClientAuth.REQUIRE).build())</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LoginServer3.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端要加载的文件多了 <code>ca.crt</code>，这是给客户端验签的时候需要用到。</p><p>再来看看客户端代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File caFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"ca.crt"</span>).toFile();</span><br><span class="line">File certFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.crt"</span>).toFile();</span><br><span class="line">File keyFile = Paths.get( <span class="hljs-string">"certs"</span>, <span class="hljs-string">"client.pem"</span>).toFile();</span><br><span class="line">SslContext sslContext = GrpcSslContexts.forClient().trustManager(caFile)</span><br><span class="line">        .keyManager(certFile, keyFile).build();</span><br><span class="line">ManagedChannel channel = NettyChannelBuilder.forAddress(<span class="hljs-string">"local.javaboy.org"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .useTransportSecurity()</span><br><span class="line">        .sslContext(sslContext)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>客户端多了 <code>client.crt</code> 和 <code>client.pem</code>，两者的作用根服务端中这两者的作用基本一致，前文已有说明，这里就不再赘述了。</p><p>好啦，如此之后，我们的 gRPC 通信就加上了 TLS 的外壳，更加安全了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥发了一篇文章和小伙伴们仔细聊了聊 TLS、CA 证书这些问题，还没看过的小伙伴可以先戳下面了解下：&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>手把手教小伙伴们使用 Nginx 部署 TienChin 项目！</title>
    <link href="http://www.javaboy.org/2023/0320/tienchin_nginx_deploy.html"/>
    <id>http://www.javaboy.org/2023/0320/tienchin_nginx_deploy.html</id>
    <published>2023-03-20T13:29:55.000Z</published>
    <updated>2023-07-20T13:47:36.384Z</updated>
    
    <content type="html"><![CDATA[<p>TienChin 项目视频已经杀青啦！戳这里<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p><a id="more"></a><p>今天我就来手把手教小伙伴们部署 TienChin 项目，一起把这个项目跑起来，看看到底是个什么样的项目。</p><p>小伙伴们知道，对于这种前后端分离的项目，我们在实际部署的时候，可以按照前后端分离的方式来部署，也可以按照前后端不分的方式来部署。接下来两种不同的部署方式我都和小伙伴们来分享一下。</p><h2 id="1-前后端分离部署"><a href="#1-前后端分离部署" class="headerlink" title="1. 前后端分离部署"></a>1. 前后端分离部署</h2><h3 id="1-1-部署架构图"><a href="#1-1-部署架构图" class="headerlink" title="1.1 部署架构图"></a>1.1 部署架构图</h3><p>前后端分离部署的话，我们一般是需要一个 Nginx 服务器，我先画一个简单的部署示意图给大家参考下：</p><p><img src="http://img.itboyhub.com/2022/08/前后端分离部署架构图-2222.png" alt></p><p>简单解释一下就是这样：</p><ol><li>浏览器发出请求。</li><li>请求首先到达 Nginx 服务器，Nginx 服务器，由 Nginx 服务器进行请求分发。</li><li>如果是一个静态资源请求，则 Nginx 将之转发到静态资源服务器上，一般可能由 Nginx 自己兼任静态资源服务器，也就是直接从 Nginx 自己硬盘上将数据读取出来。</li><li>如果是一个动态资源，则 Nginx 将之转发到 Tomcat 上，对于我们这里就是我们的 Spring Boot 服务上了，当然，如果你没有这么多服务器，我们可以将 Nginx 和 Spring Boot 部署到同一台服务器上。</li></ol><p>好了，这就是我们的大致的一个部署架构图了，很简单。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2 准备工作"></a>1.2 准备工作</h3><p>接下来有几个事情是需要我们提前准备的。</p><p>首先我们先在服务器上安装好 MySQL 和 Redis，这个具体怎么安装我这里就不啰嗦了，基操而已。</p><blockquote><p>MySQL 建议大家用 Docker 安装，省事。如果不懂 Docker，可以在公众号后台回复 Docker 有松哥写的入门教程；Redis 可以直接安装，松哥在之前的 vhr 系列教程中包含有 Redis 教程，可以公众号后台回复 vhr 查看详情。</p></blockquote><p>这样我们的准备工作就完成了。</p><h3 id="1-3-开始部署"><a href="#1-3-开始部署" class="headerlink" title="1.3 开始部署"></a>1.3 开始部署</h3><h4 id="1-3-1-拉取项目"><a href="#1-3-1-拉取项目" class="headerlink" title="1.3.1 拉取项目"></a>1.3.1 拉取项目</h4><p>首先我们需要从 GitHub 上拉取我们的项目，TienChin 项目的源代码是开源的，大家可以直接 Clone：</p><ul><li><a href="https://github.com/lenve/tienchin" target="_blank" rel="noopener">https://github.com/lenve/tienchin</a></li></ul><p>直接执行 git clone 即可。</p><p><img src="http://img.itboyhub.com/2022/08/20230319204309.png" alt></p><p>拉取下来之后，有两个文件夹：</p><p><img src="http://img.itboyhub.com/2022/08/20230319204407.png" alt></p><ul><li>tienchin 是服务端代码。</li><li>tienchin-ui 是前端代码。</li></ul><h4 id="1-3-2-修改配置"><a href="#1-3-2-修改配置" class="headerlink" title="1.3.2 修改配置"></a>1.3.2 修改配置</h4><p>首先我们创建一个名为 tienchin 的数据库，这个好说。</p><p>接下来，我们找到 <code>tienchin/sql/tienchin-video_2023-03-13.sql</code> 文件，在 tienchin 数据库中执行该脚本。</p><p>接下来，我们找到 <code>tienchin/tienchin-admin/src/main/resources/application-druid.yml</code> 文件，在该文件中，根据自己的实际情况，修改数据库连接地址、数据库名称、用户名和密码。</p><p>继续打开 <code>tienchin/tienchin-admin/src/main/resources/application.yml</code> 文件，在该文件中配置 Redis 的地址、密码等信息。</p><p>另外还有一个非常重要的配置也需要修改，就是在 <code>tienchin/tienchin-admin/src/main/resources/application.yml</code> 文件中，将 <code>server.servlet.context-path</code> 的值改为 <code>/prod-api</code>。</p><h4 id="1-3-3-服务端打包"><a href="#1-3-3-服务端打包" class="headerlink" title="1.3.3 服务端打包"></a>1.3.3 服务端打包</h4><p>接下来我们进行服务端打包。小伙伴们需要在自己电脑上安装好 Maven 并且配置好环境变量，这也是基本操作，我就不啰嗦了。</p><blockquote><p>如果电脑上还没有配置 Maven 的话，建议使用 IDEA 自带的 Maven 插件，就不用额外下载了。IDEA 自带的 Maven 插件在安装目录下的 <code>plugins/maven</code> 目录下，可以直接配置这里的 bin 目录到环境变量中即可。</p></blockquote><p>服务端打包我们就进入到 tienchin 目录下，然后执行如下代码即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>看到如下代码就表示编译成功了：</p><p><img src="http://img.itboyhub.com/2022/08/20230319205042.png" alt></p><p>编译成功之后，在 <code>tienchin/tienchin-admin/target</code> 目录下，可以看到一个名为 <code>tienchin-admin.jar</code> 的 jar 文件，这就是我们所需要的服务端代码。</p><h4 id="1-3-4-前端打包"><a href="#1-3-4-前端打包" class="headerlink" title="1.3.4 前端打包"></a>1.3.4 前端打包</h4><p>接下来进入到 <code>tienchin-ui</code> 目录下，执行如下命令安装依赖（注意，前端需要 NodeJS 至少 14 往上的版本）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后再执行如下命令进行编译打包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 目录，里边的文件就是我们所需要的静态资源文件：</p><p><img src="http://img.itboyhub.com/2022/08/20230319213219.png" alt></p><p>这样，前端代码就打包完成了。</p><h4 id="1-3-5-安装-Nginx"><a href="#1-3-5-安装-Nginx" class="headerlink" title="1.3.5 安装 Nginx"></a>1.3.5 安装 Nginx</h4><p>接下来我们来安装 Nginx，我这里直接下载 Nginx 源码进行编译安装，步骤如下：</p><ol><li>首先安装如下两个编译工具</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib-devel</span><br><span class="line">yum -y install pcre pcre-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>下载 Nginx 源码并解压。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>编译安装</li></ol><p>进入到 nginx 解压目录中，分别执行如下命令进行编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>如此之后，我们的 Nginx 就安装好了。</p><h4 id="1-3-6-配置-Nginx"><a href="#1-3-6-配置-Nginx" class="headerlink" title="1.3.6 配置 Nginx"></a>1.3.6 配置 Nginx</h4><p>接下来我们首先通过命令或者文件上传工具，先把刚刚打包的后端的 tienchin-admin.jar 和前端的 dist 目录上传到服务器上面来。</p><p>接下来，我们首先启动服务端这个 <code>tienchin-admin.jar</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar tienchin-admin.jar &gt; tienchin.log &amp;</span><br></pre></td></tr></table></figure><p>有的小伙伴在服务端部署的时候，会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20230319220500.png" alt></p><p>这个是因为服务端缺乏相应的字体，而 Flowable 在自动生成部署图片的时候，需要用到这些字体，所以我们安装需要的字体即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install fontconfig</span><br><span class="line">fc-cache --force</span><br></pre></td></tr></table></figure><p>服务端启动成功之后，我们先用 postman 测试一下登录接口，确保能运行，就说明服务端部署成功：</p><p><img src="http://img.itboyhub.com/2022/08/20230319220933.png" alt></p><p>能成功登录，就说明服务端部署成功。</p><p>接下来部署前端。</p><p>前端部署很简单，我们只需要将 dist 中的内容拷贝到 nginx 的 html 目录下即可，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp dist/* /usr/local/nginx/html/</span><br></pre></td></tr></table></figure><p>接下来执行如下命令启动 nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>nginx 启动成功之后，就可以浏览器中访问页面了：</p><p><img src="http://img.itboyhub.com/2022/08/20230319221933.png" alt></p><p>当然，现在还登录不了，因为还缺少 Nginx 的请求转发，现在当我们请求 Nginx 的时候可以看到前端页面，但是服务端的数据请求，Nginx 并不会自动转发到 Spring Boot 上面去，所以还需要我们继续配置 Nginx，Nginx 配置文件的位置在 <code>/usr/local/nginx/conf/nginx.conf</code>，我们增加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /prod-api &#123;</span><br><span class="line">       proxy_pass http://127.0.0.1:8080;</span><br><span class="line">       tcp_nodelay     on;</span><br><span class="line">       proxy_set_header Host            $host;</span><br><span class="line">       proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">       root /usr/local/nginx/html/;</span><br><span class="line">       expires 30d;</span><br><span class="line">       try_files $uri $uri/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个配置参数的含义，我给大家稍微解释下：</p><ul><li>try_files：由于我们的前端 Vue 导航是 history 模式，这个不同于 vhr 的 hash 模式，history 模式会把请求路径发到 Nginx 上去找，很明显 Ngnix 找不到这样的路径，所以 try_files 就是说如果 404 了，就默认展示 index.html 页面即可，然后具体的路由导航由 vue-router 去完成。</li><li>tcp_nodelay：启动 TCP_NODELAY，其实就是禁用 Nagle 算法，允许小包的发送。对于延时敏感型，同时数据传输量比较小的应用，开启 TCP_NODELAY 选项无疑是一个正确的选择。Nagle 算法是先把数据缓存起来，攒到一块发送。</li></ul><p>配置完成后，重启 Nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>好啦，这次重启之后，就可以顺利玩耍啦～</p><p><img src="http://img.itboyhub.com/2022/08/20230319225414.png" alt></p><h2 id="2-前后端不分部署"><a href="#2-前后端不分部署" class="headerlink" title="2. 前后端不分部署"></a>2. 前后端不分部署</h2><p>前后端不分部署相对就简单一些，不需要 Nginx 了，不过前面 <code>1.3.1-1.3.4</code> 也是需要的。</p><p>1.3.4 小节中，我们拿到前端编译打包后的内容后，直接放到 tienchin-admin 模块的 static 静态资源目录下，然后继续将服务端打成 jar 包，将 jar 包上传到服务器并启动即可，启动命令和 1.3.6 小节介绍的 jar 包启动命令一致，这个过程比较简单，涉及到的相关命令前面都有介绍，我就不重复展示了。</p><p>最后，对 TienChin 项目感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TienChin 项目视频已经杀青啦！戳这里&lt;a href=&quot;https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TienChin 项目配套视频来啦&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>TienChin 项目视频完结啦~</title>
    <link href="http://www.javaboy.org/2023/0316/tienchin_video_finish.html"/>
    <id>http://www.javaboy.org/2023/0316/tienchin_video_finish.html</id>
    <published>2023-03-16T13:29:43.000Z</published>
    <updated>2023-07-20T13:47:40.046Z</updated>
    
    <content type="html"><![CDATA[<p>感谢小伙伴们长时间的等待，上周末我们的 TienChin 项目视频终于迎来了大结局~</p><a id="more"></a><p>一年时间，周末都不能好好休息，出去玩心里也总是惦记个事，现在好啦，更完啦，一共 433 集约 87 个小时，跟小伙伴们在网上看到的其他同类课程相比，性价比应该都是比较高的了。</p><p>跟大家再来介绍一下 TienChin 项目：</p><p>TienChin 项目是一个健身会员管理系统，基于 RuoYi-Vue 脚手架来做，使用 Spring Boot + Vue3 开发，不同于之前的 vhr 是一个脚手架，TienChin 项目的业务完成度会超过 90%。这个项目的视频教程整体上分为两大块：第一块主要是解剖 RuoYi-Vue 脚手架，让小伙伴们能够熟练掌握这个脚手架的使用，在这个过程中，我会讲许多技术点，前面列出来的视频目录都属于这一部分的内容，这个过程中我不会带领大家从头敲一遍 RuoYi-Vue 脚手架，但是对项目里边的一些技术点，会有针对性的讲解，也会写一些案例来帮助大家理解这些技术点。第二块内容则主要是业务功能的完成了，业务功能涉及到的技术点主要有：SpringBoot、Vue、MyBatis Plus、MySQL、Redis、Flowable、EasyExcel 等。</p><p>因为视频已经杀青了，按照之前的约定，价格要稍微调整一下，毕竟现在买的是现货不是期货了，从今天开始，我们的视频要打八折销售啦~八折就是 ￥319，另外，凡是购买过 vhr 的小伙伴，无论何时入手 TienChin，都在现价的基础上再优惠 30。</p><p>视频更完了，这么好的事情，我们也做一个小小的活动吧：<strong>今明两天购买视频的小伙伴（时间截止到 2023.03.17 23:59:59），可以参与松哥发起的一个抽奖活动，奖品是技术图书，包邮到家，中奖率是 20%。</strong></p><blockquote><p>奖品池有一半是我的签名图书，即《Spring Boot+Vue全栈开发实战》和《深入浅出 Spring Security》；另一半不是我写的书，但都是全新未拆封的技术相关的新书，即奖品是从我列出的书中选择。</p></blockquote><p>TienChin 项目视频基本上都是工作之余录制的，一开始是早上 6-8 点之间录的，时间久了起太早有点吃不消就改成了周末录，牺牲了太多休息时间，所以是付费视频，视频定价是 399，目前可以 8 折上车，也就是 319，之前买过 vhr 的小伙伴可在此基础上再优惠 30。</p><p>录视频还是蛮辛苦的，一方面赚点小钱养家糊口，另一方面也是小伙伴们的认可在支撑着我把这件事做下去，得瑟一下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/996.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/995.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/013.jpeg" alt></p><p><strong>有时候看小伙伴们发的，我真的特别动容。虽然大家看我天天写文章聊技术，其实我在生活中除了工作之外很少和人交流，真的特别想给这些爱学习会说话的小伙伴们点赞，他们肯定会混的比我好。</strong></p><hr><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在 TienChin 项目视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。和 vhr 视频相比，现在的 TienChin 项目视频音质是杠杠滴，下面三个视频是我最近发过的，小伙伴们可以当作试看的视频：</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过）。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>其实如果单纯带着大家写业务功能，这个项目不会花太多时间，这样虽然大家完整的做了一个项目，但是技术却不会有太多长进，而我则希望在这个过程中多整点活，能让小伙伴们技术也有一些提升，这样内容一加，最终何时更完就不确定了。不过，有一点是可以保证的，每周至少一次，每周至少更一个半小时精品视频。</p><p><strong>Q6：知识星球是什么？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问，小伙伴们购买视频后，我会拉你进星球。</p><p><strong>Q7：这套视频适合哪些人看？</strong></p><p>学习这套视频，首先需要有 SSM 基础，如果没有，可以在公众号后台回复 SSM，有我录制的免费视频教程；另外也需要一些 Spring Boot 基础和 Vue 基础，要是没接触过 Spring Boot 和 Vue 的话，那么建议先看看 vhr，戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频我能学到啥？</strong></p><p>TienChin 项目基于 RuoYi-Vue 脚手架（Spring Boot+Vue3），这套视频学完后，小伙伴们对 RuoYi-Vue 脚手架基本上就融会贯通了，并能在 RuoYi-Vue 脚手架上随心所欲的开发常规的企业后台应用。并且对于分布式事务 seata、Flowable 流程引擎等框架也能熟练使用并掌握其原理，对于 Redis 在项目中的各种实际应用场景也会有较好的掌握。</p><hr><p><strong>好啦，8 折 319 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，转账 319 上车吧（买过 vhr 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢小伙伴们长时间的等待，上周末我们的 TienChin 项目视频终于迎来了大结局~&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>TLS、SSL、CA 证书、公钥、私钥。。。今天捋一捋！</title>
    <link href="http://www.javaboy.org/2023/0315/tls_ssl_ca.html"/>
    <id>http://www.javaboy.org/2023/0315/tls_ssl_ca.html</id>
    <published>2023-03-15T13:29:29.000Z</published>
    <updated>2023-07-20T13:47:47.148Z</updated>
    
    <content type="html"><![CDATA[<p>松哥最近在和小伙伴们连载 gRPC，如何确保 gRPC 通信的安全性？这就涉及到 TSL 了，但是考虑到可能有小伙伴对加密连接这一整套方案比较陌生，因此我们今天先用一篇文章跟大家捋清楚这些概念，概念搞明白了，再来看 TSL+gRPC 就很容易了。</p><a id="more"></a><h2 id="1-HTTP-的问题"><a href="#1-HTTP-的问题" class="headerlink" title="1. HTTP 的问题"></a>1. HTTP 的问题</h2><p>HTTP 协议是超文本传输协议（Hyper Text Transfer Protocol）的缩写，它是从 WEB 服务器传输超文本标记语言 HTML 到本地浏览器的传送协议。HTTP 设计之初是为了提供一种发布和接收 HTML 页面的方法，时至今日，它的作用已经不仅仅于此了。</p><p>对于我们 Java 工程师而言，HTTP 应该算是再熟悉不过的东西了，目前 HTTP 有多个版本，使用较多的是 HTTP/1.1 版本。</p><p>然而 HTTP 协议有一个缺陷那就是它是通过明文传输数据的，用户通过 HTTP 协议传输的内容很容易被恶意拦截，并且黑客可以伪装成服务端，向用户传送错误的信息，并且能轻易获取用户的隐私信息，而这些操作用户是完全无感知的。</p><p>由于存在这样的安全隐患，现在小伙伴们见到的大部分网站都在逐步转为 HTTPS，HTTP 网站会越来越少了。</p><h2 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2. HTTPS"></a>2. HTTPS</h2><p>HTTPS（HyperText Transfer Protocol Secure）中文译作超文本传输安全协议，这是一种通过计算机网络进行安全通讯的传输协议。</p><p>HTTPS 本质上还是由 HTTP 进行通信，只是在 HTTP 协议和 TCP 层之间增加了一个 SSL 的安全传输协议。整个传输的加密过程都在新的安全层 SSL/TLS 中实现，而原来的 HTTP 层的传输流程保持不变，这样就很好地兼容了旧的 HTTP 协议，也沿袭了 TCP/IP 协议族的分层思想。</p><p>通过 HTTPS，客户端可以确认服务端的身份，保证数据在传输过程中不被篡改，当我们在自己的浏览器上与某一个网站建立 HTTPS 连接的时候，满足如下情况可以表示这个服务端可以被信任：</p><ol><li>首先我们的操作系统中安装了正确且受信任的证书。我们在 cmd 命令行中执行 <code>certmgr.msc</code> 命令，可以查看操作系统已经安装的证书列表。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230314195612.png" alt></p><ol start="2"><li>浏览器本身正确实现了 HTTPS。</li><li>被访问的网站提供了一个证书，这个证书是由一个操作系统所信任的证书颁发机构签发的，操作系统所信任的证书颁发机构一般都预装在操作系统中，通过第一步的方式可以查看。</li><li>被访问的网站所提供的证书被成功认证。</li></ol><p>这里边涉及到一些证书和协议的概念，接下来松哥和大家把整个过程捋一捋。</p><h2 id="3-TLS-SSL"><a href="#3-TLS-SSL" class="headerlink" title="3. TLS/SSL"></a>3. TLS/SSL</h2><p>前面我们提到，HTTPS 就是在 HTTP 的基础之上增加了 TLS/SSL，那么这两个东西该如何理解呢？</p><p>SSL/TLS 是一种密码通信方案，算是目前使用最广泛的密码通信方案了。SSL 全称是 Secure Socket Layer，中文译作安全套接层，是 1994 年由 Netscape 公司设计的一套协议，并与 1995 年发布了 3.0 版本；TLS 全称是 Transport Layer Security，中文译作传输层安全，则是 IETF 在 SSL3.0 基础上设计的协议，实际上相当于 SSL 的后续版本，目前 TLS 先后迭代了 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 和 <code>TLS 1.3</code>，目前被广泛使用的是 <code>TLS 1.2</code> 版本。</p><p>SSL/TLS 涉及到了密码学中的对称加密、非对称加密、数字签名等等，算是密码学领域里的集大成者了。</p><h3 id="3-1-TLS"><a href="#3-1-TLS" class="headerlink" title="3.1 TLS"></a>3.1 TLS</h3><p>接下来我们就来看看 TLS 如何确保 HTTP 安全。</p><p>为了确保客户端和服务端之间的数据安全，我们很容易想到一种方案就是对传输的数据进行加密，没错，这是一个办法，事实上也是这么做的。</p><p>加密又分为两种：</p><ol><li>对称加密</li><li>非对称加密</li></ol><p>那么该使用哪一种呢？</p><p>对称加密，也就是加密密钥和解密密钥是同一个，当浏览器和服务端需要进行通信的时候，约定好一个密钥，然后使用这个密钥对发送的消息进行加密，对方收到消息之后再使用相同的密钥对消息进行解密。但是，在 B/S 架构的项目中，这种方案显然不合适，一个网站把自己的密钥告诉全世界所有的浏览器，那加密和不加密还有区别吗？</p><p>有小伙伴可能又想到了不对称加密，不对称加密倒是个办法，因为不对称加密是有一个密钥对公钥和私钥，公钥可以公布出来告诉所有人，私钥只有自己知道。通信的时候，客户端首先使用公钥对消息进行加密，服务端收到之后，再通过私钥对消息进行解密，这看起来似乎挺完美的。但是！！！非对称加密存在一个问题，就是非对称加密和解密相当耗时，通过这种方式处理加解密效率太低。</p><p>那怎么办？我们可以将两者结合起来。</p><p>具体来说，就是这样：<strong>首先服务端会生成一个非对称加密的密钥对，私钥自己保存，公钥发送给客户端，客户端拿到这个公钥之后，再生成一个对称加密的密钥，然后把对称加密的密钥通过公钥进行加密，加密之后发送给服务端，服务端通过私钥进行解密，这样客户端和服务端就可以通过对称加密进行通信了。</strong></p><p>事实上，TLS 大致上的思路就是这样的。</p><p>不过上面这个方案还是有一个漏洞，那就是服务端要通过明文传输的方式把公钥发送给客户端，这个过程还是不安全的，可能被人恶意截胡，那么这个问题该如何解决呢？</p><p>这就涉及到另外一个概念叫做数字证书了。</p><h3 id="3-2-CA"><a href="#3-2-CA" class="headerlink" title="3.2 CA"></a>3.2 CA</h3><p>数字证书是一个<strong>包含了目标网站各种信息如网站域名、证书有效期、签发机构、用于生成对称密钥的公钥、上级证书签发的签名等</strong>的文件，通过数字证书我们可以确认一个用户或者服务站点的身份。</p><p>实际场景中的数字证书是一系列的，形成了一个信任链，信任链的最顶端是 CA。</p><p>CA 是 Certificate Authority 的简写，它是一个负责发放和管理数字的证书的第三方权威机构。CA 的工作流程是这样的：</p><ol><li>CA 自己给自己颁发的用自己的私钥签名的证书称为根证书，根证书的私钥安全性至关重要，根证书的私钥都是被保存在离线计算机中，有严格的操作规章，每次需要使用时，会有专人将数据通过 USB 拷贝过去，操作完了以后，再将数据带出来（这个专指 CA 根证书的私钥）。</li><li>一个用户想要获取一个证书，首先自己得有一个密钥对，私钥自己留着，公钥以及其他信息发送给 CA，向 CA 提出申请，CA 判明用户的身份之后，会将这个公钥和用户的身份信息绑定，并且为绑定后的信息进行签名（签名是通过 CA 根证书的私钥进行的），最后将签名后的证书发给申请者。</li><li>一个用户想要鉴定一个证书的真伪，就通过 CA 的公钥对证书上的数字签名进行验证，验证通过，就认为这个这个证书是有效的。</li></ol><p><strong>上面这个流程中有一个重要前提，那就是 CA 受到大家所有人的信任。</strong></p><p>然而在实际操作中，我们并不能直接去跟 CA 申请一个数字证书，因为全世界要认证的内容太多了，CA 搞不过来，而且频繁的找 CA 申请，还有可能导致私钥泄漏，这可就是一个大的灾难了。</p><p>那怎么办呢？实际操作中，我们可以基于 CA 来构建一个信任链。具体来说，步骤是这样：</p><ol><li>首先我们的手机、笔记本等操作系统中都预装了 CA 颁发的根证书，他们是所有信任构建的基石，前面松哥已经截图给大家看了 Windows 中预装的根证书了。</li><li>假设 CA 签发了一个证书 A，在这个过程中 CA 称为 Issuer，A 称为 Subject，假设 A 是一个受信任的中间证书，已经预装在我们的操作系统中了。现在由 A 利用它自己的私钥给某一个网站签发了一个证书 B。</li><li>现在当我们的电脑需要访问该网站的时候，该网站就会给我们发来一个证书 B，由于我们的浏览器并不知道 B 证书是否合法，但是我们的电脑上已经预装了 A 证书，我们可以从 A 证书中提取出 A 的公钥，然后利用 A 的公钥对 B 证书的签名进行验证（因为 B 证书的签名是 A 的私钥签的），如果验证通过了，就说明 B 是合法的。</li><li>相同的道理，B 也可以继续签发 C 证书，C 继续签发 D 证书，这样就形成了一个信任链。</li><li>如果服务端的签名是 D 证书，那么一般来说，服务器返回给浏览器的就会包含 B、C、D 三个证书（因为 A 证书已经在我们的电脑上了），即使只返回 D 证书，浏览器也可以根据 D 书中的信息，自动下载到 B、C 两个证书然后进行验证。</li></ol><blockquote><p>松哥记得以前上大学的时候，在 12306 网站上买火车票，第一次访问的时候必须要自己先手动安装一个根证书到系统中，然后才能访问。这就是因为当时 12306 所使用的证书的签发机构不被浏览器认可，类似于上面的第 3 步，12306 给我发了一个数字证书 B 回来，但是浏览器上没有合适的公钥对这个 B 证书进行验证，当我往自己的系统上安装了 12306 给的证书之后，相当于我的电脑上有了一个证书 A，现在就可以对 B 证书进行验证了。</p></blockquote><p>总结一下：</p><ol><li>CA 是一个权威的机构，是一个发证机关，CA 发出来的证书可以证明一个人或者组织的身份。</li><li>任何人都可以得到 CA 的证书（含公钥），用以验证 CA 所签发的证书。</li><li>每一个数字证书都是由上级证书的私钥来签发的，处于最顶层的就是 CA 签发的根证书了，这个根证书没有上级证书了，所以这个根证书实际上是由 CA 自己的私钥来签发的，这也叫做自签名，即 Self-Signed。</li></ol><p>当我们有了数字签名之后，就可以解决 3.1 小节最后提出的问题了。服务端将数字签名发给浏览器，浏览器利用系统已经内置的公钥验签，确认签名没问题，然后就提取出来数字签名中的公钥，开始协商对称加密的私钥了～</p><p>好啦，有了这些知识储备之后，下篇文章松哥来和大家聊一聊 TLS+gRPC 怎么玩！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥最近在和小伙伴们连载 gRPC，如何确保 gRPC 通信的安全性？这就涉及到 TSL 了，但是考虑到可能有小伙伴对加密连接这一整套方案比较陌生，因此我们今天先用一篇文章跟大家捋清楚这些概念，概念搞明白了，再来看 TSL+gRPC 就很容易了。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 中的异常该如何处理？</title>
    <link href="http://www.javaboy.org/2023/0303/grpc_exception.html"/>
    <id>http://www.javaboy.org/2023/0303/grpc_exception.html</id>
    <published>2023-03-03T13:29:17.000Z</published>
    <updated>2023-07-20T13:47:50.355Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和小伙伴们聊一聊该如何处理 gRPC 中遇到的异常。</p><a id="more"></a><p>在之前的几篇文章中，其实我们也遇到过异常问题，只是当时没有和小伙伴们细说，只是囫囵吞枣写了一个案例而已，今天我们就来把这个话题跟小伙伴们仔细捋一捋。</p><p>我们之前写过一个登录的案例，在之前的案例中，如果用户在登录时输入了错误的用户名密码的话，那么我们是通过一个普通的数据流返回异常信息，其实，对于异常信息，我们可以通过专门的异常通道来写回到客户端。</p><h2 id="1-服务端处理异常"><a href="#1-服务端处理异常" class="headerlink" title="1. 服务端处理异常"></a>1. 服务端处理异常</h2><p>先来看看服务端如何处理异常。</p><p>还是以我们之前的 gRPC 登录案例为例，我们修改服务端的登录逻辑如下（完整代码小伙伴们可以参考之前的 <a href="https://mp.weixin.qq.com/s/jIZrP-H3DmS9pvRD5QaTfA" target="_blank" rel="noopener">手把手教大家在 gRPC 中使用 JWT 完成身份校验</a> 一文）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onError(Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"login error"</span>).asException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，在登录失败时我们通过 <code>responseObserver.onError</code> 方法将异常信息写回到客户端。这个方法的参数是一个 Throwable 对象，对于这个对象，在 Status 这个枚举类中定义了一些常见的值，分别如下：</p><ul><li>OK(0)：请求成功。</li><li>CANCELLED(1)：操作被取消。</li><li>UNKNOWN(2)：未知错误。</li><li>INVALID_ARGUMENT(3)：客户端给了无效的请求参数。</li><li>DEADLINE_EXCEEDED(4)：请求超过了截止时间。</li><li>NOT_FOUND(5)：请求资源未找到。</li><li>ALREADY_EXISTS(6)：添加的内容已经存在。</li><li>PERMISSION_DENIED(7)：请求权限不足。</li><li>RESOURCE_EXHAUSTED(8)：资源耗尽。</li><li>FAILED_PRECONDITION(9)：服务端上为准备好。</li><li>ABORTED(10)：请求被中止。</li><li>OUT_OF_RANGE(11)：请求超出范围。</li><li>UNIMPLEMENTED(12)：未实现的操作。</li><li>INTERNAL(13)：服务内部错误。</li><li>UNAVAILABLE(14)：服务不可用。</li><li>DATA_LOSS(15)：数据丢失或者损毁。</li><li>UNAUTHENTICATED(16)：请求未认证。</li></ul><p>系统默认给出的请求类型大致上就这些。当然，如果这些并不能满足你的需求，我们也可以扩展这个枚举类。</p><h2 id="2-客户端处理异常"><a href="#2-客户端处理异常" class="headerlink" title="2. 客户端处理异常"></a>2. 客户端处理异常</h2><p>当服务端给出异常信息之后，客户端的处理分为两种情况。</p><h3 id="2-1-异步请求"><a href="#2-1-异步请求" class="headerlink" title="2.1 异步请求"></a>2.1 异步请求</h3><p>如果客户端是异步请求，则直接在异常回调中处理即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，直接在 onError 回到中处理异常即可。</p><h3 id="2-2-同步请求"><a href="#2-2-同步请求" class="headerlink" title="2.2 同步请求"></a>2.2 同步请求</h3><p>如果客户端请求是同步阻塞请求，那么就要通过异常捕获的方式获取服务端返回的异常信息了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"1234"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步阻塞请求就通过异常捕获去获取服务端返回的异常信息即可。</p><h2 id="3-题外话"><a href="#3-题外话" class="headerlink" title="3. 题外话"></a>3. 题外话</h2><p>最后，再来和小伙伴们说一个提高 gRPC 数据传输效率的小技巧，那就是传输的数据可以使用 gzip 进行压缩。</p><p>具体处理方式就是在客户端调用 <code>withCompression</code> 方法指定数据压缩，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceBlockingStub stub = LoginServiceGrpc.newBlockingStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceBlockingStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            LoginResponse resp = stub.withCompression(<span class="hljs-string">"gzip"</span>).login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build());</span><br><span class="line">            System.out.println(<span class="hljs-string">"resp.getToken() = "</span> + resp.getToken());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，一个关于 gRPC 的小小知识点～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和小伙伴们聊一聊该如何处理 gRPC 中遇到的异常。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC为什么使用截止时间而不是超时时间？</title>
    <link href="http://www.javaboy.org/2023/0301/grpc_deadline.html"/>
    <id>http://www.javaboy.org/2023/0301/grpc_deadline.html</id>
    <published>2023-03-01T13:29:03.000Z</published>
    <updated>2023-07-20T13:47:53.324Z</updated>
    
    <content type="html"><![CDATA[<p>在 HTTP 请求中，我们发送请求的时候，可以设置一个请求超时时间-connectTimeout，即在指定的时间内，如果请求没有到达服务端，为了避免客户端一直进行不必要的等待，就会抛出一个请求超时异常。</p><a id="more"></a><p>但是在微服务系统中，我们却很少设置请求超时时间，一般都是用另外一个概念代替，那就是请求截止时间。</p><p>这是什么原因呢？今天我们就来简单聊一聊这个话题。</p><p>在微服务中我们客户端的请求在服务端往往会有比较复杂的链条，我想起来 Spring Cloud Sleuth 官方给的一个请求链路追踪的图，我们直接拿来看下：</p><p><img src="https://i.328888.xyz/2023/04/04/ijoAso.jpeg" alt></p><p>这张图中，请求从客户端发起之后，在服务端一共经历了四个 SERVICE，对于这样的请求，如果我们还是按照之前发送普通 HTTP 请求的方式，设置一个 connectTimeout 显然是不够的。</p><p>我举个例子：</p><p>假设我们发送一个请求，为该请求设置 connectTimeout 为 5s，那么这个时间只对第一个服务 SERVICE1 有效，也就是请求在 5s 之内没有到达 SERVICE1，那么就会抛出连接超时异常；请求如果在 5s 之内到达 SERVICE1，那么就不会抛出异常，但是！！！，请求到达 SERVICE1 并不意味着请求结束，后面从 SERVICE1 到 SERVICE2，从 SERVICE2 到 SERVICE3，从 SERVICE3 到 SERVICE4，还有四个 HTTP 请求待处理，这些请求超时了怎么办？很明显，connectTimeout 属性对于后面几个请求就鞭长莫及了。</p><p>所以，对于这种场景，我们一般使用截止时间来处理。</p><p>截止时间相当于设置<strong>整个请求生命周期</strong>的时间，也就是这个请求，我要多久拿到结果。很明显，这个时间应该在客户端发起请求的时候设置。</p><p>gRPC 中提供了对应的方法，我们可以非常方便的设置请求的截止时间 DeadLineTime，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel).withDeadline(Deadline.after(<span class="hljs-number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable = "</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过 Thread.sleep 做个简单的休眠就行了，超时之后，客户端的 onError 方法会被触发，抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable = io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 2.939621462s. [closed=[], open=[[buffered_nanos=285550823, remote_addr=localhost/127.0.0.1:50051]]]</span><br></pre></td></tr></table></figure><p>好啦，一个简单的小细节，感兴趣的小伙伴不妨去试试啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 HTTP 请求中，我们发送请求的时候，可以设置一个请求超时时间-connectTimeout，即在指定的时间内，如果请求没有到达服务端，为了避免客户端一直进行不必要的等待，就会抛出一个请求超时异常。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>手把手教大家在 gRPC 中使用 JWT 完成身份校验</title>
    <link href="http://www.javaboy.org/2023/0222/grpc_jwt.html"/>
    <id>http://www.javaboy.org/2023/0222/grpc_jwt.html</id>
    <published>2023-02-22T13:28:52.000Z</published>
    <updated>2023-07-20T13:49:12.944Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上篇文章松哥和小伙伴们聊了在 gRPC 中如何使用拦截器，这些拦截器有服务端拦截器也有客户端拦截器，这些拦截器的一个重要使用场景，就是可以进行身份的校验。当客户端发起请求的时候，服务端通过拦截器进行身份校验，就知道这个请求是谁发起的了。今天松哥就来通过一个具体的案例，来和小伙伴们演示一下 gRPC 如何结合 JWT 进行身份校验。</p><a id="more"></a><h2 id="1-JWT-介绍"><a href="#1-JWT-介绍" class="headerlink" title="1. JWT 介绍"></a>1. JWT 介绍</h2><h3 id="1-1-无状态登录"><a href="#1-1-无状态登录" class="headerlink" title="1.1 无状态登录"></a>1.1 无状态登录</h3><h4 id="1-1-1-什么是有状态"><a href="#1-1-1-什么是有状态" class="headerlink" title="1.1.1 什么是有状态"></a>1.1.1 什么是有状态</h4><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h4 id="1-1-2-什么是无状态"><a href="#1-1-2-什么是无状态" class="headerlink" title="1.1.2 什么是无状态"></a>1.1.2 什么是无状态</h4><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-2-如何实现无状态"><a href="#1-2-如何实现无状态" class="headerlink" title="1.2 如何实现无状态"></a>1.2 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-3-JWT"><a href="#1-3-JWT" class="headerlink" title="1.3 JWT"></a>1.3 JWT</h3><h4 id="1-3-1-简介"><a href="#1-3-1-简介" class="headerlink" title="1.3.1 简介"></a>1.3.1 简介</h4><p>JWT，全称是 Json Web Token， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-3-2-JWT数据格式"><a href="#1-3-2-JWT数据格式" class="headerlink" title="1.3.2 JWT数据格式"></a>1.3.2 JWT数据格式</h4><p>JWT 包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul></li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><ul><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><ul><li>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</li></ul><p>生成的数据格式如下图：</p><p><img src="http://img.itboyhub.com/2021/springboot2/37-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-3-3-JWT-交互流程"><a href="#1-3-3-JWT-交互流程" class="headerlink" title="1.3.3 JWT 交互流程"></a>1.3.3 JWT 交互流程</h4><p>流程图：</p><p> <img src="http://img.itboyhub.com/2021/springboot2/37-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如 API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了 RESTful 的无状态规范。</p><h4 id="1-3-4-JWT-存在的问题"><a href="#1-3-4-JWT-存在的问题" class="headerlink" title="1.3.4 JWT 存在的问题"></a>1.3.4 JWT 存在的问题</h4><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><blockquote><p>当然，为了解决 JWT 存在的问题，也可以将 JWT 结合 Redis 来用，服务端生成的 JWT 字符串存入到 Redis 中并设置过期时间，每次校验的时候，先看 Redis 中是否存在该 JWT 字符串，如果存在就进行后续的校验。但是这种方式有点不伦不类（又成了有状态了）。</p></blockquote><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>我们来看下 gRPC 如何结合 JWT。</p><h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><p>首先我先给大家看下我的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── grpc_api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── grpc_server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>还是跟之前文章中的一样，三个模块，grpc_api 用来存放一些公共的代码。</p><p>grpc_server 用来放服务端的代码，我这里服务端主要提供了两个接口：</p><ol><li>登录接口，登录成功之后返回 JWT 字符串。</li><li>hello 接口，客户端拿着 JWT 字符串来访问 hello 接口。</li></ol><p>grpc_client 则是我的客户端代码。</p><h3 id="2-2-grpc-api"><a href="#2-2-grpc-api" class="headerlink" title="2.2 grpc_api"></a>2.2 grpc_api</h3><p>我将 protocol buffers 和一些依赖都放在 grpc_api 模块中，因为将来我的 grpc_server 和 grpc_client 都将依赖 grpc_api。</p><p>我们来看下这里需要的依赖和插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.21.7:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.51.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的依赖和插件松哥在本系列的第一篇文章中都已经介绍过了，唯一不同的是，这里引入了 JWT 插件，JWT 我使用了比较流行的 JJWT 这个工具。JJWT 松哥在之前的文章和视频中也都有介绍过，这里就不再啰嗦了。</p><p>先来看看我的 Protocol Buffers 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.api&quot;;</span><br><span class="line">option java_outer_classname = &quot;LoginProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package login;</span><br><span class="line"></span><br><span class="line">service LoginService &#123;</span><br><span class="line">  rpc login (LoginBody) returns (LoginResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService&#123;</span><br><span class="line">  rpc sayHello(google.protobuf.StringValue) returns (google.protobuf.StringValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginBody &#123;</span><br><span class="line">  string username = 1;</span><br><span class="line">  string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LoginResponse &#123;</span><br><span class="line">  string token = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过前面几篇文章的介绍，这里我就不多说啦，就是定义了两个服务：</p><ul><li>LoginService：这个登录服务，传入用户名密码，返回登录成功之后的令牌。</li><li>HelloService：这个就是一个打招呼的服务，传入字符串，返回也是字符串。</li></ul><p>定义完成之后，生成对应的代码即可。</p><p>接下来再定义一个常量类供 grpc_server 和 grcp_client 使用，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthConstant</span> </span>&#123;</span><br><span class="line">    SecretKey JWT_KEY = Keys.hmacShaKeyFor(<span class="hljs-string">"hello_javaboy_hello_javaboy_hello_javaboy_hello_javaboy_"</span>.getBytes());</span><br><span class="line">    Context.Key&lt;String&gt; AUTH_CLIENT_ID = Context.key(<span class="hljs-string">"clientId"</span>);</span><br><span class="line">    String AUTH_HEADER = <span class="hljs-string">"Authorization"</span>;</span><br><span class="line">    String AUTH_TOKEN_TYPE = <span class="hljs-string">"Bearer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的每个常量我都给大家解释下：</p><ol><li>JWT_KEY：这个是生成 JWT 字符串以及进行 JWT 字符串校验的密钥。</li><li>AUTH_CLIENT_ID：这个是客户端的 ID，即客户端发送来的请求携带了 JWT 字符串，通过 JWT 字符串确认了用户身份，就存在这个变量中。</li><li>AUTH_HEADER：这个是携带 JWT 字符串的请求头的 KEY。</li><li>AUTH_TOKEN_TYPE：这个是携带 JWT 字符串的请求头的参数前缀，通过这个可以确认参数的类型，常见取值有 Bearer 和 Basic。</li></ol><p>如此，我们的 gRPC_api 就定义好了。</p><h3 id="2-3-grpc-server"><a href="#2-3-grpc-server" class="headerlink" title="2.3 grpc_server"></a>2.3 grpc_server</h3><p>接下来我们来定义 gRPC_server。</p><p>首先来定义登录服务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginServiceGrpc</span>.<span class="hljs-title">LoginServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginBody request, StreamObserver&lt;LoginResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String username = request.getUsername();</span><br><span class="line">        String password = request.getPassword();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"javaboy"</span>.equals(username) &amp;&amp; <span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login success"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录成功</span></span><br><span class="line">            String jwtToken = Jwts.builder().setSubject(username).signWith(AuthConstant.JWT_KEY).compact();</span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(jwtToken).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"login error"</span>);</span><br><span class="line">            <span class="hljs-comment">//登录失败</span></span><br><span class="line">            responseObserver.onNext(LoginResponse.newBuilder().setToken(<span class="hljs-string">"login error"</span>).build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省事起见，我这里没有连接数据库，用户名和密码固定为 javaboy 和 123。</p><p>登录成功之后，就生成一个 JWT 字符串返回。</p><p>登录失败，就返回一个 login error 字符串。</p><p>再来看我们的 HelloService 服务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloServiceGrpc</span>.<span class="hljs-title">HelloServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(StringValue request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String clientId = AuthConstant.AUTH_CLIENT_ID.get();</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(clientId + <span class="hljs-string">" say hello:"</span> + request.getValue()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个服务就更简单了，不啰嗦。唯一值得说的是 <code>AuthConstant.AUTH_CLIENT_ID.get();</code> 表示获取当前访问用户的 ID，这个用户 ID 是在拦截器中存入进来的。</p><p>最后，我们来看服务端比较重要的拦截器，我们要在拦截器中从请求头中获取到 JWT 令牌并解析，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> JwtParser parser = Jwts.parser().setSigningKey(AuthConstant.JWT_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler)</span> </span>&#123;</span><br><span class="line">        String authorization = metadata.get(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER));</span><br><span class="line">        Status status = Status.OK;</span><br><span class="line">        <span class="hljs-keyword">if</span> (authorization == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"miss authentication token"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authorization.startsWith(AuthConstant.AUTH_TOKEN_TYPE)) &#123;</span><br><span class="line">            status = Status.UNAUTHENTICATED.withDescription(<span class="hljs-string">"unknown token type"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Jws&lt;Claims&gt; claims = <span class="hljs-keyword">null</span>;</span><br><span class="line">            String token = authorization.substring(AuthConstant.AUTH_TOKEN_TYPE.length()).trim();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                claims = parser.parseClaimsJws(token);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                status = Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (claims != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                Context ctx = Context.current()</span><br><span class="line">                        .withValue(AuthConstant.AUTH_CLIENT_ID, claims.getBody().getSubject());</span><br><span class="line">                <span class="hljs-keyword">return</span> Contexts.interceptCall(ctx, serverCall, metadata, serverCallHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverCall.close(status, <span class="hljs-keyword">new</span> Metadata());</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerCall.Listener&lt;ReqT&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑应该好理解：</p><ol><li>首先从 Metadata 中提取出当前请求所携带的 JWT 字符串（相当于从请求头中提取出来）。</li><li>如果第一步提取到的值为 null 或者这个值不是以指定字符 Bearer 开始的，说明这个令牌是一个非法令牌，设置对应的响应 status 即可。</li><li>如果令牌都没有问题的话，接下来就进行令牌的校验，校验失败，则设置相应的 status 即可。</li><li>校验成功的话，我们就会获取到一个 Jws<claims> 对象，从这个对象中我们可以提取出来用户名，并存入到 Context 中，将来我们在 HelloServiceImpl 中就可以获取到这里的用户名了。</claims></li><li>最后，登录成功的话，<code>Contexts.interceptCall</code> 方法构建监听器并返回；登录失败，则构建一个空的监听器返回。</li></ol><p>最后，我们再来看看启动服务端：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        LoginServer server = <span class="hljs-keyword">new</span> LoginServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="hljs-keyword">new</span> LoginServiceImpl())</span><br><span class="line">                .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> HelloServiceImpl(), <span class="hljs-keyword">new</span> AuthInterceptor()))</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LoginServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟之前的相比就多加了一个 Service，添加 HelloServiceImpl 服务的时候，多加了一个拦截器，换言之，登录的时候，请求是不会被这个认证拦截器拦截的。</p><p>好啦，这样我们的 grpc_server 就开发完成了。</p><h3 id="2-4-grpc-client"><a href="#2-4-grpc-client" class="headerlink" title="2.4 grpc_client"></a>2.4 grpc_client</h3><p>接下来我们来看 grpc_client。</p><p>先来看登录：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        login(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(LoginServiceGrpc.LoginServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.login(LoginBody.newBuilder().setUsername(<span class="hljs-string">"javaboy"</span>).setPassword(<span class="hljs-string">"123"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(LoginResponse loginResponse)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"loginResponse.getToken() = "</span> + loginResponse.getToken());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法直接调用就行了，看过前面几篇 gRPC 文章的话，这里都很好理解。</p><p>再来看 hello 接口的调用，这个接口调用需要携带 JWT 字符串，而携带 JWT 字符串，则需要我们构建一个 CallCredentials 对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtCredential</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallCredentials</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtCredential</span><span class="hljs-params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyRequestMetadata</span><span class="hljs-params">(RequestInfo requestInfo, Executor executor, MetadataApplier metadataApplier)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Metadata headers = <span class="hljs-keyword">new</span> Metadata();</span><br><span class="line">                headers.put(Metadata.Key.of(AuthConstant.AUTH_HEADER, Metadata.ASCII_STRING_MARSHALLER),</span><br><span class="line">                        String.format(<span class="hljs-string">"%s %s"</span>, AuthConstant.AUTH_TOKEN_TYPE, subject));</span><br><span class="line">                metadataApplier.apply(headers);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                metadataApplier.fail(Status.UNAUTHENTICATED.withCause(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisUsesUnstableApi</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将请求的 JWT 令牌放入到请求头中即可。</p><p>最后来看看调用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        LoginServiceGrpc.LoginServiceStub stub = LoginServiceGrpc.newStub(channel);</span><br><span class="line">        sayHello(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(ManagedChannel channel)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        HelloServiceGrpc.HelloServiceStub helloServiceStub = HelloServiceGrpc.newStub(channel);</span><br><span class="line">        helloServiceStub</span><br><span class="line">                .withCallCredentials(<span class="hljs-keyword">new</span> JwtCredential(<span class="hljs-string">"eyJhbGciOiJIUzM4NCJ9.eyJzdWIiOiJqYXZhYm95In0.IMMp7oh1dl_trUn7sn8qiv9GtO-COQyCGDz_Yy8VI4fIqUcRfwQddP45IoxNovxL"</span>))</span><br><span class="line">                .sayHello(StringValue.newBuilder().setValue(<span class="hljs-string">"wangwu"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"throwable.getMessage() = "</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的登录令牌就是前面调用 login 方法时获取到的令牌。</p><p>好啦，大功告成。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>上面的登录与校验只是松哥给小伙伴们展示的一个具体案例而已，在此案例基础之上，我们还可以扩展出来更多写法，但是万变不离其宗，其他玩法就需要小伙伴们自行探索啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上篇文章松哥和小伙伴们聊了在 gRPC 中如何使用拦截器，这些拦截器有服务端拦截器也有客户端拦截器，这些拦截器的一个重要使用场景，就是可以进行身份的校验。当客户端发起请求的时候，服务端通过拦截器进行身份校验，就知道这个请求是谁发起的了。今天松哥就来通过一个具体的案例，来和小伙伴们演示一下 gRPC 如何结合 JWT 进行身份校验。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 gRPC 中的拦截器</title>
    <link href="http://www.javaboy.org/2023/0215/grpc_interceptor.html"/>
    <id>http://www.javaboy.org/2023/0215/grpc_interceptor.html</id>
    <published>2023-02-15T13:28:39.000Z</published>
    <updated>2023-07-20T13:49:19.142Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们继续 gRPC 系列。</p><p>前面松哥跟大家聊了 gRPC 的简单案例，也说了四种不同的通信模式，感兴趣的小伙伴可以戳这里：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">一个简单的案例入门 gRPC</a></li><li><a href="https://mp.weixin.qq.com/s/c-_D2RpLksIlYJDfaWOSkA" target="_blank" rel="noopener">聊一聊 gRPC 的四种通信模式</a></li></ol><p>今天我们来继续聊一聊 gRPC 中的拦截器。</p><p>有请求的发送、处理，当然就会有拦截器的需求，例如在服务端通过拦截器统一进行请求认证等操作，这些就需要拦截器来完成，今天松哥先和小伙伴们来聊一聊 gRPC 中拦截器的基本用法，后面我再整一篇文章和小伙伴们做一个基于拦截器实现的 JWT 认证的 gRPC。</p><p>gRPC 中的拦截器整体上来说可以分为两大类：</p><ol><li>服务端拦截器</li><li>客户端拦截器</li></ol><p>我们分别来看。</p><h2 id="1-服务端拦截器"><a href="#1-服务端拦截器" class="headerlink" title="1. 服务端拦截器"></a>1. 服务端拦截器</h2><p>服务端拦截器的作用有点像我们 Java 中的 Filter，服务端拦截器又可以继续细分为<strong>一元拦截器</strong>和<strong>流拦截器</strong>。</p><p>一元拦截器对应我们上篇文章中所讲的一元 RPC，也就是一次请求，一次响应这种情况。</p><p>流拦截器则对应我们上篇文章中所讲的服务端流 RPC、客户端流 RPC 以及双向流 RPC。</p><p>不过，在 Java 代码中，无论是一元拦截器还是流拦截器，代码其实都是一样的。不过如果你是用 Go 实现的 gRPC，那么这块是不一样的。</p><p>所以接下来的内容我就不去区分一元拦截器和流拦截器了，我们直接来看一个服务端拦截器的例子。</p><p>这里我就不从头开始写了，我们直接在上篇文章的基础之上继续添加拦截器即可。</p><p>服务端拦截器工作位置大致如下：</p><p><img src="http://img.itboyhub.com/2022/08/grpc-server-interceptor.drawio.png" alt></p><p>从这张图中小伙伴们可以看到，我们可以在服务端处理请求之前将请求拦截下来，统一进行权限校验等操作，也可以在服务端将请求处理完毕之后，准备响应的时候将响应拦截下来，可以对响应进行二次处理。</p><p>首先我们来看请求拦截器，实际上是一个监听器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCallListener</span>&lt;<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCallListener</span>&lt;<span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCall.Listener&lt;R&gt; delegate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceCallListener</span><span class="hljs-params">(ServerCall.Listener&lt;R&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> ServerCall.<span class="hljs-function">Listener&lt;R&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(R message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是客户端发来的消息，可以在这里进行预处理："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.onMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们自定义一个类，继承自 ForwardingServerCallListener 类，在这里重写 onMessage 方法，当有请求到达的时候，就会经过这里的 onMessage 方法。如果我们需要对传入的参数进行验证等操作，就可以在这里完成。</p><p>再来看看响应拦截器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ForwardingServerCall</span>.<span class="hljs-title">SimpleForwardingServerCall</span>&lt;<span class="hljs-title">ReqT</span>,<span class="hljs-title">RespT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BookServiceCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> ServerCall&lt;ReqT, RespT&gt; <span class="hljs-title">delegate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.delegate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodDescriptor&lt;ReqT, RespT&gt; <span class="hljs-title">getMethodDescriptor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getMethodDescriptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(RespT message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"这是服务端返回给客户端的消息："</span>+message);</span><br><span class="line">        <span class="hljs-keyword">super</span>.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可能发现了，我这里用到了很多泛型，请求类型和响应类型都不建议指定具体类型，因为拦截器可能会拦截多种类型的请求，请求参数和响应的数据类型都不一定一样。</p><p>这里是重写 sendMessage 方法，在这个方法中我们可以对服务端准备返回给客户端的消息进行预处理。</p><p>所以这个位置就相当于<strong>响应拦截器</strong>。</p><p>最后，我们需要在启动服务的时候，将这两个拦截器配置进去，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(ServerInterceptors.intercept(<span class="hljs-keyword">new</span> BookServiceImpl(), <span class="hljs-keyword">new</span> ServerInterceptor() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="hljs-function">Listener&lt;ReqT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next)</span> </span>&#123;</span><br><span class="line">                    String fullMethodName = call.getMethodDescriptor().getFullMethodName();</span><br><span class="line">                    System.out.println(fullMethodName + <span class="hljs-string">":pre"</span>);</span><br><span class="line">                    Set&lt;String&gt; keys = headers.keys();</span><br><span class="line">                    <span class="hljs-keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                        System.out.println(key + <span class="hljs-string">"&gt;&gt;&gt;"</span> + headers.get(Metadata.Key.of(key, ASCII_STRING_MARSHALLER)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BookServiceCallListener&lt;&gt;(next.startCall(<span class="hljs-keyword">new</span> BookServiceCall(call), headers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            .build()</span><br><span class="line">            .start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        BookServiceServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我之前服务启动的方法，以前我们调用 addService 方法的时候，直接添加对应的服务就可以了，现在，我们除了添加之前的 BookServiceImpl 服务之外，还额外给了一个拦截器。</p><p>每当请求到达的时候，就会经过拦截器的 interceptCall 方法，这个方法有三个参数：</p><ul><li>第一个参数 call 是消费传入的 RPC 消息的一个回调。</li><li>第二个参数 headers 则是请求的消息头，如果我们通过 JWT 进行请求校验，那么就从这个 headers 中提取出请求的 JWT 令牌然后进行校验。</li><li>第三个参数 next 就类似于我们在 Java 过滤器 filter 中的 filterChain 一样，让这个请求继续向下走。</li></ul><p>在这个方法中，我们请求头的信息都打印出来给小伙伴们参考了。然后在返回值中，将我们刚刚写的请求拦截器和响应拦截器构建并返回。</p><p>好啦，这样我们的服务端拦截器就搞好啦～无论是一元的 RPC 消息还是流式的 RPC 消息，都会经过这个拦截器，响应也是一样。</p><h2 id="2-客户端拦截器"><a href="#2-客户端拦截器" class="headerlink" title="2. 客户端拦截器"></a>2. 客户端拦截器</h2><p>客户端拦截器就比较简单了，客户端拦截器可以将我们的请求拦截下来，例如我们如果想为所有请求添加统一的令牌 Token，那么就可以在这里来做，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .intercept(<span class="hljs-keyword">new</span> ClientInterceptor() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;ReqT, RespT&gt; <span class="hljs-function">ClientCall&lt;ReqT, RespT&gt; <span class="hljs-title">interceptCall</span><span class="hljs-params">(MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, Channel next)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line">                callOptions = callOptions.withAuthority(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> next.newCall(method,callOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br></pre></td></tr></table></figure><p>当我们的请求执行的时候，这个客户端拦截器就会被触发。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和小伙伴们简单介绍一下服务端拦截器和客户端拦截器。下篇文章，松哥会通过一个 JWT 认证来和小伙伴们演示这个拦截器的具体用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们继续 gRPC 系列。&lt;/p&gt;
&lt;p&gt;前面松哥跟大家聊了 gRPC 的简单案例，也说了四种不同的通信模式，感兴趣的小伙伴可以戳这里：&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 gRPC 的四种通信模式</title>
    <link href="http://www.javaboy.org/2023/0209/grpc_4_channel.html"/>
    <id>http://www.javaboy.org/2023/0209/grpc_4_channel.html</id>
    <published>2023-02-09T13:28:28.000Z</published>
    <updated>2023-07-20T13:48:06.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>温馨提示：本文需要结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上一篇 gRPC 文章</a>一起食用，否则可能看不懂。</p></blockquote><p>前面一篇文章松哥和大家聊了 gRPC 的基本用法，今天我们再来稍微深入一点点，来看下 gRPC 中四种不同的通信模式。</p><a id="more"></a><p>gRPC 中四种不同的通信模式分别是：</p><ol><li>一元 RPC</li><li>服务端流 RPC</li><li>客户端流 RPC</li><li>双向流 RPC</li></ol><p>接下来松哥就通过四个完整的案例，来分别和向伙伴们演示这四种不同的通信模式。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>关于 gRPC 的基础知识我们就不啰嗦了，咱们直接来看我今天的 proto 文件，如下：</p><p>这次我新建了一个名为 book.proto 的文件，这里主要定义了一些图书相关的方法，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.demo&quot;;</span><br><span class="line">option java_outer_classname = &quot;BookServiceProto&quot;;</span><br><span class="line">import &quot;google/protobuf/wrappers.proto&quot;;</span><br><span class="line"></span><br><span class="line">package book;</span><br><span class="line"></span><br><span class="line">service BookService &#123;</span><br><span class="line">  rpc addBook(Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc getBook(google.protobuf.StringValue) returns (Book);</span><br><span class="line">  rpc searchBooks(google.protobuf.StringValue) returns (stream Book);</span><br><span class="line">  rpc updateBooks(stream Book) returns (google.protobuf.StringValue);</span><br><span class="line">  rpc processBooks(stream google.protobuf.StringValue) returns (stream BookSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated string tags = 2;</span><br><span class="line">  string name = 3;</span><br><span class="line">  float price = 4;</span><br><span class="line">  string author = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message BookSet &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  repeated Book bookList = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件中，有一些内容我们在<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>中都讲过了，讲过的我就不再重复了，我说一些<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有涉及到的东西：</p><ol><li>由于我们在这个文件中，引用了 Google 提供的 StringValue（<code>google.protobuf.StringValue</code>），所以这个文件上面我们首先用 import 导入相关的文件，导入之后，才可以使用。</li><li>在方法参数和返回值中出现的 stream，就表示这个方法的参数或者返回值是流的形式（其实就是数据可以多次传输）。</li><li>message 中出现了一个<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>没有的关键字 repeated，这个表示这个字段可以重复，可以简单理解为这就是我们 Java 中的数组。</li></ol><p>好了，和<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>相比，本文主要就是这几个地方不一样。</p><p>proto 文件写好之后，按照<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>介绍的方法进行编译，生成对应的代码，这里就不再重复了。</p><h2 id="2-一元-RPC"><a href="#2-一元-RPC" class="headerlink" title="2. 一元 RPC"></a>2. 一元 RPC</h2><p>一元 RPC 是一种比较简单的 RPC 模式，其实说白了我们<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>和大家介绍的就是一种一元 RPC，也就是客户端发起一个请求，服务端给出一个响应，然后请求结束。</p><p>上面我们定义的五个方法中，addBook 和 getBook 都算是一种一元 RPC。</p><h3 id="2-1-addBook"><a href="#2-1-addBook" class="headerlink" title="2.1 addBook"></a>2.1 addBook</h3><p>先来看 addBook 方法，这个方法的逻辑很简单，我们提前在服务端准备一个 Map 用来保存 Book，addBook 调用的时候，就把 book 对象存入到 Map 中，并且将 book 的 ID 返回，大家就这样一件事，来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book request, StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        bookMap.put(request.getId(), request);</span><br><span class="line">        responseObserver.onNext(StringValue.newBuilder().setValue(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>的小伙伴，我觉得这段代码应该很好理解。</p><p>客户端调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        addBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.addBook(Book.newBuilder().setPrice(<span class="hljs-number">99</span>).setId(<span class="hljs-string">"100"</span>).setName(<span class="hljs-string">"java"</span>).setAuthor(<span class="hljs-string">"javaboy"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"添加完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了 CountDownLatch 来实现线程等待，等服务端给出响应之后，客户端再结束。这里在回调的 onNext 方法中，我们就可以拿到服务端的返回值。</p><h3 id="2-2-getBook"><a href="#2-2-getBook" class="headerlink" title="2.2 getBook"></a>2.2 getBook</h3><p>getBook 跟上面的 addBook 类似，先来看服务端代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        String id = request.getValue();</span><br><span class="line">        Book book = bookMap.get(id);</span><br><span class="line">        <span class="hljs-keyword">if</span> (book != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            responseObserver.onNext(book);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 getBook 就是根据客户端传来的 id，从 Map 中查询到一个 Book 并返回。</p><p>客户端调用代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        getBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.getBook(StringValue.newBuilder().setValue(<span class="hljs-string">"2"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"book = "</span> + book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们大概也能看出来，addBook 和 getBook 基本上操作套路是一模一样的。</p><h2 id="3-服务端流-RPC"><a href="#3-服务端流-RPC" class="headerlink" title="3. 服务端流 RPC"></a>3. 服务端流 RPC</h2><p>前面的一元 RPC，客户端发起一个请求，服务端给出一个响应，请求就结束了。服务端流则是客户端发起一个请求，服务端给一个响应序列，这个响应序列组成一个流。</p><p>上面我们给出的 searchBook 就是这样一个例子，searchBook 是传递图书的 tags 参数，然后在服务端查询哪些书的 tags 满足条件，将满足条件的书全部都返回去。</p><p>我们来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBooks</span><span class="hljs-params">(StringValue request, StreamObserver&lt;Book&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = bookMap.keySet();</span><br><span class="line">        String tags = request.getValue();</span><br><span class="line">        <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Book book = bookMap.get(key);</span><br><span class="line">            <span class="hljs-keyword">int</span> tagsCount = book.getTagsCount();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tagsCount; i++) &#123;</span><br><span class="line">                String t = book.getTags(i);</span><br><span class="line">                <span class="hljs-keyword">if</span> (t.equals(tags)) &#123;</span><br><span class="line">                    responseObserver.onNext(book);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看下，这段 Java 代码应该很好理解：</p><ol><li>首先从 request 中提取客户端传来的 tags 参数。</li><li>遍历 bookMap，查看每一本书的 tags 是否等于客户端传来的 tags，如果相等，说明添加匹配，则通过 <code>responseObserver.onNext(book);</code> 将这本书写回到客户端。</li><li>等所有操作都完成后，执行 <code>responseObserver.onCompleted();</code>，表示服务端的响应序列结束了，这样客户端也就知道请求结束了。</li></ol><p>我们来看看客户端的代码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        searchBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">searchBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        stub.searchBooks(StringValue.newBuilder().setValue(<span class="hljs-string">"明清小说"</span>).build(), <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                System.out.println(book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="hljs-string">"查询完毕！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码好理解，搜索的关键字是 <code>明清小说</code>，每当服务端返回一次数据的时候，客户端回调的 onNext 方法就会被触发一次，当服务端之行了 <code>responseObserver.onCompleted();</code> 之后，客户端的 onCompleted 方法也会被触发。</p><p>这个就是服务端流，客户端发起一个请求，服务端通过 onNext 可以多次写回数据。</p><h2 id="4-客户端流-RPC"><a href="#4-客户端流-RPC" class="headerlink" title="4. 客户端流 RPC"></a>4. 客户端流 RPC</h2><p>客户端流则是客户端发起多个请求，服务端只给出一个响应。</p><p>上面的 updateBooks 就是一个客户端流的案例，客户端想要修改图书，可以发起多个请求修改多本书，服务端则收集多次修改的结果，将之汇总然后一次性返回给客户端。</p><p>我们先来看看服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;Book&gt; <span class="hljs-title">updateBooks</span><span class="hljs-params">(StreamObserver&lt;StringValue&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"更新的图书 ID 为："</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">                bookMap.put(book.getId(), book);</span><br><span class="line">                sb.append(book.getId())</span><br><span class="line">                        .append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                responseObserver.onNext(StringValue.newBuilder().setValue(sb.toString()).build());</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端每发送一本书来，就会触发服务端的 onNext 方法，然后我们在这方法中进行图书的更新操作，并记录更新结果。最后，我们在 onCompleted 方法中，将更新结果汇总返回给客户端，基本上就是这样一个流程。</p><p>我们再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        updateBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;Book&gt; request = stub.updateBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"stringValue.getValue() = "</span> + stringValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"更新完毕"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"a"</span>).setAuthor(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"c"</span>).setAuthor(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端这块，updateBooks 方法会返回一个 StreamObserver<book> 对象，调用该对象的 onNext 方法就是给服务端传递数据了，可以传递多个数据，调用该对象的 onCompleted 方法就是告诉服务端数据传递结束了，此时也会触发服务端的 onCompleted 方法，服务端的 onCompleted 方法执行之后，进而触发了客户端的 onCompleted 方法。</book></p><h2 id="5-双向流-RPC"><a href="#5-双向流-RPC" class="headerlink" title="5. 双向流 RPC"></a>5. 双向流 RPC</h2><p>双向流其实就是 3、4 小节的合体。即客户端多次发送数据，服务端也多次响应数据。</p><p>我们先来看下服务端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceGrpc</span>.<span class="hljs-title">BookServiceImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book b1 = Book.newBuilder().setId(<span class="hljs-string">"1"</span>).setName(<span class="hljs-string">"三国演义"</span>).setAuthor(<span class="hljs-string">"罗贯中"</span>).setPrice(<span class="hljs-number">30</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b2 = Book.newBuilder().setId(<span class="hljs-string">"2"</span>).setName(<span class="hljs-string">"西游记"</span>).setAuthor(<span class="hljs-string">"吴承恩"</span>).setPrice(<span class="hljs-number">40</span>).addTags(<span class="hljs-string">"志怪小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        Book b3 = Book.newBuilder().setId(<span class="hljs-string">"3"</span>).setName(<span class="hljs-string">"水浒传"</span>).setAuthor(<span class="hljs-string">"施耐庵"</span>).setPrice(<span class="hljs-number">50</span>).addTags(<span class="hljs-string">"明清小说"</span>).addTags(<span class="hljs-string">"通俗小说"</span>).build();</span><br><span class="line">        bookMap.put(<span class="hljs-string">"1"</span>, b1);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"2"</span>, b2);</span><br><span class="line">        bookMap.put(<span class="hljs-string">"3"</span>, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;StringValue&gt; <span class="hljs-title">processBooks</span><span class="hljs-params">(StreamObserver&lt;BookSet&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;StringValue&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(StringValue stringValue)</span> </span>&#123;</span><br><span class="line">                Book b = Book.newBuilder().setId(stringValue.getValue()).build();</span><br><span class="line">                books.add(b);</span><br><span class="line">                <span class="hljs-keyword">if</span> (books.size() == <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                    BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                    responseObserver.onNext(bookSet);</span><br><span class="line">                    books.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                BookSet bookSet = BookSet.newBuilder().addAllBookList(books).build();</span><br><span class="line">                responseObserver.onNext(bookSet);</span><br><span class="line">                books.clear();</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有实际意义，单纯为了给小伙伴们演示双向流，我的操作逻辑是客户端传递多个 ID 到服务端，然后服务端根据这些 ID 构建对应的 Book 对象，然后三个三个一组，再返回给客户端。客户端每次发送一个请求，都会触发服务端的 onNext 方法，我们在这个方法中对请求分组返回。最后如果还有剩余的请求，我们在 onCompleted() 方法中返回。</p><p>再来看看客户端的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        BookServiceGrpc.BookServiceStub stub = BookServiceGrpc.newStub(channel);</span><br><span class="line">        processBook(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBook</span><span class="hljs-params">(BookServiceGrpc.BookServiceStub stub)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line">        StreamObserver&lt;StringValue&gt; request = stub.processBooks(<span class="hljs-keyword">new</span> StreamObserver&lt;BookSet&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(BookSet bookSet)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"bookSet = "</span> + bookSet);</span><br><span class="line">                System.out.println(<span class="hljs-string">"============="</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"处理完毕！"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"a"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"b"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"c"</span>).build());</span><br><span class="line">        request.onNext(StringValue.newBuilder().setValue(<span class="hljs-string">"d"</span>).build());</span><br><span class="line">        request.onCompleted();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端的代码跟第四小节一模一样，不再赘述了。</p><p>好啦，这就是松哥和小伙伴们介绍的 gRPC 的四种不同的通信模式，文章中只给出了一些关键代码，如果小伙伴们没看明白，建议结合<a href="https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw" target="_blank" rel="noopener">上篇文章</a>一起阅读就懂啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;温馨提示：本文需要结合&lt;a href=&quot;https://mp.weixin.qq.com/s/OyfU0tLm4f9t3nZxce-Ksw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇 gRPC 文章&lt;/a&gt;一起食用，否则可能看不懂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面一篇文章松哥和大家聊了 gRPC 的基本用法，今天我们再来稍微深入一点点，来看下 gRPC 中四种不同的通信模式。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的案例入门 gRPC</title>
    <link href="http://www.javaboy.org/2023/0207/grpc_demo.html"/>
    <id>http://www.javaboy.org/2023/0207/grpc_demo.html</id>
    <published>2023-02-07T13:28:17.000Z</published>
    <updated>2023-07-20T13:48:10.194Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章本来要在年前和小伙伴们见面，但是因为我之前的 Mac 系统版本是 10.13.6，这个版本比较老，时至今天在运行一些新鲜玩意的时候有时候会有一些 BUG（例如运行最新版的 Nacos 等），运行 gRPC 的插件也有 BUG，代码总是生成有问题，但是因为系统升级是一个大事，所以一直等到过年放假，在家才慢慢折腾将 Mac 升级到目前的 13.1 版本，之前这些问题现在都没有了，gRPC 的案例现在也可以顺利跑起来了。</p><a id="more"></a><p>所以今天就来和小伙伴们简单聊一聊 gRPC。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>我为什么想写一篇 gRPC 的文章呢？其实本来我是想和小伙伴们梳理一下在微服务中都有哪些跨进城调用的方式，在梳理的过程中想到了 gRPC，发现还没写文章和小伙伴们聊过 gRPC，因此打算先来几篇文章和小伙伴们详细介绍一下 gRPC，然后再梳理微服务中的跨进程方案。</p><h2 id="2-什么是-gRPC"><a href="#2-什么是-gRPC" class="headerlink" title="2. 什么是 gRPC"></a>2. 什么是 gRPC</h2><p>了解 gRPC 之前先来看看什么是 RPC。</p><p>RPC 全称是 Remote Procedure Call，中文一般译作远程过程调用。RPC 是一种进程间的通信模式，程序分布在不同的地址空间里。简单来说，就是两个进程之间互相调用的一种方式。</p><p>gRPC 则是一个由 Google 发起的开源的 RPC 框架，它是一个高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。gRPC 通过对负载均衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和数据中心之间的服务。</p><p>在 gRPC 中，客户端应用程序可以直接调用部署在不同机器上的服务端应用程序中的方法，就好像它是本地对象一样，使用 gRPC 可以更容易地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定基于参数和返回类型远程调用的方法。在服务端侧，服务端实现接口，运行 gRPC 服务，处理客户端调用。在客户端侧，客户端拥有存根（Stub，在某些语言中称为客户端），它提供与服务端相同的方法。</p><p><img src="https://p3.ssl.qhimg.com/t01a1f4adda646f3a99.png" alt></p><p>gRPC 客户端和服务端可以在各种环境中运行和相互通信 – 从 Google 内部的服务器到你自己的桌面 – 并且可以使用 gRPC 支持的任何语言编写。因此，你可以轻松地用 Java 创建 gRPC 服务端，使用 Go、Python 或 Ruby 创建客户端。此外，最新的 Google API 将包含 gRPC 版本的接口，使你轻松地将 Google 功能构建到你的应用程序中。</p><p>gRPC 支持的语言版本：</p><p><img src="http://img.itboyhub.com/2022/08/20230204214656.png" alt></p><p>说了这么多，还是得整两个小案例小伙伴们可能才会清晰，所以我们也不废话了，上案例。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>先来看下我们的项目结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── grpc-api</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">├── grpc-client</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">├── grpc-server</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>大家看下，这里首先有一个 grpc-api，这个模块用来放我们的公共代码；grpc-server 是我们的服务端，grpc-client 则是我们的客户端，这些都是普通的 maven 项目。</p><h3 id="3-1-grpc-api"><a href="#3-1-grpc-api" class="headerlink" title="3.1 grpc-api"></a>3.1 grpc-api</h3><p>在 grpc-api 中，我们首先引入项目依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.grpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>grpc-stub<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.52.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- necessary for Java 9+ --&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotations-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.53<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这些常规的依赖之外，还需要一个插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.21.7:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.51.0:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我来说一下这个插件的作用。</p><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 提供的一个成熟的开源的跨平台的序列化数据结构的协议，我们编写对应的 proto 文件，通过上面这个插件可以将我们编写的 proto 文件自动转为对应的 Java 类。</p><blockquote><p>多说一句，使用 Protocol Buffers 并不是必须的，也可以使用 JSON 等，但是目前来说这个场景更常用的还是 Portal Buffers。</p></blockquote><p>接下来我们在 main 目录下新建 proto 文件夹，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230204220245.png" alt></p><p>注意，这个文件夹位置是默认的。如果我们的 proto 文件不是放在 src/main/proto 位置，那么在配置插件的时候需要指定 proto 文件的位置，咱们本篇文章主要是入门，我这里就使用默认的位置。</p><p>在 proto 文件夹中，我们新建一个 product.proto 文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;org.javaboy.grpc.demo&quot;;</span><br><span class="line">option java_outer_classname = &quot;ProductProto&quot;;</span><br><span class="line"></span><br><span class="line">package product;</span><br><span class="line"></span><br><span class="line">service ProductInfo &#123;</span><br><span class="line">  rpc addProduct (Product) returns (ProductId);</span><br><span class="line">  rpc getProduct(ProductId) returns(Product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Product &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  string name=2;</span><br><span class="line">  string description=3;</span><br><span class="line">  float price=4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ProductId &#123;</span><br><span class="line">  string value = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置算是一个比较核心的配置了，这里主要说明了负责进程传输的类、方法等到底是个啥样子：</p><ol><li><code>syntax = &quot;proto3&quot;;</code>：这个是 protocol buffers 的版本。</li><li><code>option java_multiple_files = true;</code>：这个字段是可选的，如果设置为 true，表示每一个 message 文件都会有一个单独的 class 文件；否则，message 全部定义在 outerclass 文件里。</li><li><code>option java_package = &quot;org.javaboy.grpc.demo&quot;;</code>：这个字段是可选的，用于标识生成的 java 文件的 package。如果没有指定，则使用 proto 里定义的 package，如果package 也没有指定，那就会生成在根目录下。</li><li><code>option java_outer_classname = &quot;ProductProto&quot;;</code>：这个字段是可选的，用于指定 proto 文件生成的 java 类的 outerclass 类名。什么是 outerclass？简单来说就是用一个 class 文件来定义所有的 message 对应的 Java 类，这个 class 就是 outerclass；如果没有指定，默认是 proto 文件的驼峰式；</li><li><code>package product;</code>：这个属性用来定义 message 的包名。包名的含义与平台语言无关，这个 package 仅仅被用在 proto 文件中用于区分同名的 message 类型。可以理解为 message 全名的前缀，和 message 名称合起来唯一标识一个 message 类型。当我们在 proto 文件中导入其他 proto 文件的 message，需要加上 package 前缀才行。所以包名是用来唯一标识 message 的。</li><li><code>service</code>：我们定义的跨平台方法都写在 service 中，上面的案例中我们定义了两个方法：addProduct 表示添加一件商品，参数是一个 Product 对象，返回值则是刚刚添加成功的商品的 ID；getProduct 则表示根据 ID 查询一个商品，参数是一个商品 ID，返回值则是查询到的商品对象。这里的定义相当于一个接口，将来我们要在 Java 代码中实现这个接口。</li><li><code>message</code>：这里有点像我们在 Java 中定义类，上文中我们定义了两个类，分别是 Product 和 ProductId 两个类。这两个类在 service 中被使用。</li></ol><p>message 中定义的有点像我们 Java 中定义的类，但是不能直接使用 Java 中的数据类型，毕竟这是 Protocol buffers，这个是和语言无关的，将来可以据此生成不同语言的代码，这里我们可以使用的类型和我们 Java 类型之间的对应关系如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203256.png" alt></p><p>另外我们在 message 中定义的属性的时候，都会给一个数字，例如 id=1，name=2 等，这个数字将来会在二进制消息中标识我们的字段，并且一旦我们的消息类型被使用就不应更改，这个有点像序列化的感觉。</p><p>实际上，这个 message 编译后的字节内容大概像下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/grpc-message-compile-struct-2.png" alt></p><p>这里的标签中的内容包含两部分，字段索引和字段类型，字段索引其实就是我们上面定义的数字。</p><p>定义完成之后，接下来我们就需要使用插件来生成对应的 Java 代码了，插件我们在前面已经引入了，现在只需要执行了，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203542.png" alt></p><p>注意，compile 和 compile-custom 两个指令都需要执行。其中 compile 用来编译消息对象，compile-custom 则依赖消息对象,生成接口服务。</p><p>首先我们点击 compile 看看生成的代码，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206203927.png" alt></p><p>再看 compile-custom 生成的代码，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230206204200.png" alt></p><p>好了，这样我们的准备工作就算完成了。</p><blockquote><p>有的小伙伴生成的代码文件夹颜色不对劲，此时有两种解决办法：1.选中目标文件夹，右键单击，选择 Mark Directory as-&gt; Generated Sources root；2.选中工程，右键单击，选择 Maven-&gt;Reload project。推荐使用第二种方案。</p></blockquote><h3 id="3-2-grpc-server"><a href="#3-2-grpc-server" class="headerlink" title="3.2 grpc-server"></a>3.2 grpc-server</h3><p>接下来我们创建 grpc-server 项目，并使该项目依赖 grpc-api，然后在 grpc-server 中，提供 ProductInfo 的具体实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProductInfoGrpc</span>.<span class="hljs-title">ProductInfoImplBase</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProduct</span><span class="hljs-params">(Product request, StreamObserver&lt;ProductId&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"request.toString() = "</span> + request.toString());</span><br><span class="line">        responseObserver.onNext(ProductId.newBuilder().setValue(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getProduct</span><span class="hljs-params">(ProductId request, StreamObserver&lt;Product&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        responseObserver.onNext(Product.newBuilder().setId(request.getValue()).setName(<span class="hljs-string">"三国演义"</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProductInfoGrpc.ProductInfoImplBase</code> 是根据我们在 proto 文件中定义的 service 自动生成的，我们的 ProductInfoImpl 继承自该类，并且提供了我们给出的方法的具体实现。</p><p>以 addProduct 方法为例，参数 request 就是将来客户端调用的时候传来的 Product 对象，返回结果则通过 responseObserver 来完成。我们的方法逻辑很简单，我就把参数传来的 Product 对象打印出来，然后构建一个 ProductId 对象并返回，最后调用 <code>responseObserver.onCompleted();</code> 表示数据返回完毕。</p><p>剩下的 getProduct 方法逻辑就很好懂了，我这里就不再赘述了。</p><p>最后，我们再把这个 grpc-server 项目启动起来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfoServer</span> </span>&#123;</span><br><span class="line">    Server server;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ProductInfoServer server = <span class="hljs-keyword">new</span> ProductInfoServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> port = <span class="hljs-number">50051</span>;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(<span class="hljs-keyword">new</span> ProductInfoImpl())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            ProductInfoServer.<span class="hljs-keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blockUntilShutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (server != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们这里是一个 JavaSE 项目，为了避免项目启动之后就停止，我们这里调用了 <code>server.awaitTermination();</code> 方法，就是让服务启动成功之后不要停止。</p><h3 id="3-3-grpc-client"><a href="#3-3-grpc-client" class="headerlink" title="3.3 grpc-client"></a>3.3 grpc-client</h3><p>最后再来看看客户端的调用。首先 grpc-client 项目也是需要依赖 grpc-api 的，然后直接进行方法调用，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">50051</span>)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        ProductInfoGrpc.ProductInfoBlockingStub stub = ProductInfoGrpc.newBlockingStub(channel);</span><br><span class="line">        Product p = Product.newBuilder().setId(<span class="hljs-string">"1"</span>)</span><br><span class="line">                .setPrice(<span class="hljs-number">399.0f</span>)</span><br><span class="line">                .setName(<span class="hljs-string">"TienChin项目"</span>)</span><br><span class="line">                .setDescription(<span class="hljs-string">"SpringBoot+Vue3实战视频"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        ProductId productId = stub.addProduct(p);</span><br><span class="line">        System.out.println(<span class="hljs-string">"productId.getValue() = "</span> + productId.getValue());</span><br><span class="line">        Product product = stub.getProduct(ProductId.newBuilder().setValue(<span class="hljs-string">"99999"</span>).build());</span><br><span class="line">        System.out.println(<span class="hljs-string">"product.toString() = "</span> + product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里首先需要和服务端建立连接，给出服务端的地址和端口号即可，usePlaintext() 方法表示不使用 TLS 对连接进行加密（默认情况下会使用 TLS 对连接进行加密），生产环境建议使用加密连接。</p><p>剩下的代码就比较好懂了，创建 Product 对象，调用 addProduct 方法进行添加；创建 ProductId 对象，调用 getProduct。Product 对象和 ProductId 对象都是根据我们在 proto 中定义的 message 自动生成的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>好啦，一个简单的例子，小伙伴们先对 gRPC 入个门，后面松哥会再整几篇文章跟大家介绍这里边的一些细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章本来要在年前和小伙伴们见面，但是因为我之前的 Mac 系统版本是 10.13.6，这个版本比较老，时至今天在运行一些新鲜玩意的时候有时候会有一些 BUG（例如运行最新版的 Nacos 等），运行 gRPC 的插件也有 BUG，代码总是生成有问题，但是因为系统升级是一个大事，所以一直等到过年放假，在家才慢慢折腾将 Mac 升级到目前的 13.1 版本，之前这些问题现在都没有了，gRPC 的案例现在也可以顺利跑起来了。&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://www.javaboy.org/categories/gRPC/"/>
    
    
      <category term="TLS" scheme="http://www.javaboy.org/tags/TLS/"/>
    
      <category term="gRPC" scheme="http://www.javaboy.org/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>还在用 OpenFeign？来试试 SpringBoot3 中的这个新玩意！</title>
    <link href="http://www.javaboy.org/2023/0201/httpexchange.html"/>
    <id>http://www.javaboy.org/2023/0201/httpexchange.html</id>
    <published>2023-02-01T13:28:03.000Z</published>
    <updated>2023-07-20T13:47:28.308Z</updated>
    
    <content type="html"><![CDATA[<p>年过完啦，松哥也已经搬砖搬了三天了。</p><a id="more"></a><p>疫情放开后，今年这个年格外的轻松惬意，心中一种特别压抑的东西被除去了，新闻中看到各地游人如织、西安大唐不夜城游人摩肩接踵，真的好像回到了 2019 年一样，朋友圈中也都是喜气洋洋，生活还是很美好的。</p><p>好久没发技术文章了，最近回到工作地，晚上有空又可以码码技术了，今天我们就来聊一个 Spring Boot3 中的新鲜玩意，声明式 HTTP 调用。</p><h2 id="1-由来"><a href="#1-由来" class="headerlink" title="1. 由来"></a>1. 由来</h2><p>Spring Boot3 去年底就已经正式发布，我也尝了一把鲜，最近有空会和小伙伴们慢慢聊聊 Spring Boot3 都给我们带来了哪些新东西。</p><p>今天我们就先来看看声明式 HTTP 接口。</p><p>用过 Spring Cloud 的小伙伴都知道，在 Spring Cloud 家族中，负责进程间通信的，我们可以使用 RestTemplate 或者 OpenFeign（当然也有其他方式如基于消息中间件的消息驱动的微服务或者基于 gRPC 的调用等）。</p><p>RestTemplate 我们可以将之当作一个普普通通的 HTTP 调用工具来对待，区别于其他的 HTTP 客户端，RestTemplate 用来调用 RESTful 风格的接口特别方便。</p><p>不过，比 RestTemplate 更加方便的是 OpenFeign，通过接口声明就可以实现远程调用，这些的具体用法松哥在之前的视频中讲过，这里就不再赘述了。</p><p>以前我们想要用声明式 HTTP 调用，需要通过 OpenFeign 来实现，这个需要第三方的依赖，从 Spring6 开始（Spring Boot3），Spring 自己提供了类似的功能通过 <code>@HttpExchange</code> 注解也能方便的实现 声明式 HTTP 调用。以后跨服务调用又多了一个选择。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>接下来松哥通过一个案例来和小伙伴们演示一下 <code>@HttpExchange</code> 注解的具体玩法。</p><p>首先我们先创建一个普通的名为 server 的 Spring Boot 项目，这个普通的 Spring Boot 项目中只需要提供一个简单的测试接口即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/server/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对大家来说应该是没什么难度的，我就不多说了。</p><p>现在假设我有另外一个服务名为 client，我想在 client 中调用 server 中提供的这个接口。</p><p>首先我们来创建 client 这个项目，大家注意，创建的时候我们不仅需要添加 Web 依赖，还需要 Reactive Web，因为这个 <code>@HttpExchange</code> 底层基于 WebClient，而 WebClient 则是 Reactive Web 提供的：</p><p><img src="http://img.itboyhub.com/2022/08/20230131213246.png" alt></p><p>创建完成后，接下来我们就可以声明 Http 接口了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@HttpExchange</span>(<span class="hljs-string">"/server"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ToDoService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetExchange</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些用法跟我们在 SpringMVC 中常用的 @RequestMapping 和 @GetMapping 等特别类似：</p><ul><li><code>@HttpExchange</code> 类似于 <code>@RequestMapping</code>，可以将之放在类上，起到一个请求窄化的作用，也可以放在方法上，放在方法上我们可以通过 method 属性来指定具体的请求方法，这个也跟 <code>@RequestMapping</code> 类似： <code>@HttpExchange(value = &quot;/server&quot;,method = &quot;GET&quot;)</code>。</li><li><code>@GetExchange</code> 类似于 <code>@GetMapping</code>，这个就不再赘述了，其他类似的注解还有 <code>@DeleteExchange</code>、<code>@PatchExchange</code>、<code>@PostExchange</code>、<code>@PutExchange</code> 等。</li><li>另外需要注意的是请求方法的参数需要加上 <code>@RequestParam</code> 注解，这一点和 OpenFeign 比较类似。</li></ul><p>接口声明好之后还没完，我们还需要配置一下才能使用。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">WebClient <span class="hljs-title">webClient</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> WebClient.builder()</span><br><span class="line">                .baseUrl(<span class="hljs-string">"http://localhost:8080"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">ToDoService <span class="hljs-title">toDoService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        HttpServiceProxyFactory httpServiceProxyFactory =</span><br><span class="line">                HttpServiceProxyFactory.builder(WebClientAdapter.forClient(webClient()))</span><br><span class="line">                        .build();</span><br><span class="line">        <span class="hljs-keyword">return</span> httpServiceProxyFactory.createClient(ToDoService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置主要是两方面：</p><ol><li><code>@HttpExchange</code> 是基于 WebClient 的，所以我们首先需要配置 WebClient，配置 WebClient 的时候，也顺便配置了请求的具体地址（因为在 <code>@HttpExchange</code>  注解中并未指定请求的具体域名端口啥的）；同时，对于 HTTP 请求头等如果需要定制，也是通过配置 WebClient 来实现的。</li><li>由于我们前面提供的 ToDoService 是一个接口，所以我们还需要提供一个该接口的实现类，当然这个配置完全是套路化模版化的，这块就没啥好说了。</li></ol><p>全部配置完成后，接下来我们就可以在任何需要的地方，直接注入 ToDoService 的实例去使用了，举一个简单的例子小伙伴们参考下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootTest</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ToDoService toDoService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String hello = toDoService.hello(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello = "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，一个简单的例子，小伙伴们不妨体验下。</p><p>以后，不用 OpenFeign 也能实现声明式服务调用啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年过完啦，松哥也已经搬砖搬了三天了。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="SpringBoot3" scheme="http://www.javaboy.org/tags/SpringBoot3/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们的微服务中需要网关？</title>
    <link href="http://www.javaboy.org/2023/0111/why_need_gateway.html"/>
    <id>http://www.javaboy.org/2023/0111/why_need_gateway.html</id>
    <published>2023-01-11T13:27:49.000Z</published>
    <updated>2023-07-20T13:48:16.883Z</updated>
    
    <content type="html"><![CDATA[<p>玩过微服务的小伙伴对 Spring Cloud 中的的 Spring Cloud Gateway 多多少少都有一些了解，松哥之前既写过相关的文章，也录过相关的视频跟小伙伴们介绍 Spring Cloud Gateway，不过在之前的介绍中，我可能更加侧重于跟小伙伴们介绍 Spring Cloud Gateway 的用法，对于我们在微服务中为什么要使用 Spring Cloud Gateway 可能没有和大家仔细分析过，最近年前得空，我们来一起探讨一下这个话题。</p><a id="more"></a><p>说起 Spring Cloud Gateway 的使用场景，我相信很多小伙伴都能够脱口而出认证二字，确实，在网关中完成认证操作，确实是 Gateway 的重要使用场景之一，然而并不是唯一的使用场景。在微服务中使用网关的好处可太多了，今天我们就来逐一分析一下。</p><h2 id="1-请求路由"><a href="#1-请求路由" class="headerlink" title="1. 请求路由"></a>1. 请求路由</h2><p>首先，Gateway 的第一个重要特点就是对请求进行路由，根据不同的请求头、请求参数、请求路径等，将请求路由到不同的服务上。</p><p>从这个角度来说，Spring Cloud Gateway 所扮演的角色与 Nginx 这一类的反向代理服务器类似，之前就有小伙伴问我，Spring Cloud Gateway 和 Nginx 有啥区别？能不能用 Nginx 代替 Spring Cloud Gateway？其实，你要是单纯的只看请求路由这一个功能，那么确实可以用 Nginx 代替 Spring Cloud Gateway，然而在实际开发中，我们 Spring Cloud Gateway 所承担的责任可不仅仅是请求路由转发，还有其他方面的功能（后文有介绍），其他的功能用 Nginx 做起来就有一些吃力了。</p><p>如果用 Spring Cloud Gateway 做请求路由转发，我们可以画一张简单的架构图，如下：</p><p><img src="http://img.itboyhub.com/2022/08/gateway_request_router.png" alt></p><h2 id="2-API-组合"><a href="#2-API-组合" class="headerlink" title="2. API 组合"></a>2. API 组合</h2><p>网关的另一个作用就是可以实现 API 的组合。当然这个一般来说需要一些代码开发，单纯的配置一般来说是无法实现需求的。</p><p>先来说说没有网关的时候我们可能会存在什么情况。</p><p>以松哥最近在录的 TienChin 项目视频为例，我有一个活动管理服务，也就是健身房定期会做一些促销活动，促销活动往往又分为线上或者线下，线上线下又继续细分为不同的渠道，如小红书推广、抖音推广、公众号推广、线下地推等等，所以，假设我现在要做一个修改活动的功能，那么当我选中一条记录，点击修改按钮，此时，客户端至少要发送两条请求：</p><ol><li>首先根据我选中的记录的 ID，去服务端查询这条记录当前的值。</li><li>去查询活动渠道，因为活动记录中保存的是渠道 ID，我们得去查询所有的渠道信息，然后根据渠道信息才能显示出来具体的渠道。</li></ol><p>画一张简单的架构图，类似下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/gateway_request_api_combination.png" alt></p><p>如上图所示，如果你是一个微服务项目，但是却没有网关，那么前端用户一个点击事件你可能需要在后台发出 N 多个操作。并且，这 N 多个操作还都属于互联网请求，小伙伴们知道，互联网请求的一个特点就是低带宽和高延迟，连着发送两个甚至多个请求，用户体验肯定不佳。</p><p>像这样的场景，如果我们有网关，就可以在网关中提供一个粗粒度的 API，这样，前端只需要发送一个请求到网关，然后又网关去发送多个请求，从不同的微服务上把数据拿回来再统一返回给前端。如下图：</p><p><img src="http://img.itboyhub.com/2022/08/gateway_request_api_combination.drawio.png" alt></p><p>可能有小伙伴会说，你这个请求还是发送了两次，不一定省时间。其实不然！网关往往和微服务处于同一个局域网之中，相比于互联网，局域网的通信延迟就要小很多了。</p><p>这是网关的第二个作用。</p><h2 id="3-协议切换"><a href="#3-协议切换" class="headerlink" title="3. 协议切换"></a>3. 协议切换</h2><p>通过网关我们还能实现请求协议的切换。</p><p>一般来说我们暴露给外部的服务都是 RESTful API，但是，有时候考虑到服务内部的执行效率问题，我们可以在服务内容实用其他更高效的协议，通过服务网关就可以实现这个切换。</p><p>当然，这并不是必须的，只是说，当我们在微服务中使用了网关之后，如果想做请求协议的切换，就会比较容易实现。</p><h2 id="4-限流"><a href="#4-限流" class="headerlink" title="4. 限流"></a>4. 限流</h2><p>微服务中的限流操作，一个比较好的限流位置就是网关了，我们可以利用 Alibaba 的 Sentinel 结合 Spring Cloud Gateway 就可以非常方便的实现限流操作。</p><h2 id="5-请求分析"><a href="#5-请求分析" class="headerlink" title="5. 请求分析"></a>5. 请求分析</h2><p>如果我们需要统计某一个请求的细节，如执行时间、参数等信息，那么这个操作也可以在网关上来做，在网关上对请求进行详细分析。</p><h2 id="6-缓存"><a href="#6-缓存" class="headerlink" title="6. 缓存"></a>6. 缓存</h2><p>对于一些不经常变化的数据，我们可以设置缓存时间，在网关上直接进行检查，如果缓存还没失效，直接响应 304，让从客户端读取即可。</p><h2 id="7-认证"><a href="#7-认证" class="headerlink" title="7. 认证"></a>7. 认证</h2><p>这个是大家比较熟悉的了。</p><p>一般来说，我们可能会有单独的认证服务，当认证请求到达网关之后，网关将之转发到相应的认证服务上去完成认证。对于非认证请求，到达网关的时候需要校验这个请求是否有进行认证，这个校验就没必要转发了，可以直接在网关上进行校验。</p><blockquote><p>松哥举个简单的例子，也是我自己之前在项目中的一个实践经验，就是用户登录请求到达网关之后，网关将之转发到专门的认证服务上去（由于认证的过程往往需要操作用户数据库，所以不要在网关上做认证，转发到专门的认证服务上去做认证操作），认证成功之后，返回 JWT 字符串给前端。下一次，请求带着 JWT 字符串来到网关，可以直接在网关上校验 JWT 字符串，这个校验本身比较容易，又不需要连接数据库，所以可以在网关上完成，校验成功之后，将校验得到的用户信息放到请求头中，然后再转发请求到不同的微服务上，这样在各个微服务上，就知道请求的用户到底是谁了。</p></blockquote><h2 id="8-记录请求日志"><a href="#8-记录请求日志" class="headerlink" title="8. 记录请求日志"></a>8. 记录请求日志</h2><p>如果需要记录请求日志，网关也是一个好地方。</p><p>网关能干这么多事，so，想要用 Nginx 代替 Spring Cloud Gateway 显然不太现实。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩过微服务的小伙伴对 Spring Cloud 中的的 Spring Cloud Gateway 多多少少都有一些了解，松哥之前既写过相关的文章，也录过相关的视频跟小伙伴们介绍 Spring Cloud Gateway，不过在之前的介绍中，我可能更加侧重于跟小伙伴们介绍 Spring Cloud Gateway 的用法，对于我们在微服务中为什么要使用 Spring Cloud Gateway 可能没有和大家仔细分析过，最近年前得空，我们来一起探讨一下这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>微服务的版本号要怎么设计？</title>
    <link href="http://www.javaboy.org/2023/0109/micro_service_version.html"/>
    <id>http://www.javaboy.org/2023/0109/micro_service_version.html</id>
    <published>2023-01-09T13:27:39.000Z</published>
    <updated>2023-07-20T13:48:20.295Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊一下微服务项目中的版本号要怎么设计。</p><a id="more"></a><p>小伙伴们平时看到的项目版本号，基本上都是分为了三部分 <code>X.Y.Z</code>，版本升级的时候版本号都会变，那么版本号怎么变，这可不是拍脑门决定的，今天我们就一起来探讨一下这个话题。</p><h2 id="1-语义化版本控制规范"><a href="#1-语义化版本控制规范" class="headerlink" title="1. 语义化版本控制规范"></a>1. 语义化版本控制规范</h2><p>版本号该如何控制？其实是有一个标准规范的，规范地址：</p><ul><li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></li></ul><p>这个规范非常友好的提供了中文版的内容。</p><p>语义化的版本控制规范要求版本号由三部分构成：</p><ul><li>MAJOR（X）：这个是主版本号，一般是涉及到不兼容的 API 更改时，这个会变化。</li><li>MINOR（Y）：这个是次版本号，当我们对 API 进行向后兼容的增强时，这个版本号会变化，换句话说，也就是有新增的功能时，这里会变化。</li><li>PATCH（Z）：这个是修订号，当我们进行一些 BUG 的修复，然后要发版的时候，这里会发生变化。</li></ul><p>语义化的版本控制规范主要做了如下一些要求：</p><ol><li>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。</li><li>标准的版本号必须（MUST）采用 <code>X.Y.Z</code> 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li><li>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。有的小伙伴可能会说我们的项目处于快速开发阶段，API 不稳定，天天变，要是按照这个要求来得发多少个版本才够用呀！其实，一般 API 快速变化主要有两种情况，一种是项目刚立项的时候，此时主版本号为 0，那么这个时候的 API 就不能算是稳定的 API；另外一种情况则是下个主版本处于快速开发中，但是这种情况一般会有一个新的分支用来管理下个版本的代码，所以和这里的要求实际上并不冲突（具体参见第 4、5 条）。</li><li>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</li><li>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。那么有的小伙伴可能会纠结什么时候版本号从 0.Y.Z 变为 1.Y.Z 呢？一般来说，当你的项目已经上了生产环境或者说有稳定的 API 提供给别人使用的时候，基本上就可以算是 1.Y.Z 了。</li><li>修订号 Z（x.y.Z | x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</li><li>次版本号 Y（x.Y.z | x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</li><li>主版本号 X（X.y.z | X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</li><li>先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</li><li>版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</li><li>版本的优先层级指的是不同版本在排序时如何比较。<ol><li>判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。</li><li>由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。</li><li>当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。</li><li>有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：<ol><li>只有数字的标识符以数值高低比较。</li><li>有字母或连接号时则逐字以 ASCII 的排序来比较。</li><li>数字的标识符比非数字的标识符优先层级低。</li><li>若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。<br>例如：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</li></ol></li></ol></li></ol><h2 id="2-微服务中的版本号"><a href="#2-微服务中的版本号" class="headerlink" title="2. 微服务中的版本号"></a>2. 微服务中的版本号</h2><p>那么在微服务中，我们的版本号该怎么设计呢？</p><p>首先，整体上的思路，就是按照上文所说的语义化版本控制规范来。</p><p>其次，上面虽然给出了很多条条框框，然而我们实际开发中，一般只需要从以下几个方面简单考虑即可，每次发版的时候都去翻这个规范显然也不现实：</p><ol><li>理想情况下，我们应该只进行向后兼容的更新。</li></ol><p>我们要为项目添加新功能、新特性，我们必须要考虑到项目的兼容性。例如接口中新加了一个参数，那么为了老版本的客户端能够顺利访问这个接口，服务端应该考虑为老版本客户端缺少的请求参数提供一个默认值。我们也可能为响应添加新的属性，或者提供了一些新的接口，当然这些一般都不影响老客户端。</p><ol start="2"><li>必须进行不兼容的升级。</li></ol><p>有时候我们必须进行一些不兼容的升级，对 API 做一些主要的修改，考虑到微服务之间的松耦合性，我们没法强迫客户端进行立马升级，此时可能会考虑在某一个时间段内，两个版本的 API 共存。</p><p>多个 API 共存的时候，一个比较简单的办法是在 API 设计的时候，加上版本号，例如 <code>/v1/xxx</code> 或者 <code>/v2/xxx</code>，不过这种写法有一个小小的缺陷，就是路径中加了版本号之后，这个路径看起来就不是一个完美的 REST 路径了。</p><p>所以这块还有一个方案，就是把请求的 API 的版本号写到请求头中。</p><p>具体的实现思路是这样：</p><p>首先，在微服务中，我们所有的请求一般来说都会经过网关，我们可以在网关中提取出请求头的 Accept 参数，然后根据 Accept 中的请求版本号，做不同的请求转发，如果版本号是 1.0，就转发到 1.0 的服务上去；如果版本号是 2.0，则转发到 2.0 的服务上去。基本上就是这个样子。</p><p>以现在微服务中主流的网关 Spring Cloud Gateway 为例，我们可以做如下配置：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line"><span class="hljs-attr">  application:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">gateway</span></span><br><span class="line"><span class="hljs-attr">  cloud:</span></span><br><span class="line"><span class="hljs-attr">    nacos:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        password:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        username:</span> <span class="hljs-string">nacos</span></span><br><span class="line"><span class="hljs-attr">        server-addr:</span> <span class="hljs-string">a.b.c.d:8848</span></span><br><span class="line"><span class="hljs-attr">        namespace:</span> <span class="hljs-string">public</span></span><br><span class="line"><span class="hljs-attr">    gateway:</span></span><br><span class="line"><span class="hljs-attr">      discovery:</span></span><br><span class="line"><span class="hljs-attr">        locator:</span></span><br><span class="line"><span class="hljs-comment">#          enabled: true</span></span><br><span class="line"><span class="hljs-attr">          lower-case-service-id:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">      routes:</span></span><br><span class="line"><span class="hljs-attr">        - id:</span> <span class="hljs-string">v1_provider</span></span><br><span class="line"><span class="hljs-attr">          uri:</span> <span class="hljs-attr">lb://provider</span></span><br><span class="line"><span class="hljs-attr">          predicates:</span></span><br><span class="line"><span class="hljs-bullet">            -</span> <span class="hljs-string">Path=/p/**</span></span><br><span class="line"><span class="hljs-bullet">            -</span> <span class="hljs-string">Header=Accept,.*;?version=1\.0(|;.*)</span></span><br><span class="line"><span class="hljs-attr">          filters:</span></span><br><span class="line"><span class="hljs-bullet">            -</span> <span class="hljs-string">StripPrefix=1</span></span><br><span class="line"><span class="hljs-attr">server:</span></span><br><span class="line"><span class="hljs-attr">  port:</span> <span class="hljs-number">8082</span></span><br></pre></td></tr></table></figure><p>大家看一下这个配置：</p><ol><li>首先记得关闭服务自动发现，否则通过默认的服务名进行代理就不会经过我们配置的过滤器了。</li><li>然后我们手动配置服务转发，上面的配置基本上都是常规配置，跟版本号相关的配置是 <code>Header=Accept,.*;?version=1\.0(|;.*)</code>，这个配置就是对请求头提出要求，首先前面的 Accept 表示这里是要判断请求头中的 Accept 字段，然后后面紧跟着的是 value（两者之间用 , 隔开），这个 value 是一个正则表达式 <code>.*;?version=1\.0(|;.*)</code>，意思就是在 <code>version=1.0</code> 之前和之后可以有任意字符串，只要 value 中包含 <code>version=1.0</code> 就算匹配上了。只有匹配上了，才会进行请求转发，否则不会进行请求转发。</li><li>最后，我们在发送请求的时候，设置如下请求头即可：<br><img src="http://img.itboyhub.com/2022/08/20230108200333.png" alt><br>如果版本号是 <code>version=2.0</code>，则会报一个 404 错误：<br><img src="http://img.itboyhub.com/2022/08/20230108200428.png" alt></li></ol><p>好啦，一个小小的版本号话题，感兴趣的小伙伴可以试试最后这段代码哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊一下微服务项目中的版本号要怎么设计。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>到底什么样的 REST 才是最佳 REST？</title>
    <link href="http://www.javaboy.org/2023/0106/hateoas.html"/>
    <id>http://www.javaboy.org/2023/0106/hateoas.html</id>
    <published>2023-01-06T13:27:27.000Z</published>
    <updated>2023-07-20T13:47:32.229Z</updated>
    
    <content type="html"><![CDATA[<p>说起 REST API，小伙伴们多多少少都有听说过，但是如果让你详细介绍一下什么是 REST，估计会有很多人讲不出来，或者只讲出来其中一部分。</p><a id="more"></a><p>今天松哥就来和大家一起来聊一聊到底什么是 REST，顺便再来看下 Spring HATEOAS 的用法。</p><h2 id="1-REST-成熟模型"><a href="#1-REST-成熟模型" class="headerlink" title="1. REST 成熟模型"></a>1. REST 成熟模型</h2><p>首先关于 REST，有一个大佬 Leonard Richardson 为 REST 定义了一个成熟度模型，他一共定义了四个不同的层次，分别如下：</p><ol><li>Level0：Web 服务单纯的使用 HTTP 作为数据传输方式，本质上就是远程方法调用，常见的 SOAP 和 RPC 基本上都属于这一类。</li><li>Level1：在这一级别上，引入了资源的概念，服务端的每一个资源，都有一个对应的操作地址。</li><li>Level2：在这一级别上，我们引入了不同的 HTTP 请求方法来描述不同的操作，例如 GET 表示查询、POST 表示插入、PUT 表示更新、DELETE 表示删除，并且使用 HTTP 的状态码来表示不同的响应结果。一般来说，大家在日常的接口开发中，基本上都能做到这一层级。但是这还不是最佳结果。</li><li>Level3：按照 Leonard Richardson 的意思，这一层级的 REST 基于 HATEOAS（Hypertext As The Engine Of Application State），在这一级别上，除了返回资源的 JSON 之外，还会额外返回一组 Link，这组 Link 描述了对于该资源可以做哪些操作，以及具体的该怎么做。</li></ol><p>在日常的开发中，我们一般都是只实现到 Level2 这一层级，真正做到 Level3 的估计很少，不过虽然在工作中一般不会做到 Level3 这一层级，但是，我相信很多小伙伴应该是见过 Level3 层级的 REST 是啥样子的，特别是看过 vhr 视频的小伙伴，松哥在其中讲过，通过 Spring Data Jpa+Spring Rest Repositories 实现的 CURD 接口，其实就是一个达到了 Level3 层级的 REST。</p><h2 id="2-Spring-HATEOAS"><a href="#2-Spring-HATEOAS" class="headerlink" title="2. Spring HATEOAS"></a>2. Spring HATEOAS</h2><p>那么接下来我先用 Spring HATEOAS 写一个简单的 REST，然后结合这个案例来和小伙伴们聊一聊到底 Spring HATEOAS 有何不一样的地方。</p><p>首先我们创建一个 Spring Boot 工程，引入 Web 和 Spring HATEOAS 依赖，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230105225940.png" alt></p><p>创建好之后，我们首先创建一个 User 实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RepresentationModel</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个 User 实体类需要继承自 RepresentationModel，以方便后续添加不同的 Link（以前旧的版本需要继承自 ResourceSupport）。</p><p>接下来写一个简单的测试接口。</p><p>查询所有用户：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/users"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CollectionModel&lt;User&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        User u1 = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        u1.setId(<span class="hljs-number">1</span>);</span><br><span class="line">        u1.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        u1.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        u1.add(WebMvcLinkBuilder.linkTo(UserController.class).slash(u1.getId()).withSelfRel());</span><br><span class="line">        list.add(u1);</span><br><span class="line">        User u2 = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        u2.setId(<span class="hljs-number">2</span>);</span><br><span class="line">        u2.setUsername(<span class="hljs-string">"itboy"</span>);</span><br><span class="line">        u2.setAddress(<span class="hljs-string">"www.itboyhub.com"</span>);</span><br><span class="line">        u2.add(WebMvcLinkBuilder.linkTo(UserController.class).slash(u2.getId()).withSelfRel());</span><br><span class="line">        list.add(u2);</span><br><span class="line">        CollectionModel&lt;User&gt; users = CollectionModel.of(list);</span><br><span class="line">        users.add(WebMvcLinkBuilder.linkTo(UserController.class).withRel(<span class="hljs-string">"users"</span>));</span><br><span class="line">        <span class="hljs-keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个接口，我来说几点：</p><ol><li>首先，对于这种返回一个集合或者数组的情况，返回的类型都是 CollectionModel<user>。</user></li><li>把集合弄好之后（正常应该去数据库中查询，我这里省事直接创建了），通过 <code>CollectionModel.of(list)</code> 方法去获取一个 <code>CollectionModel&lt;User&gt;</code> 对象。</li><li>对于每一个 user 对象，我都添加了一个 Link 对象，<code>WebMvcLinkBuilder.linkTo(UserController.class).slash(u1.getId()).withSelfRel()</code> 表示生成当前对象的访问链接。</li><li><code>WebMvcLinkBuilder.linkTo(UserController.class).withRel(&quot;users&quot;)</code> 表示访问所有数据的链接。</li></ol><p>好了，这个接口写完之后，我们访问看下：</p><p><img src="http://img.itboyhub.com/2022/08/20230105232810.png" alt></p><p>可以看到，返回的每一个 user 对象中，都有一个链接表示如何单独访问这个对象。最下面还有一个访问所有对象的链接。</p><p>对于上面这个案例，可能有小伙伴会质疑，难道我们从数据库中查询出来的 List 集合都要遍历一遍，然后给每一个 User 添加一个 Link 吗？其实不必，添加 Link 这个事可以直接在 User 类中完成，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RepresentationModel</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(WebMvcLinkBuilder.linkTo(UserController.class).slash(id).withSelfRel());</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接在构造方法中完成即可。此时接口里就不用那么复杂了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CollectionModel&lt;User&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>);</span><br><span class="line">    u1.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    u1.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">    list.add(u1);</span><br><span class="line">    User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>);</span><br><span class="line">    u2.setUsername(<span class="hljs-string">"itboy"</span>);</span><br><span class="line">    u2.setAddress(<span class="hljs-string">"www.itboyhub.com"</span>);</span><br><span class="line">    list.add(u2);</span><br><span class="line">    CollectionModel&lt;User&gt; users = CollectionModel.of(list);</span><br><span class="line">    users.add(WebMvcLinkBuilder.linkTo(UserController.class).withRel(<span class="hljs-string">"users"</span>));</span><br><span class="line">    <span class="hljs-keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对于根据 ID 来查询用户的需求，我们也应该给一个接口如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/users"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> EntityModel&lt;User&gt; <span class="hljs-title">getOne</span><span class="hljs-params">(@PathVariable Integer id)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        User u = <span class="hljs-keyword">new</span> User(id);</span><br><span class="line">        u.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        u.setAddress(<span class="hljs-string">"深圳"</span>);</span><br><span class="line">        u.add(Link.of(<span class="hljs-string">"http://localhost:8080/users/"</span>+id, <span class="hljs-string">"getOne"</span>));</span><br><span class="line">        Link users = WebMvcLinkBuilder.linkTo(UserController.class).withRel(<span class="hljs-string">"users"</span>);</span><br><span class="line">        u.add(users);</span><br><span class="line">        Link link = WebMvcLinkBuilder.linkTo(UserController.class).slash(u.getId()).withSelfRel();</span><br><span class="line">        u.add(link);</span><br><span class="line">        Method method = UserController.class.getMethod(<span class="hljs-string">"getOne"</span>, Integer.class);</span><br><span class="line">        Link link2 = WebMvcLinkBuilder.linkTo(method, id).withSelfRel();</span><br><span class="line">        u.add(link2);</span><br><span class="line">        <span class="hljs-keyword">return</span> EntityModel.of(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个接口，我说如下几点：</p><ol><li>如果返回类型是一个对象的话，需要使用 <code>EntityModel&lt;User&gt;</code> 类型。</li><li>搞好返回的对象之后，通过 <code>EntityModel.of(u)</code> 方法可以获取到目标数据类型。</li><li>这个地方，为了给小伙伴们演示不同的 Link 添加方式，我写了好多个（单纯为了演示不同的 Link 添加方式）：<ol><li><code>Link.of(&quot;http://localhost:8080/users/&quot;+id, &quot;getOne&quot;)</code> 这种是自己纯手工去生成当前对象的访问链接，很明显这不是一个很好的方案。当前对象的访问链接建议使用上文中提到的方式。</li><li><code>WebMvcLinkBuilder.linkTo(UserController.class).withRel(&quot;users&quot;)</code> 这个是生成当前这个 Controller 的访问链接，一般就是访问所有用户对象的链接。</li><li><code>WebMvcLinkBuilder.linkTo(UserController.class).slash(u.getId()).withSelfRel()</code> 前文已经用过了，不多说了，实际应用中建议使用这种。</li><li>也可以根据某一个方法自动生成，像这样 <code>WebMvcLinkBuilder.linkTo(method, id).withSelfRel()</code>，这个是生成某一个具体方法的访问链接。</li></ol></li></ol><p>好了，现在我们来看下这个接口生成的 JSON，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230105235158.png" alt></p><p>生成的这段 JSON 我将之标记为了三部分：</p><ol><li>第一部分，self，就是自身的访问链接，这三个链接分别是 User 的构造方法，以及前面提到的 3.3 和 3.4 的方法生成的。</li><li>第二部分，getOne 这个，是前面 3.1 中提到的方法生成的。</li><li>第三部分，users 这个，是前面提到的 3.2 方法生成的。</li></ol><p>当然，其实这块还有很多其他的生成链接的玩法，但是我就不一一介绍了，小伙伴们可以参考官方文档：</p><ul><li><a href="https://docs.spring.io/spring-hateoas/docs/current/reference/html" target="_blank" rel="noopener">https://docs.spring.io/spring-hateoas/docs/current/reference/html</a></li></ul><p>从上面 Spring HATEOAS 中返回的 JSON 我们大致上可以看到它的特点：</p><blockquote><p>当我们使用了 Spring HATEOAS，此时，客户端就会通过服务端返回的 Link Rel 来获取请求的 URI（如果没有使用 Spring HATEOAS，则客户端访问的 URI 都是提前在客户端硬编码的），现在我们就可以做到服务端在不破坏客户端实现的情况下动态的完成 URI 的修改，从而进一步解耦客户端和服务端。</p></blockquote><p>简而言之，现在客户端能干什么事情，在服务端返回的 JSON 中都会告诉客户端，客户端从服务端返回的 JSON 中获取到请求的 URL，然后直接执行即可。如果这个请求地址发生变化的话，客户端也会及时拿到最新的地址。</p><p>可能上面的例子小伙伴们感受还不是很明显，我再给大家看一段 JSON：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"tracking_id"</span>: <span class="hljs-string">"666"</span>,</span><br><span class="line">    <span class="hljs-attr">"status"</span>: <span class="hljs-string">"WAIT_PAYMENT"</span>,</span><br><span class="line">    <span class="hljs-attr">"items"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"book"</span>,</span><br><span class="line">            <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="hljs-attr">"_Links"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"self"</span>: &#123;</span><br><span class="line">            <span class="hljs-attr">"href"</span>: <span class="hljs-string">"http://localhost:8080/orders/666"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"cancel"</span>: &#123;</span><br><span class="line">            <span class="hljs-attr">"href"</span>: <span class="hljs-string">"http://localhost:8080/orders/666"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"payment"</span>: &#123;</span><br><span class="line">            <span class="hljs-attr">"href"</span>: <span class="hljs-string">"http://localhost:8080/orders/666/payments"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是电商系统下单之后等待支付的过程中返回的 JSON，这里的 links 给出了三个：</p><ul><li>self：访问这个链接可以查看当前订单信息（GET 请求）。</li><li>cancel：访问这个链接可以取消当前订单（DELETE 请求）。</li><li>payment：访问这个链接可以支付当前订单（POST 请求）。</li></ul><p>这个例子就很直白了，就是在返回的 JSON 中，直接告诉你接下来能做哪些操作，对应的 URL 分别是什么，前端拿到之后直接操作，如果这些操作路径发生了变化，前端也会立马拿到最新的路径。</p><p>这就是 Spring HATEOAS 的好处。总之一句话，Spring HATEOAS 提倡在响应返回的 Link 中给出对该资源接下来操作的 URL。这种方式解耦了服务端 URI，也可以让客户端开发者更容易地探索 API。</p><h2 id="3-REST-的优缺点"><a href="#3-REST-的优缺点" class="headerlink" title="3. REST 的优缺点"></a>3. REST 的优缺点</h2><p>虽然我们现在都鼓励设计 REST 风格的 API，然而 REST 也不全是优点，事物总是具有两面性，REST 的优缺点分别如下。</p><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><ol><li>首先，REST 足够简单，有一定 Web 开发经验的小伙伴都可以快速上手 REST。</li><li>REST 风格的接口测试起来也非常方便，利用浏览器自带的一些 REST 插件或者是 POSTMAN 之类的工具，就可以非常方便的实现 REST 接口的测试。</li><li>不需要中间代理，简化了系统的结构。</li><li>HTTP 对防火墙比较友好。</li></ol><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><ol><li>REST 只支持<strong>请求-响应</strong>的通信方法，不支持服务端推送消息到客户端。</li><li>给请求取一个合适的名字比较困难，特别是有多个相类似的接口时，例如有多个添加接口、多个更新接口等。</li><li>由于没有中间代理，所以请求/响应的时候，服务端和客户端都必须在线。</li></ol><p>好啦，跟小伙伴们聊了 REST 和 Spring HATEOAS，感兴趣的小伙伴可以去试试哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起 REST API，小伙伴们多多少少都有听说过，但是如果让你详细介绍一下什么是 REST，估计会有很多人讲不出来，或者只讲出来其中一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SOA 和微服务有何区别？</title>
    <link href="http://www.javaboy.org/2023/0104/soa_micro_service.html"/>
    <id>http://www.javaboy.org/2023/0104/soa_micro_service.html</id>
    <published>2023-01-04T13:27:13.000Z</published>
    <updated>2023-07-20T13:48:13.417Z</updated>
    
    <content type="html"><![CDATA[<p>玩过 Dubbo 的小伙伴应该都有听说过一个概念叫做 SOA，每当我们说起微服务的时候，很多人就会去纠结这和 SOA 有啥关系呀？感觉换汤不换药呀。</p><a id="more"></a><p>今天松哥来稍微和小伙伴们讨论下这个话题，我们一起来看看 SOA 和微服务到底有何异同。</p><h2 id="1-SOA"><a href="#1-SOA" class="headerlink" title="1. SOA"></a>1. SOA</h2><p>SOA，英文全称是 Service-Oriented Architecture (SOA) governance，单纯从字面来看，是面向服务的架构治理。但是小伙伴们在网上应该很难看到比较权威的关于 SOA 通俗易懂的解释。我这里还是以 TienChin 项目为例，来和大家捋一捋 SOA。</p><p>假设 TienChin 中有一个用户注册的功能，现在前端的注册有三个端：</p><ol><li>网页</li><li>手机 App</li><li>小程序</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230105225844.png" alt></p><p>如果采用传统的 JavaWeb 开发方式，那么我可能得写三遍注册功能，为三个 Client 各自提供一个接口，然而小伙伴们稍微思考一下就会发现，注册逻辑其实都差不多，区别可能仅仅是接口返回的数据格式有差异而已。因此，我们可以将注册功能抽取出来，写成一个单独的服务，然后通过远程服务调用如 HTTP 或者 Socket 等，去调用这个注册的功能模块。这就是一个简单的 SOA 架构设计。</p><p>然而看了这个很多小伙伴都懵了，这不就是微服务吗？</p><p>接下来我们就来说说 SOA 和微服务到底哪里不一样。</p><h2 id="2-SOA-PK-微服务"><a href="#2-SOA-PK-微服务" class="headerlink" title="2. SOA PK 微服务"></a>2. SOA PK 微服务</h2><h3 id="2-1-服务间通信"><a href="#2-1-服务间通信" class="headerlink" title="2.1 服务间通信"></a>2.1 服务间通信</h3><p>首先第一点，就是服务之间的通信方式不同。</p><p>玩过 Dubbo 的小伙伴都知道，Dubbo 中常用的通信协议就是 Dubbo 协议，Dubbo 协议本质上其实就是 socket 通信。在 SOA 中，服务之间的通信往往都是采用的重量级协议如 SOAP 等。</p><p>而我们常用的微服务框架 Spring Cloud，小伙伴们知道，这里的通信基本上都是 REST 这种轻量级协议，有时候我们甚至是基于消息来驱动微服务，无论哪一种，微服务中服务之间的通信协议都更加轻量级。</p><h3 id="2-2-数据库设计"><a href="#2-2-数据库设计" class="headerlink" title="2.2 数据库设计"></a>2.2 数据库设计</h3><p>在 SOA 中，一般来说不太会进行分库设计，也就是说整个系统还是使用的一个库，系统可能会分为不同的服务，但是不同的服务操作的都是同一个库。</p><p>微服务则不同，昨天的文章中，松哥画的下面这张图，基本上是每一个服务都有一个自己的库，每个服务都是操作自己的库，合同管理中需要调用用户管理的数据，不能直接调用库，得通过用户管理提供的 REST 接口去调用。</p><p><img src="http://img.itboyhub.com/2022/08/微服务TienChin架构图Nginx.drawio123.png" alt></p><h3 id="2-3-服务规模"><a href="#2-3-服务规模" class="headerlink" title="2.3 服务规模"></a>2.3 服务规模</h3><p>第三点就是服务的规模不同了。</p><p>SOA 中的每一个服务，整体上来说还是一个比较大的单体项目，因为 SOA 一般不会分的很细。而微服务则不同，在微服务中，我们会将服务都划分的很细，每一个服务基本上都是只负责一个很小的功能模块。</p><p>以前我们玩 SOA 的时候，基本上都还是传统的 SSM 项目，小伙伴们知道，搭建一个 SSM 项目就已经很费事了，所以能少搭建就少搭建。但是后来有了 Spring Boot 就不一样了，利用 Spring Boot，我们可以非常方便快捷的创建一个项目，那么此时我们就有足够的条件把服务划分的比较细致了。</p><p>所以呢，整体上看，SOA 往往是几个比较大型的服务组合在一起，而微服务则往往是几十甚至上百个服务组成。</p><p>好啦，临近放假，今天就聊点简单的不烧脑的哈哈～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩过 Dubbo 的小伙伴应该都有听说过一个概念叫做 SOA，每当我们说起微服务的时候，很多人就会去纠结这和 SOA 有啥关系呀？感觉换汤不换药呀。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>单体的 TienChin 和微服务的 TienChin 有何异同？</title>
    <link href="http://www.javaboy.org/2023/0103/micro_service_tienchin.html"/>
    <id>http://www.javaboy.org/2023/0103/micro_service_tienchin.html</id>
    <published>2023-01-03T12:13:52.000Z</published>
    <updated>2023-07-20T12:17:35.750Z</updated>
    
    <content type="html"><![CDATA[<p>有不少小伙伴希望松哥能整一个微服务的实战项目，微服务这块技术点其实松哥是讲过很多了，图文版的教程视频版的教程都有，不过确实缺乏一个项目，所以我在想等 TienChin 项目搞完之后，和小伙伴们也来一起搞一个微服务的项目。</p><a id="more"></a><p>今天我想从架构的角度来和小伙伴们聊一聊微服务。不聊具体的技术点，就单纯来看看一个微服务项目该怎么设计。</p><h2 id="1-单体版-TienChin"><a href="#1-单体版-TienChin" class="headerlink" title="1. 单体版 TienChin"></a>1. 单体版 TienChin</h2><p>松哥目前在录的 TienChin 项目就是一个前后端分离的单体项目，采用了 Spring Boot + Vue3。那么单体版的 TienChin 具有什么样的特征呢？我从优点和缺点两个方面来和大家分析。</p><p>先来看一张简单的架构图：</p><p><img src="http://img.itboyhub.com/2022/08/单体TienChin架构图.drawio.png" alt></p><p>可以看到，虽然是单体项目，但是为了开发方便，项目也细分为许多不同的模块，项目中的适配器可以分为两大类：</p><ol><li>入站适配器：就是外部系统来调用我们的系统，REST API 和 Vue 网页都算是入站适配器，外部系统通过这两个接口来调用我们的系统。</li><li>出站适配器：这个主要是我们系统内部调用外部系统的方式，例如我们的项目中需要用到 MySQL、Redis等，那么就通过出站适配器来实现。</li></ol><h3 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h3><ol><li>开发简单：随便一个 IDE，撸起袖子就可以开写了。</li><li>测试简单：项目启动之后，直接利用 POSTMAN 等工具就可以测试项目接口了。</li><li>部署简单：项目开发完成之后，打包成一个 jar 或者一个 war，直接部署就行了。</li><li>横向扩展简单：当项目并发能力不足的时候，可以方便的结合 Nginx 等负载均衡工具进行横向扩展。</li></ol><p>可以看到，单体项目的优势整体上来说还是非常明显的。</p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>然而缺点也是非常明显的。</p><ol><li>项目越来越复杂</li></ol><p>首先就是项目不可能一直这么简单，我们这个项目中还是细分了很多不同的模块。随着时间的推移，这些模块会变得越来愈复杂。修改每一个 BUG 都要小心翼翼，牵一发而动全身。并且随着项目组中人员的离职/入职，新接手的人会让这个项目更加复杂，每一次 BUG 的修复或者新功能的添加，都会让这个项目变得更加“不可捉摸”。</p><ol start="2"><li>开发进度越来越不可控</li></ol><p>由于系统越来越复杂，我们不得不增派人手参与到这个项目的开发中，以期推进项目进度。这么多人的协调又是一个问题。并且，随着项目越来越大，每一次编译运行都得数分钟、十几分钟甚至更久，这也会严重拖慢我们的项目进度。</p><ol start="3"><li>发版周期过长</li></ol><p>单体项目发版很多小伙伴可能都刻骨铭心，发版当天如临大敌，所有人都加班，等项目上线运行都没问题，各项数据都 OK，此时可能已经凌晨三四点了，所有人拖着疲惫的身体下班。正是由于每一次发版都是一个大事，所以一般单体项目不太会频繁发版（我说的频繁是指如一天一版这种），发版周期普遍比较长。</p><ol start="4"><li>难以扩展</li></ol><p>当系统不同模块对资源的需求不同的时候，我们想做针对性的硬件扩展也并不方便。</p><p>举个简单例子，有一个模块需要进行大量的运算，我们希望能为之提供更好的 CPU；有一个模块需要更大的内存，我们需要扩展更大的内存。</p><p>然而由于所有的模块都打包在一起，我们只能针对当前服务器做各种硬件升级，无法针对某一个模块做专门的硬件升级。</p><ol start="5"><li>过期的技术栈不易更新</li></ol><p>我相信很多小伙伴见到的单体项目还有一个特点就是技术栈普遍比较老旧。这也是因为单体项目时间久了之后，积重难返，想要对基础框架做版本升级往往牵一发而动全身，更别提从传统的 SSM 切换到 Spring Boot 上这种超级繁琐的工作了。因此大部分的单体项目，在立项的那一刻选用了什么技术栈、选用了技术的哪个版本，基本上这个项目未来都是这个版本了。</p><p>从上面的介绍中小伙伴们可以看到，单体项目优点很明显，然而缺点也是非常明显的。而这些缺点，都可以通过微服务来解决。</p><h2 id="2-微服务版-TienChin"><a href="#2-微服务版-TienChin" class="headerlink" title="2. 微服务版 TienChin"></a>2. 微服务版 TienChin</h2><p>如果 TienChin 项目是微服务版呢？我们来看一张简单的架构图。</p><p><img src="http://img.itboyhub.com/2022/08/微服务TienChin架构图.drawio.png" alt></p><p>简单画了张图，我来解释下：</p><ol><li>首先我们基本上是按照业务来划分服务的。每一个服务都有自己独立的数据库，自己操作自己的库。</li><li>假设在线索管理中，需要调用商机管理，那不能直接操作商机的数据库，必须去调用商机管理服务中提供的 REST API，通过这个 REST API 来操作库。</li><li>所有的服务有一个统一的入口 Gateway，如果前端是手机 App 或者小程序之类的，通过 Gateway 来访问到系统。</li><li>有一个后台管理的 Web UI 项目，提供相应的网页操作。</li></ol><p>大致上就是这个样子。</p><p>那么这个微服务版的 TienChin 跟前面的单体版 TienChin 相比优势体现在哪里呢？</p><ol><li>容易维护</li></ol><p>首先第一点就是，项目拆分为微服务之后，每个服务相对来说都比较小，项目的维护相对来说也会比较容易。一个比较小的项目，在 IDE 中启动也会比较快。可以有一个很小的团队来负责项目的维护。</p><ol start="2"><li>服务可以自由扩展</li></ol><p>以上图为例，如果某日搞促销活动，线索管理这个服务的并发量比较大，我们可以非常方便的为线索管理模块做横向扩展，如下图这样：</p><p><img src="http://img.itboyhub.com/2022/08/微服务TienChin架构图Nginx.drawio123.png" alt></p><p>任何一个服务，如果有需求，都可以非常方便的进行扩展，并且可以根据服务的特点来选择合适的硬件，例如这个服务耗内存，那就加大内存；另一个服务耗 CPU，那就选择一个性能到位的 CPU 等等。</p><ol start="3"><li>解耦后更强的容错性</li></ol><p>通过服务降级、熔断等微服务组件的使用，我们可以实现各个微服务具备更强的容错性。一个服务出故障，并不会影响其他的服务。例如合同管理里边发生了内存泄漏，这个并不会影响到商机管理服务。</p><ol start="4"><li>更容易采用新技术</li></ol><p>之前我们在谈到单体项目的弊端的时候，提到了单体项目的技术栈更新非常不易。现在我们切换成微服务了，新技术栈的切换其实就变得非常容易了。每一个微服务都可以根据当前项目的情况，选择是否采用最新的技术栈，而且一个微服务在切换最新技术栈的过程中，如果不幸发生了问题了，也不会影响到其他的微服务，只会影响到当前的服务。由于各个微服务之间基本上都是通过 REST API 进行交互的，所以，退一万步，你甚至可以使用不同的开发语言来开发不同的微服务。</p><ol start="5"><li>更友好的 CI/CD</li></ol><p>CI/CD 是 DevOps 的一部分，但是在前面的单体项目中，当项目比较大的时候，想做到持续交付/持续部署已经越来越难了，而微服务让一个超大规模的项目可以非常方便的实现 CI/CD。</p><p>现在，我们的每一个服务都有自己独立的团队、独立的代码仓库、独立的自动化部署流水线，且互不相扰，如下图这样：</p><p><img src="http://img.itboyhub.com/2022/08/持续部署.drawio.png" alt></p><p>现在，每一个服务都可以独立的实现服务的上线和部署，结合 DevOps 可以做到非常轻松的发版，不需要再像以前单体应用发版的时候，如临大敌一样。</p><p>这样划分之后，工程师也可以将自己的精力放在业务开发商，提供更多有价值的功能，而不是像一个救火队员一样，每天忙着四处灭火。</p><p>好啦，通过这样一篇简单的文章和图片，希望大家对微服务有一个基本的认知，当然，微服务也不是“银弹”，微服务架构也存在问题，这个咱们后面有空了松哥再继续和小伙伴们分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少小伙伴希望松哥能整一个微服务的实战项目，微服务这块技术点其实松哥是讲过很多了，图文版的教程视频版的教程都有，不过确实缺乏一个项目，所以我在想等 TienChin 项目搞完之后，和小伙伴们也来一起搞一个微服务的项目。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于幻读，该捋清楚了！</title>
    <link href="http://www.javaboy.org/2022/1219/mysql-phantom-rows.html"/>
    <id>http://www.javaboy.org/2022/1219/mysql-phantom-rows.html</id>
    <published>2022-12-19T10:25:17.000Z</published>
    <updated>2022-12-20T11:05:46.170Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>小伙伴们都知道，MySQL 有四种不同的隔离级别，四种不同的隔离级别会带来三种不同的问题，今天我想再和大家捋一捋这个问题。</p><a id="more"></a><h2 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h2><h3 id="1-1-理论"><a href="#1-1-理论" class="headerlink" title="1.1 理论"></a>1.1 理论</h3><p>MySQL 中事务的隔离级别一共分为四种，分别如下：</p><ul><li>序列化（SERIALIZABLE）</li><li>可重复读（REPEATABLE READ）</li><li>提交读（READ COMMITTED）</li><li>未提交读（READ UNCOMMITTED）</li></ul><p>四种不同的隔离级别含义分别如下：</p><ol><li>SERIALIZABLE</li></ol><blockquote><p>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</p></blockquote><ol start="2"><li>REPEATABLE READ</li></ol><blockquote><p>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</p></blockquote><ol start="3"><li>READ COMMITTED</li></ol><blockquote><p>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</p></blockquote><ol start="4"><li>READ UNCOMMITTED</li></ol><blockquote><p>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</p></blockquote><p><strong>在 MySQL 数据库中，默认的事务隔离级别是 REPEATABLE READ。</strong></p><h3 id="1-2-SQL-实践"><a href="#1-2-SQL-实践" class="headerlink" title="1.2 SQL 实践"></a>1.2 SQL 实践</h3><p>接下来通过几条简单的 SQL 向读者验证上面的理论。</p><h4 id="1-2-1-查看隔离级别"><a href="#1-2-1-查看隔离级别" class="headerlink" title="1.2.1 查看隔离级别"></a>1.2.1 查看隔离级别</h4><p>通过如下 SQL 可以查看数据库实例默认的全局隔离级别和当前 session 的隔离级别：</p><p>MySQL8 之前使用如下命令查看 MySQL 隔离级别：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.tx_isolation, @@tx_isolation;</span><br></pre></td></tr></table></figure><p>查询结果如图： </p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409102944.png" alt></p><p>可以看到，默认的隔离级别为 REPEATABLE-READ，全局隔离级别和当前会话隔离级别皆是如此。</p><p><strong>MySQL8 开始，通过如下命令查看 MySQL 默认隔离级别</strong>：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.transaction_isolation, @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>就是关键字变了，其他都一样。</p><p>通过如下命令可以修改隔离级别（建议开发者在修改时修改当前 session 隔离级别即可，不用修改全局的隔离级别）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>上面这条 SQL 表示将当前 session 的数据库隔离级别设置为 READ UNCOMMITTED，设置成功后，再次查询隔离级别，发现当前 session 的隔离级别已经变了，如图1-2：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409103050.png" alt></p><p><strong>注意，如果只是修改了当前 session 的隔离级别，则换一个 session 之后，隔离级别又会恢复到默认的隔离级别，所以我们测试时，修改当前 session 的隔离级别即可。</strong></p><h4 id="1-2-2-READ-UNCOMMITTED"><a href="#1-2-2-READ-UNCOMMITTED" class="headerlink" title="1.2.2 READ UNCOMMITTED"></a>1.2.2 READ UNCOMMITTED</h4><h5 id="1-2-2-1-准备测试数据"><a href="#1-2-2-1-准备测试数据" class="headerlink" title="1.2.2.1 准备测试数据"></a>1.2.2.1 准备测试数据</h5><p>READ UNCOMMITTED 是最低隔离级别，这种隔离级别中存在<strong>脏读、不可重复读以及幻象读</strong>问题，所以这里我们先来看这个隔离级别，借此大家可以搞懂这三个问题到底是怎么回事。</p><p>下面分别予以介绍。</p><p>首先创建一个简单的表，预设两条数据，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409103216.png" alt></p><p>表的数据很简单，有 javaboy 和 itboyhub 两个用户，两个人的账户各有 1000 人民币。现在模拟这两个用户之间的一个转账操作。</p><p><strong>注意，如果读者使用的是 Navicat 的话，不同的查询窗口就对应了不同的 session，如果读者使用了 SQLyog 的话，不同查询窗口对应同一个 session，因此如果使用 SQLyog，需要读者再开启一个新的连接，在新的连接中进行查询操作。</strong></p><h5 id="1-2-2-2-脏读"><a href="#1-2-2-2-脏读" class="headerlink" title="1.2.2.2 脏读"></a>1.2.2.2 脏读</h5><p>一个事务读到另外一个事务还没有提交的数据，称之为脏读。具体操作如下：</p><ol><li>首先打开两个会话窗口，假设分别为 A 和 B。</li><li>执行如下 SQL，设置会话 A 的隔离级别为 <code>READ UNCOMMITTED</code>：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED;</span><br></pre></td></tr></table></figure><p>然后我们按照如下顺序执行 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110028.png" alt></p><p>SQL1 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110118.png" alt></p><p>SQL2 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110154.png" alt></p><p>SQL3 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110222.png" alt></p><p>可以看到，在 Session A 中看到了 Session B 尚未提交的事务。</p><p>这就是<strong>脏读</strong>问题。</p><h5 id="1-2-2-3-不可重复读"><a href="#1-2-2-3-不可重复读" class="headerlink" title="1.2.2.3 不可重复读"></a>1.2.2.3 不可重复读</h5><p>不可重复读是指一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。具体操作步骤如下（操作之前先将两个账户的钱都恢复为1000）：</p><p>首先打开两个查询会话 A 和 B ，并且将 A 的数据库事务隔离级别设置为 READ UNCOMMITTED。具体 SQL 参考上文，这里不赘述。</p><p>接下来执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112642.png" alt></p><p>SQL1 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112327.png" alt></p><p>SQL2 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112729.png" alt></p><p>SQL3 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112451.png" alt></p><p>可以看到，在 SessionA 中查询同一条记录，多次查询最终的结果可能不一样，这就是<strong>不可重复读</strong>。</p><p><strong>和脏读的区别在于，脏读是看到了其他事务未提交的数据，而不可重复读是看到了其他事务已经提交的数据（由于当前 SQL 也是在事务中，因此有可能并不想看到其他事务已经提交的数据）。</strong></p><h5 id="1-2-2-4-幻象读"><a href="#1-2-2-4-幻象读" class="headerlink" title="1.2.2.4 幻象读"></a>1.2.2.4 幻象读</h5><p>幻象读和不可重复读非常像，看名字就是产生幻觉了。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`age`</span> (<span class="hljs-string">`age`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>id 是主键，age 是唯一非空索引。</p><p>表中数据如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409113352.png" alt></p><p>现在我们有两个会话 Session A 和 Session B，Session A 隔离级别是 READ UNCOMMITTED，Session B 是默认的隔离级别，执行的 SQL 如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409113818.png" alt></p><p>注意，在 SQL1 中用了一个当前读，按理说它会锁住 age 大于 80 的记录，其实也确实锁住了 89 和 99 这样的值，但是对于一开始就不存在的 100 就没能锁住了，这就导致在 SQL3 执行的时候，看到了 SQL2 插入的语句。</p><p>这就是<strong>幻读，幻读专指看到了新插入的行。</strong>。</p><p>看了上面的案例，大家应该明白了<strong>脏读</strong>、<strong>不可重复读</strong>以及<strong>幻读</strong>各自是什么含义了。</p><h4 id="1-2-3-READ-COMMITTED"><a href="#1-2-3-READ-COMMITTED" class="headerlink" title="1.2.3 READ COMMITTED"></a>1.2.3 READ COMMITTED</h4><p>和 READ UNCOMMITTED 相比，READ COMMITTED 主要解决了脏读的问题，对于不可重复读和幻象读则未解决。</p><p>将事务的隔离级别改为 <code>READ COMMITTED</code> 之后，重复上面关于脏读案例的测试，发现已经不存在脏读问题了；重复上面关于不可重复读案例的测试，发现不可重复读和幻读问题依然存在。</p><h4 id="1-2-4-REPEATABLE-READ"><a href="#1-2-4-REPEATABLE-READ" class="headerlink" title="1.2.4 REPEATABLE READ"></a>1.2.4 REPEATABLE READ</h4><p>和 READ COMMITTED 相比，REPEATABLE READ 进一步解决了不可重复读的问题，对于幻读问题，REPEATABLE READ 也有一个自己的方案。</p><p>具体是什么方案呢？松哥第二小节和大家细聊。</p><p><strong>注意，REPEATABLE READ 也是 InnoDB 引擎的默认数据库事务隔离级别</strong></p><h4 id="1-2-5-SERIALIZABLE"><a href="#1-2-5-SERIALIZABLE" class="headerlink" title="1.2.5 SERIALIZABLE"></a>1.2.5 SERIALIZABLE</h4><p>SERIALIZABLE 提供了事务之间最大限度的隔离，在这种隔离级别中，事务一个接一个顺序的执行，不会发生脏读、不可重复读以及幻象读问题，最安全。</p><p>如果设置当前事务隔离级别为 SERIALIZABLE，那么此时开启其他事务时，就会阻塞，必须等当前事务提交了，其他事务才能开启成功，因此前面的脏读、不可重复读以及幻象读问题这里都不会发生。</p><h2 id="2-幻读怎么解决"><a href="#2-幻读怎么解决" class="headerlink" title="2. 幻读怎么解决"></a>2. 幻读怎么解决</h2><p>脏读、不可重复读这两个问题通过修改事务的隔离级别就可以解决，那么幻读该如何解决呢？MySQL 中提出了 Next-Key Lock 来解决幻读问题，当然这个方案也只在 REPEATABLE READ 这个隔离级别下生效。要把这个问题理解透，你得搞明白三把锁：Record Lock、Gap Lock 以及 Next-Key Lock。</p><h3 id="2-1-Record-Lock"><a href="#2-1-Record-Lock" class="headerlink" title="2.1 Record Lock"></a>2.1 Record Lock</h3><p>Record Lock 也就是我们所说的记录锁，记录锁是对索引记录的锁，注意，它是针对<strong>索引记录</strong>，即它只锁定记录这一行数据。</p><p>例如如下一条 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</span><br></pre></td></tr></table></figure><p>注意，id 是索引，id 如果不是索引，上面这条 SQL 所加的排他锁就不是一个 Record Lock。</p><p>我们来看如下一个例子：</p><p>首先我们将系统变量 <code>innodb_status_output_locks</code> 设置为 ON，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403232144.png" alt></p><p>接下来我们执行如下 SQL，锁定一行数据，此时会自动为表加上 IX 锁：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403232442.png" alt></p><p>接下来我们在一个新的会话中执行如下指令来查看 InnoDB 存储引擎的情况：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G</span><br></pre></td></tr></table></figure><p>输出的信息很多，我们重点关注 TRANSACTIONS，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403233056.png" alt></p><p>可以看到：</p><ul><li><code>TABLE LOCK table test08.user trx id 3564804 lock mode IX</code>：这句就是说事务 id 为 3564804 的事务，为 user 表添加了意向排他锁（IX）。</li><li><code>RECORD LOCKS space id 851 page no 3 n bits 80 index PRIMARY of table test08.user trx id 3564804 lock_mode X locks rec but not gap</code>：这个就是一个锁结构的记录，这里的索引是 PRIMARY，加的锁也是正儿八经的记录锁（not gap）。</li></ul><p>看到了 <code>LOCKS REC BUT NOT GAP</code>，就说明这是一个记录锁。</p><p>那么这个 Record Lock 和我们之前所讲的 S 锁以及 X 锁有什么区别呢？S 锁是共享锁，X 锁是排他锁，当我们加 S 锁或者 X 锁的时候，如果用到了索引，锁加在了某一条具体的记录上，那么这个锁也是一个记录锁（其实，记录锁，S 锁，X 锁，概念有一些重复的地方，但是描述的重点不一样）。</p><p>或者也可以理解为记录锁又细分为 S 锁和 X 锁，它们之间的兼容性如下图：</p><table><thead><tr><th style="text-align:center">兼容性</th><th style="text-align:center">S 型记录锁</th><th style="text-align:center">X 型记录锁</th></tr></thead><tbody><tr><td style="text-align:center">S 型记录锁</td><td style="text-align:center">兼容</td><td style="text-align:center">不兼容</td></tr><tr><td style="text-align:center">X 型记录锁</td><td style="text-align:center">不兼容</td><td style="text-align:center">不兼容</td></tr></tbody></table><h3 id="2-2-Gap-Lock"><a href="#2-2-Gap-Lock" class="headerlink" title="2.2 Gap Lock"></a>2.2 Gap Lock</h3><p>Gap Lock 也叫做间隙锁，它的存在可以解决幻读问题，另外需要注意，Gap Lock 也只在 REPEATABLE READ 隔离级别下有效。先来看看什么是幻读，我们来看如下一个表格：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405102112.png" alt></p><p>有两个会话，A 和 B，先在会话 A 中开启事务，然后查询 age 为 99 的用户总数，注意使用当前读，因为在默认的隔离级别下，默认的快照读并不能读到其他事务提交的数据，至于快照读和当前读的区别，大家参考：<a href="https://mp.weixin.qq.com/s/MJGUSFHrz-2-eEvVtK-4Iw" target="_blank" rel="noopener">S 锁与 X 锁，当前读与快照读！</a>。当会话 A 中第一次查询过后，会话 B 中向数据库添加了一行记录，等到会话 A 中第二次查询的时候，就查到了和第一次查询不一样的结果，这就是幻读（注意幻读专指数据插入引起的不一致）。</p><p><strong>在 MySQL 默认的隔离级别 REPEATABLE READ 下，上图所描述的情况无法复现。无法复现的原因在于，在 MySQL 的 REPEATABLE READ 隔离级别中，它已经帮我们解决了幻读问题，解决的方案就是 Gap Lock。</strong></p><p>大家想想，之所以出现幻读的问题，是因为记录之间存在缝隙，用户可以往这些缝隙中插入数据，这就导致了幻读问题，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405104923.png" alt></p><p>如图所示，id 之间有缝隙，有缝隙就有漏洞。前面我们所说的记录锁只能锁住一条具体的记录，但是对于记录之间的空隙却无能无力，这就导致了幻读（其他事务可往缝隙中插入数据）。</p><p>现在 Gap Lock 间隙锁，就是要把这些记录之间的间隙也给锁住，间隙锁住了，就不用担心幻读问题了，<strong>这也是 Gap Lock 存在的意义</strong>。</p><p>给一条记录加 Gap Lock，是锁住了这条记录前面的空隙，例如给 id 为 1 的记录加 Gap Lock，锁住的范围是 (-∞,1)，给 id 为 3 的记录加 Gap Lock，锁住的范围是 (1,3)，那么 id 为 10 后面的空隙怎么锁定呢？MySQL 提供了一个 Supremum 表示当前页面中的最大记录，所以最后针对 Supremum 锁住的范围就是 (10,+∞)，这样，所有的间隙都被覆盖到了，由于锁定的是间隙，所以都是开区间。</p><p>那么我们怎么样能看到 Gap Lock 呢？我给大家举一个简单的例子，假设我有如下一张表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`age`</span> (<span class="hljs-string">`age`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>一个简单的表，id 是主键，age 是普通索引，表中有如下几条记录：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405155210.png" alt></p><p>接下来我们执行如下 SQL，锁定一行数据，此时也会产生间隙锁：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405160054.png" alt></p><p>接下来我们在一个新的会话中执行如下指令来查看 InnoDB 存储引擎的情况：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G</span><br></pre></td></tr></table></figure><p>输出的信息很多，我们重点关注 TRANSACTIONS，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405160201.png" alt></p><p>红色框选中的，就是一个间隙锁的加锁记录，可以看到，在某一个记录之前加了间隙锁。</p><p>这就是间隙锁。非常重要的一点需要大家牢记：<strong>Gap Lock 只在 REPEATABLE READ 隔离级别下有效</strong>。</p><h3 id="2-3-Next-Key-Lock"><a href="#2-3-Next-Key-Lock" class="headerlink" title="2.3 Next-Key Lock"></a>2.3 Next-Key Lock</h3><p>以下内容都是基于 MySQL 默认的隔离级别 REPEATABLE READ。</p><p>如果我们既想锁定一行，又想锁定行之间的记录，那么就是 Next-Key Lock 了，换言之，Next-Key Lock 是 Record Lock 和 Gap Lock 的结合体。</p><p>正常来说，我们<strong>加行锁的基本单位就是 Next-Key Lock</strong>，即既有记录锁又有间隙锁，但是有时候 Next-Key Lock 会退化，我们通过几个简单的例子来分析一下。</p><p>首先我们来看看 Next-Key Lock 的加锁规则：</p><ol><li>锁的范围是左开右闭。</li><li>如果是唯一非空索引的等值查询，Next-Key Lock 会退化成 Record Lock。</li><li>普通索引上的等值查询，向后遍历时，最后一个不满足等值条件的时候，Next-Key Lock 会退化成 Gap Lock。</li></ol><p>我们通过几个简单的例子来分析下。</p><h4 id="2-3-1-唯一非空索引"><a href="#2-3-1-唯一非空索引" class="headerlink" title="2.3.1 唯一非空索引"></a>2.3.1 唯一非空索引</h4><p>假设我有一个学生表，学生表中有学生的姓名和成绩，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`score`</span> <span class="hljs-keyword">double</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`score`</span> (<span class="hljs-string">`score`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>id 是主键，score 是成绩，其中 score 是唯一非空索引。</p><p>现在表中有如下数据：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405161748.png" alt></p><p>假设我们执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405162034.png" alt></p><p>在这个例子中，由于 score 是唯一非空索引，所以 Next-Key Lock 会退化成 Record Lock，换句话说，这行 SQL 只给 score 为 90 的记录加锁，不存在 Gap Lock，即我们新开一个会话，插入一条 score 为 88 的记录也是 OK 的。</p><p>不过这里有一个特例，如果锁定的是一个不存在的记录，那么也会产生间隙锁，例如下面这个：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171719.png" alt></p><p>由于并不存在 score 为 91 的记录，所以这里会产生一个范围为 (90,95) 的间隙锁，我们执行如下 SQL 可以验证：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171943.png" alt></p><p>可以看到，90.1、94.9 都会被阻塞（我按了 Ctrl C，所以大家看到查询终止）。</p><p>90、95 则不符合唯一非空索引的条件。</p><p>95.1 则可以插入成功。</p><p>没问题。</p><h4 id="2-3-2-非空索引"><a href="#2-3-2-非空索引" class="headerlink" title="2.3.2 非空索引"></a>2.3.2 非空索引</h4><p>现在我们重新开始，将 score 索引改为普通索引，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`score`</span> <span class="hljs-keyword">double</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`score`</span> (<span class="hljs-string">`score`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">8</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>数据还是跟前面一样，此时我们来执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163124.png" alt></p><p>我们来分析下。</p><p>此时要锁定的是 id 为 90 的记录，那么首先加间隙锁，上一个 score 为 89，所以这次加的间隙锁范围是 (89,90)，同时要锁定 id 为 90 的记录，所以进一步优化为 (89,90]。</p><p>同时，这里还有一条规则，就是满足条件的上一条记录，也需要被锁住，所以最终的锁范围就是 [89,90]。</p><p>由于 score 不是唯一性索引，所以还需要继续向后查找，找到的下一条记录是 95，由于此时 Next-Key Lock 会退化成 Gap Lock，所以锁定的范围是 (90,95)。综上，最终锁定的范围是 [89,95)。</p><p>接下来我们可以新开一个会话，我们分别尝试添加如下数据看看是否能够添加成功：</p><p>可以看到，score 为 88 是可以的，但是为 89.1 就不行。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163722.png" alt></p><p>score 为 95 也是可以的，但是为 94.9 就不行。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163835.png" alt></p><p>再试一下 89 是否可以：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405170523.png" alt></p><p>说明我们上面分析的加锁范围是正确的。</p><p>再来看如下一条 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405164654.png" alt></p><p>跟前面的案例相比，这次多了 <code>limit 1</code>，limit 1 表示只要一条记录，所以这次查找到 90 之后就不会再往后查找了，那么最终的锁就是间隙锁+一个记录锁，最终的范围就是 [89,90]。</p><p>此时新开一个会话，分别插入 score 为 88.9、89、90、91 的 记录，验证我们上面所分析的加锁范围：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405170833.png" alt></p><p>88.9 和 89 的插入结果跟我们预想的一致。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171002.png" alt></p><p>可以看到，这里 90 也能插入，能插入的原因是因为缺乏 90 往后的间隙锁。</p><p>这三把锁搞明白了，也就理解了在 REPEATABLE READ 中，是如何解决幻读的了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>总的来说，隔离级别和脏读、不可重复读以及幻象读的对应关系如下：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table><p>性能关系如图：</p><p><img src="http://img.itboyhub.com/2021/07/1-72222.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;小伙伴们都知道，MySQL 有四种不同的隔离级别，四种不同的隔离级别会带来三种不同的问题，今天我想再和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Flowable系列杀青啦！251 页PDF文档免费下载</title>
    <link href="http://www.javaboy.org/2022/1216/tienchin-flowable-pdf.html"/>
    <id>http://www.javaboy.org/2022/1216/tienchin-flowable-pdf.html</id>
    <published>2022-12-16T10:25:04.000Z</published>
    <updated>2022-12-20T11:05:42.603Z</updated>
    
    <content type="html"><![CDATA[<p>松哥今年最早是在 4 月份发过一篇 Flowable 教程，中间基本上就断了没再更新了，9 月份开始重新拾起，一口气更新了两个多月，如今，这个系列总算完结杀青啦。</p><a id="more"></a><p>为了方便小伙伴们阅读学习，我把这个系列的文章做成了 PDF，一共是 251 页，供大家免费下载学习，我们先来瞅一眼目录吧：</p><p><img src="http://img.itboyhub.com/2022/08/20221214163344.png" alt></p><p>251 页，差不多一本薄薄的书了，这本电子书中不仅有 Flowable 的基础用法，最后也有一个完整的请假案例可供小伙伴们参考，小伙伴们一定不要错过哦。</p><p>当然，考虑到有的小伙伴可能希望阅读在线的教程，所以，松哥也准备了文章索引，如下：</p><ol><li><a href="https://mp.weixin.qq.com/s/H1TNq5eUEN4H-B0oR12mpg" target="_blank" rel="noopener">工作流入门</a></li><li><a href="https://mp.weixin.qq.com/s/VOGB9JRQKxjs1bVxYJuYpA" target="_blank" rel="noopener">Flowable源码编译</a></li><li><a href="https://mp.weixin.qq.com/s/tc5OdOUONt5qPbT9ZbmQYQ" target="_blank" rel="noopener">Flowable-UI</a></li><li><a href="https://mp.weixin.qq.com/s/5Mcs73Xn8ZZi3S0euPnoSg" target="_blank" rel="noopener">Flowable表结构分析</a></li><li><a href="https://mp.weixin.qq.com/s/9S7RLcE_Xox6i3yju3q_dw" target="_blank" rel="noopener">用户和用户组</a></li><li><a href="https://mp.weixin.qq.com/s/EgbDiYjURD9yU0oFMeZowA" target="_blank" rel="noopener">流程部署与删除</a></li><li><a href="https://mp.weixin.qq.com/s/3UTii7TzyPGJIOc-68YThw" target="_blank" rel="noopener">流程实例</a></li><li><a href="https://mp.weixin.qq.com/s/uXgorkmhHcDq_VTHJNLhZw" target="_blank" rel="noopener">流程历史</a></li><li><a href="https://mp.weixin.qq.com/s/WSKc6LVtnCo7dgSbqcUqeg" target="_blank" rel="noopener">流程暂停与激活</a></li><li><a href="https://mp.weixin.qq.com/s/CbqaQMMDlJ9HLuH-bOP3ew" target="_blank" rel="noopener">DataObject 与租户</a></li><li><a href="https://mp.weixin.qq.com/s/f55gKMhvp1AQ47Bw1gaPMA" target="_blank" rel="noopener">ReceiveTask</a></li><li><a href="https://mp.weixin.qq.com/s/GnYHXlLrzxCBYvo0uv_j_w" target="_blank" rel="noopener">设置任务处理人的四种方式</a></li><li><a href="https://mp.weixin.qq.com/s/wCPkTnm93kiobSOaK_LpOw" target="_blank" rel="noopener">任务认领与回退</a></li><li><a href="https://mp.weixin.qq.com/s/ftVZghFQKaukZI6H0DhbOg" target="_blank" rel="noopener">按角色分配任务</a></li><li><a href="https://mp.weixin.qq.com/s/k4zi7PhJfQFVKDWGBc7K2g" target="_blank" rel="noopener">ServiceTask</a></li><li><a href="https://mp.weixin.qq.com/s/BBuJU5EZRJYwWMmcPT96_g" target="_blank" rel="noopener">ScriptTask</a></li><li><a href="https://mp.weixin.qq.com/s/VqQ0Zp-YXvydZb6Gy5Iyag" target="_blank" rel="noopener">三种网关</a></li><li><a href="https://mp.weixin.qq.com/s/qvm8tGucb7V_JOzAyiXcmQ" target="_blank" rel="noopener">流程变量设置</a></li><li><a href="https://mp.weixin.qq.com/s/1qgDJ63Q09vNOzMGpzA-iA" target="_blank" rel="noopener">历史流程</a></li><li><a href="https://mp.weixin.qq.com/s/jHLj_vwF5yiYWz3E8wRUWw" target="_blank" rel="noopener">定时器</a></li><li><a href="https://mp.weixin.qq.com/s/gk_hp8YUZB5L3gpdy7aCPw" target="_blank" rel="noopener">动态表单</a></li><li><a href="https://mp.weixin.qq.com/s/DKPc9SWk6nWqLS9RQLV79Q" target="_blank" rel="noopener">HTML表单</a></li><li><a href="https://mp.weixin.qq.com/s/KnUH8uerQa0fWPdAkl8zCQ" target="_blank" rel="noopener">JSON表单</a></li><li><a href="https://mp.weixin.qq.com/s/lZ4l_1WGNP5S4g8QBTUdAg" target="_blank" rel="noopener">会签与或签</a></li><li><a href="https://mp.weixin.qq.com/s/ETgKwsaceoUDp3cqKVtVtQ" target="_blank" rel="noopener">绘制实时流程图</a></li><li><a href="https://mp.weixin.qq.com/s/gd66C3YsCugm5_hZAqbMWw" target="_blank" rel="noopener">bpmn.js</a></li><li><a href="https://mp.weixin.qq.com/s/nr4jUGd4ReEE0FzjOx_D_g" target="_blank" rel="noopener">流程图绘制工具</a></li><li><a href="https://mp.weixin.qq.com/s/Pd0MEkZu12vdmGGBT9ZV-w" target="_blank" rel="noopener">SpringBoot+Vue+Flowable</a></li><li><a href="https://mp.weixin.qq.com/s/OTqIsuvCltIYkSYZCQgk3Q" target="_blank" rel="noopener">SpringSecurity+Vue+Flowable</a></li></ol><p>好啦，这是在线的文章索引。</p><p>文档资料都是免费的，这套文档也有配套的视频教程，手把手教大家玩 Flowable，视频目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">103.【workflow】状态机解决流程问题.mp4</span><br><span class="line">104.【workflow】报销审批流程.mp4</span><br><span class="line">105.【workflow】笔记本电脑生产流程.mp4</span><br><span class="line">106.【workflow】三大主流工作流.mp4</span><br><span class="line">107.【workflow】BPMN流程图规范.mp4</span><br><span class="line">108.【workflow】BPMN流程图元素.mp4</span><br><span class="line">109.【workflow】常见的流程绘制工具梳理.mp4</span><br><span class="line">110.【workflow】使用IDEA插件绘制流程图.mp4</span><br><span class="line">111.【workflow】分析流程图的XML文件.mp4</span><br><span class="line">112.【workflow】flowable-ui两种安装方式.mp4</span><br><span class="line">113.【workflow】flowable-ui四大核心功能.mp4</span><br><span class="line">114.【workflow】flowable-ui身份管理.mp4</span><br><span class="line">115.【workflow】flowable-ui管理员功能.mp4</span><br><span class="line">116.【workflow】flowable-ui建模器应用程序-报销流程介绍.mp4</span><br><span class="line">117.【workflow】flowable-ui建模器应用程序-绘制流程图.mp4</span><br><span class="line">118.【workflow】flowable-ui建模器应用程序-填写报销材料.mp4</span><br><span class="line">119.【workflow】flowable-ui建模器应用程序-小于等于1000审批流程.mp4</span><br><span class="line">120.【workflow】flowable-ui建模器应用程序-大于1000审批流程.mp4</span><br><span class="line">121.【workflow】flowable-ui建模器应用程序-流程图下载.mp4</span><br><span class="line">122.【workflow】flowable-ui建模器应用程序-创建流程应用.mp4</span><br><span class="line">123.【workflow】flowable-ui建模器应用程序-细节梳理.mp4</span><br><span class="line">124.【workflow】flowable-ui建模器应用程序-流程监控.mp4</span><br><span class="line">125.【workflow】flowable源码目录结构.mp4</span><br><span class="line">126.【workflow】flowable源码编译.mp4</span><br><span class="line">127.【workflow】flowable源码启动.mp4</span><br><span class="line">128.【workflow】flowable源码接入MySQL数据库.mp4</span><br><span class="line">129.【workflow】flowable源码接口分析.mp4</span><br><span class="line">130.【workflow】flowable添加用户.mp4</span><br><span class="line">131.【workflow】flowable修改和删除用户.mp4</span><br><span class="line">132.【workflow】flowable查询用户.mp4</span><br><span class="line">133.【workflow】flowable用户组的添加与删除.mp4</span><br><span class="line">134.【workflow】flowable用户组的更新与查询.mp4</span><br><span class="line">135.【workflow】flowable查看表详细信息.mp4</span><br><span class="line">136.【workflow】flowable流程自动部署.mp4</span><br><span class="line">137.【workflow】flowable流程自动升级.mp4</span><br><span class="line">138.【workflow】flowable修改流程定义的分类.mp4</span><br><span class="line">139.【workflow】flowable流程自动部署配置.mp4</span><br><span class="line">140.【workflow】flowable手动部署流程.mp4</span><br><span class="line">141.【workflow】flowable查询API.mp4</span><br><span class="line">142.【workflow】flowable自定义流程定义查询SQL.mp4</span><br><span class="line">143.【workflow】flowable自定义流程部署查询SQL.mp4</span><br><span class="line">144.【workflow】flowable删除流程定义.mp4</span><br><span class="line">145.【workflow】flowable流程实例与执行实例.mp4</span><br><span class="line">146.【workflow】flowable启动一个流程实例.mp4</span><br><span class="line">147.【workflow】flowable另一种流程启动方式.mp4</span><br><span class="line">148.【workflow】flowable流程执行.mp4</span><br><span class="line">149.【workflow】flowable判断流程是否执行结束.mp4</span><br><span class="line">150.【workflow】flowable查看运行活动节点.mp4</span><br><span class="line">151.【workflow】flowable删除流程实例.mp4</span><br><span class="line">156.【workflow】flowable中的租户.mp4</span><br><span class="line">157.【workflow】flowable中的ReceiveTask.mp4</span><br><span class="line">158.【workflow】UserTask直接指定处理人.mp4</span><br><span class="line">159.【workflow】UserTask委派或者自己处理.mp4</span><br><span class="line">160.【workflow】通过变量指定UserTask处理人.mp4</span><br><span class="line">161.【workflow】通过监听器指定UserTask处理人.mp4</span><br><span class="line">162.【workflow】设置UserTask处理人为流程发起人.mp4</span><br><span class="line">163.【workflow】设置UserTask候选人.mp4</span><br><span class="line">164.【workflow】UserTask认领任务.mp4</span><br><span class="line">165.【workflow】通过变量或者监听器为UserTask设置处理人.mp4</span><br><span class="line">166.【workflow】UserTask任务回退.mp4</span><br><span class="line">167.【workflow】UserTask候选人的添加与删除.mp4</span><br><span class="line">168.【workflow】UserTask按角色分配.mp4</span><br><span class="line">169.【workflow】UserTask通过变量设置角色.mp4</span><br><span class="line">170.【workflow】通过监听器配置ServiceTask.mp4</span><br><span class="line">171.【workflow】ServiceTask监听器类设置属性.mp4</span><br><span class="line">172.【workflow】ServiceTask委托表达式.mp4</span><br><span class="line">173.【workflow】ServiceTask表达式.mp4</span><br><span class="line">174.【workflow】脚本任务之JavaScript.mp4</span><br><span class="line">175.【workflow】脚本任务之Groovy.mp4</span><br><span class="line">176.【workflow】脚本任务之Juel.mp4</span><br><span class="line">177.【workflow】流程网关之排他网关.mp4</span><br><span class="line">178.【workflow】流程网关之并行网关.mp4</span><br><span class="line">179.【workflow】流程网关之包容网关.mp4</span><br><span class="line">180.【workflow】全局流程变量-启动时设置.mp4</span><br><span class="line">181.【workflow】全局流程变量-Task设置.mp4</span><br><span class="line">182.【workflow】全局流程变量-完成任务时设置.mp4</span><br><span class="line">183.【workflow】全局流程变量-通过执行实例设置.mp4</span><br><span class="line">184.【workflow】本地流程变量-1.mp4</span><br><span class="line">185.【workflow】本地流程变量-2.mp4</span><br><span class="line">186.【workflow】临时流程变量.mp4</span><br><span class="line">187.【workflow】流程历史信息-环境准备.mp4</span><br><span class="line">188.【workflow】流程历史信息-历史流程.mp4</span><br><span class="line">189.【workflow】流程历史信息-历史任务.mp4</span><br><span class="line">190.【workflow】流程历史信息-历史活动.mp4</span><br><span class="line">191.【workflow】流程历史信息-历史变量.mp4</span><br><span class="line">192.【workflow】流程历史信息-历史日志.mp4</span><br><span class="line">193.【workflow】流程历史信息-历史权限.mp4</span><br><span class="line">194.【workflow】流程历史信息-自定义SQL.mp4</span><br><span class="line">195.【workflow】流程历史信息-日志级别.mp4</span><br><span class="line">196.【workflow】流程定义定时激活.mp4</span><br><span class="line">197.【workflow】流程定义定时挂起.mp4</span><br><span class="line">198.【workflow】定时任务表分析.mp4</span><br><span class="line">199.【workflow】流程表单分类.mp4</span><br><span class="line">200.【workflow】动态表单定义.mp4</span><br><span class="line">201.【workflow】查询启动节点上的表单定义.mp4</span><br><span class="line">202.【workflow】启动带表单的实例.mp4</span><br><span class="line">203.【workflow】查询UserTask上的表单.mp4</span><br><span class="line">204.【workflow】动态表单的保存与完成.mp4</span><br><span class="line">205.【workflow】开发外置表单.mp4</span><br><span class="line">206.【workflow】部署带外置表单的流程.mp4</span><br><span class="line">207.【workflow】查看流程启动节点上的外置表单.mp4</span><br><span class="line">208.【workflow】带外置表单的流程审批.mp4</span><br><span class="line">209.【workflow】JSON格式的外置表单.mp4</span><br><span class="line">210.【workflow】根据流程定义绘制流程图.mp4</span><br><span class="line">211.【workflow】根据流程实例绘制流程图.mp4</span><br><span class="line">212.【workflow】根据流程历史绘制流程图.mp4</span><br><span class="line">213.【workflow】综合实践-项目介绍.mp4</span><br><span class="line">214.【workflow】综合实践-绘制流程图.mp4</span><br><span class="line">215.【workflow】综合实践-用户体系问题.mp4</span><br><span class="line">216.【workflow】综合实践-工程创建.mp4</span><br><span class="line">217.【workflow】综合实践-创建用户表.mp4</span><br><span class="line">218.【workflow】综合实践-自定义用户登录.mp4</span><br><span class="line">219.【workflow】综合实践-服务类开发.mp4</span><br><span class="line">220.【workflow】综合实践-流程部署.mp4</span><br><span class="line">221.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">222.【workflow】综合实践-开发请假页面.mp4</span><br><span class="line">223.【workflow】综合实践-选择审批人.mp4</span><br><span class="line">224.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">225.【workflow】综合实践-待审批流程接口.mp4</span><br><span class="line">226.【workflow】综合实践-待审批流程页面.mp4</span><br><span class="line">227.【workflow】综合实践-添加流程实例ID.mp4</span><br><span class="line">228.【workflow】综合实践-返回流程实时进度.mp4</span><br><span class="line">229.【workflow】综合实践-展示流程实时进度.mp4</span><br><span class="line">230.【workflow】综合实践-当前用户待审批的任务.mp4</span><br><span class="line">231.【workflow】综合实践-网页展示待审批任务.mp4</span><br><span class="line">232.【workflow】综合实践-请假任务审批.mp4</span><br><span class="line">233.【workflow】综合实践-查看请假历史接口.mp4</span><br><span class="line">234.【workflow】综合实践-页面展示历史请假.mp4</span><br><span class="line">235.【workflow】综合实践-查看流程进度图.mp4</span><br></pre></td></tr></table></figure><p>视频总共 130+ 集，20+ 小时，视频录制成本较高，因此这套视频是<strong>付费</strong>的，售价 ¥219，算是全网性价比比较高的 Flowable 视频教程了。</p><p>当然，如果你购买了 TienChin 项目，这套 Flowable 视频是免费赠送的，TienChin 原价 ¥399，目前有七折优惠，只要 279（由于 TienChin 项目已经进入到做项目阶段了，所以接下来可能优惠力度没这么大了），TienChin 项目介绍：<a href="https://mp.weixin.qq.com/s/iESPDUWO63Boh52oLI3Eiw" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p><p>有需要 Flowable 配套视频教程的小伙伴可以添加如下微信咨询：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p><p>好啦，小伙伴们在公众号后台回复 flowable，可以获取 PDF 下载链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥今年最早是在 4 月份发过一篇 Flowable 教程，中间基本上就断了没再更新了，9 月份开始重新拾起，一口气更新了两个多月，如今，这个系列总算完结杀青啦。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>来聊一聊 ElasticSearch 最新版的 Java 客户端</title>
    <link href="http://www.javaboy.org/2022/1214/elasticsearch-java-client.html"/>
    <id>http://www.javaboy.org/2022/1214/elasticsearch-java-client.html</id>
    <published>2022-12-14T10:24:52.000Z</published>
    <updated>2022-12-20T11:05:39.054Z</updated>
    
    <content type="html"><![CDATA[<p>可能不少小伙伴都注意到了，从 ElasticSearch7.17 这个版本开始，原先的 Java 高级客户端<br>Java High Level REST Client 废弃了，不支持了。老实说，ElasticSearch 算是我用过的所有 Java 工具中，更新最为激进的一个了，在 Es7 中废弃了 TransportClient，7.17 又废弃了 TransportClient，那么现在用啥呢？现在的客户端叫做 Elasticsearch Java API Client。</p><a id="more"></a><p>一直偷懒选择无视 Elasticsearch Java API Client，不过最近工作中用到了，所以还是整篇文章和小伙伴们简单梳理一下 Elasticsearch Java API Client 的玩法。</p><p>下面的介绍我主要从索引操作和文档操作两个方面来给大家介绍。</p><p>不过需要跟大家强调的是，ElasticSearch 的 Java 客户端想要用的 6，必须要熟悉 ElasticSearch 的查询脚本，大家平时在工作中遇到 Es 相关的问题，我也都是建议先在 Kibana 中把操作脚本写好，然后再翻译成 Java 代码，或者直接拷贝到 Java 代码中，<strong>非常不建议上来就整 Java 代码</strong>，那样很容易出错。</p><p>如果你对 Es 的操作不熟悉，松哥录了免费的视频教程，大家可以参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1ft4y1e7tq/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ft4y1e7tq/</a></li></ul><p><img src="http://img.itboyhub.com/2022/08/20221214102250.png" alt></p><p>不想看视频，也可以在微信公众号后台回复 es，有文档教程。</p><h2 id="1-Elasticsearch-Java-API-Client"><a href="#1-Elasticsearch-Java-API-Client" class="headerlink" title="1. Elasticsearch Java API Client"></a>1. Elasticsearch Java API Client</h2><p>Elasticsearch Java API Client 是 Elasticsearch 的官方 Java API，这个客户端为所有 Elasticsearch APIs 提供强类型的请求和响应。</p><blockquote><p>这里跟大家解释下什么是强类型的请求和响应：因为所有的 Elasticsearch APIs 本质上都是一个 RESTful 风格的 HTTP 请求，所以当我们调用这些 Elasticsearch APIs 的时候，可以就当成普通的 HTTP 接口来对待，例如使用 HttpUrlConnection 或者 RestTemplate 等工具来直接调用，如果使用这些工具直接调用，就需要我们自己组装 JSON 参数，然后自己解析服务端返回的 JSON。而强类型的请求和响应则是系统把请求参数封装成一个对象了，我们调用对象中的方法去设置就可以了，不需要自己手动拼接 JSON 参数了，请求的结果系统也会封装成一个对象，不需要自己手动去解析 JSON 参数了。</p></blockquote><p>小伙伴们看一下下面这个例子，我想查询 books 索引中，书名中包含 Java 关键字的图书：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsDemo02</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"http://localhost:9200/books/_search?pretty"</span>);</span><br><span class="line">        HttpURLConnection con = (HttpURLConnection) url.openConnection();</span><br><span class="line">        con.setRequestMethod(<span class="hljs-string">"GET"</span>);</span><br><span class="line">        con.setRequestProperty(<span class="hljs-string">"content-type"</span>,<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        <span class="hljs-comment">//允许输出流/允许参数</span></span><br><span class="line">        con.setDoOutput(<span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-comment">//获取输出流</span></span><br><span class="line">        OutputStream out = con.getOutputStream();</span><br><span class="line">        String params = <span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"  \"query\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"    \"term\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"      \"name\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"        \"value\": \"java\"\n"</span> +</span><br><span class="line">                <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"&#125;"</span>;</span><br><span class="line">        out.write(params.getBytes());</span><br><span class="line">        <span class="hljs-keyword">if</span> (con.getResponseCode() == <span class="hljs-number">200</span>) &#123;</span><br><span class="line">            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">            String str = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> ((str = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这就是一个普通的 HTTP 请求，请求参数就是查询的条件，这个条件是一个 JSON 字符串，需要我们自己组装，请求的返回值也是一个 JSON 字符串，这个 JSON 字符串也需要我们自己手动去解析，这种可以算是弱类型的请求和响应。</p><p>Elasticsearch Java API Client 具有如下特性：</p><ul><li>为所有 Elasticsearch APIs 提供强类型的请求和响应。</li><li>所有 API 都有阻塞和异步版本。</li><li>使用构建器模式，在创建复杂的嵌套结构时，可以编写简洁而可读的代码。</li><li>通过使用对象映射器（如 Jackson 或任何实现了 JSON-B 的解析器），实现应用程序类的无缝集成。</li><li>将协议处理委托给一个 http 客户端，如 Java Low Level REST Client，它负责所有传输级的问题。HTTP 连接池、重试、节点发现等等由它去完成。</li></ul><p>关于第三点，松哥吐槽一句，确实简洁，但是可读性一般般吧。</p><p>另外还有两点需要注意：</p><ul><li>Elasticsearch Java 客户端是向前兼容的，即该客户端支持与 Elasticsearch 的更大或相等的次要版本进行通信。</li><li>Elasticsearch Java 客户端只向后兼容默认的发行版本，并且没有做出保证。</li></ul><p>好了，那就不废话了，开整吧。</p><h2 id="2-引入-Elasticsearch-Java-API-Client"><a href="#2-引入-Elasticsearch-Java-API-Client" class="headerlink" title="2. 引入 Elasticsearch Java API Client"></a>2. 引入 Elasticsearch Java API Client</h2><p>首先需要我们加依赖，对 JDK 的版本要求是 1.8，我们需要添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>co.elastic.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 项目，就不用添加第二个依赖了，因为 Spring Boot 的 Web 中默认已经加了这个依赖了，但是 Spring Boot 一般需要额外添加下面这个依赖，出现这个原因是由于从 JavaEE 过渡到 JakartaEE 时衍生出来的一些问题，这里我就不啰嗦了，咱们直接加依赖即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.json<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.json-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3. 建立连接"></a>3. 建立连接</h2><p>接下来我们需要用我们的 Java 客户端和 ElasticSearch 之间建立连接，建立连接的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestClient restClient = RestClient.builder(</span><br><span class="line">    <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">    restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里一共有三个步骤：</p><ol><li>首先创建一个低级客户端，这个其实松哥之前的视频中和大家讲过低级客户端的用法，这里就不再赘述。</li><li>接下来创建一个通信 Transport，并利用 JacksonJsonpMapper 做数据的解析。</li><li>最后创建一个阻塞的 Java 客户端。</li></ol><p>上面这个是创建了一个阻塞的 Java 客户端，当然我们也可以创建非阻塞的 Java 客户端，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestClient restClient = RestClient.builder(</span><br><span class="line">        <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">        restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchAsyncClient client = <span class="hljs-keyword">new</span> ElasticsearchAsyncClient(transport);</span><br></pre></td></tr></table></figure><p>只有第三步和前面的不一样，其他都一样。</p><blockquote><p>利用阻塞的 Java 客户端操作 Es 的时候会发生阻塞，也就是必须等到 Es 给出响应之后，代码才会继续执行；非阻塞的 Java 客户端则不会阻塞后面的代码执行，非阻塞的 Java 客户端一般通过回调函数处理请求的响应值。</p></blockquote><p>有时候，我们可能还需要和 Es 之间建立 HTTPS 连接，那么需要在前面代码的基础之上，再套上一层 SSL，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String fingerprint = <span class="hljs-string">"&lt;certificate fingerprint&gt;"</span>;</span><br><span class="line">SSLContext sslContext = TransportUtils</span><br><span class="line">    .sslContextFromCaFingerprint(fingerprint); </span><br><span class="line">BasicCredentialsProvider credsProv = <span class="hljs-keyword">new</span> BasicCredentialsProvider(); </span><br><span class="line">credsProv.setCredentials(</span><br><span class="line">    AuthScope.ANY, <span class="hljs-keyword">new</span> UsernamePasswordCredentials(login, password)</span><br><span class="line">);</span><br><span class="line">RestClient restClient = RestClient</span><br><span class="line">    .builder(<span class="hljs-keyword">new</span> HttpHost(host, port, <span class="hljs-string">"https"</span>)) </span><br><span class="line">    .setHttpClientConfigCallback(hc -&gt; hc</span><br><span class="line">        .setSSLContext(sslContext) </span><br><span class="line">        .setDefaultCredentialsProvider(credsProv)</span><br><span class="line">    )</span><br><span class="line">    .build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br></pre></td></tr></table></figure><p>好了，关于建立连接，差不多就这些点。</p><h2 id="4-索引操作"><a href="#4-索引操作" class="headerlink" title="4. 索引操作"></a>4. 索引操作</h2><p>Elasticsearch Java API Client 中最大的特色就是建造者模式+Lambda 表达式。例如，我想创建一个索引，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test99</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(</span><br><span class="line">            c -&gt;</span><br><span class="line">                    c.index(<span class="hljs-string">"javaboy_books"</span>)</span><br><span class="line">                            .settings(s -&gt;</span><br><span class="line">                                    s.numberOfShards(<span class="hljs-string">"3"</span>)</span><br><span class="line">                                            .numberOfReplicas(<span class="hljs-string">"1"</span>))</span><br><span class="line">                            .mappings(m -&gt;</span><br><span class="line">                                    m.properties(<span class="hljs-string">"name"</span>, p -&gt; p.text(f -&gt; f.analyzer(<span class="hljs-string">"ik_max_word"</span>)))</span><br><span class="line">                                            .properties(<span class="hljs-string">"birthday"</span>, p -&gt; p.date(d -&gt; d.format(<span class="hljs-string">"yyyy-MM-dd"</span>))))</span><br><span class="line">                            .aliases(<span class="hljs-string">"books_alias"</span>, f -&gt; f.isWriteIndex(<span class="hljs-keyword">true</span>)));</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.acknowledged() = "</span> + createIndexResponse.acknowledged());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.index() = "</span> + createIndexResponse.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.shardsAcknowledged() = "</span> + createIndexResponse.shardsAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里都是建造者模式和 Lambda 表达式，方法名称其实都很好理解（前提是你得熟悉 ElasticSearch 操作脚本），例如：</p><ul><li>index 方法表示设置索引名称</li><li>settings 方法表示配置 setting 中的参数</li><li>numberOfShards 表示索引的分片数</li><li>numberOfReplicas 表示配置索引的副本数</li><li>mapping 表示配置索引中的映射规则</li><li>properties 表示配置索引中的具体字段</li><li>text 方法表示字段是 text 类型的</li><li>analyzer 表示配置字段的分词器</li><li>aliases 表示配置索引的别名</li></ul><p>反正这里的方法都是见名知义的，上面这个就类似于下面这个请求：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT javaboy_books</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"number_of_replicas"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"number_of_shards"</span>: <span class="hljs-number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>:&#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,</span><br><span class="line">        <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-attr">"birthday"</span>:&#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,</span><br><span class="line">        <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"aliases"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"xxxx"</span>:&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们在写的时候，脑子里要先有下面这个脚本，然后 Java 方法可以顺手拈来了。</p><p>最终创建好的索引如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221214102322.png" alt></p><p>有的小伙伴可能觉得调这一大堆方法太啰里啰唆了，来个简单的，直接上 JSON，那也不是不可以，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test98</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    StringReader json = <span class="hljs-keyword">new</span> StringReader(<span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"settings\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"number_of_replicas\": 1,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"number_of_shards\": 3\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"mappings\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"properties\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"name\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"type\": \"text\",\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"analyzer\": \"ik_max_word\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"birthday\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"type\": \"date\",\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"format\": \"yyyy-MM-dd\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"aliases\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"xxxx\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(</span><br><span class="line">            c -&gt;</span><br><span class="line">                    c.index(<span class="hljs-string">"javaboy_books"</span>).withJson(json));</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.acknowledged() = "</span> + createIndexResponse.acknowledged());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.index() = "</span> + createIndexResponse.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.shardsAcknowledged() = "</span> + createIndexResponse.shardsAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是直接把 JSON 参数给拼接出来，就不需要一堆建造者+Lambda 了。</p><p>如果你想删除索引呢？如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    <span class="hljs-comment">//删除一个索引</span></span><br><span class="line">    DeleteIndexResponse delete = client.indices().delete(f -&gt;</span><br><span class="line">            f.index(<span class="hljs-string">"my-index"</span>)</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="hljs-string">"delete.acknowledged() = "</span> + delete.acknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示删除一个名为 <code>my-index</code> 的索引。</p><p>好了，关于索引的操作我就说这两点。</p><p>可能有的小伙伴会说，ElasticSearch 中创建索引可以配置很多参数你都没讲。在我看来，哪些很多参数其实跟这个 Java API 没有多大关系，只要你会写查询脚本，就自然懂得 Java API 中该调用哪个方法，退一万步讲，你会脚本，不懂 Java API 的方法，那么就像上面那样，直接把你的 JSON 拷贝过来，作为 Java API 的参数即可。</p><h2 id="5-文档操作"><a href="#5-文档操作" class="headerlink" title="5. 文档操作"></a>5. 文档操作</h2><h3 id="5-1-添加文档"><a href="#5-1-添加文档" class="headerlink" title="5.1 添加文档"></a>5.1 添加文档</h3><p>先来看文档的添加操作。</p><p>如下表示我想给一个名为 books 的索引中添加一个 id 为 890 的书：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    Book book = <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    book.setId(<span class="hljs-number">890</span>);</span><br><span class="line">    book.setName(<span class="hljs-string">"深入理解Java虚拟机"</span>);</span><br><span class="line">    book.setAuthor(<span class="hljs-string">"xxx"</span>);</span><br><span class="line">    <span class="hljs-comment">//添加一个文档</span></span><br><span class="line">    <span class="hljs-comment">//这是一个同步请求，请求会卡在这里</span></span><br><span class="line">    IndexResponse response = client.index(i -&gt; i.index(<span class="hljs-string">"books"</span>).document(book).id(<span class="hljs-string">"890"</span>));</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.result() = "</span> + response.result());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.id() = "</span> + response.id());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.seqNo() = "</span> + response.seqNo());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.index() = "</span> + response.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.shards() = "</span> + response.shards());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加成功之后，返回的 IndexResponse 对象其实就是对下面这个 JSON 的封装：</p><p><img src="http://img.itboyhub.com/2022/08/20221214102339.png" alt></p><p>现在我们只需要调用相应的方法，就可以获取到 JSON 相关的属性了。</p><h3 id="5-2-删除文档"><a href="#5-2-删除文档" class="headerlink" title="5.2 删除文档"></a>5.2 删除文档</h3><p>如下表示删除 books 索引中 id 为 891 的文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test09</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchAsyncClient client = <span class="hljs-keyword">new</span> ElasticsearchAsyncClient(transport);</span><br><span class="line">    client.delete(d -&gt; d.index(<span class="hljs-string">"books"</span>).id(<span class="hljs-string">"891"</span>)).whenComplete((resp, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"resp.result() = "</span> + resp.result());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除这里我用了异步非阻塞的客户端来给小伙伴们演示的，异步非阻塞的话，就使用 whenComplete 方法处理回调就行了，里边有两个参数，一个是正常情况下返回的对象，另外一个则是出错时候的异常。</p><h3 id="5-3-查询文档"><a href="#5-3-查询文档" class="headerlink" title="5.3 查询文档"></a>5.3 查询文档</h3><p>最后，就是查询了。这应该是大家日常开发中使用较多的功能项了，不过我还是前面的态度，查询的关键不在 Java API，而在于你对 ElasticSearch 脚本的掌握程度。</p><p>所以我这里举个简单的例子，小伙伴们大致了解下 Java API 的方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest.Builder()</span><br><span class="line">            <span class="hljs-comment">//去哪个索引里搜索</span></span><br><span class="line">            .index(<span class="hljs-string">"books"</span>)</span><br><span class="line">            .query(QueryBuilders.term().field(<span class="hljs-string">"name"</span>).value(<span class="hljs-string">"java"</span>).build()._toQuery())</span><br><span class="line">            .build();</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(request, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子是一个 term 查询，查询 books 索引中书名 name 中包含 java 关键字的图书，等价于下面这个查询：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"query"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"term"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"value"</span>: <span class="hljs-string">"java"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望能够对查询关键字分词之后查询，那么可以使用 match 查询，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(s -&gt; &#123;</span><br><span class="line">        s.index(<span class="hljs-string">"books"</span>)</span><br><span class="line">                .query(q -&gt; &#123;</span><br><span class="line">                    q.match(m -&gt; &#123;</span><br><span class="line">                        m.field(<span class="hljs-string">"name"</span>).query(<span class="hljs-string">"美术计算机"</span>);</span><br><span class="line">                        <span class="hljs-keyword">return</span> m;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">return</span> q;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="hljs-keyword">return</span> s;</span><br><span class="line">    &#125;, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了让小伙伴们看到这个 Java 客户端的不同用法，上面两个查询的例子，我分别使用了构造查询请求和建造者+Lambda 的方式。</p></blockquote><p>match 查询就调用 match 方法就行了，设置查询关键字即可，这个查询等价于下面这个查询：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"query"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"match"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"美术计算机"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这种调用各种方法拼接参数的方式不习惯，那么也可以直接上 JSON，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    String key = <span class="hljs-string">"java"</span>;</span><br><span class="line">    StringReader sr = <span class="hljs-keyword">new</span> StringReader(<span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"query\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"term\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"name\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"value\": \""</span> + key + <span class="hljs-string">"\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest.Builder()</span><br><span class="line">            .withJson(sr)</span><br><span class="line">            .build();</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(request, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接把查询的 JSON 参数传进来也是可以的。这样我们就可以先在 Kibana 中写好脚本，然后直接将脚本拷贝到 Java 代码中来执行就行了。</p><p>好啦，关于 Es 中新的 Java 客户端，我就和大家说这么多，最后再强调一下，这其实不是重点，玩 Es 的重点是把 Es 的各种查询参数搞懂，那么 Java 代码其实就是顺手拈来的事了。</p><p>最后，如果大家对 Es 不熟悉，可以看看松哥录的这个免费视频教程：</p><ul><li><a href="https://www.bilibili.com/video/BV1ft4y1e7tq/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ft4y1e7tq/</a></li></ul><p><img src="http://img.itboyhub.com/2022/08/20221214102357.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能不少小伙伴都注意到了，从 ElasticSearch7.17 这个版本开始，原先的 Java 高级客户端&lt;br&gt;Java High Level REST Client 废弃了，不支持了。老实说，ElasticSearch 算是我用过的所有 Java 工具中，更新最为激进的一个了，在 Es7 中废弃了 TransportClient，7.17 又废弃了 TransportClient，那么现在用啥呢？现在的客户端叫做 Elasticsearch Java API Client。&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP在项目中的典型应用场景</title>
    <link href="http://www.javaboy.org/2022/1208/spring-aop.html"/>
    <id>http://www.javaboy.org/2022/1208/spring-aop.html</id>
    <published>2022-12-08T10:24:35.000Z</published>
    <updated>2022-12-20T11:05:34.803Z</updated>
    
    <content type="html"><![CDATA[<p>学过 Spring 的小伙伴相信都知道 AOP，AOP 学的好的小伙伴相信对 AOP 的概念也是轻车熟路：面向切面编程、切点、切面、通知，Aspect、Pointcut、Advice 等如数家珍。</p><a id="more"></a><p>AOP 之所以这么重要，是因为它在项目中有着非常广泛的应用，今天这篇文章，松哥就来和大家总结一下，我们在日常开发中，都有哪些典型场景需要用到 AOP。</p><blockquote><p>先来一句话总结下，AOP 的使用，基本上都会涉及到自定义注解，一个非常常见的组合，就是自定义注解+AOP。</p></blockquote><p>在日常的开发中，有很多重复的代码，我们总是希望将之简化，AOP 就是一个非常常用的简化手段。简化的思路一般是这样：</p><ol><li>首先，自定义一个注解。</li><li>定义 AOP 切面，在切面中，定义切点和通知，切点，也就是方法的拦截规则，我们可以按照注解来拦截，也就是某一个带有自定义注解的方法，将被我拦截下来。</li><li>拦截下来之后，前置通知、后置通知、异常通知、返回通知还是环绕通知，就可以随便写了。</li></ol><p>所以，这些涉及到自定义注解的地方，基本上都可以算是 AOP 的使用场景了，因为自定义注解，需要用 AOP 来解析。</p><p>接下来我们来看几个比较典型的例子。</p><h2 id="1-幂等性处理"><a href="#1-幂等性处理" class="headerlink" title="1. 幂等性处理"></a>1. 幂等性处理</h2><p>接口幂等性的处理，其实有很多种不同的方案，例如：</p><ol><li>Token 机制</li><li>去重表</li><li>利用 Redis 的 setnx</li><li>设置状态字段</li><li>上锁</li></ol><p>无论是哪种方案处理幂等性，每个方法里边都去写一遍幂等性的处理显然是不现实的，因此，一般都是将幂等性的处理通过自定义注解+AOP给封装起来，大致的思路如下：</p><ol><li>首先自定义一个注解。</li><li>自定义切点，拦截所有加了自定义注解的方法。</li><li>定义环绕通知，在环绕通知中，先通过上述五种思路中的任意一种，对方法执行的幂等性进行判断，判断通过了，再执行目标方法，判断不通过，则直接抛出异常，不执行目标方法。</li></ol><p>这就是自定义注解+AOP 的一个典型应用场景。</p><p>如果你对上面的表述云里雾里，不妨看看松哥之前发的这个视频，有详细的手把手教程：<a href="https://mp.weixin.qq.com/s/qSXS401IX2libPKVVVuChQ" target="_blank" rel="noopener">处理接口幂等性的两种常见方案|手把手教你</a>。</p><h2 id="2-接口限流"><a href="#2-接口限流" class="headerlink" title="2. 接口限流"></a>2. 接口限流</h2><p>对于接口限流，目前来说，一个比较成熟的方案是使用 Alibaba 的 Sentienl，简单配置一下就可以实现接口限流了。</p><p>但是如果没有用这个工具呢？如果是我们自己写呢？毫无疑问，还是自定义注解+AOP，思路大致如下：</p><ol><li>自定义注解。</li><li>在需要进行限流的接口方法上添加自定义注解，同时还可以设置一些限流的参数，例如时间窗口值、流量大小等。</li><li>自定义切点，拦截规则就是所有添加了自定义注解的方法，拦截到方法之后，在环绕通知中，可以通过 Redis 插件 redis-cell、通过漏斗算法去处理限流，这个我这里就不罗嗦了，之前的文章中都写过了。限流计算没问题的话，就执行目标方法，否则将操作拦截下来。</li></ol><p>大致思路如上，说白了就是自定义注解+ AOP，道理虽然简单，但是真正做起来，还是有很多细节，感兴趣的小伙伴可以参考松哥之前的这篇文章：<a href="https://mp.weixin.qq.com/s/rzz2tgBBJpWz7gjmEfz2XQ" target="_blank" rel="noopener">Redis 做接口限流，一个注解的事！</a>。</p><h2 id="3-日志处理"><a href="#3-日志处理" class="headerlink" title="3. 日志处理"></a>3. 日志处理</h2><p>说到 AOP，所有人都能想到的使用场景了，这个我就不罗嗦了，松哥之前也有过专门的文章介绍，没看过的小伙伴们戳这里：<a href="https://mp.weixin.qq.com/s/29WX3G7FC5BXiD0lS1tnbw" target="_blank" rel="noopener">记录项目日志，一个注解搞定</a>。</p><h2 id="4-多数据源处理"><a href="#4-多数据源处理" class="headerlink" title="4. 多数据源处理"></a>4. 多数据源处理</h2><p>有时候我们项目中存在多个不同的数据源，在实际使用中需要进行切换，网上也有一些开源的解决方案，不过这个东西其实并不难，我们也可以自己写。</p><p>自定义多数据源的处理，大致上思路如下：</p><p>从 Spring2.0.1 中引入了 AbstractRoutingDataSource 类，（注意是 Spring2.0.1 不是 Spring Boot2.0.1，所以这其实也算是 Spring 一个非常古老的特性了）, 该类充当了 DataSource 的路由中介，它能够在运行时, 根据某种 key 值来动态切换到真正的 DataSource 上。</p><p>大致的用法就是你提前准备好各种数据源，存入到一个 Map 中，Map 的 key 就是这个数据源的名字，Map 的 value 就是这个具体的数据源，然后再把这个 Map 配置到 AbstractRoutingDataSource 中，最后，每次执行数据库查询的时候，拿一个 key 出来，AbstractRoutingDataSource 会找到具体的数据源去执行这次数据库操作。</p><p>基于以上知识，我们可以自定义一个注解，在需要切换数据源的方法上，添加这个注解，然后通过 AOP 去解析这个自定义注解，当目标方法被拦截下来的时候，我们跟进注解中的配置，重新设置要执行的数据源，这样将来 service 中的方法在执行的过程中，就会使用到切换之后的数据源了。</p><p>思路并不难，松哥之前也写过详细的教程，小伙伴们参考这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/g71F3cnLtD4zqJGFCeJckQ" target="_blank" rel="noopener">手把手教你玩多数据源动态切换！</a></li><li><a href="https://mp.weixin.qq.com/s/JmVUDyyFT8OB_F8fj3FvqQ" target="_blank" rel="noopener">网页上点一下，就能切换不同数据源？松哥手把手教你！</a></li></ul><h2 id="5-方法权限处理"><a href="#5-方法权限处理" class="headerlink" title="5. 方法权限处理"></a>5. 方法权限处理</h2><p>这个其实也跟前面的差不多。</p><p>方法级别的权限处理，一般来说也是基于注解来完成的。如果你使用了 Spring Security 之类的权限框架，就不用自己解析权限注解了，按照框架的要求直接来使用就行了。</p><p>有的时候，我们可能没有使用 Spring Security，想自己处理权限注解，也是可以的。用户自定义权限注解，为注解添加属性，然后将注解添加到目标方法上，再通过 AOP 去解析这个注解，AOP 将目标方法的执行拦截下来，然后判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。</p><p>前两天松哥刚刚分享的在微服务中，服务内部的权限校验，就是自定义一个注解，将从其他微服务上来的请求给拦截下来，然后判断请求的来源，如果是从其他微服务上来的，就执行目标方法，如果不是从其他微服务上来的，而是从外部来的请求，那么就将之拦截下来抛出异常，不执行目标方法，参见：<a href="https://mp.weixin.qq.com/s/BVeBr4Wjb5XpzPwXc7iZ7g" target="_blank" rel="noopener">微服务中的鉴权该怎么做？</a>。</p><h2 id="6-事务处理"><a href="#6-事务处理" class="headerlink" title="6. 事务处理"></a>6. 事务处理</h2><p>这个倒是不需要自定义注解，对于声明式事务，直接用现成的注解就行了，但是本质上也是 AOP，如果有小伙伴在 Spring 的 XML 中配置过事务的话，就知道这个东西底层也是 AOP。</p><p>好啦，梳理了几个简单的案例，希望小伙伴们了解到 AOP 并不是屠龙术，而是在日常开发中有着广泛应用的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学过 Spring 的小伙伴相信都知道 AOP，AOP 学的好的小伙伴相信对 AOP 的概念也是轻车熟路：面向切面编程、切点、切面、通知，Aspect、Pointcut、Advice 等如数家珍。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
</feed>
