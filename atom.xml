<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-07-23T00:37:14.013Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis 中 @Param 注解的四种使用场景，最后一种经常被人忽略！</title>
    <link href="http://www.javaboy.org/2019/0723/mybatis-@param.html"/>
    <id>http://www.javaboy.org/2019/0723/mybatis-@param.html</id>
    <published>2019-07-23T00:36:00.000Z</published>
    <updated>2019-07-23T00:37:14.013Z</updated>
    
    <content type="html"><![CDATA[<p>有一些小伙伴觉得 MyBatis 只有方法中存在多个参数的时候，才需要添加 @Param 注解，其实这个理解是不准确的。即使 MyBatis 方法只有一个参数，也可能会用到 @Param 注解。</p><a id="more"></a><p>但是，在你总结出规律之前，你可能会觉得莫名其妙，有的时候一个参数明明不用添加 @Param 注解，有的时候，却需要添加，不添加会报错。</p><p>有的人会觉得这是 MyBatis 各个版本差异的锅，不可否认，MyBatis 发展很快，不同版本之间的差异还挺明显的，不过这个加不加 @Param 注解的问题，却并不是版本的锅！今天松哥就和大家来聊一聊这个问题，到底哪些情况下需要添加 @Param 注解。</p><p>首先，如下几个需要添加 @Param 注解的场景，相信大家都已经有共识了：</p><ul><li>第一种：方法有多个参数，需要 @Param 注解</li></ul><p>例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">Integer <span class="hljs-title">insert</span><span class="hljs-params">(@Param(<span class="hljs-string">"username"</span>)</span> String username, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"address"</span>)</span> String address)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    insert into user (username,address) values (#&#123;username&#125;,#&#123;address&#125;);</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是最常见的需要添加 @Param 注解的场景。</p><ul><li>第二种：方法参数要取别名，需要 @Param 注解</li></ul><p>当需要给参数取一个别名的时候，我们也需要 @Param 注解，例如方法定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(@Param(<span class="hljs-string">"name"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 定义如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserByUsername"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user where username=#&#123;name&#125;;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>老实说，这种需求不多，费事。</p><ul><li>第三种：XML 中的 SQL 使用了 $ ，那么参数中也需要 @Param 注解</li></ul><p>$ 会有注入漏洞的问题，但是有的时候你不得不使用 $ 符号，例如要传入列名或者表名的时候，这个时候必须要添加 @Param 注解，例如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">(@Param(<span class="hljs-string">"order_by"</span>)</span>String order_by)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 定义如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsers"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"order_by!=null and order_by!=''"</span>&gt;</span></span><br><span class="line">        order by $&#123;order_by&#125; desc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面这三种，都很容易懂，相信很多小伙伴也都懂，除了这三种常见的场景之外，还有一个特殊的场景，经常被人忽略。</p><ul><li>第四种，那就是动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数。</li></ul><p>如果我们在动态 SQL 中用到了 参数作为判断条件，那么也是一定要加 @Param 注解的，例如如下方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserById</span><span class="hljs-params">(@Param(<span class="hljs-string">"id"</span>)</span>Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义出来的 SQL 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id!=null"</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况，即使只有一个参数，也需要添加 @Param 注解，而这种情况却经常被人忽略！</p><p>好了，不知道大家有没有 GET 到呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些小伙伴觉得 MyBatis 只有方法中存在多个参数的时候，才需要添加 @Param 注解，其实这个理解是不准确的。即使 MyBatis 方法只有一个参数，也可能会用到 @Param 注解。&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 邮件发送的 5 种姿势！</title>
    <link href="http://www.javaboy.org/2019/0717/springboot-mail.html"/>
    <id>http://www.javaboy.org/2019/0717/springboot-mail.html</id>
    <published>2019-07-17T00:30:51.000Z</published>
    <updated>2019-07-17T00:34:57.250Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><a id="more"></a><h1 id="邮件基础"><a href="#邮件基础" class="headerlink" title="邮件基础"></a>邮件基础</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/mail/24-1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/mail/24-2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/mail/24-3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="http://www.javaboy.org/images/mail/24-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h2 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h2><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-5.png" alt></p><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-6.png" alt></p><h2 id="发送带图片资源的邮件"><a href="#发送带图片资源的邮件" class="headerlink" title="发送带图片资源的邮件"></a>发送带图片资源的邮件</h2><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="http://www.javaboy.org/images/mail/24-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h2 id="使用-Freemarker-作邮件模板"><a href="#使用-Freemarker-作邮件模板" class="headerlink" title="使用 Freemarker 作邮件模板"></a>使用 Freemarker 作邮件模板</h2><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-8.png" alt></p><h2 id="使用-Thymeleaf-作邮件模板"><a href="#使用-Thymeleaf-作邮件模板" class="headerlink" title="使用 Thymeleaf 作邮件模板"></a>使用 Thymeleaf 作邮件模板</h2><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Mail" scheme="http://www.javaboy.org/tags/Mail/"/>
    
  </entry>
  
  <entry>
    <title>2019 Java 全栈工程师进阶路线图，一定要收藏</title>
    <link href="http://www.javaboy.org/2019/0715/java-fullstack.html"/>
    <id>http://www.javaboy.org/2019/0715/java-fullstack.html</id>
    <published>2019-07-15T00:50:47.000Z</published>
    <updated>2019-07-15T00:52:51.629Z</updated>
    
    <content type="html"><![CDATA[<p>技术更新日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。</p><a id="more"></a><p>我刚开始学习 Java 那会，最大的问题就是不知道该学什么，以及学习的顺序，我相信这也是很多初学者经常面临的问题。​我当时经常胡子眉毛一把抓，那会学习资料倒是不缺，学校图书馆啥都有，就是无从下手，后来有高人指导之后，进步就很快了。</p><p>精研某一个方向，或者走全栈路线，都是可以的，两种路线各有优缺点，如果非要整个争个高下，我觉得没有必要。</p><p>自己喜欢的，才是最好的，我读书的时候就接过几百块钱的小活，没几个钱，要是跟人合作更没有赚头了，所以后来我一直在尝试全栈的路线，也一直在这条路上努力。</p><p>专精于某一方面，成为某一个领域的执牛耳者，也是让人钦佩了。</p><p>结合我自己的经验，我整理了一份 Java 全栈工程师进阶路线图，给大家参考。我整理出来的大部分知识点都有相关的学习资源，大家在公众号后台回复相应的口令就可以获取相关资源（<a href="https://mp.weixin.qq.com/s/yOVbTBVk4CJy6a0lrKjLXA" target="_blank" rel="noopener">学习资源口令</a>）。</p><p>希望大家明白，如果你是在校学生，有大把时间，个人觉得这些东西可以挨个去学，如果你已经工作了，可以根据公司的业务需求有针对性的去学习，<strong>下面的列表仅仅起一个参考的作用</strong>，当你想学的时候，知道有哪些东西需要学习。</p><h2 id="乾坤大挪移第一层"><a href="#乾坤大挪移第一层" class="headerlink" title="乾坤大挪移第一层"></a>乾坤大挪移第一层</h2><p>第一层心法，主要都是基本语法，程序设计入门，悟性高者十天半月可成，差一点的 3 到 6 个月也说不准。如果有其他开发语言的功底相助，并且有张无忌的悟性与运气，相信第一层只在片刻之间就练成了。</p><p>第一层主要包括如下部分（已经列好顺序）：</p><ol><li>Java 基础语法</li><li>Java 面向对象</li><li>Java 常用类详解</li><li>Java 异常机制</li><li>Java 集合与数据结构</li><li>Java IO</li><li>Java 多线程</li><li>Java 网络编程</li><li>Java 注解+反射</li><li>23 种设计模式</li><li>正则表达式</li><li>XML 解析/ JSON 解析</li><li>Java 10、11、12 新特性</li><li>AIO、BIO、NIO</li></ol><h2 id="乾坤大挪移第二层"><a href="#乾坤大挪移第二层" class="headerlink" title="乾坤大挪移第二层"></a>乾坤大挪移第二层</h2><p>第二层主要是修炼数据库，从基本用法到查询优化、读写分离等等都需要掌握，这里以 MySQL 数据库为例：</p><ol><li>数据库的基本概念</li><li>数据库和表的基本操作</li><li>索引与数据完整性约束</li><li>数据库中的各种复杂查询操作</li><li>MySQL 中常见函数的使用</li><li>存储过程、触发器以及事件等</li><li>数据库的备份与恢复</li><li>数据库用户管理与数据库安全性</li><li>事务和多用户</li><li>读写分离环境搭建+实践</li><li>JDBC</li><li>常见数据库连接池的配置+使用</li></ol><h2 id="乾坤大挪移第三层"><a href="#乾坤大挪移第三层" class="headerlink" title="乾坤大挪移第三层"></a>乾坤大挪移第三层</h2><p>第三层主要是修炼 Web 基础，主要包括前端的基础知识，先不用深入学习前端，后端的 Jsp/Servlet，有人会说现在公司都不用 Jsp/Servlet 了，还学这些干嘛？但是万变不离其宗，哪个顶尖高手不是从扎马步开始的？这些掌握好了，框架的原理才好理解。</p><ol><li>HTML</li><li>CSS</li><li>JavaScript</li><li>jQuery</li><li>Tomcat</li><li>Servlet（基本用法，Session、Cookie 等）</li><li>Jsp（原理、九大内置对象等）</li><li>EL 和 JSTL</li><li>过滤器/监听器等</li><li>Ajax</li><li>EasyUI</li><li>ECharts</li><li>BootStrap</li><li>Git/Svn</li><li>WebSocket</li></ol><p>前三层练好后，做个大学的毕设应该是够用了。</p><h2 id="乾坤大挪移第四层"><a href="#乾坤大挪移第四层" class="headerlink" title="乾坤大挪移第四层"></a>乾坤大挪移第四层</h2><p>第四层主要是修炼各种框架以及工具：</p><ol><li>Spring</li><li>SpringMVC</li><li>MyBatis</li><li>Maven/Gradle</li><li>Freemarker/Thymeleaf</li><li>Linux</li><li>ActiveMQ/RabbitMQ</li><li>Netty</li><li>Zookeeper</li><li>Dubbo</li><li>Redis</li><li>RBAC</li><li>Shiro</li><li>Elasticsearch</li><li>Nginx</li><li>SSO</li><li>Activiti</li><li>Quartz</li><li>Spring Batch</li><li>MongoDB</li><li>Spring Cache</li><li>Jpa</li></ol><p>这一层修炼完，你已经基本上达到了阳顶天的水平了，阳顶天是明教教主，那你出去找个项目经理的位置坐坐估计差不多吧。</p><h2 id="乾坤大挪移第五层"><a href="#乾坤大挪移第五层" class="headerlink" title="乾坤大挪移第五层"></a>乾坤大挪移第五层</h2><p>最后还不得不说 Java 目前最火的微服务，这也是一项必备技能：</p><ol><li>Spring Boot 基本原理</li><li>Spring Boot 基础配置</li><li>Spring Boot 整理视图层技术</li><li>Spring Boot 整合 Web 开发</li><li>Spring Boot 整合持久层技术</li><li>Spring Boot 整合 NoSQL</li><li>Spring Boot 构建 RESTful 服务</li><li>Spring Boot 整合各种缓存</li><li>Spring Boot 安全管理</li><li>Spring Boot 整合 WebSocket</li><li>Spring Boot 整合消息服务</li><li>Spring Boot 整合 Swagger、邮件等</li><li>Spring Boot 应用监控</li><li>Spring Cloud Eureka、Consul</li><li>微服务注册与消费</li><li>Spring Cloud OpenFeign</li><li>服务容错保护 Resilience4j</li><li>Spring Cloud Zuul/Gateway</li><li>Spring Cloud Config</li><li>Spring Cloud Bus</li><li>Spring Cloud Stream</li><li>Spring Cloud Sleuth/Zipkin</li><li>Spring Cloud Admin</li><li>Spring Cloud Alibaba</li></ol><p>第五层修炼成功后，让老板加波薪水应该是可以的吧！</p><h2 id="乾坤大挪移第六层"><a href="#乾坤大挪移第六层" class="headerlink" title="乾坤大挪移第六层"></a>乾坤大挪移第六层</h2><p>第六层主要是修炼前端，前端这几年发展的非常快，早已经不是画页面了，JavaScript 被玩的越来越溜了，所以前端不可小觑：</p><ol><li>HTML5 新特性</li><li>CSS3</li><li>ES6</li><li>JS 模块化</li><li>less</li><li>NodeJS</li><li>Webpack</li><li>Grunt</li><li>Gulp</li><li>Zepto</li><li>mpvue</li><li>AngularJS/Vue/React（非专业前端建议修炼其中一个即可）</li></ol><p>据说乾坤大挪移的作者也只修炼到这一层。</p><p>练习到这一层，基本上前后端通杀，做个架构师，或者独立接私活妥妥的了。</p><h2 id="乾坤大挪移第七层"><a href="#乾坤大挪移第七层" class="headerlink" title="乾坤大挪移第七层"></a>乾坤大挪移第七层</h2><p>本层主要修炼：</p><ul><li>《养发护发指南》</li><li>《颈椎病康复指南》</li><li>《腰椎间盘突出康复指南》</li><li>…..</li></ul><p>祝大家早日习得盖世神功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术更新日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库如何实现主键全局自增？</title>
    <link href="http://www.javaboy.org/2019/0712/mycat-id-autoincrement.html"/>
    <id>http://www.javaboy.org/2019/0712/mycat-id-autoincrement.html</id>
    <published>2019-07-12T04:55:28.000Z</published>
    <updated>2019-07-12T04:57:50.308Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家介绍了 MyCat 中数据库不同的分片规则，从留言中看出大家对分布式数据库中间件还挺感兴趣，因此今天就再来一篇，聊一聊主键全局自增要如何实现。</p><a id="more"></a><p>关于数据库分库分表的问题，我们前面还有几篇铺垫的文章，阅读前面的文章有助于更好的理解本文：</p><hr><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li><li><a href="https://mp.weixin.qq.com/s/4DvKAKiG2sFe_vEQ0mUkeQ" target="_blank" rel="noopener">数据库分库分表，分片配置轻松入门！</a></li></ol><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>主键自增这应该算是一个非常常见的需求，在单机数据库中，这个需求一个 <code>auto_increment</code> 就能实现，但是在数据库集群中，这个需求却变复杂了，因为存在多个数据库实例 ，各自都是主键自增，合在一起就不是主键自增了。</p><h1 id="最简单的思路"><a href="#最简单的思路" class="headerlink" title="最简单的思路"></a>最简单的思路</h1><p>最简单的办法莫过于通过设置主键自增的步长和起始偏移量来处理这个问题。默认情况下，主键自增步长为 1 ，如果我们有三个数据库实例，我们可以将主键自增步长设置为 3 ，这样对于第一个数据库实例而言，主键自增就是 1、4、7、10…，对于第二个数据库实例而言，主键自增就是 2、5、8、11…，对于第三个数据库实例而言，主键自增就是 3、6、9、12….。</p><p>MSSQL 可以直接在 SQL 中指定主键的自增步长和起始偏移量，但是 MySQL 则需要修改数据库配置才能实现，因此这里不推荐使用这种方式。</p><h1 id="MyCat-的办法"><a href="#MyCat-的办法" class="headerlink" title="MyCat 的办法"></a>MyCat 的办法</h1><p>MyCat 作为一个分布式数据库中间，屏蔽了数据库集群的操作，让我们操作数据库集群就像操作单机版数据库一样，对于主键自增，它有自己的方案：</p><ol><li>通过本地文件实现</li><li>通过数据库实现</li><li>通过本地时间戳实现</li><li>通过分布式 ZK ID 生成器实现</li><li>通过 ZK 递增方式实现</li></ol><p>今天我们就先来看看看如何通过 ZK 递增的方式实现主键全局自增。</p><p>配置步骤如下：</p><ul><li>首先修改主键自增方式为 4 ，4 表示使用 zookeeper 实现主键自增。</li></ul><p>server.xml</p><p><img src="http://www.javaboy.org/images/mysql/9-1.png" alt></p><ul><li>配置表自增，并且设置主键</li></ul><p>schema.xml</p><p><img src="http://www.javaboy.org/images/mysql/9-2.png" alt></p><p>设置主键自增，并且设置主键为 id 。</p><ul><li>配置 zookeeper 的信息</li></ul><p>在 myid.properties 中配置 zookeeper 信息：</p><p><img src="http://www.javaboy.org/images/mysql/9-3.png" alt></p><ul><li>配置要自增的表</li></ul><p>sequence_conf.properties</p><p><img src="http://www.javaboy.org/images/mysql/9-4.png" alt></p><p>注意，这里表名字要大写。</p><ol><li>TABLE.MINID 某线程当前区间内最小值</li><li>TABLE.MAXID 某线程当前区间内最大值</li><li>TABLE.CURID 某线程当前区间内当前值</li><li>文件配置的MAXID以及MINID决定每次取得区间，这个对于每个线程或者进程都有效</li><li>文件中的这三个属性配置只对第一个进程的第一个线程有效，其他线程和进程会动态读取 ZK</li></ol><ul><li>重启 MyCat 测试</li></ul><p>最后重启 MyCat ，删掉之前创建的表，然后创建新表进行测试即可。</p><p>好了，本文主要向大家介绍了 MyCat 实现主键全局自增的方案。不知道大家有没有 GET 到呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家介绍了 MyCat 中数据库不同的分片规则，从留言中看出大家对分布式数据库中间件还挺感兴趣，因此今天就再来一篇，聊一聊主键全局自增要如何实现。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>数据库分库分表，都有哪些分片规则？</title>
    <link href="http://www.javaboy.org/2019/0712/mycat-rule.html"/>
    <id>http://www.javaboy.org/2019/0712/mycat-rule.html</id>
    <published>2019-07-12T04:50:12.000Z</published>
    <updated>2019-07-12T04:58:05.877Z</updated>
    
    <content type="html"><![CDATA[<p>上次和大伙聊了 MyCat 的安装，今天来说一个新的话题，就是数据库的分片。</p><a id="more"></a><p>当我们把 MyCat + MySQL 的架构搭建完成之后，接下来面临的一个问题就是，数据库的分片规则：有那么多 MySQL ，一条记录通过 MyCat 到底要插入到哪个 MySQL 中？这就是我们今天要讨论的问题。</p><p>关于数据库分库分表的问题，我们前面还有几篇铺垫的文章，阅读前面的文章有助于更好的理解本文：</p><hr><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li></ol><hr><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="逻辑库"><a href="#逻辑库" class="headerlink" title="逻辑库"></a>逻辑库</h2><p>一般来说，对于应用而言，数据库中间件是透明的，应用并不需要去了解中间件复杂的运作过程，中间件对应用来说就是透明的，我们操作中间件就像操作一个普通的 MySQL 一样，这就是 MyCat 的优势之一。</p><p>但是我们毕竟操作的不是 MySQL ，而是 MyCat ，MyCat 中的数据库并不真正存储数据，数据还是存储在 MySQL 中，因此，我们可以将 MyCat 看作是一个或者多个数据库集群构成的逻辑库。</p><p><img src="http://www.javaboy.org/images/mysql/6-2.png" alt></p><h2 id="逻辑表"><a href="#逻辑表" class="headerlink" title="逻辑表"></a>逻辑表</h2><p>逻辑表又有几种不同的划分：</p><ul><li>逻辑表</li></ul><p>既然有逻辑库，那么就会有逻辑表。</p><p>因为数据库分片之后，本来存储在一张表中的数据现在被分散到 N 张表中去了，但是在应用程序眼里，还是只有一张表，它也只操作这一张表，这张表并不真正存储数据，数据存储在 N 张物理表中，这个并不真正存储数据的表称之为逻辑表。</p><ul><li>分片表</li></ul><p>分片表，是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 </p><ul><li>非分片表</li></ul><p>一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。</p><ul><li>ER 表</li></ul><p>关系型数据库是基于实体关系模型之上，通过其描述了真实世界中事物与关系，Mycat 中的 ER 表即是来源于此。根据这一思路，提出了基于 E-R 关系的数据分片策略，子表的记录与所关联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组保证数据 join 不会跨库操作。</p><p>表分组是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的重要一条规则。</p><ul><li>全局表</li></ul><p>一个真实的业务系统中，往往存在大量的类似字典表的表，这些表基本上很少变动，字典表具有以下几个特性：</p><ul><li>变动不频繁 </li><li>数据量总体变化不大 </li><li>数据规模不大，很少有超过数十万条记录</li></ul><p>对于这类的表，在分片的情况下，当业务表因为规模而进行分片以后，业务表与这些附属的字典表之间的关联，就成了比较棘手的问题，所以 MyCat 中通过数据冗余来解决这类表的 join ，即所有的分片都有一份数据的拷贝，所有将字典表或者符合字典表特性的一些表定义为全局表。</p><p>数据冗余是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的另外一条重要规则。</p><h2 id="分片节点"><a href="#分片节点" class="headerlink" title="分片节点"></a>分片节点</h2><p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。 </p><h2 id="节点主机"><a href="#节点主机" class="headerlink" title="节点主机"></a>节点主机</h2><p>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。 </p><h2 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h2><p>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。 </p><p>MyCat 提供的分片规则有如下几种：</p><ul><li>分片枚举</li><li>固定分片 hash 算法</li><li>范围约定</li><li>取模</li><li>按日期（天）分片</li><li>取模范围约束</li><li>截取数字做 hash 求模范围约束</li><li>应用指定</li><li>截取数字 hash 解析</li><li>一致性 hash</li><li>按单月小时拆分</li><li>范围求模分片</li><li>日期范围 hash 分片</li><li>冷热数据分片</li><li>自然月分片</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>这里向大家简单介绍 5 种规则。</p><h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>有一些表，数据量不大，也不怎么修改，主要是查询操作，例如系统配置表，这一类表我们可以使用 global 这种分片规则。global 的特点是，该表会在所有的库中都创建，而且每一个库中都保存了该表的完整数据。具体配置方式，就是在 schema.xml 的 table 节点中添加一个 type 属性，值为 global：</p><p><img src="http://www.javaboy.org/images/mysql/8-1.png" alt></p><p>配置完成后，重启 mycat</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mycat restart</span><br></pre></td></tr></table></figure><p>重启完成后，要删除之前已经创建的 <code>t_user</code> 表，然后重新创建表，创建完成后，向表中插入数据，可以看到，db1、db2 以及 db3 中都有数据了。</p><p><img src="http://www.javaboy.org/images/mysql/8-2.png" alt></p><p>这里 虽然查询出来的记录只有一条，实际上 db1、db2 以及 db3 中都有该条记录。</p><p>总结：global 适合于 数据量不大、以查询为主、增删改较少的表。</p><h2 id="sharding-by-intfile"><a href="#sharding-by-intfile" class="headerlink" title="sharding-by-intfile"></a>sharding-by-intfile</h2><p>sharding-by-intfile 这个是枚举分片，就是在数据表中专门设计一个字段，以后根据这个字段的值来决定数据插入到哪个 dataNode 上。</p><p>注意，在配置 sharding-by-intfile 规则时，一定要删除 type=”global” ，否则配置不会生效。具体配置如下：</p><p><img src="http://www.javaboy.org/images/mysql/8-3.png" alt></p><p>配置完成后，还需要指定枚举的数据。枚举的数据可以在 rule.xml　中查看。</p><p><img src="http://www.javaboy.org/images/mysql/8-4.png" alt></p><p>在 rule.xml 文件中，首先找到 tableRule 的名字为 sharding-by-intfile 的节点，这个节点中定义了两个属性，一个是 columns 表示一会在数据表中定义的枚举列的名字（数据表中一会需要创建一个名为 sharding_id 的列，这个列的值决定了该条数据保存在哪个数据库实例中），这个名字可以自定义；另外一个属性叫做 algorithm ，这是指 sharding-by-intfile 所对应的算法名称。根据这个名称，可以找到具体的算法：</p><p><img src="http://www.javaboy.org/images/mysql/8-5.png" alt></p><p>还是在 rule.xml 文件中，我们找到了 hash-int ，class 表示这个算法对应的 Java 类的路径。第一个属性 mapFile 表示相关的配置文件，从这个文件名可以看出，这个文件 就在 conf 目录下。</p><p>打开 conf 目录下的 partition-hash-int.txt 文件，内容如下：</p><p><img src="http://www.javaboy.org/images/mysql/8-6.png" alt></p><p>前面的数字表示枚举的值 ，后面的数字表示 dataNode 的下标，所以前面的数字可以自定义，后面的数字不能随意定义。</p><p>配置完成后，重启 MyCat ，然后进行测试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user (id integer primary key,username varchar(255),sharding_id integer);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,0);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,1);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,2);</span><br><span class="line">select  * from t_user;</span><br></pre></td></tr></table></figure><p>执行完后，sharding_id 对应值分别为 0 、1 、2 的记录分别插入到 db1 、db2 以及 db3 中。</p><h2 id="auto-sharding-long"><a href="#auto-sharding-long" class="headerlink" title="auto-sharding-long"></a>auto-sharding-long</h2><p>auto-sharding-long 表示按照既定的范围去存储数据。就是提前规划好某个字段的值在某个范围时，相应的记录存到某个 dataNode 中。</p><p>配置方式，首先修改路由规则：</p><p><img src="http://www.javaboy.org/images/mysql/8-7.png" alt></p><p>然后去 rule.xml 中查看对应的算法了规则相关的配置：</p><p><img src="http://www.javaboy.org/images/mysql/8-8.png" alt></p><p>可以看到，默认是按照 id 的范围来划分数据的存储位置的，对应的算法就是 rang-long 。</p><p>继续查看，可以找到算法对应的类，以及相关的配置文件，这个配置文件也在 conf 目录下，打开该文件：</p><p><img src="http://www.javaboy.org/images/mysql/8-9.png" alt></p><p>如上配置，表示 当 id 的取值在 0-5之间时，将数据存储到 db1 中，当 id 在 5-10 之间时，存储到 db2 中，当 id 的取值在 10-1500W 之间时，存储到 db3 中。</p><p>配置完成后，重启 MyCat ，测试：</p><p><img src="http://www.javaboy.org/images/mysql/8-10.png" alt></p><h2 id="mod-long"><a href="#mod-long" class="headerlink" title="mod-long"></a>mod-long</h2><p>取模：根据表中的某一个字段，做取模操作。根据取模的结果将记录存放在不同的 dataNode 上。这种方式不需要再添加额外字段。</p><p><img src="http://www.javaboy.org/images/mysql/8-11.png" alt></p><p>然后去 rule.xml 中配置一下 dataNode 的个数。</p><p><img src="http://www.javaboy.org/images/mysql/8-12.png" alt></p><p>可以看到，取模的字段是 id ，取模的算法名称是 mod-long ，再看具体的算法：</p><p><img src="http://www.javaboy.org/images/mysql/8-13.png" alt></p><p>在具体的算法中，配置了 dataNode 的个数为 3。</p><p>然后保存退出，重启 MyCat，进行测试：</p><p><img src="http://www.javaboy.org/images/mysql/8-14.png" alt></p><h2 id="sharding-by-murmur"><a href="#sharding-by-murmur" class="headerlink" title="sharding-by-murmur"></a>sharding-by-murmur</h2><p>前面介绍的几种方式，都存在一个问题，如果数据库要扩容，之前配置会失效，可能会出现数据库查询紊乱。因此我们要引入一致性 hash 这样一种分片规则，可以解决这个问题。具体配置和前面一样：</p><p><img src="http://www.javaboy.org/images/mysql/8-15.png" alt></p><p>另外需要注意，在 rule.xml 中修改默认 dataNode 的数量：</p><p><img src="http://www.javaboy.org/images/mysql/8-16.png" alt></p><p>修改完后，重启 MyCat ，进行测试。</p><p>好了，本文主要向大家介绍了 MyCat 的五种不同的切片规则。有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCat 官网</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次和大伙聊了 MyCat 的安装，今天来说一个新的话题，就是数据库的分片。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</title>
    <link href="http://www.javaboy.org/2019/0710/vhr.html"/>
    <id>http://www.javaboy.org/2019/0710/vhr.html</id>
    <published>2019-07-10T01:43:19.000Z</published>
    <updated>2019-07-10T01:48:44.082Z</updated>
    
    <content type="html"><![CDATA[<p>公司倒闭 1 年多了，而我在公司倒闭时候做的开源项目，最近却上了 GitHub Trending，看着这个数据，真是不胜唏嘘。</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>2017 年 11 月份的时候，松哥所在的公司因为经营不善要关门了，关门的是深圳分公司，北京总部还在正常运转。</p><p>然后就是北京那边来人，和深圳的员工挨个谈话，谈裁员和赔偿，公司制度还算完善，都按照劳动合同法走，有的同事担心公司最后不按劳动合同法走，因此觉得先拿钱先走比价划算。我当时主要考虑到两个原因，并不着急走：</p><ol><li>公司毕竟是香港上市公司，跑的了和尚跑不了庙，深圳关门了，北京那边还在运转，所以我不太担心公司赖账的事。</li><li>年底工作不好找，11 月拿赔偿走人，还有俩月才过年，这个时候不太容易拿到满意的 offer，很多公司年底都关闭 HC 了。</li></ol><p>基于上面两点考虑，我当时并不急着走人，当公司说还需要有人留下来善后一直到 2018 年 1 月 31 号的时候，我就争取了下，然后就给留下来了。</p><p>留下来后并没有太多事情要做。划水划了一周，同事在楼下叫我：“老王下来聊天”，于是下楼跟他们吹吹牛，虽然吹牛，不过大多数时候还是在筹划来年找工作的事，不过我觉得这样没什么用，与其天天规划，不如来点实实在在的东西，为来年找工作积累一点筹码。</p><h1 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h1><p>心里想着手上就开始行动了，技术栈就选择当时最流行的 Spring Boot + Vue 前后端分离，业务就打算先做一个简单的博客试试水，博客的业务比较简单，做起来快，于是，V部落项目就诞生了：</p><p><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></p><p>一个简单的博客后台管理，集成了博客编辑、发表、排版引入了 md 编辑器，博客的分类展示等，记得不到一周时间就弄完了，毕竟还是非常容易的。</p><p><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目发布后，我认认真真的写了一个介绍的 README，README 和我以前的开源项目一样，就是展示了一下项目的效果图，然后说了下要如何部署运行就完了。虽然自我感觉良好，但是并没有引起太多人关注。</p><p>在为数不多的几个关注中，我发现小伙伴在运行项目时候总是会遇到各种各样的问题，很多人多前后端分离的这种开发方式非常陌生，很多后端工程师甚至不懂，没听说过前端工程化，很多小伙伴在 GitHub 上提了很多非常简单的 issue，他们在部署<a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目时老是出错。</p><p>另一方面，由于博客项目比较简单，Vue 中很多高级功能没用上，例如状态管理，还有前后端分离时的动态权限管理，这些都没有体现出来。再加上当时才是 12 月，离过年还早着，我心想着再做一个业务复杂点的，然后把这些之前没用到的技能点都给用上。于是就有了<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>项目，这也是我们今天的主角，上了 6 月份 GitHub Trending。</p><h1 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h1><p>微人事项目，我就吸取 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>的经验，没有等项目完全发布后再上传到 GitHub 上，而是边做变更新，每做完一个功能，就写一个文档，把实现的思路，代码的原理等都记录下来，然后在打一个 tag ，发布到 GitHub 上，这样，即使是一些新手，跟着文档，也能完全做出来。</p><p>这是当时的一些提交记录：</p><p><img src="http://www.javaboy.org/images/other/51-1.png" alt></p><p>基本上每隔一两天就能完成一个新功能，然后就提交一次，这样的更新频率一直持续到 2018 年 1 月 20 之前，1 月 21 号女票从昆士兰大学访学回来，陪她在深圳玩了几天，然后把女票送回家，耽搁了好几天没更新。</p><p>到了 1 月 31 号，公司正式关门，我也就回家了，先去了女票家，在她家里呆了十多天，顺便完成了用 WebSocket 实现在线聊天的功能，提交了两个版本。</p><p>下面这两个是在女票家里提交的：</p><p><img src="http://www.javaboy.org/images/other/51-3.png" alt></p><p>这两次提交之后，差不多就回家过年了，我家在岭上没有网，因此过年期间就没再继续做这个项目了，年后从家里到深圳的当天就拿到 offer 了，上班后就比较忙了，这个项目也就更新的慢了，没有再提交比较大的版本了，主要是一些修修补补的操作。</p><h1 id="ALL-IN"><a href="#ALL-IN" class="headerlink" title="ALL IN"></a>ALL IN</h1><p>现在不是流行一个词叫做 <code>all in</code> ，用来形容我当时的状态再贴切不过了。</p><p><strong>兴趣来了，谁都拦不住</strong>。那一段时间晚上经常在家里搞到一两点，第二天正常上班。记得那一年平安夜那天是周日，我早上依然按时起床去了公司，因为当天我的 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目就要收尾了，在公司里搞到晚上 9 点多，终于弄完了，第二天就可以发布了。然后收拾东西，骑着摩拜从科兴科学园那里出发，先走北环大道，然后再下到大沙河边上，沿着大沙河骑到西丽大学城，因为是平安夜，一路上都没什么行人，到家后还没吃饭，去楼下的餐厅随便吃点，店主一家人正在准备他们的平安夜饭，见有客人，抽出一个人给我弄了一碗面，然后我就独自边玩手机边吃饭，他们一家人围在旁边的桌子上吃他们的平安夜饭，这种感觉很奇怪，孤独又充实。</p><p>吃完回到宿舍，和女票视频，心理盘算着女票再过 20 多天就从昆士兰回来了，慢慢就睡着了，第二天到公司，我的 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目就正式上线了。</p><p><strong>当你沉迷于一件事情的时候，效率非常高。</strong></p><p>那段时间，我每天骑车上下班，一边骑着自行车，心里就在想着这个功能要怎么做更好，那个功能得怎么样实现，一路上就这样不断的规划着，到了公司，放下书包，就赶紧打开电脑挨个试验路上的各种想法，做出来了就很开心，在已经没有几个人的公司走走转转休息下，然后继续坐下 coding。</p><p>有一个周末去公司做这两个开源项目的时候，中午去吃饭，两只狗懒洋洋的躺在马路中间晒太阳，我甚至有点羡慕(下图拍摄于南山科兴科学园附近，我吃饭喜欢走远一点，多溜达溜达，不知不觉就溜达到工地了，见到这么惬意一幕，冬天的太阳，真的舒服)。</p><p><img src="http://www.javaboy.org/images/other/51-4.jpeg" alt></p><p>项目在 GitHub 上开源之后，有好几位小伙伴发邮件希望能在毕设中引用这个项目，记得有一位是国内高校 top20 的研究生，我当时又诧异又激动。后来也有好几个小伙伴加松哥微信表示想将这个项目作为脚手架用在公司的项目中，虽然没能亲眼见见小伙伴的项目，但是想到自己的项目帮到了这么多人，还是挺开心的。</p><p>这两个开源项目也带给我不少收获，技术上的提升+认识很多优秀的小伙伴，并且因此还出了一本书，也算是收获满满吧。</p><h1 id="上榜"><a href="#上榜" class="headerlink" title="上榜"></a>上榜</h1><p>前两天有个小伙伴发消息说是看到我的项目出现 GitHub Trending 上了，我点开看了下，果然是的。</p><p>我是在 2013 年 11 月份注册的 GitHub，但是很长一段时间都没啥活动，后来也断断续续做过几个开源项目，但是都没啥动静，我总结其中一个原因可能也是因为我没好好对待项目，README 只是随便写写，读者一般很难上手项目，从<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>开始，我懂得了，你想要让别人重视你的项目，你首先得自己重视自己的项目。</p><p>这里再向大家安利一波这个开源项目<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>，这是一个使用了 Spring Boot + Vue 开发的前后端分离的人力资源管理系统，有一个非常完整的文档：</p><p><img src="http://www.javaboy.org/images/other/51-2.png" alt></p><p>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></p><p>欢迎大家点击阅读原文查看本项目。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外再给大家一个小小建议，如果你是初次接触前后端分离，可以先看 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目，这个项目不论从技术点还是业务上来说，都要比<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>简单， <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>搞懂之后，再来学习<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>就会容易很多了。</p><p>如果你只是刚刚接触 Java，那么松哥也有一个前后端不分开源项目可以给你练手：</p><ul><li><a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a></li></ul><p>这个项目做的比较早，功能做的相对较全，但是介绍文档没有<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>那么详细，大家可以参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司倒闭 1 年多了，而我在公司倒闭时候做的开源项目，最近却上了 GitHub Trending，看着这个数据，真是不胜唏嘘。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.javaboy.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用 Java 发送邮件，不用框架！</title>
    <link href="http://www.javaboy.org/2019/0709/java-mail.html"/>
    <id>http://www.javaboy.org/2019/0709/java-mail.html</id>
    <published>2019-07-09T08:02:43.000Z</published>
    <updated>2019-07-09T08:07:33.550Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送也是一个老生常谈的问题了，代码虽然简单，但是许多小伙伴对过程不太理解，所以还是打算和各位小伙伴聊聊这个话题。  </p><a id="more"></a><h1 id="邮件协议"><a href="#邮件协议" class="headerlink" title="邮件协议"></a>邮件协议</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件于 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="发送QQ邮件准备工作"><a href="#发送QQ邮件准备工作" class="headerlink" title="发送QQ邮件准备工作"></a>发送QQ邮件准备工作</h1><p>首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/mail/1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/mail/2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/mail/3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。  </p><p>然后我们需要 JavaxMail 这个 jar 包，小伙伴可以直接去Maven中央仓库下载，这里不再赘述。  </p><h1 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h1><h2 id="简单邮件"><a href="#简单邮件" class="headerlink" title="简单邮件"></a>简单邮件</h2><p>如果我们只发送一个简单的文本，发送方式就比较简单，整个过程可以分为三步如下：  </p><p>第一步：构造 SMTP 邮件服务器的基本环境  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.host"</span>, <span class="hljs-string">"smtp.qq.com"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.transport.protocol"</span>, <span class="hljs-string">"smtp"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.auth"</span>, <span class="hljs-string">"true"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.socketFactory.class"</span>, <span class="hljs-string">"javax.net.ssl.SSLSocketFactory"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.port"</span>, <span class="hljs-string">"465"</span>);</span><br><span class="line">Session session = Session.getDefaultInstance(properties);</span><br><span class="line">session.setDebug(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure><p>第二步：构造邮件  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage mimeMessage = <span class="hljs-keyword">new</span> MimeMessage(session);</span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.TO, <span class="hljs-string">"111@qq.com"</span>);<span class="hljs-comment">//设置收信人</span></span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.CC, <span class="hljs-string">"222@qq.com"</span>);<span class="hljs-comment">//抄送</span></span><br><span class="line">mimeMessage.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);<span class="hljs-comment">//邮件发送人</span></span><br><span class="line">mimeMessage.setSubject(<span class="hljs-string">"测试邮件主题"</span>);<span class="hljs-comment">//邮件主题</span></span><br><span class="line">mimeMessage.setContent(<span class="hljs-string">"Hello,这是一封测试邮件"</span>, <span class="hljs-string">"text/html;charset=utf-8"</span>);<span class="hljs-comment">//正文</span></span><br></pre></td></tr></table></figure><p>第三步：发送邮件  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transport transport = session.getTransport();</span><br><span class="line">transport.connect(<span class="hljs-string">"smtp.qq.com"</span>, <span class="hljs-string">"333@qq.com"</span>, <span class="hljs-string">"刚刚申请到的授权码"</span>);</span><br><span class="line">transport.sendMessage(mimeMessage, mimeMessage.getAllRecipients());<span class="hljs-comment">//发送邮件，第二个参数为收件人</span></span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h2 id="复杂邮件"><a href="#复杂邮件" class="headerlink" title="复杂邮件"></a>复杂邮件</h2><p>发送复杂邮件，第一步和第三步也是一样的，只有第二步构造邮件的过程比较麻烦，那么接下来给小伙伴们演示一个发送一封图文+两个附件的邮件。要发送复杂邮件，得先熟悉三个概念，如下：  </p><ol><li>MimeMessage：该类是个能理解MIME类型和头的电子邮件消息  </li><li>MimeMultipart：该类定义了增加、删除以及获取邮件不同部分内容的方法  </li><li>MimeBodyPart：该对象代表一个MimeMessage对象内容的一部分。每个MimeBodyPart被认为有两部分：MIME类型和匹配这个类型的内容  </li></ol><p>完整的邮件生成过程如下(第一步和第三步参考上文)：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage mimeMessage = <span class="hljs-keyword">new</span> MimeMessage(session);</span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.TO, <span class="hljs-string">"111@qq.com"</span>);<span class="hljs-comment">//设置收信人</span></span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.CC, <span class="hljs-string">"222@qq.com"</span>);<span class="hljs-comment">//抄送</span></span><br><span class="line">mimeMessage.setFrom(<span class="hljs-string">"333@qq.com"</span>);<span class="hljs-comment">//邮件发送人</span></span><br><span class="line">mimeMessage.setSubject(<span class="hljs-string">"测试邮件主题"</span>);<span class="hljs-comment">//邮件主题</span></span><br><span class="line"></span><br><span class="line">MimeMultipart mixed = <span class="hljs-keyword">new</span> MimeMultipart(<span class="hljs-string">"mixed"</span>);</span><br><span class="line">mimeMessage.setContent(mixed);<span class="hljs-comment">//设置整封邮件的MIME消息体为混合的组合关系</span></span><br><span class="line"></span><br><span class="line">MimeBodyPart attach1 = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建附件1</span></span><br><span class="line">MimeBodyPart attach2 = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建附件2</span></span><br><span class="line">MimeBodyPart content = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建邮件正文</span></span><br><span class="line"></span><br><span class="line">mixed.addBodyPart(attach1);<span class="hljs-comment">//将附件一添加到MIME消息体中</span></span><br><span class="line">mixed.addBodyPart(attach2);<span class="hljs-comment">//将附件二添加到MIME消息体中</span></span><br><span class="line">mixed.addBodyPart(content);<span class="hljs-comment">//将正文添加到消息体中</span></span><br><span class="line"></span><br><span class="line">FileDataSource fds1 = <span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\1.png"</span>));<span class="hljs-comment">//构造附件一的数据源</span></span><br><span class="line">DataHandler dh1 = <span class="hljs-keyword">new</span> DataHandler(fds1);<span class="hljs-comment">//数据处理</span></span><br><span class="line">attach1.setDataHandler(dh1);<span class="hljs-comment">//设置附件一的数据源</span></span><br><span class="line">attach1.setFileName(<span class="hljs-string">"1.png"</span>);<span class="hljs-comment">//设置附件一的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//附件二的操作与附件一类似，这里就不一一注释了</span></span><br><span class="line">FileDataSource fds2 = <span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\博客笔记.xlsx"</span>));</span><br><span class="line">DataHandler dh2 = <span class="hljs-keyword">new</span> DataHandler(fds2);</span><br><span class="line">attach2.setDataHandler(dh2);</span><br><span class="line">attach2.setFileName(MimeUtility.encodeText(<span class="hljs-string">"博客笔记.xlsx"</span>));<span class="hljs-comment">//设置文件名时，如果有中文，可以通过MimeUtility类中的encodeText方法进行编码，避免乱码</span></span><br><span class="line"></span><br><span class="line">MimeMultipart bodyMimeMultipart = <span class="hljs-keyword">new</span> MimeMultipart(<span class="hljs-string">"related"</span>);<span class="hljs-comment">//设置正文的MIME类型</span></span><br><span class="line">content.setContent(bodyMimeMultipart);<span class="hljs-comment">//将bodyMimeMultipart添加到正文消息体中</span></span><br><span class="line"></span><br><span class="line">MimeBodyPart bodyPart = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//正文的HTML部分</span></span><br><span class="line">bodyPart.setContent(<span class="hljs-string">"&lt;h1&gt;Hello大家好，这是一封测试邮件&lt;img src='cid:2.png'/&gt;&lt;/h1&gt;"</span>,<span class="hljs-string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">MimeBodyPart picPart = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//正文的图片部分</span></span><br><span class="line">DataHandler dataHandler = <span class="hljs-keyword">new</span> DataHandler(<span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\2.png"</span>));</span><br><span class="line">picPart.setDataHandler(dataHandler);</span><br><span class="line">picPart.setContentID(<span class="hljs-string">"2.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//将正文的HTML和图片部分分别添加到bodyMimeMultipart中</span></span><br><span class="line">bodyMimeMultipart.addBodyPart(bodyPart);</span><br><span class="line">bodyMimeMultipart.addBodyPart(picPart);</span><br><span class="line"></span><br><span class="line">mimeMessage.saveChanges();</span><br></pre></td></tr></table></figure><p>OK，Java Mail 发送 QQ 邮件就是这么简单，至于其他的如 163，sina 等，写法类似，这里我就不赘述了。  </p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送也是一个老生常谈的问题了，代码虽然简单，但是许多小伙伴对过程不太理解，所以还是打算和各位小伙伴聊聊这个话题。  &lt;/p&gt;
    
    </summary>
    
      <category term="mail" scheme="http://www.javaboy.org/categories/mail/"/>
    
    
      <category term="java" scheme="http://www.javaboy.org/tags/java/"/>
    
      <category term="mail" scheme="http://www.javaboy.org/tags/mail/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 打包成的可执行 jar ，为什么不能被其他项目依赖？</title>
    <link href="http://www.javaboy.org/2019/0709/springboot-jar.html"/>
    <id>http://www.javaboy.org/2019/0709/springboot-jar.html</id>
    <published>2019-07-09T02:19:18.000Z</published>
    <updated>2019-07-09T02:33:37.056Z</updated>
    
    <content type="html"><![CDATA[<p>前两天被人问到这样一个问题:</p><p>“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”</p><a id="more"></a><p>大伙有这样的疑问，就是因为还没搞清楚可执行 jar 和普通 jar 到底有什么区别？今天松哥就和大家来聊一聊这个问题。</p><h1 id="多了一个插件"><a href="#多了一个插件" class="headerlink" title="多了一个插件"></a>多了一个插件</h1><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p><p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p><p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p><p><img src="http://www.javaboy.org/images/boot/23-1.png" alt></p><p>五个功能分别是：</p><ul><li>build-info：生成项目的构建信息文件 build-info.properties</li><li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li><li>run：这个可以用来运行 Spring Boot 应用</li><li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li><li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li></ul><p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p><ol><li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li><li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li></ol><p>举个例子：</p><p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p><p><img src="http://www.javaboy.org/images/boot/23-2.png" alt></p><p>打包成功之后， <code>target</code> 中的文件如下：</p><p><img src="http://www.javaboy.org/images/boot/23-3.png" alt></p><p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p><h1 id="两种-jar-的比较"><a href="#两种-jar-的比较" class="headerlink" title="两种 jar 的比较"></a>两种 jar 的比较</h1><p>可执行 <code>jar</code> 解压之后，目录如下：</p><p><img src="http://www.javaboy.org/images/boot/23-4.png" alt></p><p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: org.javaboy.restful.RestfulApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p><p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p><p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p><p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p><p><img src="http://www.javaboy.org/images/boot/23-5.png" alt></p><p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p><p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p><h1 id="一次打包两个-jar"><a href="#一次打包两个-jar" class="headerlink" title="一次打包两个 jar"></a>一次打包两个 jar</h1><p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p><p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p><p><img src="http://www.javaboy.org/images/boot/23-6.png" alt></p><p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p><p>好了，关于 Spring Boot 中 jar 的问题，我们就说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天被人问到这样一个问题:&lt;/p&gt;
&lt;p&gt;“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 整合 Freemarker，50 多行配置是怎么省略掉的？</title>
    <link href="http://www.javaboy.org/2019/0705/springboot-freemarker.html"/>
    <id>http://www.javaboy.org/2019/0705/springboot-freemarker.html</id>
    <published>2019-07-05T04:14:59.000Z</published>
    <updated>2019-07-05T04:19:48.020Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot2 系列教程接近完工，最近进入修修补补阶段。Freemarker 整合貌似还没和大家聊过，因此今天把这个补充上。</p><a id="more"></a><p>已经完工的 Spring Boot2 教程，大家可以参考这里：</p><ol><li><a href="https://mp.weixin.qq.com/s/YXBFFtWvSwR6dVLbaGDxcQ" target="_blank" rel="noopener">干货|最新版 Spring Boot2.1.5 教程+案例合集</a></li></ol><h1 id="Freemarker-简介"><a href="#Freemarker-简介" class="headerlink" title="Freemarker 简介"></a>Freemarker 简介</h1><p>这是一个相当老牌的开源的免费的模版引擎。通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。</p><p>来看一张来自 Freemarker 官网的图片：</p><p><img src="http://www.javaboy.org/images/boot/22-1.png" alt></p><p>可以看到，Freemarker 可以将模版和数据渲染成 HTML 。</p><p>Freemarker 模版后缀为 <code>.ftl</code>(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><p>好了，这是一个简单的介绍，接下来我们来看看 Freemarker 和 Spring Boot 的一个整合操作。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在 SSM 中整合 Freemarker ，所有的配置文件加起来，前前后后大约在 50 行左右，Spring Boot 中要几行配置呢？ 0 行！</p><h2 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h2><p>首先创建一个 Spring Boot 工程，引入 Freemarker 依赖，如下图：</p><p><img src="http://www.javaboy.org/images/boot/22-2.png" alt></p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>工程创建完成后，在 <code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</code> 类中，可以看到关于 Freemarker 的自动化配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class &#125;)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(FreeMarkerProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,</span><br><span class="line">                FreeMarkerNonWebConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，当 <code>classpath</code> 下存在 <code>freemarker.template.Configuration</code> 以及 <code>FreeMarkerConfigurationFactory</code> 时，配置才会生效，也就是说当我们引入了 <code>Freemarker</code> 之后，配置就会生效。但是这里的自动化配置只做了模板位置检查，其他配置则是在导入的 <code>FreeMarkerServletWebConfiguration</code> 配置中完成的。那么我们再来看看 <code>FreeMarkerServletWebConfiguration</code> 类，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet.class, FreeMarkerConfigurer.class &#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration.class)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFreeMarkerConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span><span class="hljs-params">(FreeMarkerProperties properties)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>(properties);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span>(FreeMarkerConfig.class)</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">                applyProperties(configurer);</span><br><span class="line">                <span class="hljs-keyword">return</span> configurer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"freeMarkerViewResolver"</span>)</span><br><span class="line">        <span class="hljs-meta">@ConditionalOnProperty</span>(name = <span class="hljs-string">"spring.freemarker.enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerViewResolver <span class="hljs-title">freeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                FreeMarkerViewResolver resolver = <span class="hljs-keyword">new</span> FreeMarkerViewResolver();</span><br><span class="line">                getProperties().applyToMvcViewResolver(resolver);</span><br><span class="line">                <span class="hljs-keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单看下这段源码：</p><ol><li>@ConditionalOnWebApplication 表示当前配置在 web 环境下才会生效。</li><li>ConditionalOnClass 表示当前配置在存在 Servlet 和 FreeMarkerConfigurer 时才会生效。</li><li>@AutoConfigureAfter 表示当前自动化配置在 WebMvcAutoConfiguration 之后完成。</li><li>代码中，主要提供了 FreeMarkerConfigurer 和 FreeMarkerViewResolver。</li><li>FreeMarkerConfigurer 是 Freemarker 的一些基本配置，例如 templateLoaderPath、defaultEncoding 等</li><li>FreeMarkerViewResolver 则是视图解析器的基本配置，包含了viewClass、suffix、allowRequestOverride、allowSessionOverride 等属性。</li></ol><p>另外还有一点，在这个类的构造方法中，注入了 FreeMarkerProperties：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.freemarker"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftl"</span>;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * Well-known FreeMarker keys which are passed to FreeMarker's Configuration.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeMarkerProperties 中则配置了 Freemarker 的基本信息，例如模板位置在 <code>classpath:/templates/</code> ，再例如模板后缀为 <code>.ftl</code>，那么这些配置我们以后都可以在 application.properties 中进行修改。</p><p>如果我们在 SSM 的 XML 文件中自己配置 Freemarker ，也不过就是配置这些东西。现在，这些配置由  FreeMarkerServletWebConfiguration​  帮我们完成了。</p><h2 id="2-创建类"><a href="#2-创建类" class="headerlink" title="2.创建类"></a>2.创建类</h2><p>首先我们来创建一个 User 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来创建 <code>UserController</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">            user.setId((<span class="hljs-keyword">long</span>) i);</span><br><span class="line">            user.setUsername(<span class="hljs-string">"javaboy&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            user.setAddress(<span class="hljs-string">"www.javaboy.org&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"users"</span>, users);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 freemarker 中渲染数据：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span> <span class="hljs-attr">as</span> <span class="hljs-attr">user</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="http://www.javaboy.org/images/boot/22-3.png" alt></p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line">spring.freemarker.allow-session-override=false</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.template-loader-path=classpath:/templates/</span><br></pre></td></tr></table></figure><p>配置文件按照顺序依次解释如下：</p><ol><li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li><li>HttpSession的属性是否可以覆盖controller中model的同名项</li><li>是否开启缓存</li><li>模板文件编码</li><li>是否检查模板位置</li><li>Content-Type的值</li><li>是否将HttpServletRequest中的属性添加到Model中</li><li>是否将HttpSession中的属性添加到Model中</li><li>模板文件后缀</li><li>模板文件位置</li></ol><p>好了，整合完成之后，Freemarker 的更多用法，就和在 SSM 中使用 Freemarker 一样了，这里我就不再赘述。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文和大家简单聊一聊 Spring Boot 整合 Freemarker，算是对 Spring Boot2 教程的一个补充（后面还会有一些补充），有问题欢迎留言讨论。</p><p>本项目案例，我已经上传到 GitHub 上，欢迎大家 star：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot2 系列教程接近完工，最近进入修修补补阶段。Freemarker 整合貌似还没和大家聊过，因此今天把这个补充上。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Freemarker" scheme="http://www.javaboy.org/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离时代，Java 程序员的变与不变！</title>
    <link href="http://www.javaboy.org/2019/0701/fronted-backend.html"/>
    <id>http://www.javaboy.org/2019/0701/fronted-backend.html</id>
    <published>2019-07-01T02:22:32.000Z</published>
    <updated>2019-07-01T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>事情的起因是这样的，有个星球的小伙伴向邀请松哥在知乎上回答一个问题，原题是：</p><a id="more"></a><ul><li>前后端分离的时代，Java后台程序员的技术建议？</li></ul><p>松哥认真看了下这个问题，感觉对于初次接触前后端分离的小伙伴来说，可能都会存在这样的疑问，于是决定通过这篇文章和大家聊一聊这个话题。</p><p>我这里还是尽量从一个 Java 程序员的角度来说说这个问题，这样大家可能更好理解。</p><h1 id="从一个题外话开始"><a href="#从一个题外话开始" class="headerlink" title="从一个题外话开始"></a>从一个题外话开始</h1><p>很多小伙伴可能知道，松哥本科是经管学院的，亚当•斯密的《国富论》多多少少还是了解一点。书中提到人类社会的本质就是分工协作，亚当•斯密认为人类之间的专业分工可以极大的提高生产力、创造财富，专业分工也是工业革命的基础。人类社会的发展过程就是一个专业分工不断细化、不断深化的过程，从最早的农牧分家到手工业农业分家再到商人的出现，其实都是专业分工不断细化深化的体现。</p><p>我们的开发世界也是一个小宇宙，专业分工不断细化也是一个趋势，从这个角度来说，前后端分离，都是值得积极拥抱的。</p><p>前后端分离的开发方式在最近几年突然火起来，松哥认为有两方面的原因：</p><ol><li>前端的发展。前端经过近几年的发展，已经不再是我们传统所说的HTML+画图了，各种概念层出不穷，webpack、RxJs、Node、Redux、ssr、NuxtJs等，前端已经可以胜任很多事情，也能够完成更加丰富的用户交互。</li><li>移动互联网的发展。前两年移动互联网的火爆，很多公司的产品都要在多个平台上线，Android、iOS、小程序、公众号、PC 等等各个平台都要展示，不可能针对不同的设备开发一套后端，应该是多个前端共用同一个后端，这是就不能采用传统的前后端不分的方式来开发后端程序了。正是这样的业务需求，促进了前后端分离的发展。</li></ol><h1 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h1><p>程序员之间的分工协作方式有所变化，开发方式当然也会随着一起变化。但是这种变化其实是非常细微的，很容易上手的。</p><h2 id="变"><a href="#变" class="headerlink" title="变"></a>变</h2><ul><li>工作内容变</li></ul><p>老实说，前后端分离之后，对 Java 程序员的要求变低了，以前大家大家出去面试 Java 工程师，如果是前后端不分的话，前端基本上也是必问的，常见的问题就是各种元素选择器，这也很好理解，因为在前后端不分的开发方式中，后端工程师多多少少是要写一点前端代码的，你很难完完全全的只写 Java 代码。但是在这种情况下，你要写的前端代码其实都是很简单的，不会是特别难的。</p><p>前后端分离之后，Java 程序员只需要专注于后台业务逻辑，对外接收前台传来的参数，根据参数给出不同的响应即可，基本上不需要写前端代码。因为这个时候的前端不同于前后端不分时候的前端，前后端分离之后，前端还是有一定的难度，较为常见的是 SPA 应用，涉及到 NodeJS、Webpack 等，此时如果还要让后端工程师写前端代码，对后端工程师的技术要求就会比较高。</p><p>不过话说回来，前后端分离后，如果你还能即写前端又写后端，那可以让老板加薪了。</p><ul><li>接口变</li></ul><p>前后端不分的时候，很少会涉及到接口设计，以 SpringMVC 为例，你可能返回的始终是 ModelAndView 一类的东西，前后端分离之后，我们基本上不需要返回页面了，后端主要是返回 JSON 数据，所以关键是设计好各种接口。</p><p>一个比较好的实践方案是设计满足 RESTful 规范的接口，语义明确，简洁明了，看到 URL 就知道你想干嘛！</p><ul><li>开发流程变化</li></ul><p>前后端分离之后，前端不可能等后端开发好接口之后再去开发，如果这样，原本两个月做完的项目可能就得 4 个月才能完成。</p><p>一般在开发之前，整个项目组需要先设计好一个接口文档，一般可以采用 Swagger 来做接口文档(<a href="https://mp.weixin.qq.com/s/iTsTqEeqT9K84S091ycdog" target="_blank" rel="noopener">SpringBoot整合Swagger2，再也不用维护接口文档了！</a>)，文档中约定了接口的详细信息，前后端分别按照既定的接口规范去开发，在尚未开发完成时，可以借助 Mock 来进行测试。</p><p>前端也是使用模拟数据进行测试，开发完成之后，前后端接口联调，完成测试。</p><h2 id="不变"><a href="#不变" class="headerlink" title="不变"></a>不变</h2><p>其实除了前后端交互方式发生变化之外，其他的地方都是不变的。</p><p>前后端分离，一般来说是不会影响后端技术架构的，你使用了 SSM 或者 Spring Boot 或者 Dubbo 或者微服务，无论什么，这些技术架构既可以支撑你前后端不分的项目，也可以支撑你前后端分离的项目。</p><p>因此我说后端技术架构不受前后端分离影响。</p><p>另一方面，技术的根本不变，例如你做 Java 开发，该会的 SSM/SpringBoot/Redis/Nginx/Dubbo/SpringCloud/MySQL/MyCat/ELK/…等等，都还得会。</p><p>所以，还是去老老实实撸代码吧！</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果仅仅从一个 Java 程序员的角度来说，前后端分离开发这种方式，其实是解放了 Java 程序员，可以让我们专注于后端的工作，不用再去写前端代码，术业有专攻，可以写出更优质的后端代码。不过话说回来，如果想保持一个良好的竞争力，还是有必要去了解一下目前流行的前端开发方式。</p><p>前后端分离不是终点，只是软件开发方式演变大潮下的一个点而已，未来的路还很长，还有很多东西需要我们去学习，这只是一个其中一个而已。</p><p>最后再给大家推荐几篇松哥之前写的前后端分离的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/Qbqvlo7ftbyP6dnbuUcxrw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离，两种文件上传方式总结！</a></li><li><a href="https://mp.weixin.qq.com/s/K8ANNmm6ZrP2xMyK6LGZ_g" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，前端网络请求封装与配置</a></li><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li></ol><p>再推荐两个入门项目：</p><ol><li><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></li><li><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V部落</a></li></ol><p>好了，本文就说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事情的起因是这样的，有个星球的小伙伴向邀请松哥在知乎上回答一个问题，原题是：&lt;/p&gt;
    
    </summary>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库中间件 MyCat 搞起来！</title>
    <link href="http://www.javaboy.org/2019/0628/mycat-install.html"/>
    <id>http://www.javaboy.org/2019/0628/mycat-install.html</id>
    <published>2019-06-28T00:33:57.000Z</published>
    <updated>2019-06-28T02:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 MyCat 的铺垫文章已经写了三篇了：</p><ol><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li></ol><p>今天终于可以迎接我们的大 Boss 出场了！</p><a id="more"></a><h1 id="MyCat-简介"><a href="#MyCat-简介" class="headerlink" title="MyCat 简介"></a>MyCat 简介</h1><p>前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，就像下面这样：</p><p><img src="http://www.javaboy.org/images/mysql/6-2.png" alt></p><p>那么此时 MyCat 所扮演的角色就是分布式数据库中间件！</p><p>MyCat 是一个开源的分布式数据库中间件，它实现了 MySQL 协议，在开发者眼里，他就是一个数据库代理，我们甚至可以使用 MySQL 的客户端工具以及命令行来访问 MyCat 。</p><p>MyCat 现在已经不仅仅只支持 MySQL 了，同时也支持 MSSQL、Oracle、DB2、以及 PostgreSQL等主流数据库。甚至像 MongoDB 这种 NoSQL 也支持。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="搭建读写分离"><a href="#搭建读写分离" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h2><p>要搞 MyCat ，一般要先搭建好 MySQL 的读写分离，MySQL 的读写分离可以参考松哥之前的这篇文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li></ol><h2 id="MyCat-安装"><a href="#MyCat-安装" class="headerlink" title="MyCat 安装"></a>MyCat 安装</h2><p>环境：</p><ul><li>CentOS7</li><li>JDK1.8</li></ul><p>MyCat 使用 Java 开发，因此，运行 MyCat ，一定要具备 Java 环境，配置 Java 运行环境这个比较容易，网上资料也很多，我就不详细介绍了。</p><p>Java 环境安装好之后，首先下载 MyCat：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure><p>下载完成后，对下载文件进行解压。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure><p>解压成功后，会出现一个 <code>mycat</code> 目录，进入到 <code>mycat/conf</code> 目录，对 <code>mycat</code> 进行配置：</p><p>首先来配置 <code>schema.xml</code> 文件：</p><p><img src="http://www.javaboy.org/images/mysql/7-1.png" alt></p><ol><li>首先在 <code>schema</code> 中指定逻辑库的名字，逻辑库是指 <code>MyCat</code> 中的库，这个库不存储数据，数据存储在 <code>MySQL</code> 中的物理库中。</li><li>逻辑库中配置逻辑表，配置逻辑表时，需要指定 <code>dataNode</code> 节点， <code>dataNode</code> 就是指数据库存储的位置</li><li>配置  <code>dataNode</code> ，<code>dataNode</code> 指定  <code>dataHost</code> 和物理库的名字。</li><li><code>dataHost</code> 则配置 <code>MySQL</code> 的主机和从机的位置，登录密码等。主机和从机都可以配置多个。</li></ol><p>配置完 schema.xml 后 ，接下来配置 server.xml。</p><p>server.xml  中主要配置 MyCat 的登录用户名和密码，以及需要操作的逻辑库。</p><p><img src="http://www.javaboy.org/images/mysql/7-2.png" alt></p><p>配置完成后，接下来就可以启动 MyCat 了 。</p><p>执行 MyCat 解压目录下的 bin 目录下的 mycat 命令，可以启动 MyCat</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mycat start</span><br></pre></td></tr></table></figure><p>如果启动后，提示无法创建 <code>mycat.pid</code> 文件，就自己手动创建一个 <code>mycat.pid</code> 文件。启动成功之后，就可以在本地连接 <code>MyCat</code> 了，连接方式和 <code>MySQL</code> 一样，唯一的区别在于端口号不同。</p><p>在连接  <code>MyCat</code> 之前，先在 <code>MySQL</code> 物理库中创建 <code>db1</code>、<code>db2</code> 以及 <code>db3</code> 三个数据库。</p><p>使用 <code>SQLyog</code> 连接：</p><p><img src="http://www.javaboy.org/images/mysql/7-3.png" alt></p><p>也可以在 <code>cmd</code> 命令行登录 <code>MyCat</code> ：</p><p><img src="http://www.javaboy.org/images/mysql/7-4.png" alt></p><p>登录成功后 ，在 <code>MyCat</code>  的窗口中，执行如下命令，创建表：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t_user (id integer primary key,username varchar(255))</span><br></pre></td></tr></table></figure><p>执行成功后，我们会发现物理库中出现了相应的表。<br>接下来，手动往各个物理库的物理表中存储一条数据，然后在  MyCat 窗口中查询：</p><p><img src="http://www.javaboy.org/images/mysql/7-5.png" alt></p><p>这样就可以查询到 三个库中的三个表中的数据。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>整个过程不难，但是有的小伙伴在第一次配置的过程中还是容易出错，因此我这里还是来说两句，出错了要如何定位。</p><p>一般来说，配置 MyCat 出错，问题可能发生在两个阶段。第一个阶段就是客户端连接 MyCat 出错，第二个阶段就是 MyCat 连接 MySQL 出错。</p><p>无论你是使用 SQLyog 还是 Navicat ，我们在连接数据库的过程中，都可以先测试连接，很多人卡在这一步。</p><p>如果在测试连接的时候就连接不通，说明是 MyCat 的问题，这个时候检查步骤如下：</p><ol><li>首先当然是查看日志信息，看能不能找出端倪</li><li>通过 jps 命令查看 mycat 是否成功启动</li><li>检查 server.xml 中配置是否正确，用户名密码是否输入正确</li></ol><p>这是第一种可能的问题，第二种问题就是测试连接没问题，但是测试完后，却连接不上。反映到 Navicat 上，就是测试连接没问题，测完之后，点击连接名要打开连接时，Navicat 就崩了，出现这个问题一般是 MyCat 在连接 MySQL 出问题了，这个时候就要去检查 schema.xml 文件中关于 MySQL 主机和从机的配置是否正确，数据库地址是否正确，用户名密码是否正确。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，本文主要简单介绍了下 MyCat 的安装问题，下篇文章我们来看 MyCat 中的分片规则问题。</p><p>参考资料：</p><ol><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCat 官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 MyCat 的铺垫文章已经写了三篇了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 只能做小项目？松哥要说几句公道话！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What？Tomcat 竟然也算中间件？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天终于可以迎接我们的大 Boss 出场了！&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>What？Tomcat 竟然也算中间件？</title>
    <link href="http://www.javaboy.org/2019/0627/middleware.html"/>
    <id>http://www.javaboy.org/2019/0627/middleware.html</id>
    <published>2019-06-27T02:07:03.000Z</published>
    <updated>2019-06-28T02:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 MyCat 的铺垫文章已经写了两篇了：</p><ol><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li></ol><p>今天是最后一次铺垫，后面就可以迎接大 Boss 了！</p><a id="more"></a><p>本来今天就该讲 MyCat 了，但是我发现还有一个概念值得和大家聊一下，那就是 Java 中间件！</p><p>因为 MyCat 是一个<strong>分布式数据库中间件</strong>，要理解 MyCat ，那你就得先知道到底什么是中间件！</p><p>松哥去年在一次外训中专门讲过中间件，本来想直接和大家分享一下讲稿，但是没找到，所以又动手敲了下。</p><h1 id="中间件简介"><a href="#中间件简介" class="headerlink" title="中间件简介"></a>中间件简介</h1><p>说起中间件，很多人首先想到的就是消息中间件，那么除了消息中间件呢？其实我们日常开发中，接触到的中间件太多了，我们来看维基百科上的一段介绍：</p><blockquote><p>中间件（英语：Middleware），又译中间件、中介层，是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。在现代信息技术应用框架如 Web 服务、面向服务的体系结构等项目中应用比较广泛。如数据库、Apache 的 Tomcat ，IBM 公司的 WebSphere ,BEA 公司的 WebLogic 应用服务器，东方通公司的 Tong 系列中间件，以及 Kingdee 公司的等都属于中间件。</p></blockquote><p>看到这个，你可能会大吃一惊，原来我们不知不觉不知不觉中已经用过这么多中间件了！甚至连 Tomcat 也是一个中间件！</p><p>中间件，顾名思义，就是连接在两个软件之间的东西，是软件之间的一个粘合剂，一个胶水一样的东西。它位于操作系统和我们的应用程序之间，可以让开发者方便地处理通信、输入和输出，使开发者能够专注于自己的业务逻辑开发。</p><p>这么一说，好像 Tomcat 确实还有点像中间件！位于我们的操作系统和应用程序之间！</p><h1 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h1><p>中间件有很多，早在 1998 年 IDC 公司就将中间件分成了 6 大类，国内 2005 年之前出版的中间件相关的书上，很多都是按照这 6 大类来分的，分别是：</p><ol><li>终端仿真/屏幕转换</li><li>数据访问中间件（UDA）</li><li>远程过程调用中间件（RPC）</li><li>消息中间件（MOM）</li><li>交易中间件（TPM）</li><li>对象中间件</li></ol><p>这里边除了消息中间件和交易中间件大家可能听说过之外，其他的中间件估计都很少听说，这是因为时代在变化，有的中间件慢慢被淘汰了（例如 终端仿真/屏幕转换 中间件），有的则慢慢合并到其他框架中去了（例如 远程过程调用中间件）。</p><h1 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h1><p>那么什么是数据库中间件呢？</p><p>前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，那么我们的项目结构可能就是下面这个样子了：</p><p><img src="http://www.javaboy.org/images/mysql/6-1.png" alt></p><p>我们要在 Java 代码中配置复杂的多数据源，配置读写分离，数据查询的时候还要进行数据的预处理，例如从多个 DB 上加载到的数据要先进行排序、过滤等等操作，这样我们的 Java 代码就参杂了很多业务无关的方法，而且这些参杂进来的代码，大多数都还是重复的。</p><p>为了使开发人员，将更多精力放到业务上，我们引入数据库中间件，像下面这样：</p><p><img src="http://www.javaboy.org/images/mysql/6-2.png" alt></p><p>这张图非常形象的说明了什么是中间件！一个介于两个应用程序之间的东西。引入 MyCat 中间件之后，我们的应用程序将只需要连接 MyCat 就行了，再由 MyCat 去操作各种不同的 DB，各个分布式数据库的排序、结果集合并、数据过滤等操作都在 MyCat 中完成，这样我们的 Java 应用又可以专注于业务的开发了，那些繁琐的重复的操作，又交给 MyCat 去完成。</p><p>如果没有数据库中间件，那么我们的 Java 应用程序将直接面对分片集群，数据源切换、事务处理、数据聚合等等众多问题，这样原本该是专注于业务的 Java 应用程序，将会花大量的工作来处理分片后的问题，而且大部分的代码又都是重复的！</p><p>有了数据库中间件，应用只需要集中与业务处理，大量的通用的数据聚合，事务，数据源切换都由中间件来处理，中间件的性能与处理能力将直接决定应用的读写性能，所以在项目中选择一款好的数据库中间件至关重要。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，本文就简单介绍下中间件的基本概念，下文就可以正式开始聊分布式数据库中间件了！</p><p><strong>如果小伙伴觉得松哥自己写的技术文章还过得去的话，欢迎积极转发，松哥每隔 15 天会根据微信后台数据，选一个分享转发最多的一位小伙伴，送一本松哥自己的签名书或者 Java 领域的经典书籍，欢迎大家积极参与，下一次开奖时间在下周。</strong></p><p>参考资料：</p><ol><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCat 官方文档</a></li><li>曾宪杰.大型网站系统与Java中间件实践[M].北京：电子工业出版社，2014.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 MyCat 的铺垫文章已经写了两篇了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 只能做小项目？松哥要说几句公道话！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天是最后一次铺垫，后面就可以迎接大 Boss 了！&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="中间件" scheme="http://www.javaboy.org/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>我的第一本书，被选作大学教材了！</title>
    <link href="http://www.javaboy.org/2019/0626/springboot-vue.html"/>
    <id>http://www.javaboy.org/2019/0626/springboot-vue.html</id>
    <published>2019-06-26T01:09:40.000Z</published>
    <updated>2019-06-26T01:30:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这真是意料之外！</p><a id="more"></a><p>去年年初，接受清华大学出版社夏老师的邀请，下定决心开始写我的第一本书，战战兢兢早起晚睡，好几个月都没有陪女票出去玩，辛辛苦苦终于在年底的时候新书顺利上市！</p><p><img src="http://www.javaboy.org/images/book.jpg" alt></p><h1 id="销量出乎意料"><a href="#销量出乎意料" class="headerlink" title="销量出乎意料"></a>销量出乎意料</h1><p>新书上市之后，刚开始想的是首印的能卖完就不错了，千万别砸到出版社手里了。松哥的公众号当时也只有 4000 多人，而且一直断断续续更新，没啥影响力，新书出来后，宣传了一波之后就偃旗息鼓没再管了，结果后来发生的事情证明我的担心多余了。</p><p>2 月份回家过年，3 月份的时候收到出版社的消息第二次加印，4 月份第三次加印，5 月份第四次加印，下个月第五次加印！这一波操作真是亮瞎了。</p><p>这个销量真是出乎我的意料！从写书的第一天开始，从来不敢想会有这一天。</p><p>不停的加印，也让出版社的编辑老师又找我约稿了，希望能再来一本，可是最近几个月，每天敲键盘时间从早九点到晚十一点，有点快扛不住了，没敢答应，但是这让我看到了未来更多的可能性。</p><h1 id="选作大学教材"><a href="#选作大学教材" class="headerlink" title="选作大学教材"></a>选作大学教材</h1><p>前天，收到了出版社编辑老师的消息，说是有高校老师想把这本书选作下学期的教材，希望我能提供一份配套的 PPT 课件，我立马就答应了，熬夜赶制了一份出来。</p><p>其实新书出版第一周就有一个老师加我微信，后来又陆陆续续有好几位高校老师加我微信，一起探讨书中的内容，我自己也获益良多。这次是一个山东的一本大学将这本书选作教材，我还是有些意外，具体是哪个学校我就不透露了，我看了下，这个高校去年在陕西招生分数高一本线 50 分左右。</p><p>其实对于经常写博客的人来说，写书真是一个信手拈来的机会，遍地都是。但是并不是每一本书都有机会进入大学，成为学生的课本，甚至最后成为学生考试的噩梦（松哥的书估计不会成为考试的噩梦）！</p><p>现在国内技术图书市场，很多书生命力很短，当然原因是多方面的。但是据出版社那边的反馈，如果这本书被选作高校教材，老师讲熟练了，后面还会继续使用，也就是说后面还会继续印刷，我觉得这是最有价值的地方，相信没有作者希望自己的书昙花一现吧！</p><h1 id="为什么写书"><a href="#为什么写书" class="headerlink" title="为什么写书"></a>为什么写书</h1><p>书卖了这么多，有人要问了，松哥一定赚的盆满钵满了吧？老实说，目前拿到手的稿费还没有一个月的薪水多。当然也因为有一部分稿费还没结算，不过写书不挣钱，这个倒是真的。如果奔着赚钱，我去年应该不会写这本书，因为写书是一个非常花费时间精力的事情，写书的时间要是拿去做其他事，会有更大的收益。</p><p>那为什么要写呢？</p><p>首先，我觉得这个世界不能白白走一遭，总得留下一点东西，几年之后，和孩子吹牛，咱也得有个话题啊！</p><p>第二，我觉得这是对自己的一个证明，跨行做计算机，其实我一直都不是很自信，虽然我觉得自己的代码写的还不赖，但是总觉得差点什么！通过这本书我想告诉别人，我不是计算机科班，我也不是一流名校，但是我能在这个行业中做的很好，能够得到多数同行的认可，这就够了。</p><p>第三，作为一个农村出来的孩子，能写一本书，也能让逐渐老去的父母脸上有光，这算是当时的写作的一点私心吧。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>写书很辛苦，但是获得大家的认可还是很开心。因为《Spring Boot + Vue 全栈开发实战》这本书，认识了很多优秀的人，半年里，自己也提高了很多。因此我强烈建议每一个技术人都应该有自己的博客，记录自己技术成长的点点滴滴，说不定博客哪天给你带来一个意料之外的机会，这谁说的准呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这真是意料之外！&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.javaboy.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</title>
    <link href="http://www.javaboy.org/2019/0625/mysql.html"/>
    <id>http://www.javaboy.org/2019/0625/mysql.html</id>
    <published>2019-06-25T08:40:08.000Z</published>
    <updated>2019-06-25T08:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>千万量级的数据，用 MySQL 要怎么存？</p><a id="more"></a><p>初学者在看到这个问题的时候，可能首先想到的是 MySQL 一张表到底能存放多少条数据？</p><p>根据 MySQL 官方文档的介绍，MySQL 理论上限是 (2<sup>32</sup>)<sup>2</sup> 条数据，然而实际操作中，往往还受限于下面两条因素：</p><ol><li>myisam_data_pointer_size，MySQL 的 myisam_data_pointer_size 一般默认是 6，即 48 位，那么对应的行数就是 2<sup>48</sup>-1。</li><li>表的存储大小 256TB</li></ol><p>那有人会说，只要我的数据大小不超过上限，数据行数也不超过上限，是不是就没有问题了？其实不尽然。</p><p>在实际项目中，一般没有哪个项目真的触发到 MySQL 数据的上限了，因为当数据量变大了之后，查询速度会慢的吓人，而一般这个时候，你的数据量离 MySQL 的理论上限还远着呢！</p><p>传统的企业应用一般数据量都不大，数据也都比较容易处理，但是在互联网项目中，上千万、上亿的数据量并不鲜见。在这种时候，还要保证数据库的操作效率，我们就不得不考虑数据库的分库分表了。</p><p>那么接下来就和大家简单聊一聊数据库分库分表的问题。</p><h1 id="数据库切分"><a href="#数据库切分" class="headerlink" title="数据库切分"></a>数据库切分</h1><p>看这个名字就知道，就是把一个数据库切分成 N 多个数据库，然后存放在不同的数据库实例上面，这样做有两个好处：</p><ol><li>降低单台数据库实例的负载</li><li>可以方便的实现对数据库的扩容</li></ol><p>一般来说，数据库的切分有两种不同的切分规则：</p><ol><li>水平切分</li><li>垂直切分</li></ol><p>接下来我们就对这两种不同的切分规则分别进行介绍。</p><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>先来一张简单的示意图，大家感受一下什么是水平切分：</p><p><img src="http://www.javaboy.org/images/mysql/5-1.png" alt></p><p>假设我的 DB 中有 table-1、table-2 以及 table-3 三张表，水平切分就是拿着我的绝世好剑，对准黑色的线条，砍一剑或者砍 N 剑！</p><p>砍完之后，将砍掉的部分放到另外一个数据库实例中，变成下面这样：</p><p><img src="http://www.javaboy.org/images/mysql/5-2.png" alt><br><img src="http://www.javaboy.org/images/mysql/5-3.png" alt></p><p>这样，原本放在一个 DB 中的 table 现在放在两个 DB 中了，观察之后我们发现：</p><ol><li>两个 DB 中表的个数都是完整的，就是原来 DB 中有几张表，现在还是几张。</li><li>每张表中的数据是不完整的，数据被拆分到了不同的 DB 中去了。</li></ol><p>这就是数据库的水平切分，也可以理解为按照数据行进行切分，即按照表中某个字段的<strong>某种规则</strong>来将表数据分散到多个库之中，每个表中包含一部分数据。</p><p>这里的某种规则都包含哪些规则呢？这就涉及到数据库的分片规则问题了，这个松哥在后面的文章中也会和大家一一展开详述。这里先简单说几个常见的分片规则：</p><ol><li>按照日期划分：不容日期的数据存放到不同的数据库中。 </li><li>对 ID 取模：对表中的 ID 字段进行取模运算，根据取模结果将数据保存到不同的实例中。 </li><li>使用一致性哈希算法进行切分。 </li></ol><p>详细的用法，将在后面的文章中和大家仔细说。</p><h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p>先来一张简单的示意图，大家感受一下垂直切分：</p><p><img src="http://www.javaboy.org/images/mysql/5-4.png" alt></p><p>所谓的垂直切分就是拿着我的屠龙刀，对准了黑色的线条砍。砍完之后，将不同的表放到不同的数据库实例中去，变成下面这个样子：</p><p><img src="http://www.javaboy.org/images/mysql/5-5.png" alt><br><img src="http://www.javaboy.org/images/mysql/5-6.png" alt><br><img src="http://www.javaboy.org/images/mysql/5-7.png" alt></p><p>这个时候我们发现如下几个特点：</p><ol><li>每一个数据库实例中的表的数量都是不完整的。</li><li>每一个数据库实例中表的数据是完整的。</li></ol><p>这就是垂直切分。一般来说，垂直切分我们可以按照业务来划分，不同业务的表放到不同的数据库实例中。</p><p>老实说，在实际项目中，数据库垂直切分并不是一件容易的事，因为表之间往往存在着复杂的跨库 JOIN 问题，那么这个时候如何取舍，就要考验架构师的水平了！</p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>通过上面的介绍，相信大家对于水平切分和垂直切分已经有所了解，优缺点其实也很明显了，松哥再来和大家总结一下。</p><h3 id="水平切分-1"><a href="#水平切分-1" class="headerlink" title="水平切分"></a>水平切分</h3><ul><li>优点</li></ul><ol><li>水平切分最大的优势在于数据库的扩展性好，提前选好切分规则，数据库后期可以非常方便的进行扩容。</li><li>有效提高了数据库稳定性和系统的负载能力。拆分规则抽象好， join 操作基本可以数据库做。</li></ol><ul><li>缺点</li></ul><ol><li>水平切分后，分片事务一致性不容易解决。</li><li>拆分规则不易抽象，对架构师水平要求很高。</li><li>跨库 join 性能较差。 </li></ol><h3 id="垂直切分-1"><a href="#垂直切分-1" class="headerlink" title="垂直切分"></a>垂直切分</h3><ul><li>优点</li></ul><ol><li>一般按照业务拆分，拆分后业务清晰，可以结合微服务一起食用。 </li><li>系统之间整合或扩展相对要容易很多。</li><li>数据维护相对简单。</li></ol><ul><li>缺点</li></ul><ol><li>最大的问题在于存在单库性能瓶颈，数据表扩展不易。</li><li>跨库 join 不易。</li><li>事务处理复杂。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虽然 MySQL 中数据存储的理论上限比较高，但是在实际开发中我们不会等到数据存不下的时候才去考虑分库分表问题，因为在那之前，你就会明显的感觉到数据库的各项性能在下降，就要开始考虑分库分表了。</p><p>好了，今天主要是向大家介绍一点概念性的东西，算是我们分布式数据库中间件正式出场前的一点铺垫。</p><p>参考资料：</p><ol><li>MySQL 官方文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千万量级的数据，用 MySQL 要怎么存？&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 只能做小项目？松哥要说几句公道话！</title>
    <link href="http://www.javaboy.org/2019/0622/mysql.html"/>
    <id>http://www.javaboy.org/2019/0622/mysql.html</id>
    <published>2019-06-22T00:52:54.000Z</published>
    <updated>2019-06-22T00:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>松哥上学那会，很多人对 MySQL 有一些偏见，偏见主要集中在以下几方面：</p><ol><li>MySQL 不支持事务（事实上 MyISAM 有表锁，但是效率比较低）</li><li>MySQL 存储的数据量比较小，适合小项目，大项目还是得上 Oracle、DB2 等</li></ol><p>这么多年过去了，松哥自己在开发中一直是以 MySQL 为主，我觉得我有必要说两句公道话了。</p><a id="more"></a><h1 id="公道话"><a href="#公道话" class="headerlink" title="公道话"></a>公道话</h1><h2 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h2><p>关于第一个不支持事务的问题，这有一定的历史原因。MySQL 从设计之初，存储引擎就是可插拔的，允许公司或者个人按照自己的需求定义自己的存储引擎（当然，普通的公司或者个人其实是没有这个实力的）。MySQL 自研的使用较广的存储引擎是 MyISAM ，MyISAM 支持表锁，不支持行锁，所以在处理高并发写操作时效率要低一些，另外 MyISAM 也不支持外键（虽然现在实际项目中外键已经用的比较少了）。</p><p>但是这个问题并非无解。这就不得不说 MySQL 中另外一个大名鼎鼎的存储引擎 InnoDB 了。</p><p>InnoDB 存储引擎是由一家位于芬兰赫尔辛基的名为 Innobase Oy  的公司开发的，InnoDB 存储引擎的历史甚至比 MySQL 还要悠久。</p><p>InnoDB 刚刚开发的时侯，就是作为一个完整的数据库来开发的，因此功能很完备。开发出来之后，创始人是想将这个数据库卖掉的，但是没有找到买家。</p><p>后来 MySQL2.0 推出后，这种可插拔的存储引擎吸引了 Innobase Oy 公司创始人 Heikki Tuuri 的注意，在和 MySQL 沟通之后，决定将 InnoDB 作为一个存储引擎引入到 MySQL 中，MySQL 虽然支持 InnoDB ，但是实际上还是主推自家的 MyISAM。</p><p>但是 InnoDB 实在太优秀了，最终在 2006 年的时侯，成功吸引到大魔王 Oracle 的注意，大手一挥，就把 InnoDB 收购了。</p><p>MySQL 主推自家的 MyISAM ，日子过得也很惨淡，最终在 2008 年被 sun 公司以 10 亿美元拿下，这个操作巩固了 sun 在开源领域的领袖的地位，可是一直以来 sun 公司的变现能力都比较弱，最终 sun 自己在 2009 年被 Oracle 收入囊中。那会松哥还在读高中，某一天吃午饭的时侯，餐厅的电视机上播放央视的午间新闻，看到了这条消息，现在还有一些印象。</p><p>Oracle 收购 sun 之后，InnoDB 和 MySQL 就都成了 Oracle 的产品了，这下整合就变得非常容易了，在后来发布的版本中，InnoDB 慢慢就成为了 MySQL 的默认存储引擎。在最新的 MySQL8 中，元数据表也使用了 InnoDB 作为存储引擎。</p><p>InnoDB 存储引擎主要有如下特点：</p><ol><li>支持事务</li><li>支持 4 个级别的事务隔离</li><li>支持多版本读</li><li>支持行级锁</li><li>读写阻塞与事务隔离级别相关</li><li>支持缓存，既能缓存索引，也能缓存数据</li><li>整个表和主键以 Cluster 方式存储，组成一颗平衡树</li><li>…</li></ol><p>当然也不是说 InnoDB 一定就是好的，在实际开发中，还是要根据具体的场景来选择到底是使用 InnoDB 还是 MyISAM 。</p><p>所以第一个问题不攻自破。</p><h2 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h2><p>第二个问题确实是一个硬伤。</p><p>你要是拿 MySQL 和 Oracle 比，肯定是要差一点点感觉。毕竟一个免费一个收费，而且收费的还很贵。但是这个问题并非无解。</p><p>相信很多小伙伴都听过国内很多大厂都使用了 MySQL 来存储数据。大厂用 MySQL ，是因为他们有能力研发出自己的存储引擎，小厂一般没有这个实力，没法去研发出自己的存储引擎，但是 Oracle 又用不起，那么怎么办呢？</p><p>这几年兴起的分布式数据库中间件刚好可以很好的解决这个问题。Java 领域，类似的工具很多，例如 Sharding-JDBC 、MyCat 等，通过这些工具，可以很好的实现数据库分库分表，以及数据表的动态扩展、读写分离、分布式事务解决等。有了这些工具，极大的提高了 MySQL 的应用场景。</p><p>另一方面，近些年流行微服务，这不是单纯的炒概念，微服务架构将一个大的项目拆分成很多个小的微服务，各个微服务处理自己很小的一部分事情，这更符合人类分工协作的特点。在微服务架构中，我们对大表的需求、对多表联合查询的需求都会有所降低，MySQL 也更具用武之地。</p><p>因此，第二个问题也是可以解决的。</p><p>据松哥了解，互联网公司使用 MySQL 还是比较多的，传统软件公司，可能会更青睐 Oracle 等数据库。</p><p>不过话说回来，云计算，也是未来一个方向。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>为什么要写这篇文章呢？因为松哥打算出几篇文章给大家介绍一下分布式数据库中间件 MyCat 和 Sharding-JDBC 的用法，有了这些分布式数据库中间件，就可以让你的 MySQL 真正具备可以媲美大型数据库的能力。本文算是一个引子吧。</p><p>后面松哥就先更新 MyCat 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥上学那会，很多人对 MySQL 有一些偏见，偏见主要集中在以下几方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 不支持事务（事实上 MyISAM 有表锁，但是效率比较低）&lt;/li&gt;
&lt;li&gt;MySQL 存储的数据量比较小，适合小项目，大项目还是得上 Oracle、DB2 等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这么多年过去了，松哥自己在开发中一直是以 MySQL 为主，我觉得我有必要说两句公道话了。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>松哥整理了 15 道 Spring Boot 高频面试题，看完当面霸</title>
    <link href="http://www.javaboy.org/2019/0619/interview.html"/>
    <id>http://www.javaboy.org/2019/0619/interview.html</id>
    <published>2019-06-19T01:32:30.000Z</published>
    <updated>2019-06-19T01:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！</p><a id="more"></a><p>做 Java 开发，没有人敢小觑 Spring Boot 的重要性，现在出去面试，无论多小的公司 or 项目，都要跟你扯一扯 Spring Boot，扯一扯微服务，不会？没用过？ Sorry ，我们不合适！</p><p>今天松哥就给大家整理了 15 道高频 Spring Boot 面试题，希望能够帮助到刚刚走出校门的小伙伴以及准备寻找新的工作机会的小伙伴。</p><ul><li>1.什么是 Spring Boot ?</li></ul><p>传统的 SSM/SSH 框架组合配置繁琐臃肿，不同项目有很多重复、模板化的配置，严重降低了 Java 工程师的开发效率，而 Spring Boot 可以轻松创建基于 Spring 的、可以独立运行的、生产级的应用程序。通过对 Spring 家族和一些第三方库提供一系列自动化配置的 Starter，来使得开发快速搭建一个基于 Spring 的应用程序。</p><p>Spring Boot 让日益臃肿的 Java 代码又重回简洁。在配合 Spring Cloud 使用时，还可以发挥更大的威力。</p><ul><li>2.Spring Boot 有哪些特点 ?</li></ul><p>Spring Boot 主要有如下特点：</p><ol><li>为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>绝对没有代码生成，也不需要XML配置。</li></ol><ul><li>3.Spring Boot 中的 starter 到底是什么 ?</li></ul><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。</p><p>当然，开发者也可以自定义 Starter，自定义 Starter 可以参考：<a href="https://mp.weixin.qq.com/s/tKr_shLQnvcQADr4mvcU3A" target="_blank" rel="noopener">徒手撸一个 Spring Boot 中的 Starter ，解密自动化配置黑魔法！</a>。</p><ul><li>4.spring-boot-starter-parent 有什么用 ?</li></ul><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><p>关于这个问题，读者可以参考：<a href="https://mp.weixin.qq.com/s/2w6B4fMdbTK_mGjnaMG4BQ" target="_blank" rel="noopener">你真的理解 Spring Boot 项目中的 parent 吗？</a></p><ul><li>5.YAML 配置的优势在哪里 ?</li></ul><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><p>关于 YAML 配置，要是大家还不熟悉，可以参考: <a href="https://mp.weixin.qq.com/s/dbSBzFICIDPLkj5Tuv2-yA" target="_blank" rel="noopener">Spring Boot 中的 yaml 配置简介</a></p><ul><li>6.Spring Boot 中如何解决跨域问题 ?</li></ul><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在则是通过 @CrossOrigin 注解来解决跨域问题。关于 CORS ，小伙伴们可以参考：<a href="https://mp.weixin.qq.com/s/ASEJwiswLu1UCRE-e2twYQ" target="_blank" rel="noopener">Spring Boot 中通过 CORS 解决跨域问题</a></p><ul><li>7.比较一下 Spring Security 和 Shiro 各自的优缺点 ?</li></ul><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ol><ul><li>8.微服务中如何实现 session 共享 ?</li></ul><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。 session 共享大家可以参考：<a href="https://mp.weixin.qq.com/s/xs67SzSkMLz6-HgZVxTDFw" target="_blank" rel="noopener">Spring Boot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></p><ul><li>9.Spring Boot 如何实现热部署 ?</li></ul><p>Spring Boot 实现热部署其实很容易，引入 devtools 依赖即可，这样当编译文件发生变化时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。</p><p>如果仅仅只是页面模板发生变化，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 LiveReload 插件就可以轻松实现热部署。</p><ul><li>10.Spring Boot 中如何实现定时任务 ?</li></ul><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><p>关于定时任务这一块，大家可以参考：<a href="https://mp.weixin.qq.com/s/_20RYBkjKrB4tdpXI3hBOA" target="_blank" rel="noopener">Spring Boot 中实现定时任务的两种方式!</a></p><ul><li>11.前后端分离，如何维护接口文档 ?</li></ul><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。关于 Swagger 的用法，大家可以参考：<a href="https://mp.weixin.qq.com/s/iTsTqEeqT9K84S091ycdog" target="_blank" rel="noopener">SpringBoot整合Swagger2，再也不用维护接口文档了！</a></p><ul><li>12.什么是 Spring Data ?</li></ul><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><ol><li>SpringData 项目支持 NoSQL 存储：</li><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li>JDBC</li><li>JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><ul><li>13.Spring Boot 是否可以使用 XML 配置 ?</li></ul><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><ul><li>14.Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</li></ul><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><ul><li>15.bootstrap.properties 和 application.properties 有何区别 ?</li></ul><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>bootstrap.properties 在 application.properties 之前加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。bootstrap.properties 被 Spring ApplicationContext 的父类加载，这个类先于加载 application.properties 的 ApplicatonContext 启动。</p><p>当然，前面叙述中的 properties 也可以修改为 yaml 。</p><p>好了，本文就说到这里，欢迎小伙伴留言说说你曾经遇到过的 Spring Boot 面试题！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://www.javaboy.org/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://www.javaboy.org/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>想让自己的项目6666，可是 Chrome 不答应！</title>
    <link href="http://www.javaboy.org/2019/0617/chrome-port.html"/>
    <id>http://www.javaboy.org/2019/0617/chrome-port.html</id>
    <published>2019-06-17T02:12:58.000Z</published>
    <updated>2019-06-17T02:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>读万卷书，行万里路！有的技能可以从书里学会，有的技能却需要在实战中打怪升级慢慢掌握，今天就来和大家聊一个很多小伙伴经常遇到的问题。</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>有人向松哥反映，在搭建微服务分布式配置中心 Spring Cloud Config 时，如果将端口设置为 6000，总是访问不成功，像下面这样：</p><p><img src="http://www.javaboy.org/images/web/40-1.png" alt></p><p>如果换成 Tomcat 默认的 8080 就可以访问了。</p><p>其实不止 6000，如果你配置成 6666 ，也是无法访问成功的！</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>刚入行或者经验欠缺的小伙伴应该很容易遇到这个问题，松哥就来和大家稍微说一说这个问题。</p><p>首先，当我们将项目的端口设置为 6000 之后，并非仅仅只有 Chrome 无法访问，Firefox、Safari 也是无法访问的，反而是经常被大家忽略的坐在角落的 IE/Edge 这对难兄难弟可以访问！看看 Safari 访问 6000 端口怎么说：</p><p><img src="http://www.javaboy.org/images/web/40-2.png" alt></p><p>再看看 Firefox 访问 6000 端口怎么说：</p><p><img src="http://www.javaboy.org/images/web/40-3.png" alt></p><p>但是 Edge 就可以访问，如下：</p><p><img src="http://www.javaboy.org/images/web/40-4.png" alt></p><p>看到这里，大家首先可以确认出现这个问题，和你的代码没有关系！是不是可以松一口气了！</p><p>这个问题实际上是由 Chrome 默认的非安全端口限制导致的，除了上文说的 6000，还有其他端口也无法在 Chrome 、Firefox 以及 Safari 中访问（具体端口见文末列表）。</p><p>这些无法访问的端口大部分都是小于 1024，小于 1024 的端口大家应该会很少使用，基本上不会在这个上面栽跟头。大于 1024 的端口也并非每一个都可以使用，这才是容易犯错的地方。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>那么问题要怎么解决呢？两个思路：</p><ol><li>修改项目端口（推荐）</li><li>修改浏览器配置，使之允许访问非安全端口</li></ol><p>推荐大家使用第一种方案，省事！</p><p>如果要使用第二种方案：</p><ul><li>Chrome 修改办法如下：</li></ul><p>右键单击Chrome快捷方式 -&gt; 目标 -&gt; 末尾添加参数：<code>--explicitly-allowed-ports=6000</code></p><p><img src="http://www.javaboy.org/images/web/40-5.png" alt></p><ul><li>Firefox 修改办法如下：</li></ul><p>浏览器地址栏输入 <code>about:config</code> 打开配置页面，然后搜索 <code>network.security.ports.banned.override</code> ，将其值设为 <code>6000</code> 即可(如果没有则右键单击新建即可)。</p><p><img src="http://www.javaboy.org/images/web/40-6.png" alt></p><p>受限端口列表：</p><table><thead><tr><th style="text-align:left">端口</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">tcpmux</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">echo</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">discard</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">systat</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">daytime</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">netstat</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">qotd</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">chargen</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left">ftp data</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left">ftp access</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left">ssh</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left">telnet</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left">smtp</td></tr><tr><td style="text-align:left">37</td><td style="text-align:left">time</td></tr><tr><td style="text-align:left">42</td><td style="text-align:left">name</td></tr><tr><td style="text-align:left">43</td><td style="text-align:left">nicname</td></tr><tr><td style="text-align:left">53</td><td style="text-align:left">domain</td></tr><tr><td style="text-align:left">77</td><td style="text-align:left">priv-rjs</td></tr><tr><td style="text-align:left">79</td><td style="text-align:left">finger</td></tr><tr><td style="text-align:left">87</td><td style="text-align:left">ttylink</td></tr><tr><td style="text-align:left">95</td><td style="text-align:left">supdup</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">hostriame</td></tr><tr><td style="text-align:left">102</td><td style="text-align:left">iso-tsap</td></tr><tr><td style="text-align:left">103</td><td style="text-align:left">gppitnp</td></tr><tr><td style="text-align:left">104</td><td style="text-align:left">acr-nema</td></tr><tr><td style="text-align:left">109</td><td style="text-align:left">pop2</td></tr><tr><td style="text-align:left">110</td><td style="text-align:left">pop3</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">sunrpc</td></tr><tr><td style="text-align:left">113</td><td style="text-align:left">auth</td></tr><tr><td style="text-align:left">115</td><td style="text-align:left">sftp</td></tr><tr><td style="text-align:left">117</td><td style="text-align:left">uucp-path</td></tr><tr><td style="text-align:left">119</td><td style="text-align:left">nntp</td></tr><tr><td style="text-align:left">123</td><td style="text-align:left">NTP</td></tr><tr><td style="text-align:left">135</td><td style="text-align:left">loc-srv /epmap</td></tr><tr><td style="text-align:left">139</td><td style="text-align:left">netbios</td></tr><tr><td style="text-align:left">143</td><td style="text-align:left">imap2</td></tr><tr><td style="text-align:left">179</td><td style="text-align:left">BGP</td></tr><tr><td style="text-align:left">389</td><td style="text-align:left">ldap</td></tr><tr><td style="text-align:left">465</td><td style="text-align:left">smtp+ssl</td></tr><tr><td style="text-align:left">512</td><td style="text-align:left">print / exec</td></tr><tr><td style="text-align:left">513</td><td style="text-align:left">login</td></tr><tr><td style="text-align:left">514</td><td style="text-align:left">shell</td></tr><tr><td style="text-align:left">515</td><td style="text-align:left">printer</td></tr><tr><td style="text-align:left">526</td><td style="text-align:left">tempo</td></tr><tr><td style="text-align:left">530</td><td style="text-align:left">courier</td></tr><tr><td style="text-align:left">531</td><td style="text-align:left">chat</td></tr><tr><td style="text-align:left">532</td><td style="text-align:left">netnews</td></tr><tr><td style="text-align:left">540</td><td style="text-align:left">uucp</td></tr><tr><td style="text-align:left">556</td><td style="text-align:left">remotefs</td></tr><tr><td style="text-align:left">563</td><td style="text-align:left">nntp+ssl</td></tr><tr><td style="text-align:left">587</td><td style="text-align:left">stmp?</td></tr><tr><td style="text-align:left">601</td><td style="text-align:left">??</td></tr><tr><td style="text-align:left">636</td><td style="text-align:left">ldap+ssl</td></tr><tr><td style="text-align:left">993</td><td style="text-align:left">ldap+ssl</td></tr><tr><td style="text-align:left">995</td><td style="text-align:left">pop3+ssl</td></tr><tr><td style="text-align:left">2049</td><td style="text-align:left">nfs</td></tr><tr><td style="text-align:left">3659</td><td style="text-align:left">apple-sasl / PasswordServer</td></tr><tr><td style="text-align:left">4045</td><td style="text-align:left">lockd</td></tr><tr><td style="text-align:left">6000</td><td style="text-align:left">X11</td></tr><tr><td style="text-align:left">6665</td><td style="text-align:left">Alternate IRC [Apple addition]</td></tr><tr><td style="text-align:left">6666</td><td style="text-align:left">Alternate IRC [Apple addition]</td></tr><tr><td style="text-align:left">6667</td><td style="text-align:left">Standard IRC [Apple addition]</td></tr><tr><td style="text-align:left">6668</td><td style="text-align:left">Alternate IRC [Apple addition]</td></tr><tr><td style="text-align:left">6669</td><td style="text-align:left">Alternate IRC [Apple addition]</td></tr></tbody></table><p>好了，这就是本文和大家聊的浏览器的一个小小的坑，希望能帮助到经验欠缺的小伙伴。有问题欢迎留言讨论。</p><p>最新版 Spring Boot2.1.5 案例：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a> ，欢迎大家 star。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读万卷书，行万里路！有的技能可以从书里学会，有的技能却需要在实战中打怪升级慢慢掌握，今天就来和大家聊一个很多小伙伴经常遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome" scheme="http://www.javaboy.org/categories/Chrome/"/>
    
    
      <category term="Web" scheme="http://www.javaboy.org/tags/Web/"/>
    
      <category term="Chrome" scheme="http://www.javaboy.org/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Redis 使用</title>
    <link href="http://www.javaboy.org/2019/0615/springdata-redis.html"/>
    <id>http://www.javaboy.org/2019/0615/springdata-redis.html</id>
    <published>2019-06-15T12:52:21.000Z</published>
    <updated>2019-06-15T15:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>上文我们介绍了 Redis，在开发环境中，我们还有另外一个解决方案，那就是 Spring Data Redis 。本文我们就来看看这个东西。</p><a id="more"></a><p>本文是 Redis 系列的第十四篇文章，了解前面的文章有助于更好的理解本文：  </p><hr><p>1.<a href="https://mp.weixin.qq.com/s/NCm3zNGIDVMnlykeOiaH7Q" target="_blank" rel="noopener">Linux 上安装 Redis</a><br>2.<a href="http://mp.weixin.qq.com/s/jNSN8YO4jZbyjKR5C4in_w" target="_blank" rel="noopener">Redis 中的五种数据类型简介</a><br>3.<a href="https://mp.weixin.qq.com/s/Svvgwo_a92vNdCSazbzKRQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 介绍</a><br>4.<a href="http://mp.weixin.qq.com/s/OGUnTBmdErvZ8r_yoyg_rQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 中 BIT 相关命令</a><br>5.<a href="https://mp.weixin.qq.com/s/C07AJhRk8AvPeKxSUq8lGA" target="_blank" rel="noopener">Redis 列表与集合</a><br>6.<a href="https://mp.weixin.qq.com/s/9KlDOJlY7ZEoLEGUyDNxRg" target="_blank" rel="noopener">Redis 散列与有序集合</a><br>7.<a href="https://mp.weixin.qq.com/s/5z8IZsB_nEJXELis9e5JWQ" target="_blank" rel="noopener">Redis 中的发布订阅和事务</a><br>8.<a href="https://mp.weixin.qq.com/s/nsFVwQUc_YB1QcxYo10o-g" target="_blank" rel="noopener">Redis 快照持久化</a><br>9.<a href="https://mp.weixin.qq.com/s/CLEd7XuPmjHpqLmQaVvklQ" target="_blank" rel="noopener">Redis 之 AOF 持久化</a><br>10.<a href="https://mp.weixin.qq.com/s/TxVsMhRXZiVPhruzh9bOAA" target="_blank" rel="noopener">Redis 主从复制(一)</a><br>11.<a href="https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ" target="_blank" rel="noopener">Redis 主从复制(二)</a><br>12.<a href="https://mp.weixin.qq.com/s/0DA18OdrsCdcQihCoQ_eww" target="_blank" rel="noopener">Redis 集群搭建</a><br>13.<a href="https://mp.weixin.qq.com/s/4ghSyd8BIq01LYhhjToXrg" target="_blank" rel="noopener">Jedis 使用</a>  </p><hr><h1 id="Spring-Data-Redis-介绍"><a href="#Spring-Data-Redis-介绍" class="headerlink" title="Spring Data Redis 介绍"></a>Spring Data Redis 介绍</h1><p>Spring Data Redis 是 Spring 官方推出，可以算是 Spring 框架集成 Redis 操作的一个子框架，封装了 Redis 的很多命令，可以很方便的使用 Spring 操作 Redis 数据库，Spring 对很多工具都提供了类似的集成，如 Spring Data MongDB、Spring Data JPA 等, Spring Data Redis 只是其中一种。  </p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>要使用 SDR，首先需要搭建 Spring+SpringMVC 环境，由于这个不是本文的重点，因此这一步我直接略过，Spring+SpringMVC 环境搭建成功后，接下来我们要整合 SDR，首先需要添加如下依赖：  </p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建在 resources 目录下创建 redis.properties 文件作为 redis 的配置文件，如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis.host=192.168.248.128</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.maxIdle=300</span><br><span class="line">redis.maxTotal=600</span><br><span class="line">redis.maxWait=1000</span><br><span class="line">redis.testOnBorrow=true</span><br></pre></td></tr></table></figure><p>在 spring 的配置文件中，添加如下 bean：  </p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--引入redis.properties文件--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:redis.properties"</span>/&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--配置连接池信息--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPoolConfig"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"poolConfig"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxIdle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxIdle&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxTotal"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxTotal&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxWaitMillis"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxWait&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"testOnBorrow"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.testOnBorrow&#125;"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--配置基本连接信息--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"connectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hostName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.host&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"poolConfig"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"poolConfig"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--配置RedisTemplate--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.core.RedisTemplate"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"redisTemplate"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"connectionFactory"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-comment">&lt;!--key和value要进行序列化，否则存储对象时会出错--&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"keySerializer"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"valueSerializer"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，在 Spring 中配置了 redisTemplate 之后，接下来我们就可以在 Dao 层注入 redisTemplate 进而使用了。  </p><p>接下来我们首先创建实体类 User ，注意 User 一定要可序列化：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">   <span class="hljs-comment">//get/set省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Dao 层实现数据的添加和获取，如下：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDao</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">        ops.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">        <span class="hljs-keyword">return</span> ops.get(key).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setuser</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">        ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">        ops.set(user.getId(), user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getuser</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        ValueOperations&lt;String, User&gt; ops = redisTemplate.opsForValue();</span><br><span class="line">        User user = ops.get(id);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDR 官方文档中对 Redistemplate 的介绍，通过 Redistemplate 可以调用 ValueOperations 和 ListOperations 等等方法，分别是对 Redis 命令的高级封装。但是 ValueOperations 等等这些命令最终是要转化成为 RedisCallback 来执行的。也就是说通过使用 RedisCallback 可以实现更强的功能。  </p><p>最后，给大家展示下我的 Service 和 Controller ，如下：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    HelloDao helloDao;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        helloDao.set(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> helloDao.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setuser</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">        helloDao.setuser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getuser</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        String s = helloDao.getuser(id).toString();</span><br><span class="line">        <span class="hljs-keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Controller：</span><br><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/set"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        helloService.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/get"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> helloService.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/setuser"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="hljs-string">"1"</span>);</span><br><span class="line">        user.setUsername(<span class="hljs-string">"深圳"</span>);</span><br><span class="line">        user.setPassword(<span class="hljs-string">"sang"</span>);</span><br><span class="line">        helloService.setuser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/getuser"</span>,produces = <span class="hljs-string">"text/html;charset=UTF-8"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> helloService.getuser(<span class="hljs-string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试过程就不再展示了，小伙伴们可以用 POSTMAN 等工具自行测试。  </p><p>好了，Spring Data Redis 我们就说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文我们介绍了 Redis，在开发环境中，我们还有另外一个解决方案，那就是 Spring Data Redis 。本文我们就来看看这个东西。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
      <category term="Spring Data" scheme="http://www.javaboy.org/tags/Spring-Data/"/>
    
  </entry>
  
  <entry>
    <title>Jedis 使用</title>
    <link href="http://www.javaboy.org/2019/0615/redis-jedis.html"/>
    <id>http://www.javaboy.org/2019/0615/redis-jedis.html</id>
    <published>2019-06-15T12:52:08.000Z</published>
    <updated>2019-06-15T15:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的知识我们已经介绍的差不多了，本文我们来看看如何使用 Java 操作 redis。</p><a id="more"></a><p>本文是Redis系列的第十三篇文章，了解前面的文章有助于更好的理解本文：  </p><hr><p>1.<a href="https://mp.weixin.qq.com/s/NCm3zNGIDVMnlykeOiaH7Q" target="_blank" rel="noopener">Linux 上安装 Redis</a><br>2.<a href="http://mp.weixin.qq.com/s/jNSN8YO4jZbyjKR5C4in_w" target="_blank" rel="noopener">Redis 中的五种数据类型简介</a><br>3.<a href="https://mp.weixin.qq.com/s/Svvgwo_a92vNdCSazbzKRQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 介绍</a><br>4.<a href="http://mp.weixin.qq.com/s/OGUnTBmdErvZ8r_yoyg_rQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 中 BIT 相关命令</a><br>5.<a href="https://mp.weixin.qq.com/s/C07AJhRk8AvPeKxSUq8lGA" target="_blank" rel="noopener">Redis 列表与集合</a><br>6.<a href="https://mp.weixin.qq.com/s/9KlDOJlY7ZEoLEGUyDNxRg" target="_blank" rel="noopener">Redis 散列与有序集合</a><br>7.<a href="https://mp.weixin.qq.com/s/5z8IZsB_nEJXELis9e5JWQ" target="_blank" rel="noopener">Redis 中的发布订阅和事务</a><br>8.<a href="https://mp.weixin.qq.com/s/nsFVwQUc_YB1QcxYo10o-g" target="_blank" rel="noopener">Redis 快照持久化</a><br>9.<a href="https://mp.weixin.qq.com/s/CLEd7XuPmjHpqLmQaVvklQ" target="_blank" rel="noopener">Redis 之 AOF 持久化</a><br>10.<a href="https://mp.weixin.qq.com/s/TxVsMhRXZiVPhruzh9bOAA" target="_blank" rel="noopener">Redis 主从复制(一)</a><br>11.<a href="https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ" target="_blank" rel="noopener">Redis 主从复制(二)</a><br>12.<a href="https://mp.weixin.qq.com/s/0DA18OdrsCdcQihCoQ_eww" target="_blank" rel="noopener">Redis 集群搭建</a>  </p><hr><h1 id="有哪些解决方案"><a href="#有哪些解决方案" class="headerlink" title="有哪些解决方案"></a>有哪些解决方案</h1><p>查看 redis 官网，我们发现用 Java 操作 redis，我们有多种解决方案，如下图：  </p><p><img src="http://www.javaboy.org/images/redis/p315.png" alt></p><p>这里的解决方案有多种，我们采用 Jedis，其他的框架也都大同小异，我这里权当抛砖引玉，小伙伴也可以研究研究其他的方案，欢迎投稿。  </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>客户端要能够成功连接上 redis 服务器，需要检查如下三个配置：  </p><p>1.远程 Linux 防火墙已经关闭，以我这里的 CentOS7 为例，关闭防火墙命令 <code>systemctl stop firewalld.service</code> ，同时还可以再补一刀 <code>systemctl disable firewalld.service</code> 表示禁止防火墙开机启动。  </p><p>2.关闭 redis 保护模式，在 redis.conf 文件中，修改 protected 为 no，如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p>3.注释掉 redis 的 ip 地址绑定，还是在 redis.conf 中，将 bind:127.0.0.1 注释掉，如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bind:127.0.0.1</span><br></pre></td></tr></table></figure><p>确认了这三步之后，就可以远程连接 redis 了。  </p><h1 id="Java-端配置"><a href="#Java-端配置" class="headerlink" title="Java 端配置"></a>Java 端配置</h1><p>上面的配置完成后，我们可以创建一个普通的 JavaSE 工程来测试下了，Java 工程创建成功后，添加 Jedis 依赖，如下：  </p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过如下一个简单的程序测试一下连接是否成功：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">6379</span>);</span><br><span class="line">    String ping = jedis.ping();</span><br><span class="line">    System.out.println(ping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，看到如下结果表示连接成功了：  </p><p><img src="http://www.javaboy.org/images/redis/p316.png" alt>    </p><p>连接成功之后，剩下的事情就比较简单了，Jedis 类中方法名称和 redis 中的命令基本是一致的，看到方法名小伙伴就知道是干什么的，因此这些我这里不再重复叙述。  </p><p>频繁的创建和销毁连接会影响性能，我们可以采用连接池来部分的解决这个问题：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GenericObjectPoolConfig config = <span class="hljs-keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">    config.setMaxTotal(<span class="hljs-number">100</span>);</span><br><span class="line">    config.setMaxIdle(<span class="hljs-number">20</span>);</span><br><span class="line">    JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(config, <span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">6379</span>);</span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会频繁创建和销毁连接了，在 JavaSE 环境中可以把连接池配置成一个单例模式，如果用了 Spring 容器的话，可以把连接池交给 Spring 容器管理。  </p><p>上面这种连接都是连接单节点的 Redis，如果是一个 Redis 集群，要怎么连接呢？很简单，如下：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt; clusterNodes = <span class="hljs-keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7001</span>));</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7002</span>));</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7003</span>));</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7004</span>));</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7005</span>));</span><br><span class="line">clusterNodes.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">7006</span>));</span><br><span class="line">JedisCluster jc = <span class="hljs-keyword">new</span> JedisCluster(clusterNodes);</span><br><span class="line">jc.set(<span class="hljs-string">"address"</span>, <span class="hljs-string">"深圳"</span>);</span><br><span class="line">String address = jc.get(<span class="hljs-string">"address"</span>);</span><br><span class="line">System.out.println(address);</span><br></pre></td></tr></table></figure><p>JedisCluster 中的方法与 Redis 命令也是基本一致，我就不再重复介绍了。  </p><p>好了，jedis 就说这么多，有问题欢迎留言讨论。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 的知识我们已经介绍的差不多了，本文我们来看看如何使用 Java 操作 redis。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
      <category term="Jedis" scheme="http://www.javaboy.org/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 集群搭建</title>
    <link href="http://www.javaboy.org/2019/0615/redis-cluster.html"/>
    <id>http://www.javaboy.org/2019/0615/redis-cluster.html</id>
    <published>2019-06-15T12:52:02.000Z</published>
    <updated>2019-06-15T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>主从的搭建差不多说完了，本文我们来看看集群如何搭建。</p><a id="more"></a><p>本文是 Redis 系列的第十二篇文章，了解前面的文章有助于更好的理解本文：  </p><hr><p>1.<a href="https://mp.weixin.qq.com/s/NCm3zNGIDVMnlykeOiaH7Q" target="_blank" rel="noopener">Linux 上安装 Redis</a><br>2.<a href="http://mp.weixin.qq.com/s/jNSN8YO4jZbyjKR5C4in_w" target="_blank" rel="noopener">Redis 中的五种数据类型简介</a><br>3.<a href="https://mp.weixin.qq.com/s/Svvgwo_a92vNdCSazbzKRQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 介绍</a><br>4.<a href="http://mp.weixin.qq.com/s/OGUnTBmdErvZ8r_yoyg_rQ" target="_blank" rel="noopener">Redis 字符串 (STRING) 中 BIT 相关命令</a><br>5.<a href="https://mp.weixin.qq.com/s/C07AJhRk8AvPeKxSUq8lGA" target="_blank" rel="noopener">Redis 列表与集合</a><br>6.<a href="https://mp.weixin.qq.com/s/9KlDOJlY7ZEoLEGUyDNxRg" target="_blank" rel="noopener">Redis 散列与有序集合</a><br>7.<a href="https://mp.weixin.qq.com/s/5z8IZsB_nEJXELis9e5JWQ" target="_blank" rel="noopener">Redis 中的发布订阅和事务</a><br>8.<a href="https://mp.weixin.qq.com/s/nsFVwQUc_YB1QcxYo10o-g" target="_blank" rel="noopener">Redis 快照持久化</a><br>9.<a href="https://mp.weixin.qq.com/s/CLEd7XuPmjHpqLmQaVvklQ" target="_blank" rel="noopener">Redis 之 AOF 持久化</a><br>10.<a href="https://mp.weixin.qq.com/s/TxVsMhRXZiVPhruzh9bOAA" target="_blank" rel="noopener">Redis 主从复制(一)</a><br>11.<a href="https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ" target="_blank" rel="noopener">Redis 主从复制(二)</a>  </p><hr><h1 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h1><p>Redis 集群架构如下图：  </p><p><img src="http://www.javaboy.org/images/redis/p317.png" alt>  </p><p>Redis 集群运行原理如下：  </p><ol><li>所有的 Redis 节点彼此互联( PING-PONG 机制),内部使用二进制协议优化传输速度和带宽  </li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效  </li><li>客户端与 Redis 节点直连,不需要中间 proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可  </li><li>Redis-cluster 把所有的物理节点映射到 [0-16383] slot 上, cluster (簇)负责维护 <code>node&lt;-&gt;slot&lt;-&gt;value</code> 。Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，Redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点  </li></ol><h2 id="怎么样投票"><a href="#怎么样投票" class="headerlink" title="怎么样投票"></a>怎么样投票</h2><p>投票过程是集群中所有 master 参与,如果半数以上 master 节点与 master 节点通信超过 <code>cluster-node-timeout</code> 设置的时间,认为当前 master 节点挂掉。  </p><h2 id="怎么样判定节点不可用"><a href="#怎么样判定节点不可用" class="headerlink" title="怎么样判定节点不可用"></a>怎么样判定节点不可用</h2><p>1.如果集群任意 master 挂掉,且当前 master 没有 slave， 集群进入 fail 状态,也可以理解成集群的 slot 映射 [0-16383] 不完整时进入 fail 状态。<br>2.如果集群超过半数以上 master 挂掉，无论是否有 slave ,集群进入 fail 状态，当集群不可用时,所有对集群的操作做都不可用，收到 ((error) CLUSTERDOWN The cluster is down) 错误。  </p><h1 id="ruby-环境"><a href="#ruby-环境" class="headerlink" title="ruby 环境"></a>ruby 环境</h1><p>Redis 集群管理工具 redis-trib.rb 依赖 ruby 环境，首先需要安装 ruby 环境：</p><p>安装 ruby:  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure><p>但是这种安装方式装好的 ruby 版本可能不适用，如果安装失败，可以参考这篇文章解决 <a href="https://blog.csdn.net/fengye_yulu/article/details/77628094" target="_blank" rel="noopener">redis requires Ruby version &gt;= 2.2.2</a>。  </p><h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>首先我们对集群做一个简单规划，假设我的集群中一共有三个节点，每个节点一个主机一个从机，这样我一共需要 6 个 Redis 实例。首先创建 redis-cluster 文件夹，在该文件夹下分别创建 7001、7002、7003、7004、7005、7006 文件夹，用来存放我的 Redis 配置文件，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p323.png" alt>   </p><p>将 Redis 也在 redis-cluster 目录下安装一份，然后将 redis.conf 文件向 7001-7006 这 6 个文件夹中分别拷贝一份，拷贝完成后，分别修改如下参数：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-XX  XXX7001.conf</span><br><span class="line">protected no</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>这是 7001 目录下的配置，其他的文件夹将 7001 改为对应的数字即可。修改完成后，进入到 redis 安装目录中，分别启动各个 redis ，使用刚刚修改过的配置文件，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p318.png" alt>  </p><p>启动成功后，我们可以查看 redis 进程，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p319.png" alt></p><p>这个表示各个节点都启动成功了。接下来我们就可以进行集群的创建了，首先将 redis/src 目录下的 redis-trib.rb 文件拷贝到 redis-cluster 目录下，然后在 redis-cluster 目录下执行如下命令：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.248.128:7001 192.168.248.128:7002 192.168.248.128:7003 192.168.248.128:7004 192.168.248.128:7005 192.168.248.128:7006</span><br></pre></td></tr></table></figure><p>注意，replicas 后面的 1 表示每个主机都带有 1 个从机，执行过程如下：  </p><p><img src="http://www.javaboy.org/images/redis/p320.png" alt></p><p>注意创建过程的日志，每个 redis 都获得了一个编号，同时日志也说明了哪些实例做主机，哪些实例做从机，每个从机的主机是谁，每个主机所分配到的 hash 槽范围等等。</p><h1 id="查询集群信息"><a href="#查询集群信息" class="headerlink" title="查询集群信息"></a>查询集群信息</h1><p>集群创建成功后，我们可以登录到 Redis 控制台查看集群信息，注意登录时要添加 <code>-c</code> 参数，表示以集群方式连接，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p321.png" alt> </p><p><img src="http://www.javaboy.org/images/redis/p322.png" alt> </p><h1 id="添加主节点"><a href="#添加主节点" class="headerlink" title="添加主节点"></a>添加主节点</h1><p>首先我们准备一个端口为 7007 的主节点并启动，准备方式和前面步骤一样，启动成功后，通过如下命令添加主节点：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node  127.0.0.1:7007 127.0.0.1:7001</span><br></pre></td></tr></table></figure><p>主节点添加之后，我们可以通过 cluster nodes 命令查看主节点是否添加成功，此时我们发现新添加的节点没有分配到 slot ，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p324.png" alt>  </p><p>没有分配到 slot 将不能存储数据，此时我们需要手动分配 slot，分配命令如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb reshard 127.0.0.1:7001</span><br></pre></td></tr></table></figure><p>后面的地址为任意一个节点地址，在分配的过程中，我们一共要输入如下几个参数：  </p><p>1.一共要划分多少个 hash 槽出来？就是我们总共要给新添加的节点分多少 hash 槽，这个参数依实际情况而定，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p325.png" alt>  </p><p>2.这些划分出来的槽要给谁，这里输入 7007 节点的编号，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p326.png" alt="p326">  </p><p>3.要让谁出血？因为 hash 槽目前已经全部分配完毕，要重新从已经分好的节点中拿出来一部分给 7007 ，必然要让另外三个节点把吃进去的吐出来，这里我们可以输入多个节点的编号，每次输完一个点击回车，输完所有的输入 done 表示输入完成，这样就让这几个节点让出部分 slot，如果要让所有具有 slot 的节点都参与到此次 slot 重新分配的活动中，那么这里直接输入 all 即可，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p327.png" alt>  </p><p>OK，主要就是这几个参数，输完之后进入到 slot 重新分配环节，分配完成后，通过 cluster nodes 命令，我们可以发现 7007 已经具有 slot 了，如下：  </p><p><img src="http://www.javaboy.org/images/redis/p328.png" alt> </p><p>OK,刚刚我们是添加主节点，我们也可以添加从节点，比如我要把 7008 作为 7007 的从节点，添加方式如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node --slave --master-id 79bbb30bba66b4997b9360dd09849c67d2d02bb9  192.168.31.135:7008 192.168.31.135:7007</span><br></pre></td></tr></table></figure><p>其中 79bbb30bba66b4997b9360dd09849c67d2d02bb9 是 7007 的编号。  </p><h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><p>删除节点也比较简单，如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017</span><br></pre></td></tr></table></figure><p>注意 4b45eb75c8b428fbd77ab979b85080146a9bc017 是要删除节点的编号。</p><p>再注意：删除已经占有 hash 槽的结点会失败，报错如下：  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</span><br></pre></td></tr></table></figure><p>需要将该结点占用的 hash 槽分配出去（分配方式与上文一致，不赘述）。  </p><p>好了，redis 集群搭建我们先说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主从的搭建差不多说完了，本文我们来看看集群如何搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
</feed>
