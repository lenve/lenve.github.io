<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-10-09T00:43:31.630Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为了避免“内卷”，松哥跑去上海见世面了</title>
    <link href="http://www.javaboy.org/2020/0928/huawei-connect.html"/>
    <id>http://www.javaboy.org/2020/0928/huawei-connect.html</id>
    <published>2020-09-28T01:57:32.000Z</published>
    <updated>2020-10-09T00:43:31.630Z</updated>
    
    <content type="html"><![CDATA[<p>25 号在 HC 会场跑了一天，脚都酸了。晚上回到酒店，刚打开手机，就看到网传华为松山湖一个在建的项目着火，万幸没有人员伤亡。2020 对华为来说真是坎坷。</p><a id="more"></a><p>我前两天也受邀参加了华为在上海世博中心举办的 2020 全联接大会（huawei connect），受疫情影响，今年的全联接大会规模缩水了很多，不过今年的 HC 大会还是有很多精彩的训练营、讲演以及比赛，感觉也是不虚此行。</p><p>今年的 HC 大会一共是四天，9.23-9.26，前两天是商业相关，后两天则和开发者相关，因此我是 25 号一大早出发，大概九点多到上海，十点多到会场。第一次来上海，中国的第一大都市，地铁竟然不能用微信/支付宝，感觉这实在不符合上海这座中国 GDP 第一城的身份。</p><p>从中华艺术宫地铁站出来，就有会务的小伙伴举着牌引导参会路线，每个转弯路口都有人，大概走三四百米就到会场了，世博中心南 2 号门。</p><p><img src="http://img.itboyhub.com/2020/07/20200925212355.png" alt></p><p>进来之后，左边是展厅，楼上的会议室会有不同的演讲和训练营，还有一个 2020 华为云无人车挑战杯二十强赛队的总决赛都在楼上举行，没法同时参加这么多活动，只能先选择自己相对感兴趣的活动参加，其他的如果感兴趣可以会后看录播。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223302.png" alt></p><p>松哥就直奔展厅看黑科技去了。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223335.png" alt></p><p>华为最广为人知的身份就是 ICT 解决方案供应商，其实这只是它的看家本领，除了看家本领，华为也涉及到很多其他领域，例如智慧城市、智能电网、智慧政务、智慧油气、智慧城轨、智能铁路、智慧教育等等。</p><p>比如这个，挖掘技术哪家强？</p><p><img src="http://img.itboyhub.com/2020/07/20200927220110.png" alt></p><p>这是华为的 5G+智慧天车，通过远程操控炼钢区天车，使工人远离高危场景、高温环境、粉尘污染等不利于身心健康的工作环境，有效提升生产效率，避免了安全生产问题。</p><p>再比如这个，智慧园区：</p><p><img src="http://img.itboyhub.com/2020/07/20200927220807.png" alt></p><p>园区火灾可以自动通知到附近的人，园区资产离开划定范围会自动报警等等。</p><p>还有很多其他的展示，比如智慧航空，如果有小伙伴最近一两年到过深圳宝安机场，应该也会见到华为和深圳宝安机场合作的智慧航空。</p><p>展台还是有点枯燥，不过还是有一些比较好玩的，例如这个叫做“绝影”的机器狗：</p><p><img src="http://img.itboyhub.com/2020/07/20200925224522.png" alt></p><p>松哥还录了一小段视频：</p><!--插入视频--><p>这个机器狗能翻跟斗能尬舞，跌倒了还能自己爬起来。它是通过华为的普惠 AI 开发平台 ModelArts 训练出来的，这条狗可以在模拟的工厂危险场景中规划路线，跑步关闭燃气控制阀门，解除火情！</p><p>松哥的读者可能都是搞 Java 的，华为的 ModelArts 可能接触的少，我大概说两句：这个 ModelArts 是面向开发者的一站式 AI 开发平台，为机器学习与深度学习提供海量数据预处理及半自动化标注、大规模分布式 Training、自动化模型生成，及端-边-云模型按需部署能力，帮助用户快速创建和部署模型，管理全周期 AI 工作流。简单来说，如果你想搞 AI，使用这个可以显著降低学习门槛。</p><p>人气最旺的展台应该是 Developer 了：</p><p><img src="http://img.itboyhub.com/2020/07/20200925225956.png" alt></p><p>松哥猜测可能是因为 Developer 送的小礼物较多（狗头</p><p>展区有一些专题演讲，比如深圳 HDZ 核心组织者曹一峰总介绍 HDZ：</p><p><img src="http://img.itboyhub.com/2020/07/20200925231112.png" alt></p><p>各地 HDZ 成员的合照：</p><p><img src="http://img.itboyhub.com/2020/07/20200927230901.png" alt></p><p>HDZ 是华为开发者地带，有点类似于谷歌的 GDG，由各地区的小伙伴自主运营，举办一些线下技术沙龙，技术分享会等等，感兴趣的小伙伴可以找找你们当地的 HDZ 组织哦～</p><p>在展区出口的地方竟然看到了 JetBrains 也去摆摊了，又惊又喜：</p><p><img src="http://img.itboyhub.com/2020/07/20200925230316.png" alt><br><img src="http://img.itboyhub.com/2020/07/20200925230459.png" alt></p><p>这是展区的情况，现场还有很多训练营，松哥因为时间关系，主要去听了云原生训练营，我把训练营的 ppt 上传到百度网盘了，有需要的小伙伴可以在公号后台回复<code>云原生</code>下载。</p><p>另外还有无人车挑战杯总决赛还是蛮有意思的，可惜我错过了现场，只好回来后看录播，感兴趣的小伙伴可以自己看看：<a href="https://live.huawei.com/Cloud-AI/meeting/cn/5893.html。" target="_blank" rel="noopener">https://live.huawei.com/Cloud-AI/meeting/cn/5893.html。</a></p><p>26 号则主要是开发者嘉年华，这应该是整个展会期间最嗨的一段了。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223401.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223745.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223441.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223500.png" alt></p><p>嘉年华穿插着各种颁奖，颁了两个五百万大奖：</p><p><img src="http://img.itboyhub.com/2020/07/20200927224038.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927224111.png" alt></p><p>还有社区之星的颁奖：</p><p><img src="http://img.itboyhub.com/2020/07/20200927224521.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927224535.png" alt></p><p>华为公有云虽然起步较晚，但是这两年发展迅猛，成果还是有目共睹的。这次的 HC 大会就很好的展示华为云的技术实力。</p><hr><p>老实说，松哥平时在深圳还是相当宅，周末也不怎么动，一方面是因为事情比较多，另一方面也是自己比较懒。但是对于一些行业的活动，只要时间允许，我还是比较乐意参加的，一方面可以去见见世面，看看同行们都在关注什么技术，也看看自己的不足；另一方面则是多认识一些小伙伴，总之就是要尽量避免自己“内卷”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;25 号在 HC 会场跑了一天，脚都酸了。晚上回到酒店，刚打开手机，就看到网传华为松山湖一个在建的项目着火，万幸没有人员伤亡。2020 对华为来说真是坎坷。&lt;/p&gt;
    
    </summary>
    
      <category term="HUAWEI" scheme="http://www.javaboy.org/categories/HUAWEI/"/>
    
    
      <category term="huawei" scheme="http://www.javaboy.org/tags/huawei/"/>
    
      <category term="hdz" scheme="http://www.javaboy.org/tags/hdz/"/>
    
  </entry>
  
  <entry>
    <title>聊一个 GitHub 上开源的 RBAC 权限管理系统，很6！</title>
    <link href="http://www.javaboy.org/2020/0925/springsecurity-rbac.html"/>
    <id>http://www.javaboy.org/2020/0925/springsecurity-rbac.html</id>
    <published>2020-09-25T01:57:17.000Z</published>
    <updated>2020-10-09T00:45:32.266Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前两天写了一篇文章，和大家大概聊了聊 RBAC 权限管理系统：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/B03cDEE1i3gT0yDhIxGATw" target="_blank" rel="noopener">Spring Security 中最流行的权限管理模型！</a></li></ul><p>RBAC 理论其实并不难，相信大家看完文章都能明白。但是如何将理论转为实践代码，这还需要一点功力。</p><p>大家可能在网上也会见到众多自称 RBAC 的权限管理系统，这些系统有的确实是 RBAC，有的虽然自称 RBAC，其实并不是。</p><p>为了帮助小伙伴掌握 RBAC 权限管理模型，松哥经过大量的摸排，找到了一些开源的 RBAC 权限管理系统，我想写几篇文章和大家分析一下这些系统的实现，搞懂了别人的实现逻辑，自己再去做就非常容易了。</p><p>今天要和大家介绍的是一个来自 GitHub 上的项目，叫做 wetech-admin。</p><h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>wetech-admin 是基于 Spring Boot 2.0+Mybatis+Vue 的轻量级后台管理系统，适用于中小型项目的管理后台，支持按钮级别的权限控制，系统具有最基本的用户管理、角色管理、权限管理等通用性功能，企业或个人可直接在此基础上进行开发，扩展，添加各自的需求和业务功能!</p><ul><li>项目地址：<a href="https://github.com/cjbi/wetech-admin" target="_blank" rel="noopener">https://github.com/cjbi/wetech-admin</a></li></ul><p>松哥看了下这个项目，基本上是满足 RBAC0 模型，功能上比较完整，唯一有点遗憾的是，它是用 Shiro 开发的，而不是 Spring Security。</p><p>不过这个并不影响我们学习 RBAC，RBAC 作为一种权限模型是语言无关的，无论你用什么语言都可以实现 RBAC，更不用说同一种语言的不同框架了。</p><p>只要我们把这个 RBAC 搞懂，用 Spring Security 实现 RBAC 自然也不在话下。其实 Spring Security 实现 RBAC 所需要的技术，在松哥本系列的文章中基本上都已经介绍过了，现在只要大家搞懂了模型，就能很快实现。</p><p>我们来看看这个项目的几个效果图：</p><p><img src="http://img.itboyhub.com/2020/07/20200924112633.png" alt></p><p>可以看到，用户列表、角色列表、权限列表，三个菜单涉及到了权限管理中三张表。</p><p><img src="http://img.itboyhub.com/2020/07/20200924112742.png" alt="用户管理"></p><p><img src="http://img.itboyhub.com/2020/07/20200924113024.png" alt="角色管理"></p><p><img src="http://img.itboyhub.com/2020/07/20200924112843.png" alt="权限管理"></p><h2 id="2-项目部署"><a href="#2-项目部署" class="headerlink" title="2.项目部署"></a>2.项目部署</h2><ol><li>通过 git 下载源码</li><li>创建数据库 wetech_admin，数据库编码为UTF-8</li><li>依次执行 src/main/resources/schema.sql 和 dsrc/main/resources/data.sql 文件，初始化数据</li><li>修改 application-dev.properties 文件，更新 MySQL 账号和密码</li><li>启动服务，账号密码：admin/123456 或者 guest/123456</li></ol><p>这是官方给出的部署步骤，松哥再详细说两句。</p><p>首先项目下载下来后，包含两个目录：</p><p><img src="http://img.itboyhub.com/2020/07/20200924113320.png" alt></p><ul><li>wetech-admin-server：服务端项目，但是由于存在一个 parent，所以不能直接打开 wetech-admin-server，从它的上级目录处打开。</li><li>wetech-admin-ui：前端项目，需要首先执行 npm install 安装所需依赖，然后执行 npm run serve 启动前端项目。</li></ul><p>没搞过前后端分离的小伙伴注意，需要前后端同时启动才能访问。</p><p>松哥在启动前端时遇到一个问题，就是一直报这个错误：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot read property &apos;range&apos; of null</span><br></pre></td></tr></table></figure><p>检查过后，发现是 eslint 作怪，我就把 eslint 整个关闭了，然后就清净了。</p><p>因为我们这里主要是看 RBAC，前端不做过多涉及，项目跑起来就行。如果大家也遇到这个错误，可以按照松哥的办法试下。</p><p>另外需要注意，他这项目用了 Lombok，随意 idea 上需要安装一下 Lombok 插件。</p><h2 id="3-数据库分析"><a href="#3-数据库分析" class="headerlink" title="3.数据库分析"></a>3.数据库分析</h2><p>这个项目数据库只有三张表：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140357.png" alt></p><p>权限表、角色表以及用户表。</p><p>他没有设计关联表，而是将关联数据做成了一个字段。</p><p>比如角色表中有一个 permission_ids 字段，表示该角色对应的权限：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140639.png" alt></p><p>用户表中有一个 role_ids 字段，表示用户对应的角色：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140723.png" alt></p><p>这样设计的好处很明显，就是查询的时候非常方便，不用做一对多查询，SQL 好写并且执行效率高。</p><p>缺点就是数据更新不太方便，不过一般来说，权限系统数据更新频率较低，大部分都是查询，所以我觉得这样设计也能接受。</p><p>我们来看下这里的权限表：</p><p><img src="http://img.itboyhub.com/2020/07/20200924141311.png" alt></p><p>type 表示资源的类型，分为两种：菜单和按钮。</p><p>其中 1 表示菜单，2 表示按钮。如果是菜单，则需要有一个动态路由字符串，也就是 config 字段。该字段返回到前端之后，前端就会动态加载出对应的页面（这点和松哥 vhr （<a href="https://github.com/lenve/vhr）是一致的）。" target="_blank" rel="noopener">https://github.com/lenve/vhr）是一致的）。</a></p><p>角色表和用户表都比较简单，我就不再多说。</p><h2 id="4-代码分析"><a href="#4-代码分析" class="headerlink" title="4.代码分析"></a>4.代码分析</h2><p>普通的 CURD 代码我就不说了，和权限管理相关的代码在 tech.wetech.admin.shiro 包里边。登录在 LoginController 里边。</p><p>先来说这个登录，具体的操作是在 tech.wetech.admin.service.impl.UserServiceImpl#login 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> UserTokenDTO <span class="hljs-title">login</span><span class="hljs-params">(LoginDTO loginDTO)</span> </span>&#123;</span><br><span class="line">    User user = userMapper.selectByUsername(loginDTO.getUsername());</span><br><span class="line">    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonResultStatus.LOGIN_ERROR, <span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!passwordHelper.verifyPassword(user, loginDTO.getPassword())) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonResultStatus.LOGIN_ERROR, <span class="hljs-string">"密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserTokenDTO userInfoDTO = <span class="hljs-keyword">new</span> UserTokenDTO();</span><br><span class="line">    userInfoDTO.setUsername(user.getUsername());</span><br><span class="line">    userInfoDTO.setToken(JwtUtil.sign(user.getUsername(), String.valueOf(System.currentTimeMillis())));</span><br><span class="line">    <span class="hljs-keyword">return</span> userInfoDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是纯手工登录，登录成功后，生成一个 jwt 字符串返回给前端，以后前端每次请求，都需要携带上这个 jwt 字符串来。</p><p>tech.wetech.admin.shiro.JwtFilter 是专门处理认证请求的过滤器，所有需要认证的请求，都会经过该过滤器。这个过滤器所做的事情，就是从所有的请求头中提取出 Access-Token（就是登录成功后返回的那个 jwt 令牌），然后从令牌中解析出用户名，调用 JwtRealm 完成校验。</p><p>这是 JwtFilter：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Slf</span>4j</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AccessControlFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AUTHORIZATION_HEADER = <span class="hljs-string">"Access-Token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoginAttempt</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String authorization = req.getHeader(AUTHORIZATION_HEADER);</span><br><span class="line">        <span class="hljs-keyword">return</span> authorization != <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccessAllowed</span><span class="hljs-params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAccessDenied</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isLoginAttempt(request, response)) &#123;</span><br><span class="line">            <span class="hljs-comment">//生成jwt token</span></span><br><span class="line">            JwtToken token = <span class="hljs-keyword">new</span> JwtToken(req.getHeader(AUTHORIZATION_HEADER));</span><br><span class="line">            <span class="hljs-comment">//委托给Realm进行验证</span></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                getSubject(request, response).login(token);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onLoginFail(response);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 登录失败时默认返回401状态码</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginFail</span><span class="hljs-params">(ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        httpResponse.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        httpResponse.getWriter().write(JSONUtil.toJSONString(Result.failure(CommonResultStatus.LOGIN_ERROR)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtRealm 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Slf</span>4j</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        String username = principals.toString();</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        authorizationInfo.setRoles(userService.queryRoles(username));</span><br><span class="line">        authorizationInfo.setStringPermissions(userService.queryPermissions(username));</span><br><span class="line">        <span class="hljs-keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String credentials = (String) token.getCredentials();</span><br><span class="line">        String username = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> verify = JwtUtil.verify(credentials);</span><br><span class="line">            <span class="hljs-keyword">if</span> (!verify) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(<span class="hljs-string">"Token校验不正确"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            username = JwtUtil.getClaim(credentials, JwtUtil.ACCOUNT);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="hljs-string">"Token校验不正确："</span>, e);</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，不设置则使用默认的SimpleCredentialsMatcher</span></span><br><span class="line">        SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                username, <span class="hljs-comment">//用户名</span></span><br><span class="line">                credentials, <span class="hljs-comment">//凭证</span></span><br><span class="line">                getName()  <span class="hljs-comment">//realm name</span></span><br><span class="line">        );</span><br><span class="line">        <span class="hljs-keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认证逻辑松哥刚才已经说过了，就不再赘述。</p><p>授权逻辑就是根据用户名查询出用户角色，根据用户角色查询出用户权限，将角色和权限分别赋值给 SimpleAuthorizationInfo 对象即可。</p><p>最后在 ShiroConfig 中还有一些常规配置，我就不再多说。</p><p>权限的控制主要是在各个接口上添加 @RequiresPermissions 注解实现的。如 PermissionController、RoleController 以及 UserController。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>整体上来说，这个项目并没有太多难度。还是松哥一开始所说的，RBAC 只是一种权限设计模型，模型本身很好理解，涉及到的技术也都很简单。无论是 Shiro 还是 Spring Security，实现 RBAC 虽然有一些差别，但是用的都是最基本的技术点。</p><p>好啦，今天就和小伙伴们聊这么多，感兴趣的小伙伴可以看看哦～如果你有好的 RBAC 项目也可以留言告诉松哥，我抽空解析一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前两天写了一篇文章，和大家大概聊了聊 RBAC 权限管理系统：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>我又发现 Spring Security 中一个小秘密！</title>
    <link href="http://www.javaboy.org/2020/0923/spring-expressionurlauthorizationconfigurer-urlauthorizationconfigurer.html"/>
    <id>http://www.javaboy.org/2020/0923/spring-expressionurlauthorizationconfigurer-urlauthorizationconfigurer.html</id>
    <published>2020-09-23T01:56:29.000Z</published>
    <updated>2020-10-09T00:44:22.393Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，Spring Security 系列前前后后写了 60 多篇文章了，竟然漏掉了如此重要的一块。</p><a id="more"></a><p>平时在公司项目中，都是能用则用，先把需求整出来，有的时候也不去深究它的原理，这无形中就给自己挖了大坑。</p><p>松哥这次就是，不过也因此又发现了 Spring Security 的一个用法，今天就和小伙伴们分享下。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>事情是这样的，看过 vhr 项目（<a href="https://github.com/lenve/vhr）的小伙伴都知道" target="_blank" rel="noopener">https://github.com/lenve/vhr）的小伙伴都知道</a> vhr 里边有一个动态权限管理功能，实现的思路就是重写了 FilterInvocationSecurityMetadataSource 以及决策管理器 AccessDecisionManager，代码就类似下面这样（小伙伴们可以在 GitHub 上查看完整代码）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                    object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                    object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                    <span class="hljs-keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>昨天我想再写一个类似的功能，本想着很简单，三下五除二就搞定，大家看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                object.setAccessDecisionManager(accessDecisionManager());</span><br><span class="line">                <span class="hljs-keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf().disable();</span><br></pre></td></tr></table></figure><p>小伙伴们能看出这两段代码的差别吗？</p><p>写完之后，启动项目，一启动就报错了！</p><p><img src="http://img.itboyhub.com/2020/07/20200922092356.png" alt></p><p>我就有点懵。之前的 vhr 启动是没问题的，但是这次新的项目启动就有问题。</p><p>在 IDEA 中，通过 Ctrl+Shift+F 全局搜索，找到了异常抛出的位置：</p><p><img src="http://img.itboyhub.com/2020/07/20200922092547.png" alt></p><p>如果 requestMap 变量为空，就会抛出异常。requestMap 就是我们在 configure 方法中配置的请求和权限的映射，不过在上面的案例中，我是想像 vhr 那样做动态权限管理，所以请求和角色的映射关系我是保存在数据库中，没有必要在代码中配置。</p><p>但是根据异常提示，我就先随便加一个映射，果然启动就不报错了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                object.setAccessDecisionManager(accessDecisionManager());</span><br><span class="line">                <span class="hljs-keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf().disable();</span><br></pre></td></tr></table></figure><p>现在让我有两个郁闷的地方：</p><ol><li>vhr 为什么可以启动而不报错</li><li>这里代码中多出来的一行映射明显是累赘，最好能够去掉</li></ol><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>第一个问题很好办，仔细对比最开始贴出来的代码就能找到端倪，vhr 中的代码多了一个 permitAll 方法，这就是一个表达式，有了该方法，就意味着里边多了一个映射关系，<code>/login -&gt; permitAll</code>，这样 requestMap 就不会为空，所以启动时就不报错了。</p><p>按照这个思路，我去修改了自己的代码，去除冗余的映射，加上 permitAll，这次果然可以了。</p><p>问题虽然解决了，但是心里还是有点膈应。</p><p>为什么呢？因为用户-角色-资源的映射关系我都保存在数据库中了，权限数据库类似下面这样：</p><p><img src="http://img.itboyhub.com/2020/07/20200922094346.png" alt></p><p>既然所有的权限管理都保存在数据库中了，再在代码中配置似乎就不太合适！但是不配置，项目启动又会出错，看来还是得从源码入手。</p><p>于是松哥花了点时间，把这里涉及到的相关源码仔细梳理了一遍。</p><h2 id="3-源码梳理"><a href="#3-源码梳理" class="headerlink" title="3.源码梳理"></a>3.源码梳理</h2><p>首先大家知道，Spring Security 中的权限控制有两种不同的方式：</p><ol><li>通过 URL 请求地址进行控制。</li><li>通过方法进行控制。</li></ol><p>如果通过 URL 请求地址进行控制，负责控制类配置的是 AbstractInterceptUrlConfigurer，我们来看下它的子类：</p><p><img src="http://img.itboyhub.com/2020/07/AbstractInterceptUrlConfigurer.png" alt></p><p>可以看到它有两个子类：</p><ul><li>ExpressionUrlAuthorizationConfigurer</li><li>UrlAuthorizationConfigurer</li></ul><p>两个都可以处理基于 URL 请求地址的权限控制。不同的是，第一个 ExpressionUrlAuthorizationConfigurer<br>支持权限表达式，第二个不支持。</p><p>什么是权限表达式？其实大家都有用，只是可能没注意过这些概念，下图就是 Spring Security 中提供的内置通用权限表达式：</p><p><img src="http://img.itboyhub.com/2020/07/20200922102919.png" alt="图片源自网络"></p><p>ExpressionUrlAuthorizationConfigurer 支持权限表达式的原因是因为它使用的投票器是 WebExpressionVoter，这个投票器就是用来处理权限表达式的。</p><p>而 UrlAuthorizationConfigurer 不支持权限表达式，是因为它使用的投票器是 RoleVoter 和 AuthenticatedVoter，这两者可以用来处理角色或者权限，但是没法处理权限表达式。</p><p>关于投票器，小伙伴们可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">Spring Security 权限管理的投票器与表决机制</a>。</p><p>上面说的都是默认行为，我们也可以通过修改配置，让 UrlAuthorizationConfigurer 支持权限表达式，不过一般来说没必要这样做，如果需要支持权限表达式，直接用 ExpressionUrlAuthorizationConfigurer 即可。</p><p>当我们调用如下这行代码时：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br></pre></td></tr></table></figure><p>实际上就是通过 ExpressionUrlAuthorizationConfigurer 去配置基于 URL 请求地址的权限控制，所以它是支持权限表达式的。例如下面这段大家再熟悉不过的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).access(<span class="hljs-string">"hasRole('USER')"</span>)</span><br></pre></td></tr></table></figure><p>在 ExpressionUrlAuthorizationConfigurer 中创建 SecurityMetadataSource 时，就会检查映射关系，如果 requestMap 为空就会抛出异常：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function">ExpressionBasedFilterInvocationSecurityMetadataSource <span class="hljs-title">createMetadataSource</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">H http)</span> </span>&#123;</span><br><span class="line">LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = REGISTRY</span><br><span class="line">.createRequestMap();</span><br><span class="line"><span class="hljs-keyword">if</span> (requestMap.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"At least one mapping is required (i.e. authorizeRequests().anyRequest().authenticated())"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap,</span><br><span class="line">getExpressionHandler(http));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UrlAuthorizationConfigurer 中也有 createMetadataSource 方法，但是却是另外一套实现方案： </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function">FilterInvocationSecurityMetadataSource <span class="hljs-title">createMetadataSource</span><span class="hljs-params">(H http)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultFilterInvocationSecurityMetadataSource(</span><br><span class="line">REGISTRY.createRequestMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UrlAuthorizationConfigurer 并不会检查 requestMap 是否为空，但是它会在 createRequestMap 方法中检查一下映射关系是否完整，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(<span class="hljs-string">"/admin/**"</span>).access(<span class="hljs-string">"ROLE_ADMIN"</span>)</span><br><span class="line">.mvcMatchers(<span class="hljs-string">"/user/**"</span>).access(<span class="hljs-string">"ROLE_USER"</span>)</span><br><span class="line">.antMatchers(<span class="hljs-string">"/getinfo"</span>);</span><br></pre></td></tr></table></figure><p>最后的 /getinfo 没有指定需要的权限，这种就是不完整，就会抛出异常。</p><p>现在大家应该大致明白 ExpressionUrlAuthorizationConfigurer 和 UrlAuthorizationConfigurer 的区别了吧。</p><h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4.问题解决"></a>4.问题解决</h2><p>ExpressionUrlAuthorizationConfigurer 会要求至少配置一个映射关系，UrlAuthorizationConfigurer 则无此要求。</p><p>当我们想要动态配置权限拦截时，一般来说也不会使用权限表达式，数据库中保存的就是普通的权限或者角色，所以这个时候我们可以选择 UrlAuthorizationConfigurer 而不是 ExpressionUrlAuthorizationConfigurer。</p><p>反映到代码上，就是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);</span><br><span class="line">    http.apply(<span class="hljs-keyword">new</span> UrlAuthorizationConfigurer&lt;&gt;(applicationContext))</span><br><span class="line">            .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                    object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                    <span class="hljs-keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    http.formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来就更合理一些，不用额外配置一条映射关系。</p><p>今天这篇文章可能对没了解过动态权限控制的小伙伴来说略难，大家可以参考松哥的 vhr（<a href="https://github.com/lenve/vhr）项目去了解下动态权限控制。当然，也可以参考松哥的[Spring" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目去了解下动态权限控制。当然，也可以参考松哥的[Spring</a> Boot+Vue+微人事视频教程](<a href="https://mp.weixin.qq.com/s/EEmEL6tpuBT0qLfPwhj2OQ)，里边也有讲动态权限控制问题。" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EEmEL6tpuBT0qLfPwhj2OQ)，里边也有讲动态权限控制问题。</a></p><p>好啦，今天就和小伙伴们分享这么多，要不是这次遇到问题，我一直都懒得去研究 ExpressionUrlAuthorizationConfigurer 和 UrlAuthorizationConfigurer 有什么区别。感兴趣的小伙伴可以自己 DEBUG 验证下本文内容哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说来惭愧，Spring Security 系列前前后后写了 60 多篇文章了，竟然漏掉了如此重要的一块。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中最流行的权限管理模型！</title>
    <link href="http://www.javaboy.org/2020/0921/springsecurity-rbac.html"/>
    <id>http://www.javaboy.org/2020/0921/springsecurity-rbac.html</id>
    <published>2020-09-21T01:56:14.000Z</published>
    <updated>2020-10-09T00:45:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家说了 ACL，讲了理论，也给了一个完整的案例，相信小伙伴们对于 ACL 权限控制模型都已经比较了解了。</p><a id="more"></a><p>本文我要和大家聊一聊另外一个非常流行的权限管理模型，那就是 RBAC。</p><h2 id="1-RBAC-简介"><a href="#1-RBAC-简介" class="headerlink" title="1.RBAC 简介"></a>1.RBAC 简介</h2><p>RBAC（Role-based access control）是一种以角色为基础的访问控制（Role-based access control，RBAC），它是一种较新且广为使用的权限控制机制，这种机制不是直接给用户赋予权限，而是将权限赋予角色。</p><p>RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限关联、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。</p><h2 id="2-RBAC-的提出"><a href="#2-RBAC-的提出" class="headerlink" title="2.RBAC 的提出"></a>2.RBAC 的提出</h2><p>权限、角色这些东西，在早期 1970 年代的商业计算机程序中就可以找到相关的应用，但是早期的程序相对简单，而且并不存在一个明确的、通用的、公认的权限管理模型。</p><p>Ferraiolo 和 Kuhn 两位大佬于 1992 年提出了一种基于通用角色的访问控制模型（看来这个模型比松哥年龄还大），首次提出了 RBAC 权限模型用来代替传统的 MAC 和 DAC 两种权限控制方案，并且就 RBAC 中的相关概念给出了解释。</p><p>Ferraiolo，Cugini 和 Kuhn 于 1995 年扩展了 1992 年提出的权限模型。该模型的主要功能是所有访问都是通过角色进行的，而角色本质上是权限的集合，并且所有用户只能通过角色获得权限。在组织内，角色相对稳定，而用户和权限都很多，并且可能会迅速变化。因此，通过角色控制权限可以简化访问控制的管理和检查。</p><p>到了 1996 年，Sandhu，Coyne，Feinstein 和 Youman 正式提出了 RBAC 模型，该模型以模块化方式细化了 RBAC，并提出了基于该理论的 RBAC0-RBAC3 四种不同模型。</p><p>今天，大多数信息技术供应商已将 RBAC 纳入其产品线，除了常规的企业级应用，RBAC 也广泛应用在医疗、国防等领域。</p><p>目前网上关于 RBAC 理论性的东西松哥只找到英文的，感兴趣的小伙伴可以看下，地址是：</p><ul><li><a href="https://csrc.nist.gov/projects/Role-Based-Access-Control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/Role-Based-Access-Control</a></li></ul><p>如果小伙伴们有中文的资料链接，欢迎留言说明。</p><h2 id="3-RBAC-三原则"><a href="#3-RBAC-三原则" class="headerlink" title="3.RBAC 三原则"></a>3.RBAC 三原则</h2><ol><li>最小权限：给角色配置的权限是其完成任务所需要的最小权限集合。</li><li>责任分离：通过相互独立互斥的角色来共同完成任务。</li><li>数据抽象：通过权限的抽象来体现，RBAC 支持的数据抽象程度与 RBAC 的实现细节有关。</li></ol><h2 id="4-RBAC-模型分类"><a href="#4-RBAC-模型分类" class="headerlink" title="4.RBAC 模型分类"></a>4.RBAC 模型分类</h2><p>说到 RBAC，我们就得从它的模型分类开始看起。</p><h3 id="4-1-RBAC0"><a href="#4-1-RBAC0" class="headerlink" title="4.1 RBAC0"></a>4.1 RBAC0</h3><p>RBAC0 是最简单的用户、角色、权限模型。RBAC0 是 RBAC 权限模型中最核心的一部分，后面其他模型都是在此基础上建立。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112318.png" alt="图片源自网络"></p><p>在 RBAC0 中，一个用户可以具备多个角色，一个角色可以具备多个权限，最终用户所具备的权限是用户所具备的角色的权限并集。</p><h3 id="4-2-RBAC1"><a href="#4-2-RBAC1" class="headerlink" title="4.2 RBAC1"></a>4.2 RBAC1</h3><p>RBAC1 则是在 RABC0 的基础上引入了角色继承，让角色有了上下级关系。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112156.png" alt="图片源自网络"></p><p>在本系列前面的文章中，松哥也曾多次向大家介绍过 Spring Security 中的角色继承。</p><h3 id="4-3-RBAC2"><a href="#4-3-RBAC2" class="headerlink" title="4.3 RBAC2"></a>4.3 RBAC2</h3><p>RBAC2 也是在 RBAC0 的基础上进行扩展，引入了静态职责分离和动态职责分离。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112222.png" alt="图片源自网络"></p><p>要理解职责分离，我们得先明白角色互斥。</p><p>在实际项目中，有一些角色是互斥的，对立的，例如财务这个角色一般是不能和其他角色兼任的，否则自己报账自己审批，岂不是爽歪歪！</p><p>通过职责分离可以解决这个问题：</p><p><strong>静态职责分离</strong></p><p>在设置阶段就做好了限制。比如同一用户不能授予互斥的角色，用户只能有有限个角色，用户获得高级权限之前要有低级权限等等。</p><p><strong>动态职责分离</strong></p><p>在运行阶段进行限制。比如运行时同一用户下5个角色中只能同时有2个角色激活等等。</p><h3 id="4-4-RBAC3"><a href="#4-4-RBAC3" class="headerlink" title="4.4 RBAC3"></a>4.4 RBAC3</h3><p>将 RBAC1 和 RBAC2 结合起来，就形成了 RBAC3。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112247.png" alt="图片源自网络"></p><h2 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h2><p>我们日常见到的很多权限模型都是在 RBAC 的基础上扩展出来的。</p><p>例如在有的系统中我们可以见到用户组的概念，就是将用户分组，用户同时具备自身的角色以及分组的角色。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天就和小伙伴们简单介绍下 RBAC 权限模型。其实 RBAC 只要把权限模型搞清楚了，技术上来说，基本上没啥问题。如果你把松哥 vhr 中涉及到的 Spring Security 技术搞懂了，结合今天的文章，用 Spring Security 实现 RBAC 完全不成问题～当然，我后面也抽空给大家整一个 RBAC 的 DEMO。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家说了 ACL，讲了理论，也给了一个完整的案例，相信小伙伴们对于 ACL 权限控制模型都已经比较了解了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>一个案例演示 Spring Security 中粒度超细的权限控制！</title>
    <link href="http://www.javaboy.org/2020/0917/springsecurity-acl-demo.html"/>
    <id>http://www.javaboy.org/2020/0917/springsecurity-acl-demo.html</id>
    <published>2020-09-17T01:55:57.000Z</published>
    <updated>2020-10-09T00:45:16.978Z</updated>
    
    <content type="html"><![CDATA[<p>想要细化权限控制粒度，办法很多。本文接着上文（<a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a>），通过一个具体的案例来向小伙伴们展示基于 Acl 的权限控制。其他的权限控制模型后面也会一一介绍。</p><a id="more"></a><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先创建一个 Spring Boot 项目，由于我们这里涉及到数据库操作，所以除了 Spring Security 依赖之外，还需要加入数据库驱动以及 MyBatis 依赖。</p><p>由于没有 acl 相关的 starter，所以需要我们手动添加 acl 依赖，另外 acl 还依赖于 ehcache 缓存，所以还需要加上缓存依赖。</p><p>最终的 pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-acl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目创建成功之后，我们在 acl 的 jar 包中可以找到数据库脚本文件：</p><p><img src="http://img.itboyhub.com/2020/07/20200913155708.png" alt></p><p>根据自己的数据库选择合适的脚本执行，执行后一共创建了四张表，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200913173811.png" alt></p><p>表的含义我就不做过多解释了，不清楚的小伙伴可以参考上篇文章：<a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a></p><p>最后，再在项目的 application.properties 文件中配置数据库信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///acls?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>至此，准备工作就算完成了。接下来我们来看配置。</p><h2 id="2-ACL-配置"><a href="#2-ACL-配置" class="headerlink" title="2.ACL 配置"></a>2.ACL 配置</h2><p>这块配置代码量比较大，我先把代码摆上来，我们再逐个分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>, securedEnabled = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclAuthorizationStrategy <span class="hljs-title">aclAuthorizationStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AclAuthorizationStrategyImpl(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_ADMIN"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> PermissionGrantingStrategy <span class="hljs-title">permissionGrantingStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPermissionGrantingStrategy(<span class="hljs-keyword">new</span> ConsoleAuditLogger());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclCache <span class="hljs-title">aclCache</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EhCacheBasedAclCache(aclEhCacheFactoryBean().getObject(), permissionGrantingStrategy(), aclAuthorizationStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> EhCacheFactoryBean <span class="hljs-title">aclEhCacheFactoryBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        EhCacheFactoryBean ehCacheFactoryBean = <span class="hljs-keyword">new</span> EhCacheFactoryBean();</span><br><span class="line">        ehCacheFactoryBean.setCacheManager(aclCacheManager().getObject());</span><br><span class="line">        ehCacheFactoryBean.setCacheName(<span class="hljs-string">"aclCache"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ehCacheFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> EhCacheManagerFactoryBean <span class="hljs-title">aclCacheManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> LookupStrategy <span class="hljs-title">lookupStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicLookupStrategy(dataSource, aclCache(), aclAuthorizationStrategy(), <span class="hljs-keyword">new</span> ConsoleAuditLogger()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclService <span class="hljs-title">aclService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcMutableAclService(dataSource, lookupStrategy(), aclCache());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PermissionEvaluator <span class="hljs-title">permissionEvaluator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        AclPermissionEvaluator permissionEvaluator = <span class="hljs-keyword">new</span> AclPermissionEvaluator(aclService());</span><br><span class="line">        <span class="hljs-keyword">return</span> permissionEvaluator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@EnableGlobalMethodSecurity 注解的配置表示开启项目中 @PreAuthorize、@PostAuthorize 以及 @Secured 注解的使用，一会我们要通过这些注解配置权限。</li><li>由于引入了数据库的一整套东西，并且配置了数据库连接信息，所以这里可以注入 DataSource 实例以备后续使用。</li><li>AclAuthorizationStrategy 实例用来判断当前的认证主体是否有修改 Acl 的权限，准确来说是三种权限：修改 Acl 的 owner；修改 Acl 的审计信息以及修改 ACE 本身。这个接口只有一个实现类就是 AclAuthorizationStrategyImpl，我们在创建实例时，可以传入三个参数，分别对应了这三种权限，也可以传入一个参数，表示这一个角色可以干三件事。</li><li>PermissionGrantingStrategy 接口提供了一个 isGranted 方法，这个方法就是最终真正进行权限比对的方法，该接口只有一个实现类 DefaultPermissionGrantingStrategy，直接 new 就行了。</li><li>在 ACL 体系中，由于权限比对总是要查询数据库，造成了性能问题，因此引入了 Ehcache 做缓存。AclCache 共有两个实现类：SpringCacheBasedAclCache 和 EhCacheBasedAclCache。我们前面已经引入了 ehcache 实例，所以这里配置 EhCacheBasedAclCache 实例即可。</li><li>LookupStrategy 可以通过 ObjectIdentity 解析出对应的 Acl。LookupStrategy 只有一个实现类就是 BasicLookupStrategy，直接 new 即可。</li><li>AclService 这个我们在上文已经介绍过了，这里不再赘述。</li><li>PermissionEvaluator 是为表达式 hasPermission 提供支持的。由于本案例后面使用类似于 <code>@PreAuthorize(&quot;hasPermission(#noticeMessage, &#39;WRITE&#39;)&quot;)</code> 这样的注解进行权限控制，因此之类需要配置一个 PermissionEvaluator 实例。</li></ol><p>至此，这里的配置类就和大家介绍完了。</p><h2 id="3-情节设定"><a href="#3-情节设定" class="headerlink" title="3.情节设定"></a>3.情节设定</h2><p>假设我现在有一个通知消息类 NoticeMessage，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"NoticeMessage&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"id="</span> + id +</span><br><span class="line">                <span class="hljs-string">", content='"</span> + content + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据该类创建了数据表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`system_message`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`content`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>那么接下来的权限控制就是针对这个 NoticeMessage 的。</p><p>创建 NoticeMessageMapper，并添加几个测试方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoticeMessageMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;NoticeMessage&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function">NoticeMessage <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(NoticeMessage noticeMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(NoticeMessage noticeMessage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoticeMessageMapper.xml 内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="hljs-meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="hljs-meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"org.javaboy.acls.mapper.NoticeMessageMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        select * from system_message;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        select * from system_message where id=#&#123;id&#125;;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"save"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        insert into system_message (id,content) values (#&#123;id&#125;,#&#123;content&#125;);</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"update"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        update system_message set content = #&#123;content&#125; where id=#&#123;id&#125;;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些应该都好理解，没啥好说的。</p><p>接下来创建 NoticeMessageService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeMessageService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    NoticeMessageMapper noticeMessageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostFilter</span>(<span class="hljs-string">"hasPermission(filterObject, 'READ')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;NoticeMessage&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        List&lt;NoticeMessage&gt; all = noticeMessageMapper.findAll();</span><br><span class="line">        <span class="hljs-keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostAuthorize</span>(<span class="hljs-string">"hasPermission(returnObject, 'READ')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> NoticeMessage <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> noticeMessageMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission(#noticeMessage, 'CREATE')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> NoticeMessage <span class="hljs-title">save</span><span class="hljs-params">(NoticeMessage noticeMessage)</span> </span>&#123;</span><br><span class="line">        noticeMessageMapper.save(noticeMessage);</span><br><span class="line">        <span class="hljs-keyword">return</span> noticeMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission(#noticeMessage, 'WRITE')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(NoticeMessage noticeMessage)</span> </span>&#123;</span><br><span class="line">        noticeMessageMapper.update(noticeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到了两个新注解，稍微说下：</p><ul><li>@PostFilter：在执行方法后过滤返回的集合或数组（筛选出当前用户具有 READ 权限的数据），returnObject 就表示方法的返回值。有一个和它对应的注解 @PreFilter，这个注解允许方法调用，但必须在进入方法之前对参数进行过滤。</li><li>@PostAuthorize：允许方法调用，但是如果表达式计算结果为false，将抛出一个安全性异常，<code>#noticeMessage</code> 对应了方法的参数。</li><li>@PreAuthorize：在方法调用之前，基于表达式的计算结果来限制对方法的访问。</li></ul><p>明白了注解的含义，那么上面的方法应该就不用多做解释了吧。</p><p>配置完成，接下来我们进行测试。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>为了方便测试，我们首先准备几条测试数据，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`acl_class`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`class`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-string">'org.javaboy.acls.model.NoticeMessage'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`acl_sid`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`principal`</span>, <span class="hljs-string">`sid`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'hr'</span>),</span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'manager'</span>),</span><br><span class="line">(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-string">'ROLE_EDITOR'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`system_message`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`content`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-string">'111'</span>),</span><br><span class="line">(<span class="hljs-number">2</span>,<span class="hljs-string">'222'</span>),</span><br><span class="line">(<span class="hljs-number">3</span>,<span class="hljs-string">'333'</span>);</span><br></pre></td></tr></table></figure><p>首先添加了 acl_class，然后添加了三个 Sid，两个是用户，一个是角色，最后添加了三个 NoticeMessage 实例。</p><p>目前没有任何用户/角色能够访问到 system_message 中的三条数据。例如执行如下代码获取不到任何数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(roles = <span class="hljs-string">"EDITOR"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;NoticeMessage&gt; all = noticeMessageService.findAll();</span><br><span class="line">    System.out.println(<span class="hljs-string">"all = "</span> + all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@WithMockUser(roles = “EDITOR”) 表示使用 EDITOR 角色访问。松哥这里是为了方便。小伙伴们也可以自己给 Spring Security 配置用户，设置相关接口，然后 Controller 中添加接口进行测试，我这里就不那么麻烦了。</p></blockquote><p>现在我们对其进行配置。</p><p>首先我想设置让 hr 这个用户可以读取 system_message 表中 id 为 1 的记录，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">NoticeMessageService noticeMessageService;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JdbcMutableAclService jdbcMutableAclService;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">1</span>);</span><br><span class="line">    Permission p = BasePermission.READ;</span><br><span class="line">    MutableAcl acl = jdbcMutableAclService.createAcl(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"hr"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置了 mock user 是 javaboy，也就是这个 acl 创建好之后，它的 owner 是 javaboy，但是我们前面预设数据中 Sid 没有 javaboy，所以会自动向 acl_sid 表中添加一条记录，值为 javaboy。</p><p>在这个过程中，会分别向 acl_entry、acl_object_identity 以及 acl_sid 三张表中添加记录，因此需要添加事务，同时因为我们是在单元测试中执行，为了确保能够看到数据库中数据的变化，所以需要添加 @Rollback(value = false) 注解让事务不要自动回滚。</p><p>在方法内部，首先分别创建 ObjectIdentity 和 Permission 对象，然后创建一个 acl 对象出来，这个过程中会将 javaboy 添加到 acl_sid 表中。</p><p>接下来调用 acl_insertAce 方法，将 ace 存入 acl 中，最后调用 updateAcl 方法去更新 acl 对象即可。</p><p>配置完成后，执行该方法，执行完成后，数据库中就会有相应的记录了。</p><p>接下来，使用 hr 这个用户就可以读取到 id 为 1 的记录了。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"hr"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;NoticeMessage&gt; all = noticeMessageService.findAll();</span><br><span class="line">    assertNotNull(all);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, all.size());</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, all.get(<span class="hljs-number">0</span>).getId());</span><br><span class="line">    NoticeMessage byId = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(byId);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, byId.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>松哥这里用了两个方法来和大家演示。首先我们调用了 findAll，这个方法会查询出所有的数据，然后返回结果会被自动过滤，只剩下 hr 用户具有读取权限的数据，即 id 为 1 的数据；另一个调用的就是 findById 方法，传入参数为 1，这个好理解。</p><p>如果此时想利用 hr 这个用户修改对象，则是不可以的。我们可以继续使用上面的代码，让 hr 这个用户可以修改 id 为 1 的记录，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">1</span>);</span><br><span class="line">    Permission p = BasePermission.WRITE;</span><br><span class="line">    MutableAcl acl = (MutableAcl) jdbcMutableAclService.readAclById(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"hr"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里权限改为 WRITE 权限。由于 acl 中已经存在这个 ObjectIdentity 了，所以这里通过 readAclById 方法直接读取已有的 acl 即可。方法执行完毕后，我们再进行 hr 用户写权限的测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"hr"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    NoticeMessage msg = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(msg);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, msg.getId());</span><br><span class="line">    msg.setContent(<span class="hljs-string">"javaboy-1111"</span>);</span><br><span class="line">    noticeMessageService.update(msg);</span><br><span class="line">    msg = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(msg);</span><br><span class="line">    assertEquals(<span class="hljs-string">"javaboy-1111"</span>, msg.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，hr 就可以使用 WRITE 权限去修改对象了。</p><p>假设我现在想让 manager 这个用户去创建一个 id 为 99 的 NoticeMessage，默认情况下，manager 是没有这个权限的。我们现在可以给他赋权：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">99</span>);</span><br><span class="line">    Permission p = BasePermission.CREATE;</span><br><span class="line">    MutableAcl acl = jdbcMutableAclService.createAcl(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"manager"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的权限是 CREATE。</p><p>接下来使用 manager 用户就可以添加数据了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"manager"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    NoticeMessage noticeMessage = <span class="hljs-keyword">new</span> NoticeMessage();</span><br><span class="line">    noticeMessage.setId(<span class="hljs-number">99</span>);</span><br><span class="line">    noticeMessage.setContent(<span class="hljs-string">"999"</span>);</span><br><span class="line">    noticeMessageService.save(noticeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以添加成功了。添加成功后，manager 这个用户没有读 id 为 99 的数据的权限，可以参考前面案例自行添加。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>从上面的案例中大家可以看到，ACL 权限模型中的权限控制真的是非常非常细，细到每一个对象的 CURD。</p><p>优点就不用说了，够细！同时将业务和权限成功分离。缺点也很明显，权限数据量庞大，扩展性弱。</p><p>最后，公号后台回复 acl 获取本文案例下载链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要细化权限控制粒度，办法很多。本文接着上文（&lt;a href=&quot;https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Security 中如何细化权限粒度？&lt;/a&gt;），通过一个具体的案例来向小伙伴们展示基于 Acl 的权限控制。其他的权限控制模型后面也会一一介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中如何细化权限粒度？</title>
    <link href="http://www.javaboy.org/2020/0916/springsecurity-acl.html"/>
    <id>http://www.javaboy.org/2020/0916/springsecurity-acl.html</id>
    <published>2020-09-16T01:55:35.000Z</published>
    <updated>2020-10-09T00:45:08.213Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴表示微人事(<a href="https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了" target="_blank" rel="noopener">https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了</a> vhr 中权限管理的原理，在此基础上就可以去细化权限管理粒度，细化过程和还是用的 vhr 中用的技术，只不过设计层面重新规划而已。</p><a id="more"></a><p>当然今天我想说的并不是这个话题，主要是想和大家聊一聊 Spring Security 中权限管理粒度细化的问题。因为这个问题会涉及到不同的权限管理模型，今天和小伙伴们聊一聊～</p><h2 id="1-权限管理模型"><a href="#1-权限管理模型" class="headerlink" title="1.权限管理模型"></a>1.权限管理模型</h2><p>要想将细化权限粒度，我们不可避免会涉及到一些权限模型，例如 ACL、RBAC、DAC、MAC 以及 ABAC、PBAC 等。</p><p>在这些众多的权限模型中，我们使用较多的是 RBAC，ACL 也有一些项目在使用，另外几种则使用相对较少。因此松哥这里重点和大家介绍 ACL 和 RBAC。</p><h3 id="1-1-ACL"><a href="#1-1-ACL" class="headerlink" title="1.1 ACL"></a>1.1 ACL</h3><p>ACL 是一种比较古老的权限控制模型。英文全称是 Access Control List，中文称作访问控制列表，这是一种面向资源的访问控制模型，所有的权限配置都是针对资源的。</p><p>它的原理是这样：</p><p>对于系统中的每一个资源，都会配置一个访问列表，这个列表中记录了用户/角色对于资源的 CURD 权限，当系统需要访问这些资源时，会首先检查列表中是否存在当前用户的访问权限，进而确定当前用户是否可以执行相应的操作。</p><p>ACL 的使用非常简单，搞明白它的原理自己分分钟就能实现。但是 ACL 有一个明显的缺点，就是需要维护大量的访问权限列表。大量的访问控制列表带来的问题就是性能下降以及维护复杂。</p><h3 id="1-2-RBAC"><a href="#1-2-RBAC" class="headerlink" title="1.2 RBAC"></a>1.2 RBAC</h3><p>RBAC（Role-based access control）是一种以角色为基础的访问控制，也是目前使用较多的一种权限模型，它有多种不同的变体，松哥后面会专门写一篇文章来介绍 RBAC，这里仅简单科普下。</p><p>RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限管理、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。</p><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><p>下面这些使用常见较少，小伙伴们做一个了解即可，感兴趣的小伙伴也可以自行研究下。</p><ul><li><strong>ABAC</strong>：这是一种基于属性的访问控制。</li><li><strong>PBAC</strong>：这是一种基于策略的访问控制。</li><li><strong>DAC</strong>：除了权限控制，主体也可以将权限授予其他主体。</li><li><strong>MAC</strong>：资源可以被哪些类别的主体进行哪些操作，主体可以对哪些等级的资源进行哪些操作，这两个条件同时满足时，允许访问。</li></ul><h2 id="2-ACL"><a href="#2-ACL" class="headerlink" title="2.ACL"></a>2.ACL</h2><p>接下来松哥要和大家仔细介绍一下 ACL 这种权限模型，RBAC 我后面专门写文章介绍，本文先不做讨论。</p><p>Acl 的全称是 Access Control List，也就是我们所说的访问控制列表，是用以控制对象的访问权限的。Acl 的一个核心思路就是将某个对象的某种权限授予某个用户或某种角色，它们之间的关系是多对多，即一个用户/角色可以具备某个对象的多种权限，某个对象的权限也可以被多个用户/角色所持有。</p><p>举个简单例子：</p><p>现在有一个 User 对象，针对该对象有查询、修改、删除等权限，可以将这些权限赋值给某一个用户，也可以将这些权限赋值给某一个角色，当用户具备这些角色时就具有执行相应操作的权限。</p><p>从这个角度看，Acl 是一种粒度非常细的权限控制，它就是专门控制某一个对象的操作权限。所有的这些权限都记录在数据库中，这带来了另外一个问题就是需要维护的权限数据量非常庞大，不利于后期扩展。当然，对于一个简单的系统，使用 Acl 还是可以的，没有任何问题。</p><h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><p>接下来我们来看看 Acl 中一些核心概念。</p><p><strong>Sid</strong></p><p>Sid 代表了用户和角色，它有两种：GrantedAuthoritySid 和 PrincipalSid，前者代表角色，后者代表用户。在 Spring Security 中，用户和角色信息都是保存在 Authentication 对象中的，即 Sid 是从 Authentication 对象中提取出来的，提取出来的值是 GrantedAuthoritySid+PrincipalSid，而不是其中某一项，具体的提取方法是 SidRetrievalStrategyImpl#getSids，相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sid&gt; <span class="hljs-title">getSids</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = roleHierarchy</span><br><span class="line">.getReachableGrantedAuthorities(authentication.getAuthorities());</span><br><span class="line">List&lt;Sid&gt; sids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(authorities.size() + <span class="hljs-number">1</span>);</span><br><span class="line">sids.add(<span class="hljs-keyword">new</span> PrincipalSid(authentication));</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">sids.add(<span class="hljs-keyword">new</span> GrantedAuthoritySid(authority));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> sids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Sid 大家可以简单理解为当前用户的权限（这个说法不是很准确，可以近似理解）。</p><p><strong>ObjectIdentity</strong></p><p>ObjectIdentity 是一个域对象，这是官方的说法，有点拗口。实际上这就是你要操作的对象。</p><p>例如我有一个 User 对象，如果直接去记录能够对 User 对象执行哪些操作，这就会导致高耦和。所以我们需要对其解耦，将所有需要操作的对象通过 ObjectIdentity 描述出来，这样就能确保权限系统不和具体的业务绑定。</p><p>ObjectIdentity 中有两个关键方法，getType 和 getIdentifier。一般来说，getType 方法返回真实对象类的全路径，例如 <code>org.javaboy.acl.model.User</code>，getIdentifier 方法则返回真实对象的 id，通过这两个方法，就能够锁定一个对象。</p><p><strong>Acl</strong></p><p>看名字就知道，这算是整个系统的核心调度部分。</p><p>一个 Acl 对象会关联一个 ObjectIdentity，一个 Acl 对象还拥有一个 Sid，这个 Sid 表示这个 Acl 是属于谁的？属于谁，谁就可以修改甚至删除这个 Acl 对象。</p><p><strong>AccessControlEntry</strong></p><p>AccessControlEntry 简写为 ACE，一个 AccessControlEntry 对象代表一条权限记录。每一个 AccessControlEntry 都对应了一个 Acl，一个 Acl 对象对应多个 AccessControlEntry，有了这层对应关系，相当于就知道这个权限操作的是哪个对象。</p><p>然后 AccessControlEntry 中还包含一个 Sid 和一个 Permission 对象，表示某个 Sid 具备某种权限。</p><p>可以看到，Acl+ACE，就描述出来了某个 Sid 可以具备某个 ObjectIdentity 的某种 Permission。</p><p><strong>Permission</strong></p><p>这个就是具体的权限对象。似乎是受 Linux 影响，它使用了权限掩码，最多支持 2<sup>32</sup>-1 种权限。</p><p>Spring Security 种默认定义了五种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePermission</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPermission</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission READ = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-string">'R'</span>); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission WRITE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-string">'W'</span>); <span class="hljs-comment">// 2</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission CREATE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>, <span class="hljs-string">'C'</span>); <span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission DELETE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>, <span class="hljs-string">'D'</span>); <span class="hljs-comment">// 8</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission ADMINISTRATION = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>, <span class="hljs-string">'A'</span>); <span class="hljs-comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BasePermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BasePermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">char</span> code)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(mask, code);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AclService</strong></p><p>AclService 接口中主要定义了一些解析 Acl 对象的方法，通过 ObjectIdentity 对象解析出其对应的 Acl。</p><p>AclService 主要有两类实现接口：</p><ul><li>JdbcAclService</li><li>JdbcMutableAclService</li></ul><p>前者主要是针对 Acl 的查询操作，后者支持 Acl 的添加、更新以及删除等操作。我们常用的是 JdbcMutableAclService。</p><p>至此，Acl 中一些核心概念就和小伙伴们介绍完了。</p><h3 id="2-2-Acl-数据表"><a href="#2-2-Acl-数据表" class="headerlink" title="2.2 Acl 数据表"></a>2.2 Acl 数据表</h3><p>上面提到的对象数据，都需要对应的数据表来维护，在 spring-security-acl 依赖中，为这些数据表都提供了脚本。</p><p><img src="http://img.itboyhub.com/2020/07/20200913155708.png" alt></p><p>可以看到，针对不同类型的数据库，都有对应的脚本。</p><p>这里主要涉及到四张表，接下来松哥以 MySQL 脚本为例，来分别介绍每张表的作用及其字段的含义。</p><p><strong>acl_class</strong></p><p>acl_class 是用来保存对象类型的全路径，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200913160034.png" alt></p><p>这里的 id 自增长，class 中保存的是相应对象的全路径名。</p><p><strong>acl_sid</strong></p><p>acl_sid 表用来保存 Sid 的。</p><p><img src="http://img.itboyhub.com/2020/07/20200913160149.png" alt></p><p>根据前面的介绍，存在两种类型的 Sid，GrantedAuthoritySid 和 PrincipalSid。所以这里的 principal 字段表示该 Sid 是哪种类型的。</p><p><strong>acl_object_identity</strong></p><p>acl_object_identity 用来保存需要进行访问控制的对象信息。</p><p><img src="http://img.itboyhub.com/2020/07/20200913160557.png" alt></p><ul><li>object_id_class：关联 acl_class.id。</li><li>object_id_identity：需要控制的对象的 id。</li><li>parent_object：父对象 ID，关联一条 acl_object_identity 记录。</li><li>owner_sid：这个 acl 记录拥有者的 sid。</li><li>entries_inheriting：是否需要继承父对象的权限。</li></ul><p>简单来说，这个表中的 object_id_class 和 object_id_identity 字段锁定了你要进行权限控制的对象，具体如何控制呢？则要看 acl_entry 中的关联关系了。</p><p><strong>acl_entry</strong></p><p>这个表单纯看数据，一堆数字。</p><p><img src="http://img.itboyhub.com/2020/07/20200913162338.png" alt></p><p>松哥来捋一下，大家就懂了。</p><ul><li>acl_object_identity：关联 acl_object_identity.id。</li><li>ace_order：权限顺序。acl_object_identity 和 ace_order 的组合要唯一。</li><li>sid：关联 acl_sid.id。这条权限记录关联哪个用户/角色。</li><li>mask：权限掩码。</li><li>granting：表示当前记录是否生效。</li><li>audit_success/audit_failure：审计信息。</li></ul><p>简单来说，acl_entry 中的一条记录，关联了一个要操作的对象（acl_object_identity 和 ace_order 字段），关联了 Sid（sid 字段），也描述了权限（mask），将权限涉及到的东西都在该字段中整合起来了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就本文和小伙伴们科普一下 ACL 的概念，下篇文章松哥通过一个完整的案例来和小伙伴们演示具体用法～</p><p>参考资料：</p><ol><li><a href="https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component" target="_blank" rel="noopener">https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component</a></li><li><a href="https://www.iteye.com/blog/elim-2269021" target="_blank" rel="noopener">https://www.iteye.com/blog/elim-2269021</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴表示微人事(&lt;a href=&quot;https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了&lt;/a&gt; vhr 中权限管理的原理，在此基础上就可以去细化权限管理粒度，细化过程和还是用的 vhr 中用的技术，只不过设计层面重新规划而已。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</title>
    <link href="http://www.javaboy.org/2020/0914/springsecurity-hasrole-hasauthority.html"/>
    <id>http://www.javaboy.org/2020/0914/springsecurity-hasrole-hasauthority.html</id>
    <published>2020-09-14T01:55:19.000Z</published>
    <updated>2020-10-09T00:45:00.824Z</updated>
    
    <content type="html"><![CDATA[<p>我相信很多小伙伴在初次接触 Spring Security 时，一定会被这个问题所困扰，例如如下两段配置：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasAuthority(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasAuthority(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>那么这两种配置有什么区别呢？</p><p>今天我们就来和大家聊一聊这个问题。</p><h2 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h2><p>单纯从源码上来分析，你会发现这两个东西似乎一样，先来看 hasAuthority。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ExpressionInterceptUrlRegistry <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> access(ExpressionUrlAuthorizationConfigurer.hasAuthority(authority));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"hasAuthority('"</span> + authority + <span class="hljs-string">"')"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了 access 方法，传入了权限表达式 hasAuthority(‘xxx’)。</p><p>再看 hasRole：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ExpressionInterceptUrlRegistry <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> access(ExpressionUrlAuthorizationConfigurer.hasRole(role));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line">Assert.notNull(role, <span class="hljs-string">"role cannot be null"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (role.startsWith(<span class="hljs-string">"ROLE_"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"role should not start with 'ROLE_' since it is automatically inserted. Got '"</span></span><br><span class="line">+ role + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"hasRole('ROLE_"</span> + role + <span class="hljs-string">"')"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，hasRole 的处理逻辑和 hasAuthority 似乎一模一样，不同的是，hasRole 这里会自动给传入的字符串加上 <code>ROLE_</code> 前缀，所以在数据库中的权限字符串需要加上 <code>ROLE_</code> 前缀。即数据库中存储的用户角色如果是 <code>ROLE_admin</code>，这里就是 admin。</p><p>我们在调用 <code>hasAuthority</code> 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，可以不加 <code>ROLE_</code> 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin。</p><p><strong>也就是说，使用 <code>hasAuthority</code> 更具有一致性，你不用考虑要不要加 <code>ROLE_</code> 前缀，数据库什么样这里就是什么样！而 <code>hasRole</code> 则不同，代码里如果写的是 <code>admin</code>，框架会自动加上 <code>ROLE_</code> 前缀，所以数据库就必须是 <code>ROLE_admin</code>。</strong></p><p>看起来 hasAuthority 和 hasRole 的区别似乎仅仅在于有没有 <code>ROLE_</code> 前缀。</p><p>在最终的权限比对中，更是过分，hasAuthority 和 hasRole 居然最终都是调用了 hasAnyAuthorityName 方法（SecurityExpressionRoot 类）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthority(authority);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyAuthority</span><span class="hljs-params">(String... authorities)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthorityName(<span class="hljs-keyword">null</span>, authorities);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyRole(role);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyRole</span><span class="hljs-params">(String... roles)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthorityName(defaultRolePrefix, roles);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyAuthorityName</span><span class="hljs-params">(String prefix, String... roles)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; roleSet = getAuthoritySet();</span><br><span class="line"><span class="hljs-keyword">for</span> (String role : roles) &#123;</span><br><span class="line">String defaultedRole = getRoleWithDefaultPrefix(prefix, role);</span><br><span class="line"><span class="hljs-keyword">if</span> (roleSet.contains(defaultedRole)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasAnyRole 在调用 hasAnyAuthorityName 方法时设置了 <code>ROLE_</code> 前缀，hasAnyAuthority 在调用 hasAnyAuthorityName 方法时没有设置前缀。</p><p>所以我们单纯从源码角度来看，<code>hasRole</code> 和 <code>hasAuthority</code> 这两个功能似乎一模一样，除了前缀之外就没什么区别了。</p><p>那么 Spring Security 设计者为什么要搞两个看起来一模一样的东西呢？</p><h2 id="2-设计理念"><a href="#2-设计理念" class="headerlink" title="2.设计理念"></a>2.设计理念</h2><p>从设计上来说，这是两个不同的东西。同时提供 role 和 authority 就是为了方便开发者从两个不同的维度去设计权限，所以并不冲突。</p><p>authority 描述的的是一个具体的权限，例如针对某一项数据的查询或者删除权限，它是一个 permission，例如 read_employee、delete_employee、update_employee 之类的，这些都是具体的权限，相信大家都能理解。</p><p>role 则是一个 permission 的集合，它的命名约定就是以 <code>ROLE_</code> 开始，例如我们定义的 ROLE 是 <code>ROLE_ADMIN</code>、<code>ROLE_USER</code> 等等。我们在 Spring Security 中的很多地方都能看到对 Role 的特殊处理，例如上篇文章我们所讲的<a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">投票器和决策器中</a>，RoleVoter 在处理 Role 时会自动添加 <code>ROLE_</code> 前缀。</p><p>在项目中，我们可以将用户和角色关联，角色和权限关联，权限和资源关联。</p><p>反映到代码上，就是下面这样：</p><p>假设用 Spring Security 提供的 SimpleGrantedAuthority 的代表 authority，然后我们自定义一个 Role，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GrantedAuthority</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;SimpleGrantedAuthority&gt; allowedOperations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SimpleGrantedAuthority&gt; <span class="hljs-title">getAllowedOperations</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> allowedOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAllowedOperations</span><span class="hljs-params">(List&lt;SimpleGrantedAuthority&gt; allowedOperations)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.allowedOperations = allowedOperations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 Role 就是某些 authority 的集合，然后在 User 中定义 roles 集合。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            authorities.addAll(role.getAllowedOperations());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> authorities.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getAuthorities 方法中，加载 roles 中的权限去重后再返回即可。</p><p>通过这个例子大家应该就能搞明白 Role 和 Authority 了。</p><p>松哥在 Spring Security 的 issue 上也看到了一个类似的问题：<a href="https://github.com/spring-projects/spring-security/issues/4912" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security/issues/4912</a></p><p>从作者对这个问题的回复中，也能看到一些端倪：</p><ol><li>作者承认了目前加 <code>ROLE_</code> 前缀的方式一定程度上给开发者带来了困惑，但这是一个历史积累问题。</li><li>作者说如果不喜欢 <code>ROLE_</code>，那么可以直接使用 <code>hasAuthority</code> 代替 <code>hasRole</code>，言下之意，就是这两个功能是一样的。</li><li>作者还说了一些关于权限问题的看法，权限是典型的对对象的控制，但是 Spring Security 开发者不能向 Spring Security 用户添加所有权限，因为在大多数系统中，权限都过于复杂庞大而无法完全包含在内存中。当然，如果开发者有需要，可以自定义类继承自 GrantedAuthority 以扩展其功能。</li></ol><p>从作者的回复中我们也可以看出来，<code>hasAuthority</code> 和 <code>hasRole</code> 功能上没什么区别，设计层面上确实是两个不同的东西。</p><h2 id="3-历史沿革"><a href="#3-历史沿革" class="headerlink" title="3.历史沿革"></a>3.历史沿革</h2><p>实际上，在 Spring Security4 之前，<code>hasAuthority</code> 和 <code>hasRole</code> 几乎是一模一样的，连 <code>ROLE_</code> 区别都没有！</p><p>即 <code>hasRole(&quot;admin&quot;)</code> 和 <code>hasAuthority(&quot;admin&quot;)</code> 是一样的。</p><p>而在 Spring Security4 之后，才有了前缀 <code>ROLE_</code> 的区别。</p><p>这块如果小伙伴们感兴趣的话，可以看看 Spring Security3 到 Spring Security4 的迁移文档：</p><ul><li><a href="http://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html#m3to4-role-prefixing" target="_blank" rel="noopener">http://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html#m3to4-role-prefixing</a></li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>一言以蔽之，代码上来说，hasRole 和 hasAuthority 写代码时前缀不同，但是最终执行是一样的；设计上来说，role 和 authority 这是两个层面的权限设计思路，一个是角色，一个是权限，角色是权限的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信很多小伙伴在初次接触 Spring Security 时，一定会被这个问题所困扰，例如如下两段配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 权限管理的投票器与表决机制</title>
    <link href="http://www.javaboy.org/2020/0911/springsecurity-voter.html"/>
    <id>http://www.javaboy.org/2020/0911/springsecurity-voter.html</id>
    <published>2020-09-11T01:55:04.000Z</published>
    <updated>2020-10-09T00:44:53.385Z</updated>
    
    <content type="html"><![CDATA[<p>今天咱们来聊一聊 Spring Security 中的表决机制与投票器。</p><a id="more"></a><p>当用户想访问 Spring Security 中一个受保护的资源时，用户具备一些角色，该资源的访问也需要一些角色，在比对用户具备的角色和资源需要的角色时，就会用到投票器和表决机制。</p><p>当用户想要访问某一个资源时，投票器根据用户的角色投出赞成或者反对票，表决方式则根据投票器的结果进行表决。</p><p>在 Spring Security 中，默认提供了三种表决机制，当然，我们也可以不用系统提供的表决机制和投票器，而是完全自己来定义，这也是可以的。</p><p>本文松哥将和大家重点介绍三种表决机制和默认的投票器。</p><h2 id="1-投票器"><a href="#1-投票器" class="headerlink" title="1.投票器"></a>1.投票器</h2><p>先来看投票器。</p><p>在 Spring Security 中，投票器是由 AccessDecisionVoter 接口来规范的，我们来看下 AccessDecisionVoter 接口的实现：</p><p><img src="http://img.itboyhub.com/2020/06/AccessDecisionVoter.png" alt></p><p>可以看到，投票器的实现有好多种，我们可以选择其中一种或多种投票器，也可以自定义投票器，默认的投票器是 WebExpressionVoter。</p><p>我们来看 AccessDecisionVoter 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">S</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_GRANTED = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_ABSTAIN = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_DENIED = -<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, S object,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我稍微解释下：</p><ol><li>首先一上来定义了三个常量，从常量名字中就可以看出每个常量的含义，1 表示赞成；0 表示弃权；-1 表示拒绝。</li><li>两个 supports 方法用来判断投票器是否支持当前请求。</li><li>vote 则是具体的投票方法。在不同的实现类中实现。三个参数，authentication 表示当前登录主体；object 是一个 ilterInvocation，里边封装了当前请求；attributes 表示当前所访问的接口所需要的角色集合。</li></ol><p>我们来分别看下几个投票器的实现。</p><h3 id="1-1-RoleVoter"><a href="#1-1-RoleVoter" class="headerlink" title="1.1 RoleVoter"></a>1.1 RoleVoter</h3><p>RoleVoter 主要用来判断当前请求是否具备该接口所需要的角色，我们来看下其 vote 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> result = ACCESS_ABSTAIN;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);</span><br><span class="line"><span class="hljs-keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.supports(attribute)) &#123;</span><br><span class="line">result = ACCESS_DENIED;</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (attribute.getAttribute().equals(authority.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的判断逻辑很简单，如果当前登录主体为 null，则直接返回 ACCESS_DENIED 表示拒绝访问；否则就从当前登录主体 authentication 中抽取出角色信息，然后和 attributes 进行对比，如果具备 attributes 中所需角色的任意一种，则返回 ACCESS_GRANTED 表示允许访问。例如 attributes 中的角色为 [a,b,c]，当前用户具备 a，则允许访问，不需要三种角色同时具备。</p><p>另外还有一个需要注意的地方，就是 RoleVoter 的 supports 方法，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleVoter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> String rolePrefix = <span class="hljs-string">"ROLE_"</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRolePrefix</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> rolePrefix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRolePrefix</span><span class="hljs-params">(String rolePrefix)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolePrefix = rolePrefix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> ((attribute.getAttribute() != <span class="hljs-keyword">null</span>)</span><br><span class="line">&amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里涉及到了一个 rolePrefix 前缀，这个前缀是 <code>ROLE_</code>，在 supports 方法中，只有主体角色前缀是 <code>ROLE_</code>，这个 supoorts 方法才会返回 true，这个投票器才会生效。</p><h3 id="1-2-RoleHierarchyVoter"><a href="#1-2-RoleHierarchyVoter" class="headerlink" title="1.2 RoleHierarchyVoter"></a>1.2 RoleHierarchyVoter</h3><p>RoleHierarchyVoter 是 RoleVoter 的一个子类，在 RoleVoter 角色判断的基础上，引入了角色分层管理，也就是角色继承，关于角色继承，小伙伴们可以参考松哥之前的文章（<a href="https://mp.weixin.qq.com/s/1ZWyD41R827FhghiCHY-Sw" target="_blank" rel="noopener">Spring Security 中如何让上级拥有下级的所有权限？</a>）。</p><p>RoleHierarchyVoter 类的 vote 方法和 RoleVoter 一致，唯一的区别在于 RoleHierarchyVoter 类重写了 extractAuthorities 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(</span><br><span class="line">Authentication authentication) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> roleHierarchy.getReachableGrantedAuthorities(authentication</span><br><span class="line">.getAuthorities());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色分层之后，需要通过 getReachableGrantedAuthorities 方法获取实际具备的角色，具体请参考：<a href>Spring Security 中如何让上级拥有下级的所有权限？</a> 一文。</p><h3 id="1-3-WebExpressionVoter"><a href="#1-3-WebExpressionVoter" class="headerlink" title="1.3 WebExpressionVoter"></a>1.3 WebExpressionVoter</h3><p>这是一个基于表达式权限控制的投票器，松哥后面专门花点时间和小伙伴们聊一聊基于表达式的权限控制，这里我们先不做过多展开，简单看下它的 vote 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, FilterInvocation fi,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">assert</span> authentication != <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">assert</span> fi != <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">assert</span> attributes != <span class="hljs-keyword">null</span>;</span><br><span class="line">WebExpressionConfigAttribute weca = findConfigAttribute(attributes);</span><br><span class="line"><span class="hljs-keyword">if</span> (weca == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_ABSTAIN;</span><br><span class="line">&#125;</span><br><span class="line">EvaluationContext ctx = expressionHandler.createEvaluationContext(authentication,</span><br><span class="line">fi);</span><br><span class="line">ctx = weca.postProcess(ctx, fi);</span><br><span class="line"><span class="hljs-keyword">return</span> ExpressionUtils.evaluateAsBoolean(weca.getAuthorizeExpression(), ctx) ? ACCESS_GRANTED</span><br><span class="line">: ACCESS_DENIED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你熟练使用 SpEL 的话，这段代码应该说还是很好理解的，不过根据我的经验，实际工作中用到 SpEL 场景虽然有，但是不多，所以可能有很多小伙伴并不了解 SpEL 的用法，这个需要小伙伴们自行复习下，我也给大家推荐一篇还不错的文章：<a href="https://www.cnblogs.com/larryzeal/p/5964621.html" target="_blank" rel="noopener">https://www.cnblogs.com/larryzeal/p/5964621.html</a>。</p><p>这里代码实际上就是根据传入的 attributes 属性构建 weca 对象，然后根据传入的 authentication 参数构建 ctx 对象，最后调用 evaluateAsBoolean 方法去判断权限是否匹配。</p><p>上面介绍这三个投票器是我们在实际开发中使用较多的三个。</p><h3 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h3><p>另外还有几个比较冷门的投票器，松哥也稍微说下，小伙伴们了解下。</p><p><strong>Jsr250Voter</strong></p><p>处理 Jsr-250 权限注解的投票器，如 <code>@PermitAll</code>，<code>@DenyAll</code> 等。</p><p><strong>AuthenticatedVoter</strong></p><p>AuthenticatedVoter 用于判断 ConfigAttribute 上是否拥有 IS_AUTHENTICATED_FULLY、IS_AUTHENTICATED_REMEMBERED、IS_AUTHENTICATED_ANONYMOUSLY 三种角色。</p><p>IS_AUTHENTICATED_FULLY 表示当前认证用户必须是通过用户名/密码的方式认证的，通过 RememberMe 的方式认证无效。</p><p>IS_AUTHENTICATED_REMEMBERED 表示当前登录用户必须是通过 RememberMe 的方式完成认证的。</p><p>IS_AUTHENTICATED_ANONYMOUSLY 表示当前登录用户必须是匿名用户。</p><p>当项目引入 RememberMe 并且想区分不同的认证方式时，可以考虑这个投票器。</p><p><strong>AbstractAclVoter</strong></p><p>提供编写域对象 ACL 选项的帮助方法，没有绑定到任何特定的 ACL 系统。</p><p><strong>PreInvocationAuthorizationAdviceVoter</strong></p><p>使用 @PreFilter 和 @PreAuthorize 注解处理的权限，通过 PreInvocationAuthorizationAdvice 来授权。</p><p>当然，如果这些投票器不能满足需求，也可以自定义。</p><h2 id="2-表决机制"><a href="#2-表决机制" class="headerlink" title="2.表决机制"></a>2.表决机制</h2><p>一个请求不一定只有一个投票器，也可能有多个投票器，所以在投票器的基础上我们还需要表决机制。</p><p><img src="http://img.itboyhub.com/2020/07/20200909203727.png" alt></p><p>表决相关的类主要是三个：</p><ul><li>AffirmativeBased</li><li>ConsensusBased</li><li>UnanimousBased</li></ul><p>他们的继承关系如上图。</p><p>三个决策器都会把项目中的所有投票器调用一遍，默认使用的决策器是 AffirmativeBased。</p><p>三个决策器的区别如下：</p><ul><li>AffirmativeBased：有一个投票器同意了，就通过。</li><li>ConsensusBased：多数投票器同意就通过，平局的话，则看 allowIfEqualGrantedDeniedDecisions 参数的取值。</li><li>UnanimousBased 所有投票器都同意，请求才通过。</li></ul><p>这里的具体判断逻辑比较简单，松哥就不贴源码了，感兴趣的小伙伴可以自己看看。</p><h2 id="3-在哪里配置"><a href="#3-在哪里配置" class="headerlink" title="3.在哪里配置"></a>3.在哪里配置</h2><p>当我们使用基于表达式的权限控制时，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().fullyAuthenticated()</span><br></pre></td></tr></table></figure><p>那么默认的投票器和决策器是在 AbstractInterceptUrlConfigurer#createDefaultAccessDecisionManager 方法中配置的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> AccessDecisionManager <span class="hljs-title">createDefaultAccessDecisionManager</span><span class="hljs-params">(H http)</span> </span>&#123;</span><br><span class="line">AffirmativeBased result = <span class="hljs-keyword">new</span> AffirmativeBased(getDecisionVoters(http));</span><br><span class="line"><span class="hljs-keyword">return</span> postProcess(result);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;AccessDecisionVoter&lt;?&gt;&gt; getDecisionVoters(H http) &#123;</span><br><span class="line">List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">WebExpressionVoter expressionVoter = <span class="hljs-keyword">new</span> WebExpressionVoter();</span><br><span class="line">expressionVoter.setExpressionHandler(getExpressionHandler(http));</span><br><span class="line">decisionVoters.add(expressionVoter);</span><br><span class="line"><span class="hljs-keyword">return</span> decisionVoters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到默认的决策器和投票器，并且决策器 AffirmativeBased 对象创建好之后，还调用 postProcess 方法注册到 Spring 容器中去了，结合松哥本系列前面的文章，大家知道，如果我们想要修改该对象就非常容易了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().fullyAuthenticated()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;AffirmativeBased&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends AffirmativeBased&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                decisionVoters.add(<span class="hljs-keyword">new</span> RoleHierarchyVoter(roleHierarchy()));</span><br><span class="line">                AffirmativeBased affirmativeBased = <span class="hljs-keyword">new</span> AffirmativeBased(decisionVoters);</span><br><span class="line">                <span class="hljs-keyword">return</span> (O) affirmativeBased;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br></pre></td></tr></table></figure><p><strong>这里只是给大家一个演示，正常来说我们是不需要这样修改的</strong>。当我们使用不同的权限配置方式时，会有自动配置对应的投票器和决策器。或者我们手动配置投票器和决策器，如果是系统配置好的，大部分情况下并不需要我们修改。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>本文主要和小伙伴们简单分享一下 Spring Security 中的投票器和决策器，关于授权的更多知识，松哥下篇文章继续和小伙伴们细聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天咱们来聊一聊 Spring Security 中的表决机制与投票器。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中如何让上级拥有下级的所有权限？</title>
    <link href="http://www.javaboy.org/2020/0909/springsecurity-role-hierarchy.html"/>
    <id>http://www.javaboy.org/2020/0909/springsecurity-role-hierarchy.html</id>
    <published>2020-09-09T01:54:47.000Z</published>
    <updated>2020-10-09T00:44:45.168Z</updated>
    
    <content type="html"><![CDATA[<p>答案是能！</p><a id="more"></a><p>松哥之前写过类似的文章，但是主要是讲了用法，今天我们来看看原理！</p><p>本文基于当前 Spring Security 5.3.4 来分析，为什么要强调最新版呢？因为在在 5.0.11 版中，角色继承配置和现在不一样。旧版的方案我们现在不讨论了，直接来看当前最新版是怎么处理的。</p><h2 id="1-角色继承案例"><a href="#1-角色继承案例" class="headerlink" title="1.角色继承案例"></a>1.角色继承案例</h2><p>我们先来一个简单的权限案例。</p><p>创建一个 Spring Boot 项目，添加 Spring Security 依赖，并创建两个测试用户，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="hljs-string">"江南一点雨"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"&#123;noop&#125;123"</span>)</span><br><span class="line">            .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后准备三个测试接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个测试接口，我们的规划是这样的：</p><ol><li>/hello 是任何人都可以访问的接口</li><li>/admin/hello 是具有 admin 身份的人才能访问的接口</li><li>/user/hello 是具有 user 身份的人才能访问的接口</li><li>所有 user 能够访问的资源，admin 都能够访问</li></ol><p><strong>注意第四条规范意味着所有具备 admin 身份的人自动具备 user 身份。</strong></p><p>接下来我们来配置权限的拦截规则，在 Spring Security 的 configure(HttpSecurity http) 方法中，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里的匹配规则我们采用了 Ant 风格的路径匹配符，Ant 风格的路径匹配符在 Spring 家族中使用非常广泛，它的匹配规则也非常简单：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">匹配多层路径</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配一层路径</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>上面配置的含义是：</p><ol><li>如果请求路径满足 <code>/admin/**</code> 格式，则用户需要具备 admin 角色。</li><li>如果请求路径满足 <code>/user/**</code> 格式，则用户需要具备 user 角色。</li><li>剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。</li></ol><p>注意代码中配置的三条规则的顺序非常重要，和 Shiro 类似，Spring Security 在匹配的时候也是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，<strong>所以拦截规则的顺序不能写错</strong>。</p><p>如果使用角色继承，这个功能很好实现，我们只需要在 SecurityConfig 中添加如下代码来配置角色继承关系即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl hierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    hierarchy.setHierarchy(<span class="hljs-string">"ROLE_admin &gt; ROLE_user"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> hierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在配置时，需要给角色手动加上 <code>ROLE_</code> 前缀。上面的配置表示 <code>ROLE_admin</code> 自动具备 <code>ROLE_user</code> 的权限。</p><p>接下来，我们启动项目进行测试。</p><p>项目启动成功后，我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>再以 javaboy 身份登录，登录成功后，我们发现 javaboy 也能访问 <code>/user/hello</code> 这个接口了，说明我们的角色继承配置没问题！</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2.原理分析"></a>2.原理分析</h2><p>这里配置的核心在于我们提供了一个 RoleHierarchy 实例，所以我们的分析就从该类入手。</p><p>RoleHierarchy 是一个接口，该接口中只有一个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RoleHierarchy</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; getReachableGrantedAuthorities(</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法参数 authorities 是一个权限集合，从方法名上看方法的返回值是一个可访问的权限集合。</p><p>举个简单的例子，假设角色层次结构是 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C</code>，现在直接给用户分配的权限是 <code>ROLE_A</code>，但实际上用户拥有的权限有 <code>ROLE_A</code>、<code>ROLE_B</code> 以及 <code>ROLE_C</code>。</p><p>getReachableGrantedAuthorities 方法的目的就是是根据角色层次定义，将用户真正可以触达的角色解析出来。</p><p>RoleHierarchy 接口有两个实现类，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200908153034.png" alt></p><ul><li>NullRoleHierarchy 这是一个空的实现，将传入的参数原封不动返回。</li><li>RoleHierarchyImpl 这是我们上文所使用的实现，这个会完成一些解析操作。</li></ul><p>我们来重点看下 RoleHierarchyImpl 类。</p><p>这个类中实际上就四个方法 <code>setHierarchy</code>、<code>getReachableGrantedAuthorities</code>、<code>buildRolesReachableInOneStepMap</code> 以及 <code>buildRolesReachableInOneOrMoreStepsMap</code>，我们来逐个进行分析。</p><p>首先是我们一开始调用的 setHierarchy 方法，这个方法用来设置角色层级关系：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHierarchy</span><span class="hljs-params">(String roleHierarchyStringRepresentation)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation = roleHierarchyStringRepresentation;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"setHierarchy() - The following role hierarchy was set: "</span></span><br><span class="line">+ roleHierarchyStringRepresentation);</span><br><span class="line">&#125;</span><br><span class="line">buildRolesReachableInOneStepMap();</span><br><span class="line">buildRolesReachableInOneOrMoreStepsMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户传入的字符串变量设置给 roleHierarchyStringRepresentation 属性，然后通过 buildRolesReachableInOneStepMap 和 buildRolesReachableInOneOrMoreStepsMap 方法完成对角色层级的解析。</p><p>buildRolesReachableInOneStepMap 方法用来将角色关系解析成一层一层的形式。我们来看下它的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneStepMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String line : <span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation.split(<span class="hljs-string">"\n"</span>)) &#123;</span><br><span class="line">String[] roles = line.trim().split(<span class="hljs-string">"\\s+&gt;\\s+"</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; roles.length; i++) &#123;</span><br><span class="line">String higherRole = roles[i - <span class="hljs-number">1</span>];</span><br><span class="line">GrantedAuthority lowerRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(roles[i]);</span><br><span class="line">Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(higherRole);</span><br><span class="line">&#125;</span><br><span class="line">rolesReachableInOneStepSet.add(lowerRole);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先大家看到，按照换行符来解析用户配置的多个角色层级，这是什么意思呢？</p><p>我们前面案例中只是配置了 <code>ROLE_admin &gt; ROLE_user</code>，如果你需要配置多个继承关系，怎么配置呢？多个继承关系用 <code>\n</code> 隔开即可，如下 <code>ROLE_A &gt; ROLE_B \n ROLE_C &gt; ROLE_D</code>。还有一种情况，如果角色层级关系是连续的，也可以这样配置 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C &gt; ROLE_D</code>。</p><p>所以这里先用 <code>\n</code> 将多层继承关系拆分开形成一个数组，然后对数组进行遍历。</p><p>在具体遍历中，通过 <code>&gt;</code> 将角色关系拆分成一个数组，然后对数组进行解析，高一级的角色作为 key，低一级的角色作为 value。</p><p>代码比较简单，最终的解析出来存入 rolesReachableInOneStepMap 中的层级关系是这样的：</p><p>假设角色继承关系是 <code>ROLE_A &gt; ROLE_B \n ROLE_C &gt; ROLE_D \n ROLE_C &gt; ROLE_E</code>，Map 中的数据是这样：</p><ul><li>A–&gt;B</li><li>C–&gt;[D,E]</li></ul><p>假设角色继承关系是 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C &gt; ROLE_D</code>，Map 中的数据是这样：</p><ul><li>A–&gt;B</li><li>B–&gt;C</li><li>C–&gt;D</li></ul><p>这是 buildRolesReachableInOneStepMap 方法解析出来的 rolesReachableInOneStepMap 集合。</p><p>接下来的 buildRolesReachableInOneOrMoreStepsMap 方法则是对 rolesReachableInOneStepMap 集合进行再次解析，将角色的继承关系拉平。</p><p>例如 rolesReachableInOneStepMap 中保存的角色继承关系如下：</p><ul><li>A–&gt;B</li><li>B–&gt;C</li><li>C–&gt;D</li></ul><p>经过 buildRolesReachableInOneOrMoreStepsMap 方法解析之后，新的 Map 中保存的数据如下：</p><ul><li>A–&gt;[B、C、D]</li><li>B–&gt;[C、D]</li><li>C–&gt;D</li></ul><p>这样解析完成后，每一个角色可以触达到的角色就一目了然了。</p><p>我们来看下 buildRolesReachableInOneOrMoreStepsMap 方法的实现逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneOrMoreStepsMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String roleName : <span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.keySet()) &#123;</span><br><span class="line">Set&lt;GrantedAuthority&gt; rolesToVisitSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(roleName));</span><br><span class="line">Set&lt;GrantedAuthority&gt; visitedRolesSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">while</span> (!rolesToVisitSet.isEmpty()) &#123;</span><br><span class="line">GrantedAuthority lowerRole = rolesToVisitSet.iterator().next();</span><br><span class="line">rolesToVisitSet.remove(lowerRole);</span><br><span class="line"><span class="hljs-keyword">if</span> (!visitedRolesSet.add(lowerRole) ||</span><br><span class="line">!<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.containsKey(lowerRole.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (roleName.equals(lowerRole.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CycleInRoleHierarchyException();</span><br><span class="line">&#125;</span><br><span class="line">rolesToVisitSet.addAll(<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(lowerRole.getAuthority()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap.put(roleName, visitedRolesSet);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还比较巧妙。首先根据 roleName 从 rolesReachableInOneStepMap 中获取对应的 rolesToVisitSet，这个 rolesToVisitSet 是一个 Set 集合，对其进行遍历，将遍历结果添加到 visitedRolesSet 集合中，如果 rolesReachableInOneStepMap 集合的 key 不包含当前读取出来的 lowerRole，说明这个 lowerRole 就是整个角色体系中的最底层，直接 continue。否则就把 lowerRole 在 rolesReachableInOneStepMap 中对应的 value 拿出来继续遍历。</p><p>最后将遍历结果存入 rolesReachableInOneOrMoreStepsMap 集合中即可。</p><p>这个方法有点绕，小伙伴们可以自己打个断点品一下。</p><p>看了上面的分析，小伙伴们可能发现了，其实角色继承，最终还是拉平了去对比。</p><p>我们定义的角色有层级，但是代码中又将这种层级拉平了，方便后续的比对。</p><p>最后还有一个 getReachableGrantedAuthorities 方法，根据传入的角色分析出其可能潜在包含的一些角色：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;GrantedAuthority&gt; <span class="hljs-title">getReachableGrantedAuthorities</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authorities == <span class="hljs-keyword">null</span> || authorities.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> AuthorityUtils.NO_AUTHORITIES;</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;GrantedAuthority&gt; reachableRoles = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; processedNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authority.getAuthority() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">reachableRoles.add(authority);</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!processedNames.add(authority.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">reachableRoles.add(authority);</span><br><span class="line">Set&lt;GrantedAuthority&gt; lowerRoles = <span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap.get(authority.getAuthority());</span><br><span class="line"><span class="hljs-keyword">if</span> (lowerRoles == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority role : lowerRoles) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (processedNames.add(role.getAuthority())) &#123;</span><br><span class="line">reachableRoles.add(role);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;GrantedAuthority&gt; reachableRoleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(reachableRoles.size());</span><br><span class="line">reachableRoleList.addAll(reachableRoles);</span><br><span class="line"><span class="hljs-keyword">return</span> reachableRoleList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑比较直白，就是从 rolesReachableInOneOrMoreStepsMap 集合中查询出当前角色真正可访问的角色信息。</p><h2 id="3-RoleHierarchyVoter"><a href="#3-RoleHierarchyVoter" class="headerlink" title="3.RoleHierarchyVoter"></a>3.RoleHierarchyVoter</h2><p>getReachableGrantedAuthorities 方法将在 RoleHierarchyVoter 投票器中被调用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleHierarchyVoter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoleVoter</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> RoleHierarchy roleHierarchy = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleHierarchyVoter</span><span class="hljs-params">(RoleHierarchy roleHierarchy)</span> </span>&#123;</span><br><span class="line">Assert.notNull(roleHierarchy, <span class="hljs-string">"RoleHierarchy must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.roleHierarchy = roleHierarchy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(</span><br><span class="line">Authentication authentication) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> roleHierarchy.getReachableGrantedAuthorities(authentication</span><br><span class="line">.getAuthorities());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Spring Security 投票器，将是另外一个故事，松哥将在下篇文章中和小伙伴们分享投票器和决策器～</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们简简单单聊一下角色继承的问题，感兴趣的小伙伴可以自己试一下～如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;答案是能！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码系列之容器概览～</title>
    <link href="http://www.javaboy.org/2020/0907/spring-container-overview.html"/>
    <id>http://www.javaboy.org/2020/0907/spring-container-overview.html</id>
    <published>2020-09-07T01:54:33.000Z</published>
    <updated>2020-10-09T00:43:49.809Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章和小伙伴们分享了 Spring 中的 FactoryBean（<a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a>），大家知道 Spring 中还有一个和 FactoryBean 单词很像的类叫做 BeanFactory！</p><a id="more"></a><p>今天松哥就再通过一篇文章来和大家聊聊 BeanFactory！</p><h2 id="1-容器概览"><a href="#1-容器概览" class="headerlink" title="1.容器概览"></a>1.容器概览</h2><p>Spring 中的 Ioc 容器，我们可以大致上分为两种：</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><h3 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h3><p>BeanFactory 是最最基础的 IoC 容器，它提供了一个 IoC 容器所需的基本功能。在本系列前面文章中我们所用到的 XmlBeanFactory 就是它的实现之一。</p><p>BeanFactory 默认采用延迟初始化策略，即当容器启动时，并未完成 Bean 的初始化，只有当调用到该 Bean 的实例时，才会完成其初始化操作，并进行依赖注入。</p><p>例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>));</span><br><span class="line">User user = factory.getBean(User.class);</span><br></pre></td></tr></table></figure><p>当第一行代码执行的时候，beans.xml 中配置的 User 对象并未进行初始化，只有当第二行 getBean 方法调用时，User 对象才进行了初始化操作。</p><p>这样设计的好处是容器启动速度快，因为要做的事情比较少。</p><h3 id="1-2-ApplicationContext"><a href="#1-2-ApplicationContext" class="headerlink" title="1.2 ApplicationContext"></a>1.2 ApplicationContext</h3><p>ApplicationContext 是在 BeanFactory 的基础上实现的，BeanFactory 的功能它都有，算是一种高级容器。</p><p>ApplicationContext 在 BeanFactory 的基础上提供了事件发布、国际化等功能。</p><p>同时，ApplicationContext 和 BeanFactory 还有一个很大的不同在于 ApplicationContext 在容器启动时，就会完成所有 Bean 的初始化，这也就以为着容器启动时间较长，并且对系统资源要求也较高。</p><p>例如如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure><p>当这段代码执行时，beans.xml 中配置的 User 对象就会完成初始化操作。</p><h2 id="2-BeanFactory"><a href="#2-BeanFactory" class="headerlink" title="2.BeanFactory"></a>2.BeanFactory</h2><p>BeanFactory 的继承关系图太大了，放在文章里显示不全。小伙伴们可以在 IDEA 中自行查看，我这里就不贴图出来了。</p><p>我们来看下 BeanFactory 的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，BeanFactory 主要提供了一些和 Bean 相关的查询方法。</p><p><strong>FACTORY_BEAN_PREFIX</strong></p><p>这是定义的 FactoryBean 前缀，具体参考<a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a>。</p><p><strong>getBean</strong></p><p>getBean 方法一共有五个。</p><p>在获取一个 Bean 的时候，可以指定 Bean 的名字，也可以指定 Bean 的类型，也可以同时指定，这个好理解。</p><p>还有两个重载的方法里边有一个 args 参数，这个可能有的小伙伴们没怎么用过，我这里稍微解释下。</p><p>其实我们大概能猜出来 args 是获取 Bean 时所需要的参数，如果使用该方法给 Bean 配置参数，需要将 Bean 的 scope 设置为 prototype，这就意味着每次获取 Bean 的时候，才去进行 Bean 的初始化（否则配置的参数无法生效）。</p><p>松哥通过一个例子来给大家演示下。</p><p>首先我们提供一个 User 类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", age="</span> + age +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，User 类只有一个有参的构造方法。</p><p>接下来我们在 XML 文件中进行配置，XML 文件中需要配置 User 类的构造方法参数，我们可以配置为 null，同时记得设置 scope 属性为 prototype。</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring_demo04.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user1"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后再通过如下方式加载 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">User user = ctx.getBean(User.class,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"javaboy"</span>,<span class="hljs-number">99</span>&#125;);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=&apos;javaboy&apos;, age=99&#125;</span><br></pre></td></tr></table></figure><p>可以看到，为 Bean 配置的参数都生效了。</p><p><strong>getBeanProvider</strong></p><p>方法用于获取指定 Bean 的提供者，可以看到它返回的是一个 ObjectProvider，该类扩展自 ObjectFactory，从 Spring4.3 时开始提供。</p><p>可能大家对 ObjectProvider 接触较少，这里我也稍微说一下。</p><p>先来看 ObjectFactory：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFactory 有点类似于我们在 <a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a> 一文中所讲的 FactoryBean。</p><p>不同的是，ObjectFactory 中只有一个 getObject 方法，该方法可以返回 Object 实例。ObjectFactory 与 FactoryBean 相似，但是后者的实现通常是在 BeanFactory 中定义为 SPI 实例，而此类的实现通常是作为 API 注入给其他 Bean。</p><p>再来看 ObjectProvider（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObjectProvider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//返回指定类型的 bean, 如果容器中不存在, 抛出 NoSuchBeanDefinitionException 异常；如果容器中有多个此类型的 bean, 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">//如果指定类型的 bean 注册到容器中, 返回 bean 实例, 否则返回 null</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getIfAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">//如果指定类型的 bean 在容器中只有一个 bean, 返回 bean 实例, 如果不存在则返回 null；如果容器中有多个此类型的 bean, 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getIfUnique</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">// Spring5.0 之后提供，返回指定类型 Bean 的迭代器</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> stream().iterator();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//转为 Stream</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Multi element access not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title">orderedStream</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Ordered element access not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 ObjectProvider 的源码，那么它有什么用呢？松哥举个简单例子。</p><p>在 Spring4.3 之前。</p><p>假设我有一个 UserDao，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个 UserService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UserService 中注入 UserDao 时，必须明确给出 @Autowired 注解。</p><p>这看起来不够优雅！</p><p>从 Spring4.3 开始，在 UserService 中注入 UserDao 时，如果构造方法只有一个参数，可以不用添加 @Autowired 注解，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 UserDao 为 null，则会导致 UserService 初始化失败，通过 ObjectProvider 可以解决，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(ObjectProvider&lt;UserDao&gt; userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao.getIfUnique();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 ObjectProvider。好啦，扯远了，我们回到 BeanFactory 继续看它里边的方法。</p><p><strong>containsBean</strong></p><p>判断容器中是否包含某个 Bean。</p><p><strong>isSingleton</strong></p><p>判断某个 Bean 是否是单例的。</p><p><strong>isPrototype</strong></p><p>判断某个 Bean 是否是 prototype。</p><p><strong>isTypeMatch</strong></p><p>返回指定名称的 Bean 是否匹配指定的类型。</p><p><strong>getType</strong></p><p>返回指定名称的 Bean 对应的数据类型。</p><p><strong>getAliases</strong></p><p>返回 Bean 的别名。</p><p>这就是 BeanFactory 中定义的所有方法，可以看到，基本上都是容器相关的查询方法，接下来将在 BeanFactory 的各种实现类中，对其进行实现。</p><h2 id="3-二级接口"><a href="#3-二级接口" class="headerlink" title="3.二级接口"></a>3.二级接口</h2><p>BeanFactory 作为 IoC 容器中最顶层的定义，没有继承任何接口，我们可以称之为一级接口，直接继承自 BeanFactory 的接口有三个，我们称之为二级接口。</p><h3 id="3-1-HierarchicalBeanFactory"><a href="#3-1-HierarchicalBeanFactory" class="headerlink" title="3.1 HierarchicalBeanFactory"></a>3.1 HierarchicalBeanFactory</h3><p>HierarchicalBeanFactory 继承自 BeanFactory，定义了工厂分层，在其基础上又扩展了两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">BeanFactory <span class="hljs-title">getParentBeanFactory</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsLocalBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getParentBeanFactory 方法返回 Bean 工厂的父工厂，实现了工厂分层。</li><li>containsLocalBean 方法则判断本地工厂是否包含这个 Bean。</li></ul><p>HierarchicalBeanFactory 有一个接口 <strong>ConfigurableBeanFactory</strong>，ConfigurableBeanFactory 接口继承自 HierarchicalBeanFactory 和 SingletonBeanRegistry，其中 SingletonBeanRegistry 这个接口定义了对单例 Bean 的定义以及获取方法。也就是说，ConfigurableBeanFactory 中兼具工厂分层和单例处理功能。同时，在 HierarchicalBeanFactory 中 getParentBeanFactory 所 get 到的对象，也是在 ConfigurableBeanFactory 中完成配置。</p><h3 id="3-2-AutowireCapableBeanFactory"><a href="#3-2-AutowireCapableBeanFactory" class="headerlink" title="3.2 AutowireCapableBeanFactory"></a>3.2 AutowireCapableBeanFactory</h3><p>AutowireCapableBeanFactory 继承自 BeanFacotory，它扩展了自动装配的功能。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_NO = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_BY_NAME = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_BY_TYPE = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="hljs-number">3</span>;</span><br><span class="line"><span class="hljs-meta">@Deprecated</span></span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_AUTODETECT = <span class="hljs-number">4</span>;</span><br><span class="line">String ORIGINAL_INSTANCE_SUFFIX = <span class="hljs-string">".ORIGINAL"</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">createBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">autowireBean</span><span class="hljs-params">(Object existingBean)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">autowire</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">autowireBeanProperties</span><span class="hljs-params">(Object existingBean, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">configureBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyBeanPropertyValues</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyBean</span><span class="hljs-params">(Object existingBean)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">NamedBeanHolder&lt;T&gt; <span class="hljs-title">resolveNamedBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveBeanByName</span><span class="hljs-params">(String name, DependencyDescriptor descriptor)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过五个常量定义了五种不同的装配策略，分别是：不自动装配、通过名称自动装配、通过类型自动装配、通过构造方法自动装配，还有一个过期的常量。</p><p><code>ORIGINAL_INSTANCE_SUFFIX</code> 则是初始化实例给定名称时约定的后缀，该后缀会添加到类的全路径后面，例如：<code>com.mypackage.MyClass.ORIGINAL</code>。</p><p><code>createBean</code> 方法用来创建 <code>Bean</code> 实例；<code>autowire*</code> 方法则用来完成自动装配；<code>configureBean</code> 用来配置 <code>Bean</code>；<code>initializeBean</code> 用来初始化 <code>Bean</code>；<code>applyBeanPropertyValues</code> 将指定 <code>bean</code> 的 <code>BeanDefinition</code> 应用到一个已经存在的 <code>Bean</code> 上；<code>applyBeanPostProcessorsBeforeInitialization/applyBeanPostProcessorsAfterInitialization</code> 调用 <code>Bean</code> 的后置处理器；<code>destroyBean</code> 方法用来销毁 <code>Bean</code>；<code>resolve*</code> 方法用来解析 <code>Bean</code>。</p><h3 id="3-3-ListableBeanFactory"><a href="#3-3-ListableBeanFactory" class="headerlink" title="3.3 ListableBeanFactory"></a>3.3 ListableBeanFactory</h3><p>ListableBeanFactory 继承自 BeanFacotory，该接口可以列出工厂可以生产的所有实例。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;</span><br><span class="line">String[] getBeanDefinitionNames();</span><br><span class="line">String[] getBeanNamesForType(ResolvableType type);</span><br><span class="line">String[] getBeanNamesForType(ResolvableType type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit);</span><br><span class="line">String[] getBeanNamesForType(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; type);</span><br><span class="line">String[] getBeanNamesForType(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit);</span><br><span class="line">&lt;T&gt; <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">getBeansOfType</span><span class="hljs-params">(@Nullable Class&lt;T&gt; type)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">getBeansOfType</span><span class="hljs-params">(@Nullable Class&lt;T&gt; type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class="line"><span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getBeansWithAnnotation</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">&lt;A extends Annotation&gt; <span class="hljs-function">A <span class="hljs-title">findAnnotationOnBean</span><span class="hljs-params">(String beanName, Class&lt;A&gt; annotationType)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>containsBeanDefinition：判断容器是否包含某一个 Bean 的定义。</li><li>getBeanDefinitionCount：获取 BeanDefinition 数量。getBeanDefinitionCount 和 containsBeanDefinition 执行效率较低，慎用。</li><li>getBeanDefinitionNames：获取所有 Bean 的名字。</li><li>getBeanNamesForType：返回指定类型的 BeanName。</li><li>getBeansOfType：返回指定类的名称和 Bean Map（相同类型的 Bean 可能存在多种实例）。</li><li>getBeanNamesForAnnotation：根据注解获取指定的 BeanName。</li><li>getBeansWithAnnotation：根据注解获取指定的 BeanName 以及 Bean Map。</li><li>findAnnotationOnBean：根据指定 beanName 和注解类型查找指定的 Bean。</li></ul><p>ListableBeanFactory 有一个实现接口 <strong>ConfigurableListableBeanFactory</strong>，这是以上所介绍接口的集大成者，ConfigurableListableBeanFactory 继承自 ListableBeanFactory、AutowireCapableBeanFactory 以及 ConfigurableBeanFactory，可以看到，三个二级接口功能集于一身，它包含了 BeanFactory 体系目前的所有方法。这些方法都在 DefaultListableBeanFactory 中进行实现，也就是我们前面所讲的 <a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a>。</p><p>这就是直接继承自 BeanFactory 的三个接口。这三个接口中，有的方法大家可能用过，有的可能没用过，松哥后面抽空整一个视频，把这里涉及到的方法用法给小伙伴们演示一遍，加深大家的理解。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，本文主要和小伙伴们梳理了一下 BeanFactory 体系，扯的有点多了，下篇文章我们来继续看基于 BeanFactory 的 ApplicationContext。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章和小伙伴们分享了 Spring 中的 FactoryBean（&lt;a href=&quot;https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 源码第 9 篇，深入分析 FactoryBean&lt;/a&gt;），大家知道 Spring 中还有一个和 FactoryBean 单词很像的类叫做 BeanFactory！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>什么是计时攻击？Spring Boot 中该如何防御？</title>
    <link href="http://www.javaboy.org/2020/0902/springsecurity-timing-attack.html"/>
    <id>http://www.javaboy.org/2020/0902/springsecurity-timing-attack.html</id>
    <published>2020-09-02T01:53:17.000Z</published>
    <updated>2020-10-09T00:44:29.095Z</updated>
    
    <content type="html"><![CDATA[<p>松哥最近在研究 Spring Security 源码，发现了很多好玩的代码，抽空写几篇文章和小伙伴们分享一下。</p><a id="more"></a><p>很多人吐槽 Spring Security 比 Shiro 重量级，这个重量级不是凭空来的，重量有重量的好处，就是它提供了更为强大的防护功能。</p><p>比如松哥最近看到的一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> UserDetails <span class="hljs-title">retrieveUser</span><span class="hljs-params">(String username,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">prepareTimingAttackProtection();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">UserDetails loadedUser = <span class="hljs-keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line"><span class="hljs-keyword">if</span> (loadedUser == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line"><span class="hljs-string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> loadedUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line">mitigateAgainstTimingAttack(authentication);</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码位于 DaoAuthenticationProvider 类中，为了方便大家理解，我来简单说下这段代码的上下文环境。</p><p>当用户提交用户名密码登录之后，Spring Security 需要根据用户提交的用户名去数据库中查询用户，这块如果大家不熟悉，可以参考松哥之前的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p>查到用户对象之后，再去比对从数据库中查到的用户密码和用户提交的密码之间的差异。具体的比对工作，可以参考<a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a>一文。</p><p>而上面这段代码就是 Spring Security 根据用户登录时传入的用户名去数据库中查询用户，并将查到的用户返回。方法中还有一个 authentication 参数，这个参数里边保存了用户登录时传入的用户名/密码信息。</p><p>那么这段代码有什么神奇之处呢？</p><p>我们来一行一行分析。</p><h2 id="源码梳理"><a href="#源码梳理" class="headerlink" title="源码梳理"></a>源码梳理</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>首先方法一进来调用了 prepareTimingAttackProtection 方法，从方法名字上可以看出，这个是为计时攻击的防御做准备，那么什么又是计时攻击呢？别急，松哥一会来解释。我们先来吧流程走完。prepareTimingAttackProtection 方法的执行很简单，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareTimingAttackProtection</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.userNotFoundEncodedPassword == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.userNotFoundEncodedPassword = <span class="hljs-keyword">this</span>.passwordEncoder.encode(USER_NOT_FOUND_PASSWORD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就是将常量 USER_NOT_FOUND_PASSWORD 使用 passwordEncoder 编码之后（如果不了解 passwordEncoder，可以参考 <a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a>一文），将编码结果赋值给 userNotFoundEncodedPassword 变量。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>接下来调用 loadUserByUsername 方法，根据登录用户传入的用户名去数据库中查询用户，如果查到了，就将查到的对象返回。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>如果查询过程中抛出 UsernameNotFoundException 异常，按理说直接抛出异常，接下来的密码比对也不用做了，因为根据用户名都没查到用户，这次登录肯定是失败的，没有必要进行密码比对操作！</p><p>但是大家注意，在抛出异常之前调用了 mitigateAgainstTimingAttack 方法。这个方法从名字上来看，有缓解计时攻击的意思。</p><p>我们来看下该方法的执行流程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mitigateAgainstTimingAttack</span><span class="hljs-params">(UsernamePasswordAuthenticationToken authentication)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication.getCredentials() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"><span class="hljs-keyword">this</span>.passwordEncoder.matches(presentedPassword, <span class="hljs-keyword">this</span>.userNotFoundEncodedPassword);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里首先获取到登录用户传入的密码即 presentedPassword，然后调用 passwordEncoder.matches 方法进行密码比对操作，本来该方法的第二个参数是数据库查询出来的用户密码，现在数据库中没有查到用户，所以第二个参数用 userNotFoundEncodedPassword 代替了，userNotFoundEncodedPassword 就是我们一开始调用 prepareTimingAttackProtection 方法时赋值的变量。这个密码比对，从一开始就注定了肯定会失败，那为什么还要比对呢？</p><h2 id="计时攻击"><a href="#计时攻击" class="headerlink" title="计时攻击"></a>计时攻击</h2><p>这就引入了我们今天的主题–计时攻击。</p><p>计时攻击是旁路攻击的一种，在密码学中，旁道攻击又称侧信道攻击、边信道攻击（Side-channel attack）。</p><p>这种攻击方式并非利用加密算法的理论弱点，也不是暴力破解，而是从密码系统的物理实现中获取的信息。例如：时间信息、功率消耗、电磁泄露等额外的信息源，这些信息可被用于对系统的进一步破解。</p><p>旁路攻击有多种不同的分类：</p><ul><li>缓存攻击（Cache Side-Channel Attacks），通过获取对缓存的访问权而获取缓存内的一些敏感信息，例如攻击者获取云端主机物理主机的访问权而获取存储器的访问权。</li><li><strong>计时攻击（Timing attack），通过设备运算的用时来推断出所使用的运算操作，或者通过对比运算的时间推定数据位于哪个存储设备，或者利用通信的时间差进行数据窃取。</strong></li><li>基于功耗监控的旁路攻击，同一设备不同的硬件电路单元的运作功耗也是不一样的，因此一个程序运行时的功耗会随着程序使用哪一种硬件电路单元而变动，据此推断出数据输出位于哪一个硬件单元，进而窃取数据。</li><li>电磁攻击（Electromagnetic attack），设备运算时会泄漏电磁辐射，经过得当分析的话可解析出这些泄漏的电磁辐射中包含的信息（比如文本、声音、图像等），这种攻击方式除了用于密码学攻击以外也被用于非密码学攻击等窃听行为，如TEMPEST 攻击。</li><li>声学密码分析（Acoustic cryptanalysis），通过捕捉设备在运算时泄漏的声学信号捉取信息（与功率分析类似）。</li><li>差别错误分析，隐密数据在程序运行发生错误并输出错误信息时被发现。</li><li>数据残留（Data remanence），可使理应被删除的敏感数据被读取出来（例如冷启动攻击）。</li><li>软件初始化错误攻击，现时较为少见，行锤攻击（Row hammer）是该类攻击方式的一个实例，在这种攻击实现中，被禁止访问的存储器位置旁边的存储器空间如果被频繁访问将会有状态保留丢失的风险。</li><li>光学方式，即隐密数据被一些视觉光学仪器（如高清晰度相机、高清晰度摄影机等设备）捕捉。</li></ul><p>所有的攻击类型都利用了加密/解密系统在进行加密/解密操作时算法逻辑没有被发现缺陷，但是通过物理效应提供了有用的额外信息（这也是称为“旁路”的缘由），而这些物理信息往往包含了密钥、密码、密文等隐密数据。</p><p>而上面 Spring Security 中的那段代码就是为了防止计时攻击。</p><p>具体是怎么做的呢？假设 Spring Security 从数据库中没有查到用户信息就直接抛出异常了，没有去执行 mitigateAgainstTimingAttack 方法，那么黑客经过大量的测试，再经过统计分析，就会发现有一些登录验证耗时明显少于其他登录，进而推断出登录验证时间较短的都是不存在的用户，而登录耗时较长的是数据库中存在的用户。</p><p>现在 Spring Security 中，通过执行 mitigateAgainstTimingAttack 方法，无论用户存在或者不存在，登录校验的耗时不会有明显差别，这样就避免了计时攻击。</p><p>可能有小伙伴会说，passwordEncoder.matches 方法执行能耗费多少时间呀？这要看你怎么计时了，时间单位越小，差异就越明显：毫秒（ms）、微秒（µs）、奈秒（ns）、皮秒（ps）、飛秒（fs）、阿秒（as）、仄秒（zs）。</p><p>另外，Spring Security 为了安全，passwordEncoder 中引入了一个概念叫做自适应单向函数，这种函数故意执行的很慢并且消耗大量系统资源，所以非常有必要进行计时攻击防御。</p><p>关于自适应单向函数，这是另外一个故事了，松哥抽空再和小伙伴们聊～</p><p>好啦，今天就先和小伙伴们聊这么多，小伙伴们决定有收获的话，记得点个在看鼓励下松哥哦～</p><p>不知不觉，Spring Security 系列已经连载了 49 篇啦，感兴趣的小伙伴也可以看看本系列其他文章哦：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li><li><a href="https://mp.weixin.qq.com/s/edtYkmgx_SnYoqsy-yFmsQ" target="_blank" rel="noopener">神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</a></li><li><a href="https://mp.weixin.qq.com/s/42-rjiZShvZXYM_ULQt0YQ" target="_blank" rel="noopener">Spring Security 配置中的 and 到底该怎么理解？</a></li><li><a href="https://mp.weixin.qq.com/s/f1teXTEuDR7S0j_Ml2qL8g" target="_blank" rel="noopener">一文搞定 Spring Security 异常处理机制！</a></li><li><a href="https://mp.weixin.qq.com/s/dm2SmUzb7vQZA3C0NFp86A" target="_blank" rel="noopener">写了这么多年代码，这样的登录方式还是头一回见！</a></li><li><a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a></li><li><a href="https://mp.weixin.qq.com/s/sF4vPZQv7rtBYhBhmONJ5w" target="_blank" rel="noopener">Spring Security 可以同时对接多个用户表？</a></li><li><a href="https://mp.weixin.qq.com/s/4dcQ6lohB3sEcnkAXxdZwg" target="_blank" rel="noopener">在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/LBgZu-mBifPG_-azCG7Lcg" target="_blank" rel="noopener">花式玩 Spring Security ，这样的用户定义方式你可能没见过！</a></li><li><a href="https://mp.weixin.qq.com/s/vP-QGm9GNxMInIeGSZvWwQ" target="_blank" rel="noopener">深入理解 WebSecurityConfigurerAdapter【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/d2o9QpK1EfBMRR8zfHhv2g" target="_blank" rel="noopener">盘点 Spring Security 框架中的八大经典设计模式</a></li><li><a href="https://mp.weixin.qq.com/s/D0weIKPto4lcuwl9DQpmvQ" target="_blank" rel="noopener">Spring Security 初始化流程梳理</a></li><li><a href="https://mp.weixin.qq.com/s/0WOefpO6-aYSIRNiNnijyg" target="_blank" rel="noopener">为什么你使用的 Spring Security OAuth 过期了？松哥来和大家捋一捋！</a></li><li><a href="https://mp.weixin.qq.com/s/-kDQbP1htEfn_8n7ZfKqmA" target="_blank" rel="noopener">一个诡异的登录问题</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥最近在研究 Spring Security 源码，发现了很多好玩的代码，抽空写几篇文章和小伙伴们分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>一个诡异的登录问题</title>
    <link href="http://www.javaboy.org/2020/0831/springsecurity-login.html"/>
    <id>http://www.javaboy.org/2020/0831/springsecurity-login.html</id>
    <published>2020-08-31T01:53:00.000Z</published>
    <updated>2020-10-09T00:44:36.089Z</updated>
    
    <content type="html"><![CDATA[<p>美好周末，从解 BUG 开始！</p><a id="more"></a><p>周五本来想早点下班，临了有一个简单的需求突然提上来，心想着整完了就走，没想到一下折腾了 1 个多小时才搞定，愉快的周末就从加班中开启了。回到家里把这件事复盘一下，小伙伴们看看是否能够从中 GET 到一些未知的东西。</p><p>需求是这样的：</p><p>项目是 <code>Spring Boot</code> 项目，里边对请求进行了划分，有的请求是 <code>HTTP</code> 协议，有的请求是 <code>HTTPS</code> 协议，项目规定，有一些请求必须是 <code>HTTPS</code> 协议，例如 /https 接口，该接口必须使用 <code>HTTPS</code> 协议访问，如果用户使用了 <code>HTTP</code> 协议访问，那么会自动发生请求重定向，重定向到 <code>HTTPS</code> 协议上；同时也有一些请求必须是 <code>HTTP</code> 协议，例如 /http 接口，该接口必须使用 <code>HTTP</code> 协议访问，如果用户使用了 <code>HTTPS</code> 协议访问，那么会自动发生请求重定向，重定向到 <code>HTTP</code> 协议上。对于一些没有明确规定的接口，当用户访问 <code>HTTP</code> 协议时，不需要自动跳转到 <code>HTTPS</code> 协议上，即用户如果使用 <code>HTTP</code> 协议就是 <code>HTTP</code> 协议，用户如果使用 <code>HTTPS</code> 协议就是 <code>HTTPS</code> 协议。</p><p>这个任务实在是小 case，由于项目本身已经支持 <code>HTTPS</code> 了，我只需要再添加一个 <code>HTTP</code> 监听的端口即可(<a href="https://mp.weixin.qq.com/s/Jf6VF1bHdHAjnk_5-FdSIA" target="_blank" rel="noopener">Spring Boot 中配置 Https</a>)，添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="hljs-keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> Connector <span class="hljs-title">createTomcatConnector</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Connector connector = <span class="hljs-keyword">new</span></span><br><span class="line">                Connector(<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">        connector.setScheme(<span class="hljs-string">"http"</span>);</span><br><span class="line">        connector.setPort(<span class="hljs-number">8080</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成后，项目启动日志如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200830112713.png" alt></p><p>可以看到，项目已经同时支持 <code>HTTPS</code> 和 <code>HTTP</code> 了，两者分别在不同的端口上监听。</p><p>接下来利用 Spring Security 中的 <code>HTTPS</code> 校验转发功能对请求进行区分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.</span><br><span class="line"><span class="hljs-comment">//省略其他</span></span><br><span class="line">                .requiresChannel()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/https"</span>).requiresSecure()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/http"</span>).requiresInsecure()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，so easy!</p><p>配置完成后，启动项目，如下两个地址都可以访问到登录页面：</p><ul><li><a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a></li><li><a href="https://localhost:8444/login" target="_blank" rel="noopener">https://localhost:8444/login</a></li></ul><p>可以使用任意一个地址登录。</p><p>假如使用了 <code>HTTP</code> 协议登录，登录成功后，如果直接访问 <code>http://localhost:8080/http</code> 请求，可以直接访问到，没有任何问题；如果登录成功后访问 <code>http://localhost:8080/https</code> 请求，则会自动重定向到 <code>https://localhost:8444/https</code>，一切看起来都很完美。</p><p>似乎可以下班了。</p><p>别急，我再用 <code>HTTPS</code> 登录测试了，打开 <code>https://localhost:8444/login</code> 页面，登录成功，请求 <code>https://localhost:8444/https</code> 地址没有问题，请求 <code>https://localhost:8444/http</code> ，傻眼了。</p><p>当我使用 <code>HTTPS</code> 登录成功后，请求 <code>https://localhost:8444/http</code> 地址时，按理说会重定向到 <code>http://localhost:8080/http</code>，结果并没有，而是重定向到登录页面，这是咋回事？更为诡异的是，现在在登录页面，无论我怎么做，都登录失败。</p><p>看来 965 到底是海市蜃楼，还是继续解决问题吧。</p><p>那就从登录开始，好端端的为什么突然就无法登录了呢？</p><p>先清除浏览器缓存试试？咦，清除浏览器缓存后登录成功了！</p><p>经过多次尝试后，我总结出来了如下规律：</p><p>如果使用 <code>HTTP</code> 协议登录，登录成功后，HTTP 协议和 <code>HTTPS</code> 协议之间互相重定向没有任何问题。如果使用了 <code>HTTPS</code> 协议登录，登录成功后，HTTPS 协议重定向到 <code>HTTP</code> 协议时，需要重新登录，并且在登录页面总是登录失败，需要清除浏览器缓存才能登录成功。</p><blockquote><p>先找到规律这个很重要，有的小伙伴微信问松哥问题时候，喜欢说，<code>这个东西它一会可以一会又不行</code>，老实说，这个问题提的非常业余！所有看似无规律的 BUG 背后都是有规律的，找到规律才是解决 BUG 的第一步。</p></blockquote><p>在整个过程中，最为诡异的是从 <code>HTTPS</code> 重定向到 <code>HTTP</code> 之后，无论怎么样都登录不了，服务端重启也没用，只能清除浏览器缓存，这个非常奇怪，我觉得就先从这个地方入手 DEBUG。</p><p>那就 DEBUG，浏览器发送登录请求，服务端我把 <code>Spring Security</code> 登录流程走了一遍，貌似没问题，登录成功后重定向到 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，这也是正常的，继续 DEBUG，重定向到 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 地址时，出现了一点点意外，该请求在 Spring Security 过滤器链的最后一个环节 FilterSecurityInterceptor 中执行时候抛出异常了，异常原因是因为检查用户身份，发现这是个匿名用户！（<a href="https://mp.weixin.qq.com/s/f1teXTEuDR7S0j_Ml2qL8g" target="_blank" rel="noopener">一文搞定 Spring Security 异常处理机制！</a>）</p><p>不对呀，一开始已经登录成功了，怎么会是匿名用户呢？<code>Spring Security</code> 在登录成功后，会将用户信息保存在 <code>SecurityContextHolder</code> 中（<a href="https://mp.weixin.qq.com/s/4dcQ6lohB3sEcnkAXxdZwg" target="_blank" rel="noopener">在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</a>），是不是没保存？重新检查登录过程，发现登录成功后是保存了用户信息的。但是当登录成功后再次发送请求却说我没登录，还剩一种可能，是不是前端请求的问题，JSESSIONID 拿错了？或者没拿？</p><p>浏览器 F12 检查前端请求，发现登录成功后，重定向到 <code>http://localhost:8080/</code> 地址时，果然没有携带 Cookie！</p><p>现在的问题是为什么它就不携带 Cookie 呢？</p><p>一瞬间脑子里闪过了诸多可能性，是不是浏览器 SameSite 机制导致的？是不是。。。最后思维定格在 Cookie 的 Secure 标记上。</p><p>如果请求是 HTTPS，则服务端响应的 Cookie 中含有 Secure 标记：</p><p><img src="http://img.itboyhub.com/2020/07/图9-14.png" alt></p><p>这个标记表示该 Cookie 只可以在安全环境下（HTTPS）传输，如果请求是 <code>HTTP</code> 协议，则不会携带该 Cookie。这样就能解释通为什么登录成功后重定向时不携带 Cookie 了。</p><p>新的问题来了，我使用的是 <code>HTTP</code> 协议登录，为什么 Cookie 中有 Secure 标记呢？回答这个问题，我们要完整的梳理一遍登录过程。</p><p>首先我们使用 <code>HTTPS</code> 协议登录，登录成功后，返回的 Cookie 中含有 Secure 标记，接下来我们访问 <code>https://localhost:8444/http</code>，该请求重定向到 <code>http://localhost:8080/http</code>，重定向的请求是 <code>HTTP</code> 请求，而 Cookie 只可以在 <code>HTTPS</code> 环境下传输，所以不会携带 Cookie，服务端以为这是一个匿名请求，所以要求重定向到登录页面，回到登录页面继续登录，此时发起的登录是 <code>HTTP</code> 请求，即端口是 8080，由于 Cookie 并不会区分端口号，所以使用 8080 登录成功后，使用的还是之前 8444 生成的 Cookie，但是 8080 又无法在发送请求时，自动携带该 Cookie，所以看到的就是总是登录失败，当清除浏览器缓存后，8444 的 Cookie 就被清除了，8080 再次登录就可以生成自己的没有 Secure 标记的 Cookie，此时一切又恢复正常了。</p><p>这里边其实主要涉及到两个知识点：</p><ol><li>含有 Secure 标记的 Cookie 只可以在安全环境下（HTTPS）传输。</li><li>Cookie 是不区分端口号的，如果 Cookie 名相同，会自动覆盖，并且读取的是相同的数据。所以 8080 和 8444 并不会自动使用两个 Cookie。</li></ol><p>至此，总算搞清楚这个诡异的登录问题了。那么接下来的解决方案就很容易了。</p><p>还是那句话，所有看似无规律的 BUG 都是有规律的，找到规律才有解决问题的可能性！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美好周末，从解 BUG 开始！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>为什么你使用的 Spring Security OAuth 过期了？松哥来和大家捋一捋！</title>
    <link href="http://www.javaboy.org/2020/0828/spring-security-oauth2.html"/>
    <id>http://www.javaboy.org/2020/0828/spring-security-oauth2.html</id>
    <published>2020-08-28T01:52:45.000Z</published>
    <updated>2020-10-09T00:44:14.556Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，大家在用 Spring Security OAuth2 时可能发现有很多类过期了。</p><a id="more"></a><p>大家在选择 OAuth2 依赖的时候，可能也会困惑，有好几个地方都可以选：</p><p><img src="http://img.itboyhub.com/2020/07/20200827095618.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200827095652.png" alt></p><p>那么到底选择哪一个依赖合适呢？这不同的依赖又有什么区别？今天松哥就来和大家聊一聊 Spring Security 中关于 OAuth2 的恩怨。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来大致介绍一下 OAuth2 在 Spring 框架中的发展历程。</p><p>大约十年前，Spring 引入了一个社区驱动的开源项目 Spring Security OAuth，并将其纳入 Spring 项目组合中。到今天，它已经发展成为一个成熟的项目，可以支持大部分 OAuth 规范，包括<code>资源服务器</code>、<code>客户端</code>和<code>授权服务器</code>等。</p><p>现在它已成为 UAA（User Account and Authentication Server） 的基础。Spring Security OAuth 项目已成为一个样板项目，它证明了 Spring 社区可以出色的完成工作。</p><p>然而早期的项目存在这样一些问题：</p><ol><li>OAuth 是在很早的时候完成的，开发者无法预料未来的变化以及这些代码到底要被怎么用，导致很多 Spring 项目提供了自己的 OAuth 支持，这就带来了 OAuth2 支持的碎片化。</li><li>最早的 OAuth 项目同时支持 OAuth1.0 和 OAuth2.0，现在 OAuth1.0 早已经不再使用，可以放弃了。</li><li>现在我们有更多的库可以选择，可以在这些库的基础上去开发，以便更好的支持 JWT 等新玩意。</li></ol><p>基于以上这些原因，官方决定在社区成功的基础上，重写 Spring Security OAuth，以更好地协调 Spring 和 OAuth，并简化代码库，以使 Spring 的 OAuth 支持更加灵活。</p><p>然而，在重写的过程中，发生了不少波折。</p><h2 id="2018-01-30"><a href="#2018-01-30" class="headerlink" title="2018.01.30"></a>2018.01.30</h2><p>事情得从 2018 年 1 月 30 号讲起。</p><p>那天 Spring 官方发了一个通知，说是要逐渐停止现有的 OAuth2 支持，而在 Spring Security5 中构建下一代 OAuth2.0 支持。</p><p>为什么要这样呢？</p><p>大家知道，OAuth2 只是一种协议，Spring 框架通过代码对这种协议进行落地。</p><p>当时 OAuth2 的落地方案比较混乱（这种混乱到今天依然存在），在 Spring Security OAuth、Spring Cloud Security、Spring Boot 1.5.x 以及当时最新的 Spring Security5.x 中都提供了对 OAuth2 的实现。</p><p>以至于当开发者需要使用 OAuth2 时，不得不问，到底选哪一个依赖合适呢？已经有三个地方提供了 OAuth2 的支持，已经够混乱了，为什么还要在最新的 Spring Security5.x 中继续提供实现呢？</p><p>太乱了！</p><p>所以 Spring 官方决定有必要将 OAuth2.0 的支持统一到一个项目中，以便为用户提供明确的选择并避免任何潜在的混乱，同时 OAuth2 的开发文档也要重新编写，以方便开发人员学习。所有的决定将在 Spring Security5 中开始，构建下一代 OAuth2.0 的支持。</p><p>从那个时候起，Spring Security OAuth 项目就正式处于维护模式。官方将提供至少 1 年的错误/安全修复程序，并且会考虑添加次要功能，但不会添加主要功能。同时将 Spring Security OAuth 中的所有功能重构到 Spring Security5.x 中。</p><p><strong>老实说，这是一个英明的决定，当时并没有引起太多的反响。但是接下来的事情就不是那么顺利了。</strong></p><h2 id="2019-11-14"><a href="#2019-11-14" class="headerlink" title="2019.11.14"></a>2019.11.14</h2><p>时间到了 2019.11.14。</p><p>这天，官方又发了个通知。</p><p>先说了 Spring Security OAuth 在迁往 Spring Security5.x 的过程非常顺利，大部分迁移工作已经完成了，剩下的将在 5.3 版本中完成迁移，在迁移的过程中还添加了许多新功能，包括对 OpenID Connect1.0 的支持</p><p>接下来话锋一转，说了一件很多人难以接受的事情，那就是将<strong>不再提供对授权服务器的支持</strong>（要是小伙伴们不懂什么是授权服务器，可以在公众号江南一点雨后台回复 <code>OAuth2</code> ，有松哥写的 OAuth2 教程）。</p><p>不提供的原因，官方给了两个：</p><ol><li>在 2019 年，将有大量的商业和开源授权服务器可用。</li><li>授权服务器是使用一个库来构建产品，而 Spring Security 作为框架，并不适合做这件事情。</li></ol><p>一石激起千层浪，许多开发者表示对此难以接受。这件事也在 Spring 社区引发了激烈的讨论，好在 Spring 官方愿意倾听来自社区的声音。</p><h2 id="2020-04-15"><a href="#2020-04-15" class="headerlink" title="2020.04.15"></a>2020.04.15</h2><p>这天，官方又发了个通知。</p><p>这次宣布了 Spring Authorization Server 项目。这是一个由 Spring Security 团队领导的社区驱动的项目，致力于向 Spring 社区提供 Authorization Server 支持。</p><p>官方倾听了来自社区的声音，决定继续提供授权服务器。</p><p>这次只是宣布了一下，算是安抚了一下社区的情绪，但是项目还没开发出来。</p><h2 id="2020-08-21"><a href="#2020-08-21" class="headerlink" title="2020.08.21"></a>2020.08.21</h2><p>Spring Authorization Server 0.0.1 正式发布！</p><p>同时公布了项目源码地址：<a href="https://github.com/spring-projects-experimental/spring-authorization-server" target="_blank" rel="noopener">https://github.com/spring-projects-experimental/spring-authorization-server</a></p><p>在这个版本中，主要提供了如下功能：</p><ul><li>OAuth 2.0授权代码授予  -RFC 6749</li><li>OAuth 2.0客户端凭据授予  -RFC 6749</li><li>JSON Web令牌（JWT）  -RFC 7519</li><li>JSON Web签名（JWS）  -RFC 7515</li><li>JSON Web密钥（JWK）  -RFC 7517</li><li>密钥管理，用于在签署JWT（JWS）时提供密钥</li></ul><p>其他功能还在紧锣密鼓的开发中。</p><p>这就是 OAuth2 最近几年的变更之路。</p><h2 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h2><p>回到最开始的问题。</p><p><strong>类过期了怎么办？</strong></p><p>类过期是因为旧的写法已经不被支持，松哥举个简单例子，以前我们定义资源服务器是这样的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在迁移到 Spring Security5.x 中之后，我们是这样定义的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResourceServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .oauth2ResourceServer()</span><br><span class="line">                .opaqueToken()</span><br><span class="line">                .introspectionUri(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>)</span><br><span class="line">                .introspectionClientCredentials(<span class="hljs-string">"javaboy"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码作用是一样的。后面的是目前最新写法，不存在过期的问题。</p><p><strong>选哪个依赖</strong></p><p>现在大家已经知道为什么会存在多种不同的依赖，Spring Cloud Security OAuth2 中使用旧的写法并不会提示过期，但是它同时也支持新的写法，建议小伙伴们用新的写法，反正迟早都要改过来。</p><p>松哥在四月份的时候出了一个 OAuth2 的教程，当时就是基于 Spring Cloud Security OAuth2 来做的，用了旧的写法，但是没有提示过期的问题，感兴趣的小伙伴可以看看（公众号后台回复 OAuth2），无论新旧，只要会其中一个，另外一个上手就很容易了。</p><p>当然，后面我也会结合最新的 Spring Security5.x 来更新一套 OAuth2 教程，欢迎大家关注～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，大家在用 Spring Security OAuth2 时可能发现有很多类过期了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第 9 篇，深入分析 FactoryBean</title>
    <link href="http://www.javaboy.org/2020/0824/spring-factorybean.html"/>
    <id>http://www.javaboy.org/2020/0824/spring-factorybean.html</id>
    <published>2020-08-24T01:52:24.000Z</published>
    <updated>2020-10-09T00:44:07.432Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们在面试的时候，有一个经典的问题：</p><a id="more"></a><ul><li>Spring 中 FactoryBean 和 BeanFactory 有什么区别？</li></ul><p>原本是风马牛不相及的两个东西，只是因为单词前后颠倒了一下，就变成了一个高频面试题！</p><p>在本系列前面文章中松哥在和大家分析 DefaultListableBeanFactory 容器的时候涉及到了一点点 BeanFactory 的知识，不过在那篇文章中 BeanFactory 毕竟不是主角，以后的文章松哥还会和大家再去探讨 BeanFactory 的功能。</p><p>今天我们就先来看看 FactoryBean 是什么？</p><p>只要我们分别将 FactoryBean 和 BeanFactory 的功能搞清楚，上面的那道面试题自然不在话下。</p><p>阅读本系列前面文章，有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li><a href="https://mp.weixin.qq.com/s/8WnRZtHmstum23Ut5EXAug" target="_blank" rel="noopener">手把手教你搭建 Spring 源码分析环境</a></li><li><a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/dDX7ijnhkrMwlkUcCqOlnw" target="_blank" rel="noopener">Spring 源码解读第七弹！bean 标签的解析</a></li><li><a href="https://mp.weixin.qq.com/s/_FG7qePUVO42Vh2Pfhj-rg" target="_blank" rel="noopener">Spring 源码第 8 篇，各种属性的解析</a></li></ol><h2 id="1-一个-Demo"><a href="#1-一个-Demo" class="headerlink" title="1.一个 Demo"></a>1.一个 Demo</h2><p>我们先从一个简单的 Demo 开始。</p><p>新建一个 Maven 项目，引入 Spring 依赖，然后创建一个 HelloService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello javaboy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再创建一个 HelloService 的工厂类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">HelloService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> HelloService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新建的 HelloServiceFactoryBean 类实现了 FactoryBean 接口，并指定了 HelloService 泛型。</p><p>接下来我们在 beans.xml 文件中配置 HelloServiceFactoryBean 实例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.springdemo03.HelloServiceFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"helloService"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载该配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">    Object helloService = ctx.getBean(<span class="hljs-string">"helloService"</span>);</span><br><span class="line">    System.out.println(helloService.getClass().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载 XML 配置文件，并获取 Bean 实例，然后将 Bean 实例的类型打印出来。</p><p>按照我们之前的理解，这里获取到的 Bean 应该是 HelloServiceFactoryBean 的实例，但是实际打印结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class org.javaboy.springdemo03.HelloService</span><br></pre></td></tr></table></figure><p>竟然是 HelloService！</p><p>到底怎么回事？我们得从 FactoryBean 接口开始讲起。</p><h2 id="2-FactoryBean-接口"><a href="#2-FactoryBean-接口" class="headerlink" title="2.FactoryBean 接口"></a>2.FactoryBean 接口</h2><p>FactoryBean 在 Spring 框架中具有重要地位，Spring 框架本身也为此提供了多种不同的实现类：</p><p><img src="http://img.itboyhub.com/2020/07/20200822112454.png" alt></p><p>按理说我们配置一个 Bean，直接在 XML 文件中进行配置即可。但是有的时候一个类的属性非常多，在 XML 中配置起来反而非常不方便，这个时候 Java 代码配置的优势就体现出来了，使用 FactoryBean 就可以通过 Java 代码配置 Bean 的相关属性。</p><p>从 Spring3.0 开始，FactoryBean 开始支持泛型，就是大家所看到的 FactoryBean<t> 形式，FactoryBean<t> 接口中一共有三个方法：</t></t></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getObject：该方法返回 FactoryBean 所创建的实例，如果在 XML 配置文件中，我们提供的 class 是一个 FactoryBean 的话，那么当我们调用 getBean 方法去获取实例时，最终获取到的是 getObject 方法的返回值。</li><li>getObjectType：返回对象的类型。</li><li>isSingleton：getObject 方法所返回的对象是否单例。</li></ul><p>所以当我们调用 getBean 方法去获取 Bean 实例的时候，实际上获取到的是 getObject 方法的返回值，那么是不是就没有办法获取 HelloServiceFactoryBean 呢？当然是有的！</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">    Object helloService = ctx.getBean(<span class="hljs-string">"&amp;helloService"</span>);</span><br><span class="line">    System.out.println(helloService.getClass().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class org.javaboy.springdemo03.HelloServiceFactoryBean</span><br></pre></td></tr></table></figure><p>小伙伴们可以看到，只需要在 Bean 的名字前面加上一个 &amp; 符号，获取到的就是 HelloServiceFactoryBean 实例了。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>根据 <a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a> 一文中的介绍，在 DefaultListableBeanFactory 中还有一个 preInstantiateSingletons 方法可以提前注册 Bean，该方法是在 ConfigurableListableBeanFactory 接口中声明的，DefaultListableBeanFactory 类实现了 ConfigurableListableBeanFactory 接口并实现了接口中的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Pre-instantiating singletons in "</span> + <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line"><span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);</span><br><span class="line"><span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="hljs-keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preInstantiateSingletons 方法的整体逻辑比较简单，就是遍历 beanNames，对符合条件的 Bean 进行实例化，而且大家注意，这里所谓的提前初始化其实就是在我们调用 getBean 方法之前，它自己先调用了一下 getBean。</p><p>这里有几个比较关键的点。</p><p>第一个就是 isFactoryBean 方法的调用，该方法就是根据 beanName 去获取 Bean 实例，进而判断是不是一个 FactoryBean，如果没有 Bean 实例（还没创建出来），则根据 BeanDefinition 去判断是不是一个 FactoryBean。</p><p>如果是 FactoryBean，则在 getBean 时自动加上了 FACTORY_BEAN_PREFIX 前缀，这个常量其实就是 &amp;，这样获取到的实例实际上就是 FactoryBean 的实例。获取到 FactoryBean 实例之后，接下来判断是否需要在容器启动阶段，调用 getObject 方法初始化 Bean，如果 isEagerInit 为 true，则去初始化。</p><p>按照我们前面的定义，这里获取到的 isEagerInit 属性为 false，即不提前加载 Bean，而是在开发者手动调用 getBean 的方法的时候才去加载。如果希望这里能够提前加载，需要重新定义 HelloServiceFactoryBean，并使之实现 SmartFactoryBean 接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceFactoryBean2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartFactoryBean</span>&lt;<span class="hljs-title">HelloService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> HelloService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEagerInit</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 SmartFactoryBean 接口之后，重写 isEagerInit 方法并返回 true，其他方法不变，重新配置 beans.xml 文件，然后启动容器。此时在容器启动时，就会提前调用 getBean 方法完成 Bean 的加载。</p><p>接下来我们来看 getBean 方法。</p><p>getBean 方法首先调用 AbstractBeanFactory#doGetBean，在该方法中，又会调用到 AbstractBeanFactory#getObjectForBeanInstance 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanInstance <span class="hljs-keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line"><span class="hljs-comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line"><span class="hljs-comment">// caller actually wants a reference to the factory.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">Object object = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Return bean instance from factory.</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="hljs-comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> synthetic = (mbd != <span class="hljs-keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码很有意思：</p><p>BeanFactoryUtils.isFactoryDereference 方法用来判断 name 是不是以 &amp; 开头的，如果是以 &amp; 开头的，表示想要获取的是一个 FactoryBean，那么此时如果 beanInstance 刚好就是一个 FactoryBean，则直接返回。并将 mbd 中的 isFactoryBean 属性设置为 true。</p><p>如果 name 不是以 &amp; 开头的，说明用户就是想获取 FactoryBean 所构造的 Bean，那么此时如果 beanInstance 不是 FactoryBean 实例，则直接返回。</p><p>如果当前的 beanInstance 是一个 FactoryBean，而用户想获取的只是一个普通 Bean，那么就会进入到接下来的代码中。</p><p>首先调用 getCachedObjectForFactoryBean 方法去从缓存中获取 Bean。如果是第一次获取 Bean，这个缓存中是没有的数据的，getObject 方法调用过一次之后，Bean 才有可能被保存到缓存中了。</p><p>为什么说有可能呢？Bean 如果是单例的，则会被保存在缓存中，Bean 如果不是单例的，则不会被保存在缓存中，而是每次加载都去创建新的。</p><p>如果没能从缓存中加载到 Bean，则最终会调用 getObjectFromFactoryBean 方法去加载 Bean。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="hljs-keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">Object object = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="hljs-comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="hljs-comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">Object alreadyThere = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (alreadyThere != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="hljs-comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="hljs-string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getObjectFromFactoryBean 方法中，首先通过 isSingleton 和 containsSingleton 两个方法判断 getObject 方法返回值是否是单例的，单例的走一条路，非单例的走另外一条路。</p><p>如果是单例的：</p><p>先去缓存中再拿一次，看能不能拿到。如果缓存中没有，调用 doGetObjectFromFactoryBean 方法去获取，这是真正的获取方法。获取到之后，进行 Bean 的后置处理，处理完成后，如果 Bean 是单例的，就缓存起来。</p><p>如果不是单例的：</p><p>不是单例就简单，直接调用 doGetObjectFromFactoryBean 方法获取 Bean 实例，然后进行后置处理就完事，也不用缓存。</p><p>接下来我们就来看看 doGetObjectFromFactoryBean 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">doGetObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName)</span> <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Do not accept a null value for a FactoryBean that's not fully</span></span><br><span class="line"><span class="hljs-comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">beanName, <span class="hljs-string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">&#125;</span><br><span class="line">object = <span class="hljs-keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了一些判断之后，最终通过 factory.getObject(); 方法获取我们想要的实例。</p><p>这就是整个 FactoryBean 的加载流程。</p><h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h2><p>FactoryBean 在 Spring 框架中有非常广泛的应用，即使我们不写上面那段代码，也还是使用了不少的 FactoryBean。</p><p>接下来松哥随便举两个例子。</p><h3 id="4-1-SqlSessionFactoryBean"><a href="#4-1-SqlSessionFactoryBean" class="headerlink" title="4.1 SqlSessionFactoryBean"></a>4.1 SqlSessionFactoryBean</h3><p>这可能是大家接触最多的 FactoryBean，当 MyBatis 整合 Spring 时，我们少不了如下一行配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"typeAliasesPackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.javaboy.meeting.model"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapperLocations"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            classpath*:org/javaboy/meeting/mapper/*.xml</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是在配置 FactoryBean。当我们单独使用 MyBatis 时候，需要有一个 SqlSessionFactory（公众号江南一点雨后台回复 MyBatis 有 MyBatis 教程），现在整合之后，没有 SqlSessionFactory 了，我们有理由相信是 SqlSessionFactoryBean 的 getObject 方法提供了 SqlSessionFactory，我们来看下其源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sqlSessionFactory == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    afterPropertiesSet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实如此！</p><h3 id="4-2-Jackson2ObjectMapperFactoryBean"><a href="#4-2-Jackson2ObjectMapperFactoryBean" class="headerlink" title="4.2 Jackson2ObjectMapperFactoryBean"></a>4.2 Jackson2ObjectMapperFactoryBean</h3><p>这也是一个大家使用相对较多的 FactoryBean。</p><p>如果项目中使用了 Jackson，同时希望在全局层面做一些配置，一般来说我们可能会用到这个类：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">"conversionService"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"objectMapper"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"simpleDateFormat"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MappingJackson2HttpMessageConverter 类的 objectMapper 属性实际上是需要一个 ObjectMapper 对象，但是我们这里却提供了一个 Jackson2ObjectMapperFactoryBean，这是因为 Jackson2ObjectMapperFactoryBean 的 getObject 方法就是我们需要的 ObjectMapper：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.objectMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-FormattingConversionServiceFactoryBean"><a href="#4-3-FormattingConversionServiceFactoryBean" class="headerlink" title="4.3 FormattingConversionServiceFactoryBean"></a>4.3 FormattingConversionServiceFactoryBean</h3><p>FormattingConversionServiceFactoryBean 也曾经出现在松哥的 SpringMVC 教程中（公众号江南一点雨后台回复 springmvc 获取教程）。</p><p>如果前端传递的参数格式是 key-value 形式，那么日期类型的参数需要服务端提供一个日期类型转换器，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> sdf.parse(source);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中对此进行配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">"conversionService"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"conversionService"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"dateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FormattingConversionServiceFactoryBean 中的 getObject 方法最终返回的是 FormattingConversionService。</p><p>类似的例子还有很多，例如 EhCacheManagerFactoryBean、YamlPropertiesFactoryBean 等，松哥就不一一赘述了，感兴趣的小伙伴可以自行查看。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天就和小伙伴们聊一聊 FactoryBean，讲了它的源码，也讲了它的用法，后面再来和大家聊一聊 BeanFactory，两个都聊完了了，文章一开始提出的面试题就不在话下了。</p><p>小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们在面试的时候，有一个经典的问题：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>凌晨 1 点的 Bug，我似乎被微信坑了一把</title>
    <link href="http://www.javaboy.org/2020/0820/weixin-bug.html"/>
    <id>http://www.javaboy.org/2020/0820/weixin-bug.html</id>
    <published>2020-08-20T01:52:02.000Z</published>
    <updated>2020-10-09T00:43:24.345Z</updated>
    
    <content type="html"><![CDATA[<p>晚上十二点了，都躺床上准备睡觉了，有小伙伴发来了消息：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/07/稿定设计导出-20200819-151343.jpg" alt></p><p>看起来好像是松哥的微信公众号后台服务挂了，同时我微信上也收到了报警信息：</p><p><img src="http://img.itboyhub.com/2020/07/20200819154551.png" alt></p><p>这感觉和公司项目上线出 BUG 一模一样，赶紧爬起来看看是啥情况。</p><p>这里要先和大家解释下微信公众号后台是怎么一回事。</p><p>大家平时看到的文章，直接在微信公众号后台编辑发布即可，不需要任何额外的开发;公众号后台的关键字自动回复功能，微信也有提供，可以在公众号后台一个一个的配置回复的关键字及其对应的信息，也可以自己开发一个后台。</p><p>松哥因为之前整了 2TB 的免费学习资料（公号后台回复 2TB），涉及到的关键字非常多，在公众号后台一个一个配置太麻烦了，我就自己开发了一个后台，专门用来处理微信公众号后台的关键字回复，并且还写了两篇技术帖：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486810&amp;idx=1&amp;sn=7a4edfa233abb041655deaf49d45c800&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 开发微信公众号（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486824&amp;idx=1&amp;sn=e0ad61b14d9b4b274d80bd145e49ded5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 开发微信公众号（二）</a></li></ul><p>如果是自己开发后台，消息的传递流程是这样：</p><p><img src="http://img.itboyhub.com/2020/07/20200819153534.png" alt></p><ol><li>首先关键字 <code>vhr</code> 这个字符从公众号上发送到了微信服务器</li><li>接下来微信服务器会把 <code>vhr</code> 转发到我自己的服务器上</li><li>我收到 <code>vhr</code> 这个字符之后，就去数据库中查询，将查询的结果，按照腾讯要求的 XML 格式进行返回</li><li>微信服务器把从我的服务器收到的信息，再发回到微信上，于是小伙伴们就看到了返回结果了</li></ol><p>大致的流程就是这个样子。</p><p>所以当小伙伴发来消息后，那我想肯定是这里的某一个环节出问题了。应该不是代码问题，代码从去年 9 月上线到现在差不多稳定运行 1 年了，所以代码出问题概率很小。</p><p>家里的网络有点慢，使用起来不太方便，而且时间比较晚了，我想着赶紧把问题解决了早点睡觉，于是第一个想到了重启大法，结果重启之后还是不行。</p><p>没办法，只能一个一个排查。</p><ol><li>首先看看数据库是否完好，因为很久之前买过一个国外的服务器，被人入侵数据库勒索比特币，所以这次第一个先检查数据库有没有问题，只要数据库没问题，就不是大事（其实数据库有问题也没关系，被入侵过之后，我已经养成了日常备份的好习惯）。</li><li>数据库没问题，那就再看看 Spring Boot 的运行日志，也未发现问题；</li><li>由于我的服务器上部署了多个服务，用了 Nginx 做反向代理，所以接着又去看了 Nginx 的访问日志，总算发现一点端倪。当我在手机上给微信公众号后台发送关键字的时候，Nginx 的访问日志中看不到相关记录，说明微信的服务器没有把关键字转发到我的服务器上面来。</li><li>猜测可能是微信服务器和我自己的服务器之间的通信受阻，会不会是我的服务调不通呢？我又用 postman 测试了自己的接口，发现没问题。</li></ol><p>这就把人难住了。接口是通的，但是就是查不到数据。一边冥思苦想一边用手机回复关键字测试，忽然发现我的另外一个微信号回复关键字可以正常响应，我又去看了 Nginx 访问日志，也可以看到相关记录，这迷之响应让我感觉我的服务其实没问题，可能是微信的问题。</p><p>有的微信可以正常回复关键字，有的不可以，我需要更多的案例来证明我的猜想。大晚上的哪里找这么多微信去呢？</p><p>忽然想到了微信公众号后台的消息功能，这个地方可以显示出所有小伙伴发送来的消息以及我的服务器给出的响应。赶紧打开看了一下，大晚上还有不少小伙伴在回复关键字查询资源，可以看到，有的小伙伴回复关键字会有正常响应：</p><p><img src="http://img.itboyhub.com/2020/07/20200819163317.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200819163354.png" alt></p><p>而有的小伙伴回复关键字则没有响应：</p><p><img src="http://img.itboyhub.com/2020/07/20200819163521.png" alt></p><p>有的小伙伴可能会问是不是我的服务不稳定呢？基本上可以排除这一可能，有两个原因：</p><ol><li>我一个手机上装了两个微信，这边刚发送完关键字那边就发送，但是一个有响应而另一个没响应。</li><li>假如服务不稳定，Nginx 上也应该收到请求，但实际上 Nginx 日志中并未显示收到微信发来的请求。</li></ol><p>这个时候从一个小伙伴处得知，他在当天下午给一个公众号回复关键字的时候也出现了类似问题：</p><p><img src="http://img.itboyhub.com/2020/07/20200819221323.png" alt></p><p>虽然没有证据表明这两个就一定有关系，但是我还是倾向于相信是微信出问题了。</p><p>看着小伙伴们在后台回复消息却没有响应，我也很焦急，但是却没有办法，已经快两点了，睡觉吧，睡一觉就好了，谁知道呢。</p><p>整个过程最让我惊奇的是小伙伴们太刻苦了，凌晨一点服务器上 Nginx 的访问日志一直在刷新，看到还有人在访问我的博客网站。</p><p>第二天早上醒来的时候，服务还是没有恢复，到了早上十点左右的时候，我什么都没做，服务自动恢复了，至少我自己这边几个微信号都可以正常回复关键字了。</p><p>这一波折腾，让我本就不充裕的睡眠雪上加霜。不知道小伙伴们周二有没有遇到这个问题？下次小伙伴们在后台回复关键字的时候如果遇到这个问题，直接公众号下方菜单加我微信反映即可，松哥会及时想办法或者将你需要的资源私发给大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上十二点了，都躺床上准备睡觉了，有小伙伴发来了消息：&lt;/p&gt;
    
    </summary>
    
      <category term="weixin" scheme="http://www.javaboy.org/categories/weixin/"/>
    
    
      <category term="weixin" scheme="http://www.javaboy.org/tags/weixin/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第 8 篇，各种属性的解析</title>
    <link href="http://www.javaboy.org/2020/0817/spring-attribute-resolve.html"/>
    <id>http://www.javaboy.org/2020/0817/spring-attribute-resolve.html</id>
    <published>2020-08-17T01:51:39.000Z</published>
    <updated>2020-10-09T00:43:57.876Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 源码解析第 8 篇，继续。</p><a id="more"></a><p>上篇文章我们分析了 bean 标签的解析过程，但是主要是涉及到一些简单的属性，一些冷门属性如 lookup-method 等没有和大家分析，主要是考虑到这些属性大家可能用得少，因此我上周录制了一个简单的视频，先带领小伙伴们复习了一下这些冷门属性的用法：</p><!--插入视频--><p>现在关于 bean 节点的配置大家都了解了，我们接下来就来看下完整的解析过程。</p><p>阅读本系列前面文章，有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li><a href="https://mp.weixin.qq.com/s/8WnRZtHmstum23Ut5EXAug" target="_blank" rel="noopener">手把手教你搭建 Spring 源码分析环境</a></li><li><a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/dDX7ijnhkrMwlkUcCqOlnw" target="_blank" rel="noopener">Spring 源码解读第七弹！bean 标签的解析</a></li></ol><h2 id="1-解析方法回顾"><a href="#1-解析方法回顾" class="headerlink" title="1.解析方法回顾"></a>1.解析方法回顾</h2><p>上篇文章我们最终分析到下面这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));</span><br><span class="line">String className = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line">bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"><span class="hljs-keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="hljs-string">"Bean class ["</span> + className + <span class="hljs-string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="hljs-string">"Class that bean class ["</span> + className + <span class="hljs-string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="hljs-string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseBeanDefinitionAttributes 方法用来解析普通属性，我们已经在上篇文章中分析过了，这里不再赘述，今天主要来看看其他几个方法的解析工作。</p><h2 id="2-Description"><a href="#2-Description" class="headerlink" title="2.Description"></a>2.Description</h2><p>首先是 description 的解析，直接通过 DomUtils.getChildElementValueByTagName 工具方法从节点中取出 description 属性的值。这个没啥好说的。</p><p>小伙伴们在分析源码时，这些工具方法如果你不确定它的功能，或者想验证它的其他用法，可以通过 IDEA 提供的 Evaluate Expression 功能现场调用该方法，进而验证自己想法，就是下图标出来的那个计算器小图标，点击之后，输入你想执行的代码：</p><p><img src="http://img.itboyhub.com/2020/07/20200815182111.png" alt></p><h2 id="3-parseMetaElements"><a href="#3-parseMetaElements" class="headerlink" title="3.parseMetaElements"></a>3.parseMetaElements</h2><p>这个方法主要是解析 meta 属性。前面的视频中已经讲了，这个 meta 属性是保存在 BeanDefinition 中的，也是从 BeanDefinition 中获取的，按照这个思路，来看解析代码就很容易懂了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseMetaElements</span><span class="hljs-params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>&#123;</span><br><span class="line">NodeList nl = ele.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">Element metaElement = (Element) node;</span><br><span class="line">String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">BeanMetadataAttribute attribute = <span class="hljs-keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">attribute.setSource(extractSource(metaElement));</span><br><span class="line">attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，遍历元素，从中提取出 meta 元素的值，并构建出 BeanMetadataAttribute 对象，最后存入 GenericBeanDefinition 对象中。</p><p>有小伙伴说不是存入 BeanMetadataAttributeAccessor 中吗？这其实是 GenericBeanDefinition 的父类，BeanMetadataAttributeAccessor 专门用来处理属性的加载和读取，相关介绍可以参考松哥前面的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li></ul><h2 id="4-parseLookupOverrideSubElements"><a href="#4-parseLookupOverrideSubElements" class="headerlink" title="4.parseLookupOverrideSubElements"></a>4.parseLookupOverrideSubElements</h2><p>这个方法是为了解析出 lookup-method 属性，在前面的视频中松哥已经和大家聊过，lookup-method 可以动态替换运行的方法，按照这个思路，我们来看下这个方法的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseLookupOverrideSubElements</span><span class="hljs-params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line">String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">String beanRef = ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">LookupOverride override = <span class="hljs-keyword">new</span> LookupOverride(methodName, beanRef);</span><br><span class="line">override.setSource(extractSource(ele));</span><br><span class="line">overrides.addOverride(override);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这里遍历元素，从 lookup-method 属性中，取出来 methodName 和 beanRef 属性，构造出 LookupOverride 然后存入 GenericBeanDefinition 的 methodOverrides 属性中。</p><p>存入 GenericBeanDefinition 的 methodOverrides 属性中之后，我们也可以在代码中查看：</p><p><img src="http://img.itboyhub.com/2020/07/20200815185711.png" alt></p><h2 id="5-parseReplacedMethodSubElements"><a href="#5-parseReplacedMethodSubElements" class="headerlink" title="5.parseReplacedMethodSubElements"></a>5.parseReplacedMethodSubElements</h2><p>parseReplacedMethodSubElements 这个方法主要是解析 replace-method 属性的，根据前面视频的讲解，replace-method 可以实现动态替换方法，并且可以在替换时修改方法。</p><p>按照这个思路，该方法就很好理解了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseReplacedMethodSubElements</span><span class="hljs-params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123;</span><br><span class="line">Element replacedMethodEle = (Element) node;</span><br><span class="line">String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span><br><span class="line">ReplaceOverride replaceOverride = <span class="hljs-keyword">new</span> ReplaceOverride(name, callback);</span><br><span class="line"><span class="hljs-comment">// Look for arg-type match elements.</span></span><br><span class="line">List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span><br><span class="line"><span class="hljs-keyword">for</span> (Element argTypeEle : argTypeEles) &#123;</span><br><span class="line">String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span><br><span class="line">match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(match)) &#123;</span><br><span class="line">replaceOverride.addTypeIdentifier(match);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">replaceOverride.setSource(extractSource(replacedMethodEle));</span><br><span class="line">overrides.addOverride(replaceOverride);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name 获取到的是要替换的旧方法，callback 则是获取到的要替换的新方法，接下来再去构造 ReplaceOverride 对象。</p><p>另外由于 replace-method 内部还可以再配置参数类型，所以在构造完 ReplaceOverride 对象之后，接下来还要去解析 arg-type。</p><h2 id="6-parseConstructorArgElements"><a href="#6-parseConstructorArgElements" class="headerlink" title="6.parseConstructorArgElements"></a>6.parseConstructorArgElements</h2><p>parseConstructorArgElements 这个方法主要是用来解析构造方法的。这个大家日常开发中应该接触的很多。如果小伙伴们对于各种各样的构造方法注入还不太熟悉，可以在微信公众号江南一点雨后台回复 spring5，获取松哥之前录制的免费 Spring 入门教程，里边有讲。</p><p>我们来看下构造方法的解析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConstructorArgElements</span><span class="hljs-params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) &#123;</span><br><span class="line">parseConstructorArgElement((Element) node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConstructorArgElement</span><span class="hljs-params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line"><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">error(<span class="hljs-string">"'index' cannot be lower than 0"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">Object value = parsePropertyValue(ele, bd, <span class="hljs-keyword">null</span>);</span><br><span class="line">ConstructorArgumentValues.ValueHolder valueHolder = <span class="hljs-keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="hljs-keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">error(<span class="hljs-string">"Ambiguous constructor-arg entries for index "</span> + index, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">error(<span class="hljs-string">"Attribute 'index' of tag 'constructor-arg' must be an integer"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">Object value = parsePropertyValue(ele, bd, <span class="hljs-keyword">null</span>);</span><br><span class="line">ConstructorArgumentValues.ValueHolder valueHolder = <span class="hljs-keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line">bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造函数最终在 parseConstructorArgElement 方法中解析。</p><ol><li>一开始先去获取 name，index 以及 value 属性，因为构造方法的参数可以指定 name，也可以指定下标。</li><li>先去判断 index 是否有值，进而决定按照 index 解析还是按照 name 解析。</li><li>无论哪种解析方式，都是通过 parsePropertyValue 方法将 value 解析出来。</li><li>解析出来的子元素保存在 ConstructorArgumentValues.ValueHolder 对象中。</li><li>如果是通过 index 来解析参数，最终调用 addIndexedArgumentValue 方法保存解析结果，如果是通过 name 来解析参数，最终通过 addGenericArgumentValue 方法来保存解析结果。</li></ol><h2 id="7-parsePropertyElements"><a href="#7-parsePropertyElements" class="headerlink" title="7.parsePropertyElements"></a>7.parsePropertyElements</h2><p>parsePropertyElements 方法用来解析属性注入。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parsePropertyElements</span><span class="hljs-params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">parsePropertyElement((Element) node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parsePropertyElement</span><span class="hljs-params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">error(<span class="hljs-string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">error(<span class="hljs-string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="hljs-string">"'"</span>, ele);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">PropertyValue pv = <span class="hljs-keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">parseMetaElements(ele, pv);</span><br><span class="line">pv.setSource(extractSource(ele));</span><br><span class="line">bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面看了那么多，再看这个方法就比较简单了。这里最终还是通过 parsePropertyValue 方法解析出 value，并调用 addPropertyValue 方法来存入相关的值。</p><h2 id="8-parseQualifierElements"><a href="#8-parseQualifierElements" class="headerlink" title="8.parseQualifierElements"></a>8.parseQualifierElements</h2><p>parseQualifierElements 就是用来解析 qualifier 节点的，最终也是保存在对应的属性中。解析过程和前面的类似，我就不再赘述了，我们来看下解析结果：</p><p><img src="http://img.itboyhub.com/2020/07/20200815205009.png" alt></p><h2 id="9-再谈-BeanDefinition"><a href="#9-再谈-BeanDefinition" class="headerlink" title="9.再谈 BeanDefinition"></a>9.再谈 BeanDefinition</h2><p>这里的属性解析完了都是保存在 GenericBeanDefinition 对象中，而该对象将来可以用来构建一个 Bean。</p><p>在 Spring 容器中，我们广泛使用的是一个一个的 Bean，BeanDefinition 从名字上就可以看出是关于 Bean 的定义。</p><p>事实上就是这样，我们在 XML 文件中配置的 Bean 的各种属性，这些属性不仅仅是和对象相关，Spring 容器还要解决 Bean 的生命周期、销毁、初始化等等各种操作，我们定义的关于 Bean 的生命周期、销毁、初始化等操作总得有一个对象来承载，那么这个对象就是 BeanDefinition。</p><p>XML 中定义的各种属性都会先加载到 BeanDefinition 上，然后通过 BeanDefinition 来生成一个 Bean，从这个角度来说，BeanDefinition 和 Bean 的关系有点类似于类和对象的关系。</p><p>在 Spring 中，主要有三种类型的 BeanDefinition：</p><ul><li>RootBeanDefinition</li><li>ChildBeanDefinition</li><li>GenericBeanDefinition</li></ul><p>在 Spring 中，如果我们为一个 Bean 配置了父 Bean，父 Bean 将被解析为 RootBeanDefinition，子 Bean 被解析为 ChildBeanDefinition，要是没有父 Bean，则被解析为 RootBeanDefinition。</p><p>GenericBeanDefinition 是从 Spring2.5 以后新加入的 BeanDefinition 实现类。GenericBeanDefinition 可以动态设置父 Bean，同时兼具 RootBeanDefinition 和 ChildBeanDefinition 的功能。</p><p>目前普遍使用的就是 GenericBeanDefinition，所以我们看到前面的解析结果也是保存到 GenericBeanDefinition 中的。</p><p>关于 BeanDefinition 的更多信息，小伙伴们可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></p><p>好啦，Spring 第 8 篇，我们就先聊这么多，小伙伴们要是觉得有收获，记得点个在看鼓励下哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 源码解析第 8 篇，继续。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>松哥最近帮助一个自学的弟弟成功上岸了，挺有成就感的！</title>
    <link href="http://www.javaboy.org/2020/0812/zixue.html"/>
    <id>http://www.javaboy.org/2020/0812/zixue.html</id>
    <published>2020-08-12T01:51:15.000Z</published>
    <updated>2020-10-09T00:43:17.389Z</updated>
    
    <content type="html"><![CDATA[<p>表弟和未来的小舅子分别在 7 月 19 和 7 月 20 号来到深圳，想在深圳找份 Java 开发的工作。我抽空给他们指导了一下，两人上上周均已拿到 offer，上周都去上班了。</p><a id="more"></a><p>表弟是在家自学转行的，小舅子则是计算机专业的应届生，这里就来和大家说说表弟找工作的事吧，因为松哥读者中可能转行的小伙伴有不少，希望这些找工作的经历能给大家一些参考。</p><p>表弟是大专学历，2019 年毕业的，学的并非计算机专业，刚毕业的时候跟人在外面装基站，干了几个月不想干了，我去年国庆节回老家的时候，他已经辞了工作了，说是想学 Java。我觉得这个想法不错，现在不是 360 行，行行转 IT 么。</p><p>但是我肯定没时间教他，想让他去培训，但是又担心他培训后不能上岸，到时候浪费了时间又浪费了钱，我自己也得承担责任。思来想去还是在家看 B 站视频比较稳妥一点，有问题我可以帮忙解决（实际上大部分问题是他自己搞定的）。</p><p>我在 B  站上找了 Java 开发入门的视频给他，看完之后，我又找了数据库的视频给他，看完之后又找了 Web 基础的视频给他、接着就是 SSM 框架、Redis 等等，基本上就是按照我之前的 <a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图，大佬是这样炼成的！一定要收藏</a> 一文中提到的学习顺序给他找对应的学习视频，一直从 Java 基础看到 Spring Cloud 微服务，中间也做了几个项目，也都是网上找的视频，当然还有我的 <a href="https://mp.weixin.qq.com/s/EEmEL6tpuBT0qLfPwhj2OQ" target="_blank" rel="noopener">vhr</a>。</p><p>我平时工作挺忙的，有时候他问我问题我都很晚才回复，所以大部分学习问题都是他自己解决的，自己一个人折腾，就是学的比较慢，但是可能记得牢。</p><p>到今年 4 月份的时候，表弟发消息说视频都看完了，项目也都做完了，要出来找工作了，我感觉时间也差不多了，从去年十月份到今年 4 月份，半年了，也该出师了。</p><p>一开始就打算在西安找，五一过后开始在西安投简历，一直到来深圳之前，在西安投了两个多月简历，一共面试了三家，其中一家还是个培训机构，另一家则让他去搞测试，但是不签劳动合同。不签劳动合同这个太扯淡了。西安的就业市场本身就比较脆弱，工资低要求高，他只有大专学历而且没有实际开发经验，两个多月面试了三家，心理压力可想而知。</p><p>我在深圳跟他打电话我都觉得郁闷，简历我都看过，感觉也没啥大问题（简历不敢乱吹，我怕他技术 hold 不住）。</p><p>因为离得远，我也不知道他这半年到底学了个啥水平。我当时都在想，不行就去找个测试吧，开发干不了，测试相对容易些或许还能找到，没想到他在西安一直没有面试机会，到后来连测试的面试机会都没有，扛到 7 月份实在扛不住了，说是要来深圳。</p><p>来深圳之前甚至已经做了最坏的打算，要是还找不到，那就进工厂吧。</p><p>7 月 19 到深圳。在他来深圳之前，有个在外包做招聘的朋友说是要人，我就把表弟的简历发过去了，他来的当天晚上就安排了电话面试，我就坐在旁边，问题回答的那叫一个尴尬了，我都坐不住了。</p><p>一方面缺乏面试锻炼，整个面试过程中很紧张，另一方面，就是一些开发中的场景问题答不对，同时一些简单的 SQL 搞不定。</p><p>三方面的问题挨个解决。</p><p>自我介绍紧张，那就写下来，思路梳理一下记录下来，面试前多看。</p><p>另一方面就是多争取一些面试机会，面的多了才会不紧张。我看了他 Boss 直聘上的简历投递，和 HR 打招呼的话都太生硬了，这个打招呼也不是说需要多么圆滑，但是不卑不亢客客气气应该是最低要求，于是改了 Boss 直聘上的问候语，尽量多争取一些面试机会，面多了才能不紧张。</p><p>因为表弟是在家自学的，所以一些开发场景问题是他的短板，这个问题我相信很多自学或者培训的小伙伴都会存在。但是这个问题很难穷尽，这个问题一来靠悟性，二来靠表达。我的办法是，一方面在网上找面试题看，看看别人是怎么说的，另一方面就是每场面试的问题，全部都记录下来，回来一个一个复盘，一个一个解决，争取不在同一个问题上绊倒两次，面一场顶一场。</p><p>因为他面的是初级工程师，SQL 基本上是必问的，看得出来他之前就没有重视这里。不过 SQL 的问题好解决，在 Leetcode 上刷 SQL 题就行了，要求他每天至少做两小时的 SQL 题。</p><p>在和表弟沟通的过程中，我渐渐发现他基础还可以，至少比我想象的还是要好一点，但是缺乏总结，很多东西会写但是说不出来，这个问题也好解决，把平时看的面试题，看懂了都写笔记，总结下来。</p><p>同时因为表弟是和小舅子都在找工作，两个人住在一起，所以两个人可以交流面试题，这样效果更好一些。</p><p>要说深圳到底是一线城市机会多，从西安来深圳一周就面了三家，其中一家给了 offer，感觉还不错就去上班了。自学 Java，只要上岸了，以后的路就好走了。</p><p>自己折腾了半年，总算成功上岸！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;表弟和未来的小舅子分别在 7 月 19 和 7 月 20 号来到深圳，想在深圳找份 Java 开发的工作。我抽空给他们指导了一下，两人上上周均已拿到 offer，上周都去上班了。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="自学" scheme="http://www.javaboy.org/tags/%E8%87%AA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解读第七弹！bean 标签的解析</title>
    <link href="http://www.javaboy.org/2020/0810/spring-bean-tag.html"/>
    <id>http://www.javaboy.org/2020/0810/spring-bean-tag.html</id>
    <published>2020-08-10T01:50:55.000Z</published>
    <updated>2020-10-09T00:43:40.803Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 源码解读继续。</p><a id="more"></a><p>本文是 Spring 系列第八篇，如果小伙伴们还没阅读过本系列前面的文章，建议先看看，这有助于更好的理解本文。</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li><a href="https://mp.weixin.qq.com/s/8WnRZtHmstum23Ut5EXAug" target="_blank" rel="noopener">手把手教你搭建 Spring 源码分析环境</a></li><li><a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a></li></ol><h2 id="1-前文回顾"><a href="#1-前文回顾" class="headerlink" title="1.前文回顾"></a>1.前文回顾</h2><p>不知道小伙伴们是否还记得，在前面我们讲 Spring 文档加载的时候，涉及到如下一段源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Loaded "</span> + count + <span class="hljs-string">" bean definitions from "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Line "</span> + ex.getLineNumber() + <span class="hljs-string">" in XML document from "</span> + resource + <span class="hljs-string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"XML document from "</span> + resource + <span class="hljs-string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就两个核心方法：</p><ol><li>首先调用 doLoadDocument 方法获取 Spring 的 XML 配置文件加载出来的 Document 文档对象，这个方法的执行流程我们在前面已经介绍过了，这里就不再赘述。</li><li>接下来就是调用 registerBeanDefinitions 方法，讲加载出来的文档对象进行解析，定义出相应的 BeanDefinition 对象出来。</li></ol><p>BeanDefinition 是什么，有什么作用，松哥在之前的 <a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a> 一文中已经做过介绍，这里就不再赘述。</p><p>本文我们就来看看 Document 对象是如何一步一步加载成 BeanDefinition 的。</p><h2 id="2-parseDefaultElement"><a href="#2-parseDefaultElement" class="headerlink" title="2.parseDefaultElement"></a>2.parseDefaultElement</h2><p>我们就从 registerBeanDefinitions 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过调用 createBeanDefinitionDocumentReader 方法获取到一个 BeanDefinitionDocumentReader 的实例，具体的对象则是 DefaultBeanDefinitionDocumentReader，也就是说接下来调用 DefaultBeanDefinitionDocumentReader#registerBeanDefinitions 进行解析。继续来看该方法的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readerContext = readerContext;</span><br><span class="line">doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用到了 doRegisterBeanDefinitions 方法继续完成注册：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="hljs-comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="hljs-comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="hljs-comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="hljs-comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="hljs-comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="hljs-comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="hljs-comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="hljs-string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法流程比较简单，首先检查了一下有没有 profile 需要处理（如果有人不清楚 Spring 中的 profile，可以在公众号后台回复 spring5 获取松哥录制的免费的 Spring 入门教程）。处理完 profile 之后，接下来就是解析了，解析有一个前置处理方法 preProcessXml 和后置处理方法 postProcessXml，不过这两个方法默认都是空方法，真正的解析方法是 parseBeanDefinitions：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中进行节点的解析，最终会来到 parseDefaultElement 方法中。我们一起来看下该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="hljs-comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于来到期盼已久的 parseDefaultElement 方法中了。</p><p>在该方法中，我们可以看到，节点一共被分为了四大类：</p><ul><li>import</li><li>alias</li><li>bean</li><li>beans</li></ul><p>每一个节点都好理解，因为我们在开发中可能多多少少都有用过，需要注意的是，如果是 beans 节点，又会再次调用 doRegisterBeanDefinitions 方法进行递归解析，源码上面还给了一个注释 recurse，意思就是递归。</p><p>四种类型的节点解析，我们就从 bean 的解析看起吧，因为 beans 节点是我们最常用的节点，这个搞清楚了，另外三个节点就可以举一反三了。</p><p>我们来看 processBeanDefinition 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="hljs-string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，首先调用代理类 BeanDefinitionParserDelegate 对元素进行解析，解析的结果会保存在 bdHolder 中，也就是 bean 节点中配置的元素 class、id、name 等属性，在经过这一步的解析之后，都会保存到 bdHolder 中。</p><p>如果 bdHolder 不为空，那么接下来对子节点的属性继续解析，同时对 bdHolder 进行注册，最终发出事件，通知这个 bean 节点已经加载完了。</p><p>如此看来，整个解析的核心过程应该在 delegate.parseBeanDefinitionElement(ele) 方法中，追踪该方法的执行，我们最终来到这里：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"' as bean name and "</span> + aliases + <span class="hljs-string">" as aliases"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (containingBean == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="hljs-keyword">this</span>.readerContext.getRegistry(), <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="hljs-keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="hljs-comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="hljs-comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="hljs-comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="hljs-keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line"><span class="hljs-string">"using generated bean name ["</span> + beanName + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中所作的事情我们可以大致分为 5 个步骤：</p><ol><li>提取出 id 和 name 属性值。</li><li>检查 beanName 是否唯一。</li><li>对节点做进一步的解析，解析出 beanDefinition 对象，真是的类型是 GenericBeanDefinition。</li><li>如果 beanName 属性没有值，则使用默认的规则生成 beanName（默认规则是类名全路径）。</li><li>最终将获取到的信息封装成一个 BeanDefinitionHolder 返回。</li></ol><p>在这一层面主要完成了对 id 和 name 的处理，如果用户没有给 bean 定义名称的话，则生成一个默认的名称，至于其他属性的解析，则主要是在 parseBeanDefinitionElement 方法中完成的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));</span><br><span class="line">String className = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line">bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"><span class="hljs-keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="hljs-string">"Bean class ["</span> + className + <span class="hljs-string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="hljs-string">"Class that bean class ["</span> + className + <span class="hljs-string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="hljs-string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先解析出 className 属性。</li><li>解析出 parent 属性。</li><li>调用 createBeanDefinition 方法创建出用于保存对象的 BeanDefinition，既 GenericBeanDefinition。</li><li>parseBeanDefinitionAttributes 用来解析出各种各样的节点属性。</li><li>parseMetaElements 用来解析 Meta 数据。</li><li>parseLookupOverrideSubElements 解析 lookup-method 属性。</li><li>parseReplacedMethodSubElements 解析 replace-method 属性。</li><li>parseConstructorArgElements 解析构造函数参数。</li><li>parsePropertyElements 解析 property 子元素。</li><li>parseQualifierElements 解析 qualifier 子元素。</li><li>最终返回 bd。</li></ol><p>可以看到，bean 节点中所有的属性都解析了，有的是我们日常常见的属性，有的是我们不常见的甚至从来都没见到过的，无论哪种情况，现在全部都解析了。解析完成后，将获得的 GenericBeanDefinition 返回。</p><h2 id="3-常规属性解析"><a href="#3-常规属性解析" class="headerlink" title="3. 常规属性解析"></a>3. 常规属性解析</h2><p>这里有一些属性的解析可能比较冷门，这个我一会说，还有一些比较常规，例如 parseBeanDefinitionAttributes 方法用来解析各种各样的节点属性，这些节点属性可能大家都比较熟悉，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionAttributes</span><span class="hljs-params">(Element ele, String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">error(<span class="hljs-string">"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">bd.setScope(containingBean.getScope());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line">String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">lazyInit = <span class="hljs-keyword">this</span>.defaults.getLazyInit();</span><br><span class="line">&#125;</span><br><span class="line">bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line">String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line">String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">String candidatePattern = <span class="hljs-keyword">this</span>.defaults.getAutowireCandidates();</span><br><span class="line"><span class="hljs-keyword">if</span> (candidatePattern != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">bd.setInitMethodName(initMethodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.getInitMethod() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bd.setInitMethodName(<span class="hljs-keyword">this</span>.defaults.getInitMethod());</span><br><span class="line">bd.setEnforceInitMethod(<span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.getDestroyMethod() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bd.setDestroyMethodName(<span class="hljs-keyword">this</span>.defaults.getDestroyMethod());</span><br><span class="line">bd.setEnforceDestroyMethod(<span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里解析的节点属性，从上往下，依次是：</p><ol><li>解析 singleton 属性（该属性已废弃，使用 scope 替代）。</li><li>解析 scope 属性，如果未指定 scope 属性，但是存在 containingBean，则使用 containingBean 的 scope 属性值。</li><li>解析 abstract 属性。</li><li>解析 lazy-init 属性。</li><li>解析 autowire 属性。</li><li>解析 depends-on 属性。</li><li>解析 autowire-candidate 属性。</li><li>解析 primary 属性。</li><li>解析 init-method 属性。</li><li>解析 destroy-method 属性。</li><li>解析 factory-method 属性。</li><li>解析 factory-bean 属性。</li></ol><p>这些属性作用大家都比较熟悉。因为日常用的多一些。</p><p><strong>前面提到的解析中，lookup-method、replace-method、以及 qualifier 等属性可能大家日常都很少用到，甚至没有听说过，如果用都没用过，那源码肯定不好理解，所以接下来松哥会录制一个视频，来和大家讲一讲这些冷门属性的使用，然后我们再继续深入解析这里的 parseMetaElements、parseLookupOverrideSubElements 等方法。</strong></p><h2 id="4-Bean-的生成"><a href="#4-Bean-的生成" class="headerlink" title="4. Bean 的生成"></a>4. Bean 的生成</h2><p>有了 BeanDefinitionHolder 之后，接下来 Bean 的生成就很容易了。</p><p>大家回顾如下两篇文章来理解有了 BeanDefinition 之后，如何转化为具体的 Bean：</p><ul><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li><a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a></li></ul><p>好啦，今天的文章就先说这么多~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 源码解读继续。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Vue 专业社区，和一群小伙伴们一起切磋技术！</title>
    <link href="http://www.javaboy.org/2020/0805/springboot-vue.html"/>
    <id>http://www.javaboy.org/2020/0805/springboot-vue.html</id>
    <published>2020-08-05T01:50:26.000Z</published>
    <updated>2020-10-09T00:45:38.580Z</updated>
    
    <content type="html"><![CDATA[<p>Java 达摩院这个星球松哥运营一年多了，初衷是为了和大家分享 Java 开发技术，后来慢慢演变为专业解决松哥录制的 Spring Boot+Vue+微人事+Spring Cloud+Redis 视频问题的社区。</p><a id="more"></a><p>网上的学习资料很多，但是良莠不齐。很多时候我们缺的不仅仅是一个优质的学习资料，还缺乏一个解决问题的社区，看视频学习过程中，遇到的问题该怎么解决，自己闷头苦想效率要低很多，要是有个人稍微点拨一下，学习效率就会高很多。</p><p>因此我从很早就开始运营 Java 达摩院这个星球，小伙伴们在学习松哥的 Spring Boot + Vue + 微人事 + Spring Cloud + Redis 视频时，遇到问题都可以在这里提问，视频相关的问题每一个都会回复大家：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20200804-164548.jpg" alt></p><p><img src="http://img.itboyhub.com//2020/04/vhr/20200804-165402.jpg" alt></p><p>一些很多小伙伴都会遇到的典型问题我会统一说明回复：</p><p><img src="http://img.itboyhub.com/2020/07/稿定设计导出-20200804-200529.jpg" alt></p><p><strong>由于这个星球主要是为了帮助大家更好的学习松哥的视频教程，因此我没有给星球设置到期时间，你可以简单理解为你在星球中可以一直呆到把四套视频教程（Spring Boot+微人事+Spring Cloud+Redis）都吃透，然后自行决定是否退出。</strong></p><p>另外需要说明的是，未来松哥可能还会再录一些入门级的免费视频教程，大家在学习的时候遇到问题，也可以在知识星球上提问。</p><p>好啦，不说废话了，加松哥微信，发红包 199，我手动拉你进星球，进入星球后还能免费获赠一套松哥自己录制的 Spring Boot+微人事+Spring Cloud+Redis 视频教程。</p><p><img src="http://img.itboyhub.com/2020/07/20200804202205.png" alt></p><p>考虑到可能有小伙伴还不了解松哥自己录制的这套视频教程，因此这里也和大家介绍下。</p><p>四套视频教程加入星球后免费学习：</p><ol><li>Spring Boot</li><li>Vue+微人事</li><li>Spring Cloud</li><li>Redis</li></ol><p>四套视频总大小在 50G 左右，总时长在 90 小时左右（其中 Spring Boot 约 22 小时，Vue+微人事约 32 小时，Spring Cloud 约 22 小时，Redis 约 14 小时）。</p><p>由于视频的目录比较长，我就不在这里列出来了，小伙伴们可以在公众号后台回复 <code>视频目录</code> 就可以查看整套视频的完整目录。</p><p>这套视频除了星球上的小伙伴在看之外，也有一些高校老师购买，两个比较知名的高校是西交大和北邮，另外也有一些普通重本、二本、三本、专科和培训机构的老师购买，反馈都不错，有的是因为和我聊天我得知对方工作，有的是看对方发的朋友圈得知，总之，这套视频大家只要认真看，就一定会有收获。</p><p>买视频的小伙伴里有 30% 左右的小伙伴是朋友介绍来的，这也令我非常感动，非常感谢大家的认可和支持。我利用业余时间做这个视频，赚点小钱，在赚钱之外，我非常在意大家的认可，我也非常珍惜这份信任，所以我也一直在尽力提供最好的视频，早期的视频音质有点问题，后来买了一个专业的麦解决了，后来小伙伴反应希望能有笔记，所以 Spring Cloud 和 Redis 在录制的时候都有笔记。</p><p>总之，非常感谢大家的信任，我也一直在改进。现在虽然视频录完了，但是问题的解答还会继续，大家看视频遇到问题，可以继续在星球上提问，我可能回复的不是很及时，但是看到了都会回复。</p><p>接下来我把视频常见问题给大家罗列一下：</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码，一人一码。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：以后录的视频都可以看吗？</strong></p><p>这次松哥一共计划出四套视频课程，并且四套视频已经全部录完，大家在公众号后台回复 <code>视频目录</code> 可以查看已经录完的视频详细目录。也就是 199 一共可以看这四套视频，但是四套视频问题的解答，会一直持续下去。</p><p><strong>Q4：视频可以试看吗？</strong></p><p>其实我平时在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。小伙伴们也可以在公众号后台回复 <code>vhr试看</code> 获取试看合集。</p><p><strong>Q5：这套视频适合哪些人看？</strong></p><p>学习这套视频，后端需要有 SSM 基础，前端需要有 js 基础（可以不懂 Vue，第十六章视频会讲）。要是不懂 SSM，可以先看松哥之前手敲 5 万余字的 SSM 教程，公众号后台回复 ssm 可以获取下载链接。</p><p><strong>Q6：视频中的技术版本是什么</strong></p><ul><li>Spring Boot 录制基于 2.1.6-2.1.8 之间（因为录制的过程中 Spring Boot 版本在变，而我一直使用最新版本录制）。</li><li>微人事基于 SpringBoot2.1.8。</li><li>Spring Cloud 基于目前最新稳定版 H 版。</li><li>Redis 基于 Redis5。</li></ul><p><strong>视频是松哥业余做的，没有助理客服之类的，在微信上回复你消息的就是我本人，所以有的时候消息回复有些慢，请大家理解。</strong></p><p>好了，加松哥微信，发红包 199，和众多小伙伴一起撸 Spring Boot + Vue +Spring Cloud + Redis 以及微人事项目吧。</p><p><img src="http://img.itboyhub.com/2020/07/20200804202205.png" alt></p><p>下面是小伙伴们对视频的一些评价：</p><p><img src="http://img.itboyhub.com/2020/05/20200514-193629.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-5.png" alt><br><img src="http://img.itboyhub.com//2020/03/video-6.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-7.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-8.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-10.png" alt><br><img src="http://img.itboyhub.com/2020/05/20200526225220.png" alt></p><p>这些都是小伙伴们的评价，每个小伙伴技术基础和技术消化能力有差异，所以我基本上不会给大家承诺学完这套视频视频就能找到工作，或者学完之后年薪 xx 万，这个太扯了。因为每个人都不一样，虽然之前有小伙伴表示学完之后顺利找到新工作，但是别人的经验不一定适用你。</p><p>松哥能做的，就是希望能够把这套视频的内容跟大家讲清楚，视频都有哪些东西，涉及到哪些技术点给大家讲清楚。至于要不要买，则需要小伙伴们自行判断。</p><p>好了，加松哥微信，发红包 199，和众多小伙伴一起撸 Spring Boot + Vue +Spring Cloud +Redis 以及微人事项目吧。</p><p><img src="http://img.itboyhub.com/2020/07/20200804202205.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 达摩院这个星球松哥运营一年多了，初衷是为了和大家分享 Java 开发技术，后来慢慢演变为专业解决松哥录制的 Spring Boot+Vue+微人事+Spring Cloud+Redis 视频问题的社区。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 初始化流程梳理</title>
    <link href="http://www.javaboy.org/2020/0803/springsecurity-start-analysis.html"/>
    <id>http://www.javaboy.org/2020/0803/springsecurity-start-analysis.html</id>
    <published>2020-08-03T13:29:10.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们对 Spring Security 源码的讲解都比较零散，今天松哥试着来和大家捋一遍 Spring Security 的初始化流程，顺便将前面的源码解析文章串起来。</p><a id="more"></a><p>Spring Security 启动流程并不难，但是由于涉及到的知识点非常庞杂，所以松哥在之前已经连载过好几篇源码解读的文章了，大家把这些源码解读的文章搞懂了，今天这篇文章就好理解了。</p><p>在 Spring Boot 中，Spring Security 的初始化，我们就从自动化配置开始分析吧！</p><h2 id="1-SecurityAutoConfiguration"><a href="#1-SecurityAutoConfiguration" class="headerlink" title="1.SecurityAutoConfiguration"></a>1.SecurityAutoConfiguration</h2><p>Spring Security 的自动化配置类是 SecurityAutoConfiguration，我们就从这个配置类开始分析。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(DefaultAuthenticationEventPublisher.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(SecurityProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class,</span><br><span class="line">SecurityDataConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(AuthenticationEventPublisher.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultAuthenticationEventPublisher <span class="hljs-title">authenticationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultAuthenticationEventPublisher(publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Bean 中，定义了一个事件发布器。另外导入了三个配置：</p><ol><li>SpringBootWebSecurityConfiguration：这个配置的作用是在如果开发者没有自定义 WebSecurityConfigurerAdapter 的话，这里提供一个默认的实现。</li><li>WebSecurityEnablerConfiguration：这个配置是 Spring Security 的核心配置，也将是我们分析的重点。</li><li>SecurityDataConfiguration：提供了 Spring Security 整合 Spring Data 的支持，由于国内使用 MyBatis 较多，所以这个配置发光发热的场景有限。</li></ol><h2 id="2-WebSecurityEnablerConfiguration"><a href="#2-WebSecurityEnablerConfiguration" class="headerlink" title="2.WebSecurityEnablerConfiguration"></a>2.WebSecurityEnablerConfiguration</h2><p>接着来看上面出现的 WebSecurityEnablerConfiguration：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnBean</span>(WebSecurityConfigurerAdapter.class)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@EnableWebSecurity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityEnablerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置倒没啥可说的，给了一堆生效条件，最终给出了一个 @EnableWebSecurity 注解，看来初始化重任落在 @EnableWebSecurity 注解身上了。</p><h2 id="3-EnableWebSecurity"><a href="#3-EnableWebSecurity" class="headerlink" title="3.@EnableWebSecurity"></a>3.@EnableWebSecurity</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; WebSecurityConfiguration.class,</span><br><span class="line">SpringWebMvcImportSelector.class,</span><br><span class="line">OAuth2ImportSelector.class &#125;)</span><br><span class="line"><span class="hljs-meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Controls debugging support for Spring Security. Default is false.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> if true, enables debug support with Spring Security</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableWebSecurity 所做的事情，有两件比较重要：</p><ol><li>导入 WebSecurityConfiguration 配置。</li><li>通过 @EnableGlobalAuthentication 注解引入全局配置。</li></ol><h3 id="3-1-WebSecurityConfiguration"><a href="#3-1-WebSecurityConfiguration" class="headerlink" title="3.1 WebSecurityConfiguration"></a>3.1 WebSecurityConfiguration</h3><p>WebSecurityConfiguration 类实现了两个接口，我们来分别看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportAware</span>, <span class="hljs-title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportAware 接口和 @Import 注解一起使用的。实现了 ImportAware 接口的配置类可以方便的通过 setImportMetadata 方法获取到导入类中的数据配置。</p><p>可能有点绕，我再梳理下，就是 WebSecurityConfiguration 实现了 ImportAware 接口，使用 @Import 注解在 @EnableWebSecurity 上导入 WebSecurityConfiguration 之后，在 WebSecurityConfiguration 的 setImportMetadata 方法中可以方便的获取到 @EnableWebSecurity 中的属性值，这里主要是 debug 属性。</p><p>我们来看下 WebSecurityConfiguration#setImportMetadata 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; enableWebSecurityAttrMap = importMetadata</span><br><span class="line">.getAnnotationAttributes(EnableWebSecurity.class.getName());</span><br><span class="line">AnnotationAttributes enableWebSecurityAttrs = AnnotationAttributes</span><br><span class="line">.fromMap(enableWebSecurityAttrMap);</span><br><span class="line">debugEnabled = enableWebSecurityAttrs.getBoolean(<span class="hljs-string">"debug"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (webSecurity != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">webSecurity.debug(debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到 debug 属性赋值给 WebSecurity。</p><p>实现 BeanClassLoaderAware 接口则是为了方便的获取 ClassLoader。</p><p>这是 WebSecurityConfiguration 实现的两个接口。</p><p>在 WebSecurityConfiguration 内部定义的 Bean 中，最为重要的是两个方法：</p><ol><li>springSecurityFilterChain 该方法目的是为了获取过滤器链。</li><li>setFilterChainProxySecurityConfigurer 这个方法是为了收集配置类并创建 WebSecurity。</li></ol><p>这两个方法是核心，我们来逐一分析，先来看 setFilterChainProxySecurityConfigurer：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFilterChainProxySecurityConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Value(<span class="hljs-string">"#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;"</span>)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">webSecurity = objectPostProcessor</span><br><span class="line">.postProcess(<span class="hljs-keyword">new</span> WebSecurity(objectPostProcessor));</span><br><span class="line"><span class="hljs-keyword">if</span> (debugEnabled != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">webSecurity.debug(debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line">webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">Integer previousOrder = <span class="hljs-keyword">null</span>;</span><br><span class="line">Object previousConfig = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class="line">Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class="line"><span class="hljs-keyword">if</span> (previousOrder != <span class="hljs-keyword">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"@Order on WebSecurityConfigurers must be unique. Order of "</span></span><br><span class="line">+ order + <span class="hljs-string">" was already used on "</span> + previousConfig + <span class="hljs-string">", so it cannot be used on "</span></span><br><span class="line">+ config + <span class="hljs-string">" too."</span>);</span><br><span class="line">&#125;</span><br><span class="line">previousOrder = order;</span><br><span class="line">previousConfig = config;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class="line">webSecurity.apply(webSecurityConfigurer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个方法有两个参数，两个参数都会自动进行注入，第一个参数 ObjectPostProcessor 是一个后置处理器，默认的实现是 AutowireBeanFactoryObjectPostProcessor，主要是为了将 new 出来的对象注入到 Spring 容器中（参见<a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a>）。</p><p>第二个参数 webSecurityConfigurers 是一个集合，这个集合里存放的都是 SecurityConfigurer，我们前面分析的过滤器链中过滤器的配置器，包括 WebSecurityConfigurerAdapter 的子类，都是 SecurityConfigurer 的实现类。根据 @Value 注解中的描述，我们可以知道，这个集合中的数据来自 autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers() 方法。</p><p>在 WebSecurityConfiguration 中定义了该实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AutowiredWebSecurityConfigurersIgnoreParents <span class="hljs-title">autowiredWebSecurityConfigurersIgnoreParents</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutowiredWebSecurityConfigurersIgnoreParents(beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的 getWebSecurityConfigurers 方法我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class="line">.getBeansOfType(WebSecurityConfigurer.class);</span><br><span class="line"><span class="hljs-keyword">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class="line">webSecurityConfigurers.add(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实就是从 beanFactory 工厂中查询到 WebSecurityConfigurer 的实例返回。</p><p>WebSecurityConfigurer 的实例其实就是 WebSecurityConfigurerAdapter，如果我们没有自定义 WebSecurityConfigurerAdapter，那么默认使用的是 SpringBootWebSecurityConfiguration 中自定义的 WebSecurityConfigurerAdapter。</p><p>当然我们也可能自定义了 WebSecurityConfigurerAdapter，而且如果我们配置了多个过滤器链（多个 HttpSecurity 配置），那么 WebSecurityConfigurerAdapter 的实例也将有多个。所以这里返回的是 List 集合。</p><p>至此，我们搞明白了了 setFilterChainProxySecurityConfigurer 方法的两个参数。回到该方法我们继续分析。</p><p>接下来创建了 webSecurity 对象，并且放到 ObjectPostProcessor 中处理了一下，也就是把 new 出来的对象存入 Spring 容器中。</p><p>调用 webSecurityConfigurers.sort 方法对 WebSecurityConfigurerAdapter 进行排序，如果我们配置了多个 WebSecurityConfigurerAdapter 实例（多个过滤器链，参见：<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>），那么我们肯定要通过 @Order 注解对其进行排序，以便分出一个优先级出来，而且这个优先级还不能相同。</p><p>所以接下来的 for 循环中就是判断这个优先级是否有相同的，要是有，直接抛出异常。</p><p>最后，遍历 webSecurityConfigurers，并将其数据挨个配置到 webSecurity 中。webSecurity.apply 方法会将这些配置存入 AbstractConfiguredSecurityBuilder.configurers 属性中（参见：<a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a>）。</p><p>这就是 setFilterChainProxySecurityConfigurer 方法的工作逻辑，大家看到，它主要是在构造 WebSecurity 对象。</p><p>WebSecurityConfiguration 中第二个比较关键的方法是 springSecurityFilterChain，该方法是在上个方法执行之后执行，方法的目的是构建过滤器链，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span>(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">springSecurityFilterChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> hasConfigurers = webSecurityConfigurers != <span class="hljs-keyword">null</span></span><br><span class="line">&amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class="line"><span class="hljs-keyword">if</span> (!hasConfigurers) &#123;</span><br><span class="line">WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class="line">.postProcess(<span class="hljs-keyword">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">webSecurity.apply(adapter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会判断有没有 webSecurityConfigurers 存在，一般来说都是有的，即使你没有配置，还有一个默认的。当然，如果不存在的话，这里会现场 new 一个出来，然后调用 apply 方法。</p><p>最最关键的就是最后的 webSecurity.build() 方法了，这个方法的调用就是去构建过滤器链了。</p><p>根据 <a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a> 一文的介绍，这个 build 方法最终是在 AbstractConfiguredSecurityBuilder#doBuild 方法中执行的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">buildState = BuildState.INITIALIZING;</span><br><span class="line">beforeInit();</span><br><span class="line">init();</span><br><span class="line">buildState = BuildState.CONFIGURING;</span><br><span class="line">beforeConfigure();</span><br><span class="line">configure();</span><br><span class="line">buildState = BuildState.BUILDING;</span><br><span class="line">O result = performBuild();</span><br><span class="line">buildState = BuildState.BUILT;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会记录下来整个项目的构建状态。三个比较关键的方法，一个是 init、一个 configure 还有一个 performBuild。</p><p>init 方法会遍历所有的 WebSecurityConfigurerAdapter ，并执行其 init 方法。WebSecurityConfigurerAdapter#init 方法主要是做 HttpSecurity 的初始化工作，具体参考：<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。init 方法在执行时，会涉及到 HttpSecurity 的初始化，而 HttpSecurity 的初始化，需要配置 AuthenticationManager，所以这里最终还会涉及到一些全局的 AuthenticationManagerBuilder 及相关属性的初始化，具体参见：<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a>，需要注意的是，AuthenticationManager 在初始化的过程中，也会来到这个 doBuild 方法中，具体参考松哥前面文章，这里就不再赘述。</p><p>configure 方法会遍历所有的 WebSecurityConfigurerAdapter ，并执行其 configure 方法。WebSecurityConfigurerAdapter#configure 方法默认是一个空方法，开发者可以自己重写该方法去定义自己的 WebSecurity，具体参考：<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。</p><p>最后调用 performBuild 方法进行构建，这个最终执行的是 WebSecurity#performBuild 方法，该方法执行流程，参考松哥前面文章<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。</p><p>performBuild 方法执行的过程，也是过滤器链构建的过程。里边会调用到过滤器链的构建方法，也就是默认的十多个过滤器会挨个构建，这个构建过程也会调用到这个 doBuild 方法。</p><p>performBuild 方法中将成功构建 FilterChainProxy，最终形成我们需要的过滤器链。</p><h3 id="3-2-EnableGlobalAuthentication"><a href="#3-2-EnableGlobalAuthentication" class="headerlink" title="3.2 @EnableGlobalAuthentication"></a>3.2 @EnableGlobalAuthentication</h3><p>@EnableWebSecurity 注解除了过滤器链的构建，还有一个注解就是 @EnableGlobalAuthentication。我们也顺便来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(AuthenticationConfiguration.class)</span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableGlobalAuthentication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该注解的作用主要是导入 AuthenticationConfiguration 配置，该配置前面已经介绍过了，参考：<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a>一文。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>这便是 Spring Security 的一个大致的初始化流程。大部分的源码在前面的文章中都讲过了，本文主要是是一个梳理，如果小伙伴们还没看前面的文章，建议看过了再来学习本文哦。</p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1NDY0MTkzNQ==&amp;action=getalbum&amp;album_id=1319828555819286528&amp;subscene=38&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI1NDY0MTkzNQ%3D%3D%26mid%3D2247489179%26idx%3D1%26sn%3D01aae04306638e68d9ea483e508d56ac%26chksm%3De9c344fbdeb4cded021f3e125f39cb4f5fb25ca5e903a621dbb5bd76264c76a1b90bbc7e6756%26scene%3D38%26key%3Dd7cd6cebe5b965e753315b8fba3c3785b8b3ed8da8440543110c60ab3a01fc0291bab2006360738c9faf88e3a0a5e2e2747427d90eaa778919bcd3c12bd32d84bacd1b7b197b7c133449c13e60589b5f%26ascene%3D0%26uin%3DMTQ5NzA1MzQwMw%253D%253D%26devicetype%3DiMac%2BMacBookPro15%252C1%2BOSX%2BOSX%2B10.13.6%2Bbuild(17G2208" target="_blank" rel="noopener">Spring Security 系列历史文章合集</a>%26version%3D12031f10%26nettype%3DWIFI%26lang%3Den%26fontScale%3D100%26exportkey%3DA3Wiahk84DJaxlesHRkR9Lo%253D%26pass_ticket%3DTw4Lf%252FDXMBnX6b1zckIiLAXh%252FIXYTPiEPUroWij5MLEcC%252BvlNTmlIjOKDAln3v39%26winzoom%3D1.000000&amp;uin=&amp;key=&amp;devicetype=iMac+MacBookPro15%2C1+OSX+OSX+10.13.6+build(17G2208)&amp;version=12031f10&amp;lang=en&amp;nettype=WIFI&amp;ascene=0&amp;fontScale=100&amp;winzoom=1.000000)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们对 Spring Security 源码的讲解都比较零散，今天松哥试着来和大家捋一遍 Spring Security 的初始化流程，顺便将前面的源码解析文章串起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
</feed>
