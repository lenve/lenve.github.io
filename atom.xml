<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-04-23T09:30:34.752Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot+OAuth2，一个注解搞定单点登录！</title>
    <link href="http://www.javaboy.org/2020/0423/oauth2-sso.html"/>
    <id>http://www.javaboy.org/2020/0423/oauth2-sso.html</id>
    <published>2020-04-23T09:18:23.000Z</published>
    <updated>2020-04-23T09:30:34.752Z</updated>
    
    <content type="html"><![CDATA[<p>需要先说一下，松哥最近写的教程，都是成系列的，有一些重复的东西写来写去就没意思了，所以每一篇文章都默认大家已经懂了前面的内容了，因此下文有任何看不懂的地方，建议一定先看下相关系列：</p><a id="more"></a><p><strong>Spring Security 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p><strong>OAuth2 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">和大家分享一点微服务架构中的安全管理思路</a></li></ol><p>好了，开始今天的正文。</p><p>单点登录是我们在分布式系统中很常见的一个需求。</p><p>分布式系统由多个不同的子系统组成，而我们在使用系统的时候，只需要登录一次即可，这样其他系统都认为用户已经登录了，不用再去登录。前面和小伙伴们分享了 OAuth2+JWT 的登录方式，这种无状态登录实际上天然的满足单点登录的需求，可以参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><p>当然大家也都知道，无状态登录也是有弊端的。</p><p>所以今天松哥想和大家说一说 Spring Boot+OAuth2 做单点登录，利用 @EnableOAuth2Sso 注解快速实现单点登录功能。</p><p>松哥依然建议大家在阅读本文时，先看看本系列前面的文章，这有助于更好的理解本文。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>前面的案例中，松哥一直都把授权服务器和资源服务器分开创建，今天这个案例，为了省事，我就把授权服务器和资源服务器搭建在一起（不过相信大家看了前面的文章，应该也能自己把这两个服务器拆分开）。</p><p>所以，今天我们一共需要三个服务：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">1111</td><td style="text-align:left">授权服务器+资源服务器</td></tr><tr><td style="text-align:left">client1</td><td style="text-align:left">1112</td><td style="text-align:left">子系统1</td></tr><tr><td style="text-align:left">client2</td><td style="text-align:left">1113</td><td style="text-align:left">子系统2</td></tr></tbody></table><p>auth-server 用来扮演授权服务器+资源服务器的角色，client1 和 client2 则分别扮演子系统的角色，将来等 client1 登录成功之后，我们也就能访问 client2 了，这样就能看出来单点登录的效果。</p><p>我们创建一个名为 oauth2-sso 的 Maven 项目作为父工程即可。</p><h2 id="2-统一认证中心"><a href="#2-统一认证中心" class="headerlink" title="2.统一认证中心"></a>2.统一认证中心</h2><p>接下来我们来搭建统一认证中心。</p><p>首先我们创建一个名为 auth-server 的 module，创建时添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-1.png" alt></p><p>项目创建成功之后，这个模块由于要扮演授权服务器+资源服务器的角色，所以我们先在这个项目的启动类上添加 @EnableResourceServer 注解，表示这是一个资源服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们进行授权服务器的配置，由于资源服务器和授权服务器合并在一起，因此授权服务器的配置要省事很多：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(passwordEncoder.encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .autoApprove(<span class="hljs-keyword">true</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:1112/login"</span>, <span class="hljs-string">"http://localhost:1113/login"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .accessTokenValiditySeconds(<span class="hljs-number">7200</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只需要简单配置一下客户端的信息即可，这里的配置很简单，前面的文章也讲过了，大家要是不懂，可以参考本系列前面的文章：<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a>。</p><p>当然这里为了简便，客户端的信息配置是基于内存的，如果大家想将客户端信息存入数据库中，也是可以的，参考：<a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></p><p>接下来我们再来配置 Spring Security：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/login.html"</span>, <span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/images/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.requestMatchers()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/oauth/authorize"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Spring Security 的配置，如果小伙伴们不懂，可以看看松哥最近正在连载的 Spring Security 系列。</p><p>我这里来大致捋一下：</p><ol><li>首先提供一个 BCryptPasswordEncoder 的实例，用来做密码加解密用。</li><li>由于我自定义了登录页面，所以在 WebSecurity 中对这些静态资源方形。</li><li>HttpSecurity 中，我们对认证相关的端点放行，同时配置一下登录页面和登录接口。</li><li>AuthenticationManagerBuilder 中提供一个基于内存的用户（小伙伴们可以根据 Spring Security 系列第 7 篇文章自行调整为从数据库加载）。</li><li>另外还有一个比较关键的地方，因为资源服务器和授权服务器在一起，所以我们需要一个 @Order 注解来提升 Spring Security 配置的优先级。</li></ol><p>SecurityConfig 和 AuthServerConfig 都是授权服务器需要提供的东西（如果小伙伴们想将授权服务器和资源服务器拆分，请留意这句话），接下来，我们还需要提供一个暴露用户信息的接口（如果将授权服务器和资源服务器分开，这个接口将由资源服务器提供）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(Principal principal)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在 application.properties 中配置一下项目端口：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=1111</span><br></pre></td></tr></table></figure><p>另外，松哥自己提前准备了一个登录页面，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-4.png" alt></p><p>将登录页面相关的 html、css、js 等拷贝到 resources/static 目录下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-3.png" alt></p><p>这个页面很简单，就是一个登录表单而已，我把核心部分列出来：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"pass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意一下 action 提交地址不要写错即可。</p><p><strong>文末可以下载源码。</strong></p><p>如此之后，我们的统一认证登录平台就算是 OK 了。</p><h2 id="3-客户端创建"><a href="#3-客户端创建" class="headerlink" title="3.客户端创建"></a>3.客户端创建</h2><p>接下来我们来创建一个客户端项目，创建一个名为 client1 的 Spring Boot 项目，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-1.png" alt></p><p>项目创建成功之后，我们来配置一下 Spring Security：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableOAuth</span>2Sso</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated().and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置很简单，就是说我们 client1 中所有的接口都需要认证之后才能访问，另外添加一个 @EnableOAuth2Sso 注解来开启单点登录功能。</p><p>接下来我们在 client1 中再来提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="hljs-keyword">return</span> authentication.getName() + Arrays.toString(authentication.getAuthorities().toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个测试接口返回当前登录用户的姓名和角色信息。</p><p>接下来我们需要在 client1 的 application.properties 中配置 oauth2 的相关信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">security.oauth2.client.client-secret=123</span><br><span class="line">security.oauth2.client.client-id=javaboy</span><br><span class="line">security.oauth2.client.user-authorization-uri=http://localhost:1111/oauth/authorize</span><br><span class="line">security.oauth2.client.access-token-uri=http://localhost:1111/oauth/token</span><br><span class="line">security.oauth2.resource.user-info-uri=http://localhost:1111/user</span><br><span class="line"></span><br><span class="line">server.port=1112</span><br><span class="line"></span><br><span class="line">server.servlet.session.cookie.name=s1</span><br></pre></td></tr></table></figure><p>这里的配置也比较熟悉，我们来看一下：</p><ol><li>client-secret 是客户端密码。</li><li>client-id 是客户端 id。</li><li>user-authorization-uri 是用户授权的端点。</li><li>access-token-uri 是获取令牌的端点。</li><li>user-info-uri 是获取用户信息的接口（从资源服务器上获取）。</li><li>最后再配置一下端口，然后给 cookie 取一个名字。</li></ol><p>如此之后，我们的 client1 就算是配置完成了。</p><p>按照相同的方式，我们再来配置一个 client2，client2 和 client1 一模一样，就是 cookie 的名字不同（随意取，不相同即可）。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>接下来，我们分别启动 auth-server、client1 和 client2，首先我们尝试去方式 client1 中的 hello 接口，这个时候会自动跳转到统一认证中心：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-4.png" alt></p><p>然后输入用户名密码进行登录。</p><p>登录成功之后，会自动跳转回 client1 的 hello 接口，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-7.png" alt></p><p>此时我们再去访问 client2 ，发现也不用登录了，直接就可以访问：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-8.png" alt></p><p>OK，如此之后，我们的单点登录就成功了。</p><h2 id="5-流程解析"><a href="#5-流程解析" class="headerlink" title="5.流程解析"></a>5.流程解析</h2><p>最后，我再来和小伙伴们把上面代码的一个执行流程捋一捋：</p><ol><li>首先我们去访问 client1 的 /hello 接口，但是这个接口是需要登录才能访问的，因此我们的请求被拦截下来，拦截下来之后，系统会给我们重定向到 client1 的 /login 接口，这是让我们去登录。</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-9.png" alt></p><ol start="2"><li>当我们去访问 client1 的登录接口时，由于我们配置了 @EnableOAuth2Sso 注解，这个操作会再次被拦截下来，单点登录拦截器会根据我们在 application.properties 中的配置，自动发起请求去获取授权码：</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-10.png" alt></p><ol start="3"><li>在第二步发送的请求是请求 auth-server 服务上的东西，这次请求当然也避免不了要先登录，所以再次重定向到 auth-server 的登录页面，也就是大家看到的统一认证中心。</li><li>在统一认真中心我们完成登录功能，登录完成之后，会继续执行第二步的请求，这个时候就可以成功获取到授权码了。</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-11.png" alt></p><ol start="5"><li>获取到授权码之后，这个时候会重定向到我们 client1 的 login 页面，但是实际上我们的 client1 其实是没有登录页面的，所以这个操作依然会被拦截，此时拦截到的地址包含有授权码，拿着授权码，在 OAuth2ClientAuthenticationProcessingFilter 类中向 auth-server 发起请求，就能拿到 access_token 了（参考：<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a>）。</li><li>在第五步拿到 access_token 之后，接下来在向我们配置的 user-info-uri 地址发送请求，获取登录用户信息，拿到用户信息之后，在 client1 上自己再走一遍 Spring Security 登录流程，这就 OK 了。</li></ol><p>OK，本文和小伙伴们聊了一些 SpringBoot +OAuth2 单点登录的问题，完整案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要先说一下，松哥最近写的教程，都是成系列的，有一些重复的东西写来写去就没意思了，所以每一篇文章都默认大家已经懂了前面的内容了，因此下文有任何看不懂的地方，建议一定先看下相关系列：&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</title>
    <link href="http://www.javaboy.org/2020/0422/spring-cloud-oauth2.html"/>
    <id>http://www.javaboy.org/2020/0422/spring-cloud-oauth2.html</id>
    <published>2020-04-22T09:18:08.000Z</published>
    <updated>2020-04-23T09:30:41.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直在发安全相关的 Spring Security 和 OAuth2，当然这两个系列还在继续，对 Spring Security 和 OAuth2 感兴趣的小伙伴，不要错过前面的文章哦，本文主要将一些理论上的东西，所以要是前面的 OAuth2 不懂，可能阅读起来有些吃力：</p><a id="more"></a><p><strong>Spring Security 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p><strong>OAuth2 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li></ol><p>这两个系列都还没完，还在继续更新，也会定期推出文章的配套视频，欢迎小伙伴们保持关注。</p><p>今天就不和大家聊代码了，我想结合自己目前的工作，和大家说一说 Spring Cloud 基础架构的安全管理问题，因为我最近一直在做这方面的工作，有一些心得，发出来和小伙伴们一起探讨。</p><p>这其实是一个挺复杂的问题，本文我尽量从一个容易理解的方面来和大家介绍，我们先把这个思想体系搭建起来，后面的文章，松哥会抽空给大家上代码。</p><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h2><p>在微服务中，我们一般都会有一个网关，网关背后有很多个微服务，所有的请求都是首先到达网关，再由网关转发到不同的服务上去。另外我们可能会搭建一个统一认证中心，我画一个已经过简化的架构图大家来看下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-8-2.png" alt></p><p>可以看到，在这个微服务架构中，我们的鉴权流程是这样：</p><ol><li>客户端携带用户名密码发送登录请求到网关。</li><li>网关收到请求之后，将请求路由到统一认证中心。</li><li>统一认证中心确认用户的身份没有问题之后，将返回一个 access_token 给网关。</li><li>网关将 access_token 转发到客户端。</li><li>客户端将获取到的 access_token 放在请求头中去请求真正的微服务，当然这个操作依然会被网关拦下。</li><li>网关将客户端的请求路由到微服务上，接下来微服务需要根据 access_token 鉴定用户身份。</li><li>微服务可以调用统一认证中心去检验用户身份，如果我们采用了 JWT 的话，这一步实际上可以省略。</li><li>微服务确认了用户身份和权限之后，就可以根据实际情况返回数据给用户了。</li></ol><p>这是我们一个大致的认证流程。</p><p>流程清楚了之后，代码写起来就非常容易了。有小伙伴会说，既然流程都清楚了，那我是不是可以自定义认证的相关逻辑了？</p><p>这个想法没错，但是我并不建议。当大家看到这张简化版的架构图，应该很容易就想到 OAuth2 了，很明显，将 OAuth2 放在这里最恰当不过。使用 OAuth2 好处是它是一个经过市场验证的安全标准，使用 OAuth2 的话，你就不用担心可能存在的风险漏洞，如果是自己设计的话，要考虑的问题就比较多。</p><p>但是 OAuth2 中存在的一些角色问题在这里是如何划分呢？</p><p>首先大家明白，OAuth2 中的授权服务器在校验的时候，实际上是有两个方面的校验工作，一方面是校验客户端信息，另一方面是校验用户信息，微服务 A 和 微服务 B 都在处理业务上的事情，实际上没有必要和客户端关联起来，所以我们可以在网关上先初步校验客户端信息，然后在微服务上再去校验用户身份信息。</p><p>具体来说是这样：</p><p>在上面的架构图中，网关还有另外一个身份就是资源服务器，当请求到达网关之后，如果是去往统一认证中心的请求，则直接转发即可；如果请求是去往普通微服务的请求，网关可以先做初步校验，就是校验客户端身份，如果没有问题，则将请求路由到不同的微服务上，各个微服务再根据自身的业务和权限情况，进行响应。</p><p>为什么不把所有权限校验都在网关做了呢？</p><p>对于一个超大型的微服务项目而言，涉及到的子系统可能非常多，权限控制也是非常复杂，网关不可能了解所有业务系统的逻辑，如果把所有的鉴权操作都放在网关上做，很明显会加大网关的复杂度，让网关变得非常臃肿。另一方面，不同的微服务可能是由不同的团队开发的，如果把每个微服务的鉴权系统放在网关上做，又会增加开发的难度，所以，我们可以先在网关对用户身份做初步校验，没问题的话，再把请求路由到不同的微服务，做具体的校验。</p><p>在这个过程中，我们可以使用普通的 access_token，就是那种一个 UUID 字符串的，如果使用了这种格式的 access_token，我们可以通过调用授权服务器来确定用户身份，也就是上图中的第七步不可以省略，这对于分布式系统来说显然不是最佳方案。结合 JWT 就可以很好的解决这个问题，JWT 中保存了用户的所有信息，微服务拿到 JWT 字符串之后，就可以很好的解析出用户的信息了。</p><h2 id="2-为什么不建议-Cookie"><a href="#2-为什么不建议-Cookie" class="headerlink" title="2.为什么不建议 Cookie"></a>2.为什么不建议 Cookie</h2><p>微服务架构是一种分布式系统，在分布式系统中，我们经常需要将用户的信息从一个微服务传递到另外一个微服务中去，传统的 SecurityContext 这种基于 ThreadLocal 基于内存的方式显然就不太合适，因为这种方式无法灵活的在分布式系统之间传递用户信息，也无法很好的支持单点登录。具体可以参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><p>另一方面，前端应用程序多样化，Android、iOS、各种平台的小程序、H5 页面等等，并非所有的前端应用都会对 Cookie 有友好的支持，后端使用 access_token 也可以避免前端将来面临的这些问题。</p><h2 id="3-内部调用鉴权"><a href="#3-内部调用鉴权" class="headerlink" title="3. 内部调用鉴权"></a>3. 内部调用鉴权</h2><p>微服务内部调用的鉴权也需要考虑。当然，如果系统对于安全性的要求不高的话，这一步其实可以省略。</p><p>如果不能省略，我也来说说思路。</p><p>现在的微服务之间调用，例如 A 调用 B，如果是基于 Spring Cloud 架构的话，可能以 Open Feign 调用为主，这种情况下，我们可以自定义一个请求拦截器，当请求要发出的时候，自动拦截请求，然后自动向请求头中添加认证信息。</p><p>然后可以定义一个公共的注解，这个注解专门用来做校验工作，该注解可以从从请求头中提取出 A 传递来的信息进行校验。</p><p>在 B 中使用这个公共的注解即可。</p><p>当然 B 中也可以不使用注解，而是通过路径来校验，但是在这个场景下，注解反而灵活一些。</p><h2 id="4-还要不要-Spring-Security"><a href="#4-还要不要-Spring-Security" class="headerlink" title="4. 还要不要 Spring Security"></a>4. 还要不要 Spring Security</h2><p>有小伙伴会问，在微服务上拿到 JWT 字符串之后，是不是可以自己解析？（JWT 解析参考：<a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a>）这样就不需要 Spring Security 了？</p><p>虽然自己解析并不存在技术上的难点，但是我还是不建议自己解析，建议继续在 Spring Security 的基础上完成剩余操作。</p><p>我们拿到 JWT 之后，通过 Spring Cloud Security 来自动解析 JWT 字符串，获取用户信息，然后自动将用户信息注入 SecurityContext 中，相当于自动完成一次登录操作，然后继续后面的操作，这样自己要省事很多，而且 Spring Security 中的各种路径拦截规则我们都还可以继续使用。</p><p>好了，本文就是和大家聊一点思路，基于这个思路，松哥有一个 Spring Cloud 微服务脚手架代码正在完善，近期会和小伙伴们见面，请大家保持关注哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直在发安全相关的 Spring Security 和 OAuth2，当然这两个系列还在继续，对 Spring Security 和 OAuth2 感兴趣的小伙伴，不要错过前面的文章哦，本文主要将一些理论上的东西，所以要是前面的 OAuth2 不懂，可能阅读起来有些吃力：&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>274 页 pdf 文档，Spring Boot 教程也有离线版了</title>
    <link href="http://www.javaboy.org/2020/0422/spring-boot-guide.html"/>
    <id>http://www.javaboy.org/2020/0422/spring-boot-guide.html</id>
    <published>2020-04-22T09:17:53.000Z</published>
    <updated>2020-04-23T10:16:40.078Z</updated>
    
    <content type="html"><![CDATA[<p>上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在松哥公众号后台分别回复：<code>maven</code>、<code>spring</code>、<code>springmvc</code>、<code>mybatis</code> 可以获取松哥手敲的干货教程，当然也可以直接访问在线教程：</p><a id="more"></a><ul><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><strong>不过，从今天开始，公众号后台干货喜迎新的关键字 <code>springboot</code>。</strong></p><p>很早就有小伙伴问松哥 Spring Boot 教程有没有电子版的，其实这个我一直在准备，迟迟没有发布的原因在于我一直觉得已有的教程还不够完善，还需要补充，而 pdf 一旦发布，传播开来后，再更新的话，大家不容易及时 GET 到。</p><p>所以，我一直做的是在线电子书，在线电子书的好处是可以及时更新，这样无论什么时候大家打开在线文档，看到的就是最新的教程。</p><p>不过由于电子文档托管在 GitHub 上，GitHub 近来访问速度越来越慢，图片也经常加载不出来。另一方面，昨天整理完了 15 道 Spring Boot 面试题，然后早期博客的排版问题我也逐一整理了一遍，这个教程也算是告一段落了，阶段性收尾，于是抽空做了这个离线的 pdf 文档。</p><p><img src="http://img.itboyhub.com/2020/04/spring-boot-51-1.png" alt><br><img src="http://img.itboyhub.com/2020/04/spring-boot-51-2.png" alt></p><p>还是老规矩，小伙伴们在公众号后台回复 springboot，可以获取该 pdf 文档。</p><p>如果不想看离线的 pdf ，也可以看在线的教程，内容基本是一样的：</p><ul><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p><img src="http://img.itboyhub.com/2020/04/spring-boot-51-3.png" alt></p><p>松哥最早开始写博客的时候，对于排版技巧啥的都不太懂，导致一开始的博客排版比较丑陋，最近我基本上都挨个重新排版了一遍，所以文章看起来会更加整齐一些了。</p><p>另外松哥每一次发布的 pdf 文档教程，都是有书签的，大家点击左边的书签可以快速导航到自己想看的知识点。不过由于国内的版权环境不佳，所以松哥发布的 pdf 教程都是经过我处理的，但是这个处理并不影响阅读，该怎么看还是怎么看（建议用 Adobe 官方的 pdf 阅读器）。</p><p>好了，废话就不多说了，Spring Boot 撸起来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在松哥公众号后台分别回复：&lt;code&gt;maven&lt;/code&gt;、&lt;code&gt;spring&lt;/code&gt;、&lt;code&gt;springmvc&lt;/code&gt;、&lt;code&gt;mybatis&lt;/code&gt; 可以获取松哥手敲的干货教程，当然也可以直接访问在线教程：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</title>
    <link href="http://www.javaboy.org/2020/0421/oauth2-jwt.html"/>
    <id>http://www.javaboy.org/2020/0421/oauth2-jwt.html</id>
    <published>2020-04-21T09:17:35.000Z</published>
    <updated>2020-04-23T09:30:52.337Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>本文是我们 OAuth2 系列的第五篇，通过前面四篇文章相信大家对于 OAuth2 中的各种授权登录流程已经轻车熟路了。</p><a id="more"></a><p>前面的文章松哥侧重于和大家理清楚 OAuth2 的登录流程，对于一些登录细节则没有去深究，接下来松哥会和大家把这些案例一一进行晚上。</p><p>本文依然是在前面案例的基础上完成，所以还是强烈建议小伙伴们阅读本系列前面的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li></ol><p>今天松哥主要和大家分享如何把 OAuth2 和 JWT 套在一起玩！</p><p>传统的通过 session 来记录用户认证信息的方式我们可以理解为这是一种有状态登录，而 JWT 则代表了一种无状态登录。<strong>无状态登录天然的具备单点登录能力，所以这个技术组合小伙伴们还是很有必要认真学习下。</strong> 可能有小伙伴对这个概念还不太熟悉，我这里就先来科普一下有状态登录和无状态登录。</p><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1. 无状态登录"></a>1. 无状态登录</h2><h3 id="1-1-什么是有状态"><a href="#1-1-什么是有状态" class="headerlink" title="1.1 什么是有状态"></a>1.1 什么是有状态</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h3><h4 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h4><p>JWT，全称是 Json Web Token ， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-4-2-JWT-数据格式"><a href="#1-4-2-JWT-数据格式" class="headerlink" title="1.4.2 JWT 数据格式"></a>1.4.2 JWT 数据格式</h4><p>JWT 包含三部分数据：</p><p>1.Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><p>2.Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了 7 个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><p>3.Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥 secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</p><p>生成的数据格式如下图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-4-3-JWT-交互流程"><a href="#1-4-3-JWT-交互流程" class="headerlink" title="1.4.3 JWT 交互流程"></a>1.4.3 JWT 交互流程</h4><p>流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就符合了 RESTful 的无状态规范。</p><h3 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h3><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><h2 id="2-OAuth2-中的问题"><a href="#2-OAuth2-中的问题" class="headerlink" title="2.OAuth2 中的问题"></a>2.OAuth2 中的问题</h2><p>在<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">前面的文章中</a>，授权服务器派发了 access_token 之后，客户端拿着 access_token 去请求资源服务器，资源服务器要去校验 access_token 的真伪，所以我们在资源服务器上配置了 RemoteTokenServices，让资源服务器做远程校验：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">    services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">    services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高并发环境下这样的校验方式显然是有问题的，如果结合 JWT，用户的所有信息都保存在 JWT 中，这样就可以有效的解决上面的问题。</p><h2 id="3-改造方案"><a href="#3-改造方案" class="headerlink" title="3.改造方案"></a>3.改造方案</h2><h3 id="3-1-授权服务器改造"><a href="#3-1-授权服务器改造" class="headerlink" title="3.1 授权服务器改造"></a>3.1 授权服务器改造</h3><p>首先我们来看对授权服务器的改造，我们来修改 AccessTokenConfig 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String SIGNING_KEY = <span class="hljs-string">"javaboy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="hljs-keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改造主要是两方面：</p><ol><li>TokenStore 我们使用 JwtTokenStore 这个实例。之前我们将 access_token 无论是存储在内存中，还是存储在 Redis 中，都是要存下来的，客户端将 access_token 发来之后，我们还要校验看对不对。但是如果使用了 JWT，access_token 实际上就不用存储了（无状态登录，服务端不需要保存信息），因为用户的所有信息都在 jwt 里边，所以这里配置的 JwtTokenStore 本质上并不是做存储。</li><li>另外我们还提供了一个 JwtAccessTokenConverter，这个 JwtAccessTokenConverter 可以实现将用户信息和 JWT 进行转换（将用户信息转为 jwt 字符串，或者从 jwt 字符串提取出用户信息）。</li><li>另外，在 JWT 字符串生成的时候，我们需要一个签名，这个签名需要自己保存好。</li></ol><p>这里 JWT 默认生成的用户信息主要是用户角色、用户名等，如果我们希望在生成的 JWT 上面添加额外的信息，可以按照如下方式添加：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAdditionalInformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenEnhancer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; info = accessToken.getAdditionalInformation();</span><br><span class="line">        info.put(<span class="hljs-string">"author"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);</span><br><span class="line">        <span class="hljs-keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类 CustomAdditionalInformation 实现 TokenEnhancer 接口，并实现接口中的 enhance 方法。enhance 方法中的 OAuth2AccessToken 参数就是已经生成的 access_token 信息，我们可以从 OAuth2AccessToken 中取出已经生成的额外信息，然后在此基础上追加自己的信息。</p><p><strong>需要提醒一句，其实我们配置的 JwtAccessTokenConverter 也是 TokenEnhancer 的一个实例</strong></p><p>配置完成之后，我们还需要在 AuthorizationServer 中修改 AuthorizationServerTokenServices 实例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">CustomAdditionalInformation customAdditionalInformation;</span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService());</span><br><span class="line">    services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    TokenEnhancerChain tokenEnhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();</span><br><span class="line">    tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter, customAdditionalInformation));</span><br><span class="line">    services.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是是在 DefaultTokenServices 中配置 TokenEnhancer，将之前的 JwtAccessTokenConverter 和 CustomAdditionalInformation 两个实例注入进来即可。</p><p>如此之后，我们的 auth-server 就算是配置成功了。</p><h3 id="3-2-资源服务器改造"><a href="#3-2-资源服务器改造" class="headerlink" title="3.2 资源服务器改造"></a>3.2 资源服务器改造</h3><p>接下来我们还需要对资源服务器进行改造，也就是 user-server，我们将 auth-server 中的 AccessTokenConfig 类拷贝到 user-server 中，然后在资源服务器配置中不再配置远程校验地址，而是配置一个 TokenStore 即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置好之后，会自动调用 JwtAccessTokenConverter 将 jwt 解析出来，jwt 里边就包含了用户的基本信息，所以就不用远程校验 access_token 了。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>OK，上面配置完成后，我们就可以启动 auth-server、user-server 进行测试，这里为了测试方便，我配置了 password 模式来测试（参考<a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a>）。</p><p>首先我们请求 auth-server 获取 token，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-4.png" alt></p><p>可以看到，jwt 的字符串还是挺长的，另外返回的数据中也有我们自定义的信息。根据本文第一小节的介绍，小伙伴们可以使用一些在线的 Base64 工具自行解码 jwt 字符串的前两部分，当然也可以通过 check_token 接口来解析：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-5.png" alt></p><p>解析后就可以看到 jwt 中保存的用户详细信息了。</p><p>拿到 access_token 之后，我们就可以去访问 user-server 中的资源了，访问方式跟之前的一样，请求头中传入 access_token 即可：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-6.png" alt></p><p>如此之后，我们就成功的将 OAuth2 和 Jwt 结合起来了。</p><h2 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h2><p>那么普通的 access_token 到底是怎么变为 jwt 的？jwt 和认证信息又是如何自动转换的？松哥也来和大家扯一扯。</p><p>首先我们知道，access_token 的生成，默认是在 DefaultTokenServices#createAccessToken 方法中的，我们来看下 createAccessToken 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken)</span> </span>&#123;</span><br><span class="line">DefaultOAuth2AccessToken token = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(UUID.randomUUID().toString());</span><br><span class="line"><span class="hljs-keyword">int</span> validitySeconds = getAccessTokenValiditySeconds(authentication.getOAuth2Request());</span><br><span class="line"><span class="hljs-keyword">if</span> (validitySeconds &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">token.setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + (validitySeconds * <span class="hljs-number">1000L</span>)));</span><br><span class="line">&#125;</span><br><span class="line">token.setRefreshToken(refreshToken);</span><br><span class="line">token.setScope(authentication.getOAuth2Request().getScope());</span><br><span class="line"><span class="hljs-keyword">return</span> accessTokenEnhancer != <span class="hljs-keyword">null</span> ? accessTokenEnhancer.enhance(token, authentication) : token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中我们可以看到：</p><ol><li>默认生成的 access_token 其实就是一个 UUID 字符串。</li><li>getAccessTokenValiditySeconds 方法用来获取 access_token 的有效期，点进去这个方法，我们发现这个数字是从数据库中查询出来的，其实就是我们配置的 access_token 的有效期，我们配置的有效期单位是秒。</li><li>如果设置的 access_token 有效期大于 0，则调用 setExpiration 方法设置过期时间，过期时间就是在当前时间基础上加上用户设置的过期时间，注意乘以 1000 将时间单位转为毫秒。</li><li>接下来设置刷新 token 和授权范围 scope（刷新 token 的生成过程在 createRefreshToken 方法中，其实和 access_token 的生成过程类似）。</li><li>最后面 return 比较关键，这里会判断有没有 accessTokenEnhancer，如果 accessTokenEnhancer 不为 null，则在 accessTokenEnhancer 中再处理一遍才返回，accessTokenEnhancer 中再处理一遍就比较关键了，就是 access_token 转为 jwt 字符串的过程。</li></ol><p>这里的 accessTokenEnhancer 实际上是一个 TokenEnhancerChain，这个链中有一个 delegates 变量保存了我们定义的两个 TokenEnhancer（auth-server 中定义的 JwtAccessTokenConverter 和 CustomAdditionalInformation），也就是说，我们的 access_token 信息将在这两个类中进行二次处理。<strong>处理的顺序是按照集合中保存的顺序，就是先在 JwtAccessTokenConverter 中处理，后在 CustomAdditionalInformation 中处理，顺序不能乱，也意味着我们在 auth-server 中定义的时候，JwtAccessTokenConverter 和 CustomAdditionalInformation 的顺序不能写错。</strong></p><p>无论是 JwtAccessTokenConverter 还是 CustomAdditionalInformation，它里边核心的方法都是 enhance，我们先来看 JwtAccessTokenConverter#enhance：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">DefaultOAuth2AccessToken result = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;(accessToken.getAdditionalInformation());</span><br><span class="line">String tokenId = result.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (!info.containsKey(TOKEN_ID)) &#123;</span><br><span class="line">info.put(TOKEN_ID, tokenId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">tokenId = (String) info.get(TOKEN_ID);</span><br><span class="line">&#125;</span><br><span class="line">result.setAdditionalInformation(info);</span><br><span class="line">result.setValue(encode(result, authentication));</span><br><span class="line">OAuth2RefreshToken refreshToken = result.getRefreshToken();</span><br><span class="line"><span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">DefaultOAuth2AccessToken encodedRefreshToken = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">encodedRefreshToken.setValue(refreshToken.getValue());</span><br><span class="line"><span class="hljs-comment">// Refresh tokens do not expire unless explicitly of the right type</span></span><br><span class="line">encodedRefreshToken.setExpiration(<span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; claims = objectMapper</span><br><span class="line">.parseMap(JwtHelper.decode(refreshToken.getValue()).getClaims());</span><br><span class="line"><span class="hljs-keyword">if</span> (claims.containsKey(TOKEN_ID)) &#123;</span><br><span class="line">encodedRefreshToken.setValue(claims.get(TOKEN_ID).toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; refreshTokenInfo = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;(</span><br><span class="line">accessToken.getAdditionalInformation());</span><br><span class="line">refreshTokenInfo.put(TOKEN_ID, encodedRefreshToken.getValue());</span><br><span class="line">refreshTokenInfo.put(ACCESS_TOKEN_ID, tokenId);</span><br><span class="line">encodedRefreshToken.setAdditionalInformation(refreshTokenInfo);</span><br><span class="line">DefaultOAuth2RefreshToken token = <span class="hljs-keyword">new</span> DefaultOAuth2RefreshToken(</span><br><span class="line">encode(encodedRefreshToken, authentication));</span><br><span class="line"><span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;</span><br><span class="line">Date expiration = ((ExpiringOAuth2RefreshToken) refreshToken).getExpiration();</span><br><span class="line">encodedRefreshToken.setExpiration(expiration);</span><br><span class="line">token = <span class="hljs-keyword">new</span> DefaultExpiringOAuth2RefreshToken(encode(encodedRefreshToken, authentication), expiration);</span><br><span class="line">&#125;</span><br><span class="line">result.setRefreshToken(token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然比较长，但是却很好理解：</p><ol><li>首先构造一个 DefaultOAuth2AccessToken 对象。</li><li>将 accessToken 中的附加信息拿出来（此时默认没有附加信息）。</li><li>获取旧的 access_token（就是上一步 UUID 字符串），将之作为附加信息存入到 info 中（第四小节测试中，返回的 jwt 中有一个 jti，其实就是这里存入进来的）。</li><li>将附加信息存入 result 中。</li><li>对 result 进行编码，将编码结果作为新的 access_token，这个编码的过程就是 jwt 字符串生成的过程。</li><li>接下来是处理刷新 token，刷新 token 如果是 jwt 字符串，则需要有一个解码操作，否则不需要，刷新 token 如果是 ExpiringOAuth2RefreshToken 的实例，表示刷新 token 已经过期，则重新生成一个，这里的逻辑比较简单，我就不啰嗦了。</li></ol><p>最后我们再来看看这里多次出现的 encode 方法，就是 jwt 字符串编码的过程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">encode</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">String content;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">content = objectMapper.formatMap(tokenConverter.convertAccessToken(accessToken, authentication));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot convert access token to JSON"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">String token = JwtHelper.encode(content, signer).getEncoded();</span><br><span class="line"><span class="hljs-keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里首先是把用户信息和 access_token 生成一个 JSON 字符串，然后调用 JwtHelper.encode 方法进行 jwt 编码。</p><p>jwt 编码的过程其实也不难，松哥之前也写过相应的文章，感兴趣的小伙伴可以公众号后台回复 springboot，里边有一篇文章就是讲自动手动生成 jwt 字符串的，这里我就不赘述了。</p><p>OK，本文和小伙伴们聊了一些 OAuth2+JWT 的问题，完成案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;本文是我们 OAuth2 系列的第五篇，通过前面四篇文章相信大家对于 OAuth2 中的各种授权登录流程已经轻车熟路了。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你玩转 OAuth2 授权码模式|视频版</title>
    <link href="http://www.javaboy.org/2020/0420/oauth2-authorization-code-video.html"/>
    <id>http://www.javaboy.org/2020/0420/oauth2-authorization-code-video.html</id>
    <published>2020-04-20T09:17:19.000Z</published>
    <updated>2020-04-23T09:31:00.652Z</updated>
    
    <content type="html"><![CDATA[<p>*<a href="https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ" target="_blank" rel="noopener">视频地址</a></p><p>昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。</p><a id="more"></a><p>本文我将通过一个<strong>完整的 Demo</strong> ，注意，是一个<strong>完整的 Demo</strong>，带领小伙伴们把授权码模式走一遍。</p><p>如果小伙伴们还没有看上篇文章可以先看下，这有助于你理解本文中的一些概念：</p><ul><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li></ul><h2 id="1-案例架构"><a href="#1-案例架构" class="headerlink" title="1.案例架构"></a>1.案例架构</h2><p>因为 OAuth2 涉及到的东西比较多，网上的案例大多都是简化的，对于很多初学者而言，简化的案例看的人云里雾里，所以松哥这次想自己搭建一个完整的测试案例，在这个案例中，主要包括如下服务：</p><ul><li>第三方应用</li><li>授权服务器</li><li>资源服务器</li><li>用户</li></ul><p>我用一个表格来给大家整理下：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">8080</td><td style="text-align:left">授权服务器</td></tr><tr><td style="text-align:left">user-server</td><td style="text-align:left">8081</td><td style="text-align:left">资源服务器</td></tr><tr><td style="text-align:left">client-app</td><td style="text-align:left">8082</td><td style="text-align:left">第三方应用</td></tr></tbody></table><p>就是说，我们常见的 OAuth2 授权码模式登录中，涉及到的各个角色，我都会自己提供，自己测试，这样可以最大限度的让小伙伴们了解到 OAuth2 的工作原理（文末可以下载案例源码）。</p><p>注意：小伙伴们一定先看下<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>松哥所讲的 OAuth2 授权码模式登录流程，再来学习本文。</p><p>那我们首先来创建一个空的 Maven 父工程，创建好之后，里边什么都不用加，也不用写代码。我们将在这个父工程中搭建这个子模块。</p><h2 id="2-授权服务器搭建"><a href="#2-授权服务器搭建" class="headerlink" title="2.授权服务器搭建"></a>2.授权服务器搭建</h2><p>首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖：</p><ul><li>web</li><li>spring cloud security</li><li>spirng cloud OAuth2</li></ul><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建完成后，首先提供一个 Spring Security 的基本配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。</p><p>这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。</p><p>这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。</p><p>基本的用户信息配置完成后，接下来我们来配置授权服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.checkTokenAccess(<span class="hljs-string">"permitAll()"</span>)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">                .tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationCodeServices <span class="hljs-title">authorizationCodeServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点长，我来给大家挨个解释：</p><ol><li>首先我们提供了一个 TokenStore 的实例，这个是指你生成的 Token 要往哪里存储，我们可以存在 Redis 中，也可以存在内存中，也可以结合 JWT 等等，这里，我们就先把它存在内存中，所以提供一个 InMemoryTokenStore 的实例即可。</li><li>接下来我们创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。</li><li>在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。</li><li>AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。checkTokenAccess 是指一个 Token 校验的端点，这个端点我们设置为可以直接访问（在后面，当资源服务器收到 Token 之后，需要去校验 Token 的合法性，就会访问这个端点）。</li><li>ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操作中，refresh_token 也被算作一种。</li><li>AuthorizationServerEndpointsConfigurer 这里用来配置令牌的访问端点和令牌服务。authorizationCodeServices用来配置授权码的存储，这里我们是存在在内存中，tokenServices 用来配置令牌的存储，即 access_token 的存储位置，这里我们也先存储在内存中。有小伙伴会问，授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的，如果搞不清楚，建议重新阅读上篇文章恶补一下：<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li>tokenServices 这个 Bean 主要用来配置 Token 的一些基本信息，例如 Token 是否支持刷新、Token 的存储位置、Token 的有效期以及刷新 Token 的有效期等等。Token 有效期这个好理解，刷新 Token 的有效期我说一下，当 Token 快要过期的时候，我们需要获取一个新的 Token，在获取新的 Token 时候，需要有一个凭证信息，这个凭证信息不是旧的 Token，而是另外一个 refresh_token，这个 refresh_token 也是有有效期的。</li></ol><p>好了，如此之后，我们的授权服务器就算是配置完成了，接下来我们启动授权服务器。</p><h2 id="3-资源服务器搭建"><a href="#3-资源服务器搭建" class="headerlink" title="3.资源服务器搭建"></a>3.资源服务器搭建</h2><p>接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。</p><p>资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。</p><p>我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建成功之后，添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码很简单，我简单的说一下：</p><ol><li>tokenServices 我们配置了一个 RemoteTokenServices 的实例，这是因为资源服务器和授权服务器是分开的，资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices 了。</li><li>RemoteTokenServices 中我们配置了 access_token 的校验地址、client_id、client_secret 这三个信息，当用户来资源服务器请求资源时，会携带上一个 access_token，通过这里的配置，就能够校验出 token 是否正确等。</li><li>最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。</li></ol><p>接下来我们再来配置两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，我们的资源服务器就算配置成功了。</p><h2 id="4-第三方应用搭建"><a href="#4-第三方应用搭建" class="headerlink" title="4.第三方应用搭建"></a>4.第三方应用搭建</h2><p>接下来搭建我们的第三方应用程序。</p><p>注意，第三方应用并非必须，下面所写的代码也可以用 POSTMAN 去测试，这个小伙伴们可以自行尝试。</p><p>第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-2.png" alt></p><p>在 resources/templates 目录下，创建 index.html ，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/oauth/authorize?client_id=javaboy&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html"</span>&gt;</span>第三方登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一段 Thymeleaf 模版，点击超链接就可以实现第三方登录，超链接的参数如下：</p><ul><li>client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。</li><li>response_type 表示响应类型，这里是 code 表示响应一个授权码。</li><li>redirect_uri 表示授权成功后的重定向地址，这里表示回到第三方应用的首页。</li><li>scope 表示授权范围。</li></ul><p>h1 标签中的数据是来自资源服务器的，当授权服务器通过后，我们拿着 access_token 去资源服务器加载数据，加载到的数据就在 h1 标签中显示出来。</p><p>接下来我们来定义一个 HelloController：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">            map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">            Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">            String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line">            HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">            headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 HelloController 中，我们定义出 /index.html 的地址。</p><p>如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作：</p><ol><li>根据拿到的 code，去请求 <code>http://localhost:8080/oauth/token</code> 地址去获取 Token，返回的数据结构如下：</li></ol><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"e7f223c4-7543-43c0-b5a6-5011743b5af4"</span>,</span><br><span class="line">    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,</span><br><span class="line">    <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"aafc167b-a112-456e-bbd8-58cb56d915dd"</span>,</span><br><span class="line">    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">7199</span>,</span><br><span class="line">    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>access_token 就是我们请求数据所需要的令牌，refresh_token 则是我们刷新 token 所需要的令牌，expires_in 表示 token 有效期还剩多久。</p><ol start="2"><li>接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中。</li></ol><p><strong>这里我只是举一个简单的例子，目的是和大家把这个流程走通，正常来说，access_token 我们可能需要一个定时任务去维护，不用每次请求页面都去获取，定期去获取最新的 access_token 即可。后面的文章中，松哥还会继续完善这个案例，到时候再来和大家解决这些细节问题。</strong></p><p>OK，代码写完后，我们就可以启动第三方应用开始测试了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们去测试。</p><p>首先我们去访问 <code>http://localhost:8082/index.html</code> 页面，结果如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-3.png" alt></p><p>然后我们点击 第三方登录 这个超链接，点完之后，会进入到授权服务器的默认登录页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-4.png" alt></p><p>接下来我们输入在授权服务器中配置的用户信息来登录，登录成功后，会看到如下页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-5.png" alt></p><p>在这个页面中，我们可以看到一个提示，询问是否授权 javaboy 这个用户去访问被保护的资源，我们选择 approve(批准)，然后点击下方的 Authorize 按钮，点完之后，页面会自动跳转回我的第三方应用中：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-6.png" alt></p><p>大家注意，这个时候地址栏多了一个 code 参数，这就是授权服务器给出的授权码，拿着这个授权码，我们就可以去请求 access_token，授权码使用一次就会失效。</p><p>同时大家注意到页面多了一个 admin，这个 admin 就是从资源服务器请求到的数据。</p><p>当然，我们在授权服务器中配置了两个用户，大家也可以尝试用 javaboy/123 这个用户去登录，因为这个用户不具备 admin 角色，所以使用这个用户将无法获取到 admin 这个字符串，报错信息如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-7.png" alt></p><p>这个小伙伴们可以自己去测试，我就不再演示了。</p><p>最后在说一句，这不是终极版，只是一个雏形，后面的文章，松哥再带大家来继续完善这个案例。</p><p>好了，本文案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*&lt;a href=&quot;https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2 令牌还能存入 Redis ？越玩越溜！</title>
    <link href="http://www.javaboy.org/2020/0417/oauth2-redis.html"/>
    <id>http://www.javaboy.org/2020/0417/oauth2-redis.html</id>
    <published>2020-04-17T09:17:00.000Z</published>
    <updated>2020-04-23T09:31:09.289Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth2 的登录流程相信小伙伴们看了前面的文章应该已经清楚了，接下来我们来看一下这里的细节问题，使我们的案例更贴近实际项目。</p><a id="more"></a><p>还是需要跟小伙伴们强调下本系列前面几篇文章非常重要，一定要阅读之后再来学习本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li></ol><p>本文我将从三个方面来做优化：</p><ol><li>令牌往哪里存？</li><li>客户端信息入库</li><li>第三方应用优化</li></ol><p>好，我们分别来看。</p><p><strong>注意，本文的案例在本系列第三篇文章的基础上修改而来。</strong></p><h2 id="1-令牌往哪里存？"><a href="#1-令牌往哪里存？" class="headerlink" title="1.令牌往哪里存？"></a>1.令牌往哪里存？</h2><p>在我们配置授权码模式的时候，有两个东西当时存在了内存中：</p><ul><li>InMemoryAuthorizationCodeServices 这个表授权码存在内存中。</li><li>InMemoryTokenStore 表示生成的令牌存在内存中。</li></ul><p>授权码用过一次就会失效，存在内存中没什么问题，但是令牌，我们实际上还有其他的存储方案。</p><p>我们所使用的 InMemoryTokenStore 实现了 TokenStore 接口，我们来看下 TokenStore 接口的实现类：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-4-1.png" alt></p><p>可以看到，我们有多种方式来存储 access_token。</p><ol><li>InMemoryTokenStore，这是我们之前使用的，也是系统默认的，就是将 access_token 存到内存中，单机应用这个没有问题，但是在分布式环境下不推荐。</li><li>JdbcTokenStore，看名字就知道，这种方式令牌会被保存到数据中，这样就可以方便的和其他应用共享令牌信息。</li><li>JwtTokenStore，这个其实不是存储，因为使用了 jwt 之后，在生成的 jwt 中就有用户的所有信息，服务端不需要保存，这也是无状态登录，关于 OAuth2 结合 JWT 的用法，松哥本系列未来的文章中，也会详细介绍，这里就不再多说。</li><li>RedisTokenStore，这个很明显就是将 access_token 存到 redis 中。</li><li>JwkTokenStore，将 access_token 保存到 JSON Web Key。</li></ol><p>虽然这里支持的方案比较多，但是我们常用的实际上主要是两个，RedisTokenStore 和 JwtTokenStore，JwtTokenStore 的比较复杂，我会在后面专门写文章来单独介绍，这里先来跟大家演示存入 RedisTokenStore。</p><p>首先我们启动一个 Redis 服务，然后给 auth-server 添加 Redis 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖添加成功后，在 application.properties 中添加 redis 配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=123</span><br></pre></td></tr></table></figure><p>配置完成后，我们修改 TokenStore 的实例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分别启动 auth-server、client-app 以及 user-server，走一遍第三方登录流程，然后我们发现，派发的 access_token 在 redis 中也有一份：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-4--2.png" alt></p><p>可以看到，数据都存到 Redis 中了，access_token 这个 key 在 Redis 中的有效期就是授权码的有效期。正是因为 Redis 中的这种过期机制，让它在存储 access_token 时具有天然的优势。</p><h2 id="2-客户端信息入库"><a href="#2-客户端信息入库" class="headerlink" title="2.客户端信息入库"></a>2.客户端信息入库</h2><p>在前面的文章中，客户端信息我们是直接存储在内存中的，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">            .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">            .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">            .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">            .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在实际项目中，这种方式并不可取，一来客户端信息在代码中写死了，以后不好维护，而来我们的客户端信息可能量非常大，都写在代码里那你的代码该有多长呀（想象一下有多少第三方应用接入了微信登录）～</p><p>所以我们要将客户端信息存入数据库中。</p><p>客户端信息入库涉及到的接口主要是 ClientDetailsService，这个接口主要有两个实现类，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-4-3.png" alt></p><p>InMemoryClientDetailsService 就不多说了，这是存在内存中的。如果要存入数据库，很明显是 JdbcClientDetailsService，我们来大概看下 JdbcClientDetailsService 的源码，就能分析出数据库的结构了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcClientDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientDetailsService</span>, <span class="hljs-title">ClientRegistrationService</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CLIENT_FIELDS_FOR_UPDATE = <span class="hljs-string">"resource_ids, scope, "</span></span><br><span class="line">+ <span class="hljs-string">"authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, "</span></span><br><span class="line">+ <span class="hljs-string">"refresh_token_validity, additional_information, autoapprove"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CLIENT_FIELDS = <span class="hljs-string">"client_secret, "</span> + CLIENT_FIELDS_FOR_UPDATE;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BASE_FIND_STATEMENT = <span class="hljs-string">"select client_id, "</span> + CLIENT_FIELDS</span><br><span class="line">+ <span class="hljs-string">" from oauth_client_details"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_FIND_STATEMENT = BASE_FIND_STATEMENT + <span class="hljs-string">" order by client_id"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SELECT_STATEMENT = BASE_FIND_STATEMENT + <span class="hljs-string">" where client_id = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_INSERT_STATEMENT = <span class="hljs-string">"insert into oauth_client_details ("</span> + CLIENT_FIELDS</span><br><span class="line">+ <span class="hljs-string">", client_id) values (?,?,?,?,?,?,?,?,?,?,?)"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_UPDATE_STATEMENT = <span class="hljs-string">"update oauth_client_details "</span> + <span class="hljs-string">"set "</span></span><br><span class="line">+ CLIENT_FIELDS_FOR_UPDATE.replaceAll(<span class="hljs-string">", "</span>, <span class="hljs-string">"=?, "</span>) + <span class="hljs-string">"=? where client_id = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_UPDATE_SECRET_STATEMENT = <span class="hljs-string">"update oauth_client_details "</span></span><br><span class="line">+ <span class="hljs-string">"set client_secret = ? where client_id = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_DELETE_STATEMENT = <span class="hljs-string">"delete from oauth_client_details where client_id = ?"</span>;</span><br></pre></td></tr></table></figure><p>从这段简单的源码中，我们大概就能分析出表的结构，松哥给出的 SQL 脚本如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`oauth_client_details`</span>;</span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`oauth_client_details`</span> (</span><br><span class="line">  <span class="hljs-string">`client_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">48</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`resource_ids`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`client_secret`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`scope`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`authorized_grant_types`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`web_server_redirect_uri`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`authorities`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`access_token_validity`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`refresh_token_validity`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`additional_information`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">4096</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`autoapprove`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`client_id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>接下来我们将一开始定义的客户端的关键信息存入数据库中，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-4-4.png" alt></p><p>既然用到了数据库，依赖当然也要提供相应的支持，我们给 auth-server 添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.properties 中配置一下数据库的连接信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimeZone=Asia/Shanghai</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.username=root</span><br><span class="line"></span><br><span class="line">spring.main.allow-bean-definition-overriding=true</span><br></pre></td></tr></table></figure><p>这里的配置多了最后一条。这是因为我们一会要创建自己的 ClientDetailsService，而系统已经创建了 ClientDetailsService，加了最后一条就允许我们自己的实例覆盖系统默认的实例。</p><p>接下来，我们来提供自己的实例即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">ClientDetailsService <span class="hljs-title">clientDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.withClientDetails(clientDetailsService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启 auth-server，走一遍第三方登录流程，和我们前面效果一样。不再赘述。</p><p>我们也可以将令牌有效期配置在数据库中，这样就不用在代码中配置了，修改后的数据库如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-4-5.png" alt></p><p>修改后的 AuthorizationServerTokenServices 实例如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService());</span><br><span class="line">    services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-第三方应用优化"><a href="#3-第三方应用优化" class="headerlink" title="3.第三方应用优化"></a>3.第三方应用优化</h2><p>前面我们所写的第三方登录，我们在 Controller 中是这么定义的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">        map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">        map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">        map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">        Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">        System.out.println(resp);</span><br><span class="line">        String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">        System.out.println(access_token);</span><br><span class="line">        HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">        HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时只是为了给大家演示登录流程，今天我们来把这个过程再来稍微优化下。</p><p>首先我们来定义一个专门的类 TokenTask 用来解决 Token 的管理问题：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenTask</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    <span class="hljs-keyword">public</span> String access_token = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> String refresh_token = <span class="hljs-string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(access_token) &amp;&amp; code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">            map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">            Map&lt;String, String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">            access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">            refresh_token = resp.get(<span class="hljs-string">"refresh_token"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> loadDataFromResServer();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> loadDataFromResServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">loadDataFromResServer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">            headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            <span class="hljs-keyword">return</span> entity.getBody();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"未加载"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 55 0/1 * * ？"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tokenTask</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">        map.add(<span class="hljs-string">"refresh_token"</span>, refresh_token);</span><br><span class="line">        map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"refresh_token"</span>);</span><br><span class="line">        Map&lt;String, String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">        access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">        refresh_token = resp.get(<span class="hljs-string">"refresh_token"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码没有技术难点，主要是逻辑上，我稍微解释一下：</p><ol><li>首先在 getData 方法中，如果 access_token 为空字符串，并且 code 不为 null，表示这是刚刚拿到授权码的时候，准备去申请令牌了，令牌拿到之后，将 access_token 和 refresh_token 分别赋值给全局变量，然后调用  loadDataFromResServer 方法去资源服务器加载数据。</li><li>另外有一个 tokenTask 方法，这是一个定时任务，每隔 115 分钟去刷新一下 access_token（access_token 有效期是 120 分钟）。</li></ol><p>改造完成后，我们再去 HelloController 中略作调整：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenTask tokenTask;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"msg"</span>, tokenTask.getData(code));</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就 OK 了，当我们再去下图这个页面按 F5 刷新就不会出错了。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-6.png" alt></p><p>OK，本文和小伙伴们聊了一些前面案例的细节问题，完成案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OAuth2 的登录流程相信小伙伴们看了前面的文章应该已经清楚了，接下来我们来看一下这里的细节问题，使我们的案例更贴近实际项目。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</title>
    <link href="http://www.javaboy.org/2020/0416/springsecurity-springdatajpa.html"/>
    <id>http://www.javaboy.org/2020/0416/springsecurity-springdatajpa.html</id>
    <published>2020-04-16T09:16:44.000Z</published>
    <updated>2020-04-23T09:31:45.450Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security+Spring Data Jpa 强强联手，安全管理没有简单，只有更简单！</p><a id="more"></a><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>这周忙着更新 OAuth2，Spring Security 也抽空来一篇。</p><p>Spring Security 系列我们前面已经更新了 6 篇了，本文是第 7 篇，建议先看本系列前面的文章，有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li></ol><p>前面虽然讲了 6 篇，但是我们的用户数据都保存在内存中，在第 6 篇文章中，虽然介绍了 JdbcUserDetailsManager，但是使用起来依然不便，所以今天我要采用一个更加灵活的定义方式。</p><p>那就是我们自己来定义授权数据库的模型。</p><p>为了操作简单，我这里引入 Spring Data Jpa 来帮助我们完成数据库操作。但是本文我不会去重点介绍 Spring Data Jpa 的用法，如果小伙伴们不熟悉 Spring Data Jpa 的操作，可以在公众号后台回复 springboot 获取松哥手敲的 Spring Boot 教程，里边有 jpa 相关操作，也可以看看松哥录制的视频教程：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><h2 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h2><p>首先我们创建一个新的 Spring Boot 工程，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-1.png" alt></p><p>注意，除了 Spring Security 依赖之外，我们还需要数据依赖和 Spring Data Jpa 依赖。</p><p>工程创建完成后，我们再在数据库中创建一个空的库，就叫做 withjpa，里边什么都不用做，这样我们的准备工作就算完成了。</p><h2 id="2-准备模型"><a href="#2-准备模型" class="headerlink" title="2.准备模型"></a>2.准备模型</h2><p>接下来我们创建两个实体类，分别表示用户角色了用户类：</p><p>用户角色：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_role"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> String nameZh;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实体类用来描述用户角色信息，有角色 id、角色名称（英文、中文），@Entity 表示这是一个实体类，项目启动后，将会根据实体类的属性在数据库中自动创建一个角色表。</p><p>用户实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line">    <span class="hljs-meta">@ManyToMany</span>(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Role role : getRoles()) &#123;</span><br><span class="line">            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他 get/set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户实体类主要需要实现  UserDetails 接口，并实现接口中的方法。</p><p>这里的字段基本都好理解，几个特殊的我来稍微说一下：</p><ol><li>accountNonExpired、accountNonLocked、credentialsNonExpired、enabled 这四个属性分别用来描述用户的状态，表示账户是否没有过期、账户是否没有被锁定、密码是否没有过期、以及账户是否可用。</li><li>roles 属性表示用户的角色，User 和 Role 是多对多关系，用一个 @ManyToMany 注解来描述。</li><li>getAuthorities 方法返回用户的角色信息，我们在这个方法中把自己的 Role 稍微转化一下即可。</li></ol><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>数据模型准备好之后，我们再来定义一个 UserDao：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">findUserByUsername</span><span class="hljs-params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的东西很简单，我们只需要继承 JpaRepository 然后提供一个根据 username 查询 user 的方法即可。如果小伙伴们不熟悉 Spring Data Jpa 的操作，可以在公众号后台回复 springboot 获取松哥手敲的 Spring Boot 教程，里边有 jpa 相关操作，也可以看看松哥录制的视频教程：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>。</p><p>在接下来定义 UserService ，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userDao.findUserByUsername(username);</span><br><span class="line">        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己定义的 UserService 需要实现 UserDetailsService 接口，实现该接口，就要实现接口中的方法，也就是 loadUserByUsername ，这个方法的参数就是用户在登录的时候传入的用户名，根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对）。</p><p>配置完成后，接下来我们在 Spring Security 中稍作配置，Spring Security 和测试用的 HelloController 我还是沿用之前文章中的（<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a>），主要列出来需要修改的地方。</p><p>在 SecurityConfig 中，我们通过如下方式来配置用户：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，还是重写 configure 方法，只不过这次我们不是基于内存，也不是基于 JdbcUserDetailsManager，而是使用自定义的 UserService，就这样配置就 OK 了。</p><p>最后，我们再在 application.properties 中配置一下数据库和 JPA 的基本信息，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="hljs-number">123</span></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="hljs-comment">///withjpa?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">spring.jpa.database=mysql</span><br><span class="line">spring.jpa.database-platform=mysql</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.show-sql=<span class="hljs-keyword">true</span></span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect</span><br></pre></td></tr></table></figure><p>都是常规配置，我们就不再重复解释了。</p><p>这一套组合拳下来，我们的 Spring Security 就算是接入数据库了，接下来我们来进行测试，测试的 HelloController 参考<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">上篇文章</a>，我就不重复写了。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>首先我们来添加两条测试数据，在单元测试中添加如下方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">UserDao userDao;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    User u1 = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    u1.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    u1.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">    u1.setAccountNonExpired(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u1.setAccountNonLocked(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u1.setCredentialsNonExpired(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u1.setEnabled(<span class="hljs-keyword">true</span>);</span><br><span class="line">    List&lt;Role&gt; rs1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Role r1 = <span class="hljs-keyword">new</span> Role();</span><br><span class="line">    r1.setName(<span class="hljs-string">"ROLE_admin"</span>);</span><br><span class="line">    r1.setNameZh(<span class="hljs-string">"管理员"</span>);</span><br><span class="line">    rs1.add(r1);</span><br><span class="line">    u1.setRoles(rs1);</span><br><span class="line">    userDao.save(u1);</span><br><span class="line">    User u2 = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    u2.setUsername(<span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">    u2.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">    u2.setAccountNonExpired(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u2.setAccountNonLocked(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u2.setCredentialsNonExpired(<span class="hljs-keyword">true</span>);</span><br><span class="line">    u2.setEnabled(<span class="hljs-keyword">true</span>);</span><br><span class="line">    List&lt;Role&gt; rs2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Role r2 = <span class="hljs-keyword">new</span> Role();</span><br><span class="line">    r2.setName(<span class="hljs-string">"ROLE_user"</span>);</span><br><span class="line">    r2.setNameZh(<span class="hljs-string">"普通用户"</span>);</span><br><span class="line">    rs2.add(r2);</span><br><span class="line">    u2.setRoles(rs2);</span><br><span class="line">    userDao.save(u2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该方法后，我们会发现数据库中多了三张表：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-2.png" alt></p><p>这就是根据我们的实体类自动创建出来的。</p><p>我们来查看一下表中的数据。</p><p>用户表：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-6.png" alt></p><p>角色表：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-7.png" alt></p><p>用户和角色关联表：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-8.png" alt></p><p>有了数据，接下来启动项目，我们来进行测试。</p><p>我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/spring-security-7-9.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>具体测试效果小伙伴们可以参考松哥的视频，我就不截图了。</p><p>在测试的过程中，如果在数据库中将用户的 enabled 属性设置为 false，表示禁用该账户，此时再使用该账户登录就会登录失败。</p><p>按照相同的方式，大家也可以测试 javaboy 用户。</p><p>好了，今天就和小伙伴们说这么多.</p><p><strong>感谢小伙伴们的阅读，如果觉得有用，毫不犹豫的点个在看鼓励下松哥，我会以风驰电掣般的速度快速更完这个系列～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security+Spring Data Jpa 强强联手，安全管理没有简单，只有更简单！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>死磕 OAuth2，教练我要学全套的！</title>
    <link href="http://www.javaboy.org/2020/0415/oauth2-password-implicit.html"/>
    <id>http://www.javaboy.org/2020/0415/oauth2-password-implicit.html</id>
    <published>2020-04-15T09:16:30.000Z</published>
    <updated>2020-04-23T09:31:19.844Z</updated>
    
    <content type="html"><![CDATA[<p>昨天松哥和小伙伴们说了 OAuth2 中的授权码模式，我从头到尾写了一个非常详细的案例，来和小伙伴们分享授权码模式的使用。</p><a id="more"></a><p>有小伙伴表示为什么没有另外三种授权模式的演示代码？要学就学全套的！这不，松哥赶紧把另外三个授权模式的代码整出来，供小伙伴们参考。</p><p>今天的案例，我就不从头开始写了，我们就在<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">上篇文章</a>代码的基础上修改就行了，如果小伙伴们还没看过本系列前面几篇文章，建议一定先看下，否则本文可能看不懂：</p><ul><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li></ul><p>接下来松哥直接上代码，各种授权模式的流程我就不再重复介绍了，大家可以参考本系列<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">第一篇文章</a>。</p><p>对了，文末依然可以下载本文源代码。</p><h2 id="1-简化模式"><a href="#1-简化模式" class="headerlink" title="1.简化模式"></a>1.简化模式</h2><p>要支持简化模式，其实很简单。</p><p>首先，我们在授权服务器中，增加如下配置表示支持简化模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">            .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">            .authorizedGrantTypes(<span class="hljs-string">"refresh_token"</span>,<span class="hljs-string">"implicit"</span>)</span><br><span class="line">            .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">            .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们只需要在 authorizedGrantTypes 中增加 implicit 表示支持简化模式即可。</p><p>配置完成后，重启 auth-server。</p><p>接下来我们配置资源服务器。因为简化模式没有服务端，我们只能通过 js 来请求资源服务器上的数据，所以资源服务器需要支持跨域，我们修改如下两个地方使之支持跨域：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@CrossOrigin</span>(value = <span class="hljs-string">"*"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在 Controller 上添加 @CrossOrigin 注解使之支持跨域，然后配置 Spring Security 使之支持跨域：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .cors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启 user-server。</p><p>接下来我们来配置第三方应用：</p><p>首先我们修改 index.html 页面：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/oauth/authorize?client_id=javaboy&amp;response_type=token&amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html"</span>&gt;</span>第三方登录（简化模式）<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-undefined">    var hash = window.location.hash;//提取出参数，类似这种格式#access_token=9fda1800-3b57-4d32-ad01-05ff700d44cc&amp;token_type=bearer&amp;expires_in=7199</span></span><br><span class="line"><span class="hljs-undefined">    if (hash &amp;&amp; hash.length &gt; 0) &#123;</span></span><br><span class="line"><span class="hljs-undefined">        var params = hash.substring(1).split("&amp;");</span></span><br><span class="line"><span class="hljs-undefined">        var token = params[0].split("=");//[access_token,9fda1800-3b57-4d32-ad01-05ff700d44cc]</span></span><br><span class="line"><span class="hljs-undefined">        $.ajax(&#123;</span></span><br><span class="line"><span class="hljs-undefined">            type: 'get',</span></span><br><span class="line"><span class="hljs-undefined">            headers: &#123;</span></span><br><span class="line"><span class="hljs-undefined">                'Authorization': 'Bearer ' + token[1]</span></span><br><span class="line"><span class="hljs-undefined">            &#125;,</span></span><br><span class="line"><span class="hljs-undefined">            url: 'http://localhost:8081/admin/hello',</span></span><br><span class="line"><span class="hljs-undefined">            success: function (data) &#123;</span></span><br><span class="line"><span class="hljs-undefined">                $("#div1").html(data)</span></span><br><span class="line"><span class="hljs-undefined">            &#125;</span></span><br><span class="line"><span class="hljs-undefined">        &#125;)</span></span><br><span class="line"><span class="hljs-undefined">    &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是之前的超链接不变，但是我们将 response_type 的值修改为 token，表示直接返回授权码，其他参数不变。</p><p>这样，当用户登录成功之后，会自动重定向到 <a href="http://localhost:8082/index.html" target="_blank" rel="noopener">http://localhost:8082/index.html</a> 页面，并且添加了一个锚点参数，类似下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8082/index.html#access_token=9fda1800-3b57-4d32-ad01-05ff700d44cc&amp;token_type=bearer&amp;expires_in=1940</span><br></pre></td></tr></table></figure><p>所以接下来，我们就在 js 中提取出 <code>#</code> 后面的参数，并进一步解析出 access_token 的值。</p><p>拿着 access_token 的值，我们去发送一个 Ajax 请求，将 access_token 放在请求头中，请求成功后，将请求到的数据放在 div 中。</p><p>这就是我们说的简化模式。</p><p>配置完成后，启动 client-app，访问 <code>http://localhost:8082/index.html</code> 页面进行测试，用户授权之后，会自动重定向到该页面，显示效果如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-3-1.png" alt></p><p>完整代码可以在文末下载。</p><h2 id="2-密码模式"><a href="#2-密码模式" class="headerlink" title="2.密码模式"></a>2.密码模式</h2><p>密码模式，需要用户直接在第三方应用上输入用户名密码登录，我们来看下。</p><p><strong>注意，接下来的代码是在上篇文章授权码模式的基础上改造。</strong></p><p>首先对 auth-server 进行改造，使之支持 password 模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">            .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">            .authorizedGrantTypes(<span class="hljs-string">"password"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">            .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">            .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其他地方都不变，主要是在 authorizedGrantTypes 中增加了 password 模式。</p><p>由于使用了 password 模式之后，用户要进行登录，所以我们需要配置一个 AuthenticationManager，还是在 AuthorizationServer 类中，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">AuthenticationManager authenticationManager;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    endpoints</span><br><span class="line">            .authenticationManager(authenticationManager)</span><br><span class="line">            .tokenServices(tokenServices());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在授权码模式中，我们配置的 AuthorizationCodeServices 现在不需要了，取而代之的是 authenticationManager。</p><p>那么这个 authenticationManager 实例从哪里来呢？这需要我们在 Spring Security 的配置中提供，这松哥在之前的 Spring Security 系列教程中说过多次，我就不再赘述，这里直接上代码，在 SecurityConfig 中添加如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启 auth-server。</p><p>接下来配置 client-app，首先我们添加登录功能，修改 index.html ，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这一个简单的登录功能没啥好说的。</p><p>我们来看登录接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password,Model model)</span> </span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="hljs-string">"username"</span>, username);</span><br><span class="line">    map.add(<span class="hljs-string">"password"</span>, password);</span><br><span class="line">    map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">    map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"password"</span>);</span><br><span class="line">    Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">    String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">    HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">    ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">    model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口中，当收到一个用户名密码之后，我们通过 RestTemplate 发送一个 POST 请求，注意 post 请求中，grant_type 参数的值为 password，通过这个请求，我们可以获取 auth-server 返回的 access_token，格式如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;access_token=02e3a1e1-925f-4d2c-baac-42d76703cae4, token_type=bearer, refresh_token=836d4b75-fe53-4e41-9df1-2aad6dd80a5d, expires_in=7199, scope=all&#125;</span><br></pre></td></tr></table></figure><p>可以看到，返回的 token 数据和前面的类似，不再赘述。</p><p>我们提取出 access_token 之后，接下来去请求资源服务器，并将访问到的数据放在 model 中。</p><p>OK，配置完成后，启动 client-app，访问 <a href="http://localhost:8082/index.html" target="_blank" rel="noopener">http://localhost:8082/index.html</a> 页面进行测试。授权完成后，我们在项目首页可以看到如下内容：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-3-2.png" alt></p><p>完整代码可以在文末下载。</p><h2 id="3-客户端模式"><a href="#3-客户端模式" class="headerlink" title="3.客户端模式"></a>3.客户端模式</h2><p>客户端模式适用于没有前端页面的应用，所以我这里用一个单元测试来个大家演示。</p><p><strong>注意，接下来的代码是在上篇文章授权码模式的基础上改造。</strong></p><p>首先修改 auth-server ，使之支持客户端模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">            .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">            .authorizedGrantTypes(<span class="hljs-string">"client_credentials"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">            .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">            .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其他地方都不变，主要是在 authorizedGrantTypes 中增加了 client_credentials 模式。</p><p>配置完成后，重启 auth-server。</p><p>接下来，在 client-app 中，通过单元测试，我们来写一段测试代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">    map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"client_credentials"</span>);</span><br><span class="line">    Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">    String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">    HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">    ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">    System.out.println(entity.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码跟前面的都差不多，就是请求参数不一样而已，参数 grant_type 的值为 client_credentials。其他都一样，我就不再赘述了。</p><p>这段单元测试，执行完成后，就打印出 hello，我就不再截图了。</p><p>完整代码可以在文末下载。</p><h2 id="4-刷新-token"><a href="#4-刷新-token" class="headerlink" title="4.刷新 token"></a>4.刷新 token</h2><p>接下来松哥要讲的，是四种授权模式共有的功能。</p><p>以授权码模式为例，当我们启动 auth-server 之后，在 IntelliJ IDEA 中，我们可以看到项目暴露出来的接口：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-3-4.png" alt></p><p>那么这些接口都是干嘛用的呢？我们通过如下一张表格来理解下：</p><table><thead><tr><th style="text-align:left">端点</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">/oauth/authorize</td><td style="text-align:left">这个是授权的端点</td></tr><tr><td style="text-align:left">/oauth/token</td><td style="text-align:left">这个是用来获取令牌的端点</td></tr><tr><td style="text-align:left">/oauth/confirm_access</td><td style="text-align:left">用户确认授权提交的端点（就是 auth-server 询问用户是否授权那个页面的提交地址）</td></tr><tr><td style="text-align:left">/oauth/error</td><td style="text-align:left">授权出错的端点</td></tr><tr><td style="text-align:left">/oauth/check_token</td><td style="text-align:left">校验 access_token 的端点</td></tr><tr><td style="text-align:left">/oauth/token_key</td><td style="text-align:left">提供公钥的端点</td></tr></tbody></table><p>一目了然。这几个端点大部分我们都用过了，没用过的在未来也会用到，到时候再详细和小伙伴们解释。</p><p>/oauth/token 端点除了颁发令牌，还可以用来刷新令牌，在我们获取令牌的时候，除了 access_token 之外，还有一个 refresh_token，这个 refresh_token 就是用来刷新令牌用的。</p><p>我用 postman 来做一个简单的刷新令牌请求：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-3-5.png" alt></p><p>注意，刷新的时候需要携带上 refresh_token 参数，刷新完成之后，之前旧的 access_token 就会失效。</p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><p>通过上面三个案例，再结合上篇文章，松哥通过四个完完整整的代码，向家展示了 OAuth2 四种授权模式的基本用法。</p><p>这四个完整的案例，大家都可以直接从 github 上下载：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-3-3.png" alt></p><p>好了，先说这么多，如果有收获，一定记得点个在看鼓励下松哥～</p><p>案例地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天松哥和小伙伴们说了 OAuth2 中的授权码模式，我从头到尾写了一个非常详细的案例，来和小伙伴们分享授权码模式的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</title>
    <link href="http://www.javaboy.org/2020/0414/oauth2_authorization_code.html"/>
    <id>http://www.javaboy.org/2020/0414/oauth2_authorization_code.html</id>
    <published>2020-04-13T23:15:51.000Z</published>
    <updated>2020-04-14T23:35:14.210Z</updated>
    
    <content type="html"><![CDATA[<p>昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。</p><a id="more"></a><p>本文我将通过一个<strong>完整的 Demo</strong> ，注意，是一个<strong>完整的 Demo</strong>，带领小伙伴们把授权码模式走一遍。</p><p>如果小伙伴们还没有看上篇文章可以先看下，这有助于你理解本文中的一些概念：</p><ul><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li></ul><h2 id="1-案例架构"><a href="#1-案例架构" class="headerlink" title="1.案例架构"></a>1.案例架构</h2><p>因为 OAuth2 涉及到的东西比较多，网上的案例大多都是简化的，对于很多初学者而言，简化的案例看的人云里雾里，所以松哥这次想自己搭建一个完整的测试案例，在这个案例中，主要包括如下服务：</p><ul><li>第三方应用</li><li>授权服务器</li><li>资源服务器</li><li>用户</li></ul><p>我用一个表格来给大家整理下：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">8080</td><td style="text-align:left">授权服务器</td></tr><tr><td style="text-align:left">user-server</td><td style="text-align:left">8081</td><td style="text-align:left">资源服务器</td></tr><tr><td style="text-align:left">client-app</td><td style="text-align:left">8082</td><td style="text-align:left">第三方应用</td></tr></tbody></table><p>就是说，我们常见的 OAuth2 授权码模式登录中，涉及到的各个角色，我都会自己提供，自己测试，这样可以最大限度的让小伙伴们了解到 OAuth2 的工作原理（文末可以下载案例源码）。</p><p>注意：小伙伴们一定先看下<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>松哥所讲的 OAuth2 授权码模式登录流程，再来学习本文。</p><p>那我们首先来创建一个空的 Maven 父工程，创建好之后，里边什么都不用加，也不用写代码。我们将在这个父工程中搭建这个子模块。</p><h2 id="2-授权服务器搭建"><a href="#2-授权服务器搭建" class="headerlink" title="2.授权服务器搭建"></a>2.授权服务器搭建</h2><p>首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖：</p><ul><li>web</li><li>spring cloud security</li><li>spirng cloud OAuth2</li></ul><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建完成后，首先提供一个 Spring Security 的基本配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。</p><p>这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。</p><p>这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。</p><p>基本的用户信息配置完成后，接下来我们来配置授权服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.checkTokenAccess(<span class="hljs-string">"permitAll()"</span>)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">                .tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationCodeServices <span class="hljs-title">authorizationCodeServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点长，我来给大家挨个解释：</p><ol><li>首先我们提供了一个 TokenStore 的实例，这个是指你生成的 Token 要往哪里存储，我们可以存在 Redis 中，也可以存在内存中，也可以结合 JWT 等等，这里，我们就先把它存在内存中，所以提供一个 InMemoryTokenStore 的实例即可。</li><li>接下来我们创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。</li><li>在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。</li><li>AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。checkTokenAccess 是指一个 Token 校验的端点，这个端点我们设置为可以直接访问（在后面，当资源服务器收到 Token 之后，需要去校验 Token 的合法性，就会访问这个端点）。</li><li>ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操作中，refresh_token 也被算作一种。</li><li>AuthorizationServerEndpointsConfigurer 这里用来配置令牌的访问端点和令牌服务。authorizationCodeServices用来配置授权码的存储，这里我们是存在在内存中，tokenServices 用来配置令牌的存储，即 access_token 的存储位置，这里我们也先存储在内存中。有小伙伴会问，授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的，如果搞不清楚，建议重新阅读上篇文章恶补一下：<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li>tokenServices 这个 Bean 主要用来配置 Token 的一些基本信息，例如 Token 是否支持刷新、Token 的存储位置、Token 的有效期以及刷新 Token 的有效期等等。Token 有效期这个好理解，刷新 Token 的有效期我说一下，当 Token 快要过期的时候，我们需要获取一个新的 Token，在获取新的 Token 时候，需要有一个凭证信息，这个凭证信息不是旧的 Token，而是另外一个 refresh_token，这个 refresh_token 也是有有效期的。</li></ol><p>好了，如此之后，我们的授权服务器就算是配置完成了，接下来我们启动授权服务器。</p><h2 id="3-资源服务器搭建"><a href="#3-资源服务器搭建" class="headerlink" title="3.资源服务器搭建"></a>3.资源服务器搭建</h2><p>接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。</p><p>资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。</p><p>我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建成功之后，添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码很简单，我简单的说一下：</p><ol><li>tokenServices 我们配置了一个 RemoteTokenServices 的实例，这是因为资源服务器和授权服务器是分开的，资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices 了。</li><li>RemoteTokenServices 中我们配置了 access_token 的校验地址、client_id、client_secret 这三个信息，当用户来资源服务器请求资源时，会携带上一个 access_token，通过这里的配置，就能够校验出 token 是否正确等。</li><li>最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。</li></ol><p>接下来我们再来配置两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，我们的资源服务器就算配置成功了。</p><h2 id="4-第三方应用搭建"><a href="#4-第三方应用搭建" class="headerlink" title="4.第三方应用搭建"></a>4.第三方应用搭建</h2><p>接下来搭建我们的第三方应用程序。</p><p>注意，第三方应用并非必须，下面所写的代码也可以用 POSTMAN 去测试，这个小伙伴们可以自行尝试。</p><p>第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-2.png" alt></p><p>在 resources/templates 目录下，创建 index.html ，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/oauth/authorize?client_id=javaboy&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html"</span>&gt;</span>第三方登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一段 Thymeleaf 模版，点击超链接就可以实现第三方登录，超链接的参数如下：</p><ul><li>client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。</li><li>response_type 表示响应类型，这里是 code 表示响应一个授权码。</li><li>redirect_uri 表示授权成功后的重定向地址，这里表示回到第三方应用的首页。</li><li>scope 表示授权范围。</li></ul><p>h1 标签中的数据是来自资源服务器的，当授权服务器通过后，我们拿着 access_token 去资源服务器加载数据，加载到的数据就在 h1 标签中显示出来。</p><p>接下来我们来定义一个 HelloController：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">            map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">            Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">            String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line">            HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">            headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 HelloController 中，我们定义出 /index.html 的地址。</p><p>如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作：</p><ol><li>根据拿到的 code，去请求 <code>http://localhost:8080/oauth/token</code> 地址去获取 Token，返回的数据结构如下：</li></ol><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"e7f223c4-7543-43c0-b5a6-5011743b5af4"</span>,</span><br><span class="line">    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,</span><br><span class="line">    <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"aafc167b-a112-456e-bbd8-58cb56d915dd"</span>,</span><br><span class="line">    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">7199</span>,</span><br><span class="line">    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>access_token 就是我们请求数据所需要的令牌，refresh_token 则是我们刷新 token 所需要的令牌，expires_in 表示 token 有效期还剩多久。</p><ol start="2"><li>接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中。</li></ol><p><strong>这里我只是举一个简单的例子，目的是和大家把这个流程走通，正常来说，access_token 我们可能需要一个定时任务去维护，不用每次请求页面都去获取，定期去获取最新的 access_token 即可。后面的文章中，松哥还会继续完善这个案例，到时候再来和大家解决这些细节问题。</strong></p><p>OK，代码写完后，我们就可以启动第三方应用开始测试了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们去测试。</p><p>首先我们去访问 <code>http://localhost:8082/index.html</code> 页面，结果如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-3.png" alt></p><p>然后我们点击 第三方登录 这个超链接，点完之后，会进入到授权服务器的默认登录页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-4.png" alt></p><p>接下来我们输入在授权服务器中配置的用户信息来登录，登录成功后，会看到如下页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-5.png" alt></p><p>在这个页面中，我们可以看到一个提示，询问是否授权 javaboy 这个用户去访问被保护的资源，我们选择 approve(批准)，然后点击下方的 Authorize 按钮，点完之后，页面会自动跳转回我的第三方应用中：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-6.png" alt></p><p>大家注意，这个时候地址栏多了一个 code 参数，这就是授权服务器给出的授权码，拿着这个授权码，我们就可以去请求 access_token，授权码使用一次就会失效。</p><p>同时大家注意到页面多了一个 admin，这个 admin 就是从资源服务器请求到的数据。</p><p>当然，我们在授权服务器中配置了两个用户，大家也可以尝试用 javaboy/123 这个用户去登录，因为这个用户不具备 admin 角色，所以使用这个用户将无法获取到 admin 这个字符串，报错信息如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-7.png" alt></p><p>这个小伙伴们可以自己去测试，我就不再演示了。</p><p>最后在说一句，这不是终极版，只是一个雏形，后面的文章，松哥再带大家来继续完善这个案例。</p><p>好了，本文案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</title>
    <link href="http://www.javaboy.org/2020/0413/oauth2-info.html"/>
    <id>http://www.javaboy.org/2020/0413/oauth2-info.html</id>
    <published>2020-04-12T23:15:34.000Z</published>
    <updated>2020-04-14T23:35:28.591Z</updated>
    
    <content type="html"><![CDATA[<p>最近在更新 Spring Security 系列，不知不觉已经更新了 6 篇了，要聊 Spring Security，当然就绕不过 OAuth2，但是有很多小伙伴等不及了，不停的追问 OAuth2 的相关技能点，所以我也抽空撸几篇文章，来和大家把 OAuth2 好好的捋一捋，也顺便回顾一下松哥关于 OAuth2 的一些使用经验。</p><a id="more"></a><p>OAuth2 很多小伙伴看过千千万万遍，四种授权模式、认证流程早已烂熟于心，但是就是写不出来代码。所以松哥这次将结合自己的使用经验，再搞一个完整的配套案例，分享给大家。当然这里涉及到的条条框框可能就比较多了，所以我这里可能会分几篇文章来讲解，本文是第一篇。</p><p>当然呢，大家学习这篇文章，建议还是先把已经更新的 Spring Security 系列看一看，入个门：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li></ol><p>好了，不说废话，咱们来看 OAuth2。</p><h2 id="1-为什么需要-OAuth2"><a href="#1-为什么需要-OAuth2" class="headerlink" title="1.为什么需要 OAuth2"></a>1.为什么需要 OAuth2</h2><p>关于我们为什么需要 OAuth2 的问题，网上的文章很多，我们常见的第三方登录就是一个 OAuth2 的典型应用，阮一峰大佬之前有一篇文章非常形象的解释了这个问题，内容如下（原文地址：<a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html）：" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html）：</a></p><h3 id="1-1-快递员问题"><a href="#1-1-快递员问题" class="headerlink" title="1.1 快递员问题"></a>1.1 快递员问题</h3><p>我住在一个大型的居民小区。</p><p><img src="http://img.itboyhub.com/2020/04/oath.png" alt></p><p>小区有门禁系统。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-2.png" alt></p><p>进入的时候需要输入密码。</p><p><img src="http://img.itboyhub.com/2020/04/oath-1-3.png" alt></p><p>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-4.png" alt></p><p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p><p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p><h3 id="1-2-授权机制的设计"><a href="#1-2-授权机制的设计" class="headerlink" title="1.2 授权机制的设计"></a>1.2 授权机制的设计</h3><p>于是，我设计了一套授权机制。</p><p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p><p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p><p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p><p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p><p>第四步，快递员向门禁系统输入令牌，进入小区。</p><p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h3 id="1-3-互联网场景"><a href="#1-3-互联网场景" class="headerlink" title="1.3 互联网场景"></a>1.3 互联网场景</h3><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><h3 id="1-4-令牌与密码"><a href="#1-4-令牌与密码" class="headerlink" title="1.4 令牌与密码"></a>1.4 令牌与密码</h3><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p>OAuth2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><p>这段看完，相信大家已经大概明白 OAuth2 的作用了。</p><h2 id="2-什么是-OAuth2"><a href="#2-什么是-OAuth2" class="headerlink" title="2.什么是 OAuth2"></a>2.什么是 OAuth2</h2><p>看完了阮一峰大佬的介绍，那么接下来松哥再从协议的角度来和大家聊一聊 OAuth2。</p><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p><p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。</p><p>对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。</p><h2 id="3-四种模式"><a href="#3-四种模式" class="headerlink" title="3.四种模式"></a>3.四种模式</h2><p>OAuth2 协议一共支持 4 种不同的授权模式：</p><ol><li>授权码模式：常见的第三方平台登录功能基本都是使用这种模式。</li><li>简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li><li>密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。</li><li>客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li></ol><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1 授权码模式"></a>3.1 授权码模式</h3><p>授权码模式是最安全并且使用最广泛的一种模式。以松哥的 <a href="www.javaboy.org">www.javaboy.org</a> 为例，假如我要引入微信登录功能，那么我的流程可能是这样：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-7.png" alt="图片源自网络"></p><p>在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。</p><p>上面这张流程图的含义，具体是这样：</p><ol><li>首先，我会在我的 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。</li><li>接下来的第三步，就是用户点击了超链接之后，像授权服务器发送请求，一般来说，我放在 <a href="http://www.javaboy.org">www.javaboy.org</a> 网页上的超链接可能有如下参数：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=code&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span><br></pre></td></tr></table></figure><p>这里边有好几个参数，在后面的代码中我们都会用到，这里先和大家简单解释一下：</p><ul><li>response_type 表示授权类型，使用授权码模式的时候这里固定为 code，表示要求返回授权码（将来拿着这个授权码去获取 access_token）。</li><li>client_id 表示客户端 id，也就是我应用的 id。有的小伙伴对这个不好理解，我说一下，如果我想让我的 <a href="http://www.javaboy.org">www.javaboy.org</a> 接入微信登录功能，我肯定得去微信开放平台注册，去填入我自己应用的基本信息等等，弄完之后，微信会给我一个 APPID，也就是我这里的 client_id，所以，从这里可以看出，授权服务器在校验的时候，会做两件事：1.校验客户端的身份；2.校验用户身份。</li><li>redirect_uri 表示用户登录在成功/失败后，跳转的地址（成功登录微信后，跳转到 <a href="http://www.javaboy.org">www.javaboy.org</a> 中的哪个页面），跳转的时候，还会携带上一个授权码参数。</li><li>scope 表示授权范围，即 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站拿着用户的 token 都能干啥（一般来说就是获取用户非敏感的基本信息）。</li></ul><ol start="3"><li>接下来第四步，<a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站，拿着第三步获取到的 code 以及自己的 client_id 和 client_secret 以及其他一些信息去授权服务器请求令牌，微信的授权服务器在校验过这些数据之后，就会发送一个令牌回来。这个过程一般是在后端完成的，而不是利用 js 去完成。</li><li>接下来拿着这个 token，我们就可以去请求用户信息了。</li></ol><p>一般情况下我们认为授权码模式是四种模式中最安全的一种模式，因为这种模式我们的 access_token 不用经过浏览器或者移动端 App，是直接从我们的后台发送到授权服务器上，这样就很大程度减少了 access_token 泄漏的风险。</p><p>OK，这是我们介绍的授权码模式。</p><h3 id="3-2-简化模式"><a href="#3-2-简化模式" class="headerlink" title="3.2 简化模式"></a>3.2 简化模式</h3><p>简化模式是怎么一回事呢？</p><p>松哥之前发过两篇文章教大家搭建自己的博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li><li><a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a></li></ul><p>这两种技术栈搭建的博客/电子书都是典型的纯前端应用，就是只有页面，没有后端，对于这种情况，如果我想接入微信登录该怎么办呢？这就用到了我们说的简化模式。</p><p>我们来看下简化模式的流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-8.png" alt="图片源自网络"></p><p>这个流程是这样：</p><ol><li>在我 <a href="http://www.javaboy.org">www.javaboy.org</a> 网站上有一个微信登录的超链接，这个超链接类似下面这样：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=token&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span><br></pre></td></tr></table></figure><p>这里的参数和前面授权码模式的基本相同，只有 response_type 的值不一样，这里是 token，表示要求授权服务器直接返回 access_token。</p><ol start="2"><li>用户点击我这个超链接之后，就会跳转到微信登录页面，然后用户进行登录。</li><li>用户登录成功后，微信会自动重定向到 redirect_uri 参数指定的跳转网址，同时携带上 access_token，这样用户在前端就获取到 access_token 了。</li></ol><p>简化模式的弊端很明显，因为没有后端，所以非常不安全，除非你对安全性要求不高，否则不建议使用。</p><h3 id="3-3-密码模式"><a href="#3-3-密码模式" class="headerlink" title="3.3 密码模式"></a>3.3 密码模式</h3><p>密码模式在 Spring Cloud 项目中有着非常广泛的应用，这块松哥在本系列后面的文章中会重点讲解，这里我们先来了解下密码模式是怎么一回事。</p><p>密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站上接入微信登录，我使用了密码模式，那你就要在 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用。</p><p>微服务中有一个特殊的场景，就是服务之间的调用，用密码模式做鉴权是非常恰当不过的了。这个以后再细说。</p><p>我们来看下密码模式的流程：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-9.png" alt></p><p>密码式的流程比较简单：</p><ol><li>首先 <a href="http://www.javaboy.org">www.javaboy.org</a> 会发送一个 post 请求，类似下面这样的：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=password&amp;client_id=javaboy&amp;username=江南一点雨&amp;password=123</span><br></pre></td></tr></table></figure><p>这里的参数和前面授权码模式的略有差异，response_type 的值不一样，这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。</p><ol start="2"><li>微信校验过用户名/密码之后，直接在 HTTP 响应中把 access_token 返回给客户端。</li></ol><p>OK，这就是密码模式的流程。</p><h3 id="3-4-客户端模式"><a href="#3-4-客户端模式" class="headerlink" title="3.4 客户端模式"></a>3.4 客户端模式</h3><p>有的应用可能没有前端页面，就是一个后台，例如松哥之前发的两篇公众号后台开发的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台，看看松哥公众号后台是怎么实现的！</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 如何给微信公众号返回消息</a></li></ul><p>这种应用开发好了就没有后台。</p><p>我们来看一个客户端模式的流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-10.png" alt></p><p>这个步骤也很简单，就两步：</p><ol><li>客户端发送一个请求到授权服务器，请求格式如下：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET</span><br></pre></td></tr></table></figure><p>这里有三个参数，含义如下：</p><ul><li>grant_type，获取access_token填写client_credential</li><li>client_id 和 client_secret 用来确认客户端的身份</li></ul><ol start="2"><li>授权服务器通过验证后，会直接返回 access_token 给客户端。</li></ol><p>大家发现，在这个过程中好像没有用户什么事了！是的，客户端模式给出的令牌，就是针对第三方应用的，而不是针对用户的。</p><p>在接入微信公众号后台的时候，有一个获取 Access_token 的步骤，其实就是这种模式，我截了一张微信开发平台文档的图，大家看下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-11.png" alt></p><p>可以看到，这其实就是客户端模式。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>其实基于微信公众号的开发，对于 OAuth2 玩的很溜，如果小伙伴们感兴趣，可以看看微信公众号的开发文档，结合松哥这篇文章，相信大家对于 OAuth2 会有一个更加深刻的认识。</p><p>微信公众平台地址：<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></p><p>好了，今天就先和大家说这么多，下篇文章，我们上代码来讲解 Spring Cloud Security OAuth2。</p><p>参考资料：</p><ol><li><a href="https://curity.io/resources/oauth/" target="_blank" rel="noopener">https://curity.io/resources/oauth/</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></li><li><a href="https://segmentfault.com/a/1190000010540911" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010540911</a></li><li><a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在更新 Spring Security 系列，不知不觉已经更新了 6 篇了，要聊 Spring Security，当然就绕不过 OAuth2，但是有很多小伙伴等不及了，不停的追问 OAuth2 的相关技能点，所以我也抽空撸几篇文章，来和大家把 OAuth2 好好的捋一捋，也顺便回顾一下松哥关于 OAuth2 的一些使用经验。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之狂拽炫酷的列编辑</title>
    <link href="http://www.javaboy.org/2020/0411/idea.html"/>
    <id>http://www.javaboy.org/2020/0411/idea.html</id>
    <published>2020-04-10T23:15:17.000Z</published>
    <updated>2020-04-14T23:41:11.506Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何将用户数据存入数据库？</title>
    <link href="http://www.javaboy.org/2020/0409/spring-security-JdbcUserDetailsManager.html"/>
    <id>http://www.javaboy.org/2020/0409/spring-security-JdbcUserDetailsManager.html</id>
    <published>2020-04-08T23:14:58.000Z</published>
    <updated>2020-04-14T23:42:09.173Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><a id="more"></a><p>以下是视频笔记。</p><p>Spring Security 介绍到现在，我们还没连上数据库呢。</p><p>真正的项目中，大部分情况下，我们都是自己设计权限数据库，例如微人事（<a href="https://github.com/lenve/vhr）项目那样。" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目那样。</a></p><p>不过，Spring Security 也给我们提供了一个它自己设计好的权限数据库，这里我们先来看看这是怎么回事！先来学这个简单的，然后我们再去看复杂的。</p><p>另外，松哥最近发在公众号上的视频也都在 B 站同步了一份，B 站更方便将视频做成一个系列，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-1.jpg" alt></p><p>大家可以来 B 站找我，B 站搜索 <strong>江南一点雨</strong> 或者扫描下面二维码就能找到。</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-2.png" alt></p><h2 id="1-UserDetailService"><a href="#1-UserDetailService" class="headerlink" title="1.UserDetailService"></a>1.UserDetailService</h2><p>Spring Security 支持多种不同的数据源，这些不同的数据源最终都将被封装成 UserDetailsService 的实例，在微人事（<a href="https://github.com/lenve/vhr）项目中，我们是自己来创建一个类实现" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目中，我们是自己来创建一个类实现</a> UserDetailsService 接口，除了自己封装，我们也可以使用系统默认提供的 UserDetailsService 实例，例如上篇文章和大家介绍的 InMemoryUserDetailsManager 。</p><p>我们来看下 UserDetailsService 都有哪些实现类：</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-3.png" alt></p><p>可以看到，在几个能直接使用的实现类中，除了 InMemoryUserDetailsManager 之外，还有一个 JdbcUserDetailsManager，使用 JdbcUserDetailsManager 可以让我们通过 JDBC 的方式将数据库和 Spring Security 连接起来。</p><h2 id="2-JdbcUserDetailsManager"><a href="#2-JdbcUserDetailsManager" class="headerlink" title="2.JdbcUserDetailsManager"></a>2.JdbcUserDetailsManager</h2><p>JdbcUserDetailsManager 自己提供了一个数据库模型，这个数据库模型保存在如下位置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure><p>这里存储的脚本内容如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">users</span>(username varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> primary <span class="hljs-keyword">key</span>,<span class="hljs-keyword">password</span> varchar_ignorecase(<span class="hljs-number">500</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,enabled <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>);</span><br><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> authorities (username varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,authority varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<span class="hljs-keyword">constraint</span> fk_authorities_users <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(username) <span class="hljs-keyword">references</span> <span class="hljs-keyword">users</span>(username));</span><br><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> ix_auth_username <span class="hljs-keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure><p>可以看到，脚本中有一种数据类型 varchar_ignorecase，这个其实是针对 HSQLDB 数据库创建的，而我们使用的 MySQL 并不支持这种数据类型，所以这里需要大家手动调整一下数据类型，将 varchar_ignorecase 改为 varchar 即可。</p><p>修改完成后，创建数据库，执行完成后的脚本。</p><p>执行完 SQL 脚本后，我们可以看到一共创建了两张表：users 和 authorities。</p><ul><li>users 表中保存用户的基本信息，包括用户名、用户密码以及账户是否可用。</li><li>authorities 中保存了用户的角色。</li><li>authorities 和 users 通过 username 关联起来。</li></ul><p>配置完成后，接下来，我们将上篇文章中通过 InMemoryUserDetailsManager 提供的用户数据用 JdbcUserDetailsManager 代替掉，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    JdbcUserDetailsManager manager = <span class="hljs-keyword">new</span> JdbcUserDetailsManager();</span><br><span class="line">    manager.setDataSource(dataSource);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!manager.userExists(<span class="hljs-string">"javaboy"</span>)) &#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!manager.userExists(<span class="hljs-string">"江南一点雨"</span>)) &#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置的含义如下：</p><ol><li>首先构建一个 JdbcUserDetailsManager 实例。</li><li>给 JdbcUserDetailsManager 实例添加一个 DataSource 对象。</li><li>调用 userExists 方法判断用户是否存在，如果不存在，就创建一个新的用户出来（因为每次项目启动时这段代码都会执行，所以加一个判断，避免重复创建用户）。</li><li>用户的创建方法和我们之前 InMemoryUserDetailsManager 中的创建方法基本一致。</li></ol><p>这里的 createUser 或者 userExists 方法其实都是调用写好的 SQL 去判断的，我们从它的源码里就能看出来（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUserDetailsManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JdbcDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsManager</span>,</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">GroupManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_USER_EXISTS_SQL = <span class="hljs-string">"select username from users where username = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> String userExistsSql = DEF_USER_EXISTS_SQL;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">userExists</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; users = getJdbcTemplate().queryForList(userExistsSql,</span><br><span class="line"><span class="hljs-keyword">new</span> String[] &#123; username &#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (users.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectResultSizeDataAccessException(</span><br><span class="line"><span class="hljs-string">"More than one user found with name '"</span> + username + <span class="hljs-string">"'"</span>, <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> users.size() == <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中就可以看出来，userExists 方法的执行逻辑其实就是调用 JdbcTemplate 来执行预定义好的 SQL 脚本，进而判断出用户是否存在，其他的判断方法都是类似，我就不再赘述。</p><h2 id="3-数据库支持"><a href="#3-数据库支持" class="headerlink" title="3.数据库支持"></a>3.数据库支持</h2><p>通过前面的代码，大家看到这里需要数据库支持，所以我们在项目中添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再在 application.properties 中配置一下数据库连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.url=jdbc:mysql:///security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>配置完成后，就可以启动项目。</p><p>项目启动成功后，我们就可以看到数据库中自动添加了两个用户进来，并且用户都配置了角色。如下图：</p><p><img src="http://img.itboyhub.com/2020/04/security-6-4.png" alt><br><img src="http://img.itboyhub.com/2020/04/security-6-5.png" alt></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>接下来我们就可以进行测试了。</p><p>我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>具体测试效果小伙伴们可以参考松哥的视频，我就不截图了。</p><p>在测试的过程中，如果在数据库中将用户的 enabled 属性设置为 false，表示禁用该账户，此时再使用该账户登录就会登录失败。</p><p>按照相同的方式，大家也可以测试 javaboy 用户。</p><p>好了，今天就和小伙伴们说这么多.</p><p><strong>感谢小伙伴们的阅读，如果觉得有用，毫不犹豫的点个在看鼓励下松哥，我会以风驰电掣般的速度快速更完这个系列～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文配套视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 &lt;a href=&quot;https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 系列视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>推荐七个略火的Spring Boot+Vue开源项目</title>
    <link href="http://www.javaboy.org/2020/0409/springboot-vue.html"/>
    <id>http://www.javaboy.org/2020/0409/springboot-vue.html</id>
    <published>2020-04-08T23:14:40.000Z</published>
    <updated>2020-04-14T23:37:26.090Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！</p><a id="more"></a><p>其实前后端分离本身并不难，后段提供接口，前端做数据展示，关键是这种思想。很多人做惯了前后端不分的开发，在做前后端分离的时候，很容易带进来一些前后端不分时候的开发思路，结果做出来的产品不伦不类，因此松哥这里给大家整理了几个开源的前后端分离项目，帮助大家快速掌握前后端分离开发技术栈。</p><h2 id="美人鱼"><a href="#美人鱼" class="headerlink" title="美人鱼"></a>美人鱼</h2><ul><li>star 数 4.2k</li><li>项目地址： <a href="https://gitee.com/mumu-osc/NiceFish" target="_blank" rel="noopener">https://gitee.com/mumu-osc/NiceFish</a></li></ul><p>听名字就知道这是个不错的项目，事实上确实不赖。NiceFish（美人鱼） 是一个系列项目，目标是示范前后端分离的开发模式:前端浏览器、移动端、Electron 环境中的各种开发模式；后端有两个版本：SpringBoot 版本和 SpringCloud 版本，前端有 Angular 、React 以及 Electron 等版本。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-1.png" alt></p><h2 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h2><ul><li>star 数 15.3k</li><li>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li></ul><p>微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。</p><p>项目效果图:</p><p><img src="http://img.itboyhub.com/2020/03/fe-2.png" alt></p><p>项目部分文档截图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-3.png" alt></p><h2 id="bootshiro"><a href="#bootshiro" class="headerlink" title="bootshiro"></a>bootshiro</h2><ul><li>star 数 2.1k</li><li>项目地址： <a href="https://gitee.com/tomsun28/bootshiro" target="_blank" rel="noopener">https://gitee.com/tomsun28/bootshiro</a></li></ul><p>bootshiro 是基于 Spring Boot + Shiro + JWT 的真正 RESTful URL 资源无状态认证权限管理系统的后端,前端 usthe 。区别于一般项目，该项目提供页面可配置式的、动态的 RESTful api 安全管理支持，并且实现数据传输动态秘钥加密，jwt 过期刷新，用户操作监控等，加固应用安全。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-4.PNG" alt></p><h2 id="open-capacity-platform"><a href="#open-capacity-platform" class="headerlink" title="open-capacity-platform"></a>open-capacity-platform</h2><ul><li>star 数 4.1k</li><li>项目地址：<a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a></li></ul><p>open-capacity-platform 微服务能力开放平台，简称 ocp ，是基于 layui + springcloud 的企业级微服务框架(用户权限管理，配置中心管理，应用管理，….)，其核心的设计目标是分离前后端，快速开发部署，学习简单，功能强大，提供快速接入核心接口能力，其目标是帮助企业搭建一套类似百度能力开放平台的框架。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-5.png" alt></p><h2 id="V-部落"><a href="#V-部落" class="headerlink" title="V 部落"></a>V 部落</h2><ul><li>star 数 4.6k</li><li>项目地址：<a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>V部落是一个多用户博客管理平台，采用 Vue + SpringBoot + ElementUI 开发。<strong>这个项目最大的优势是简单，属于功能完整但是又非常简单的那种，非常非常适合初学者。</strong></p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-6.png" alt></p><h2 id="悟空-CRM"><a href="#悟空-CRM" class="headerlink" title="悟空 CRM"></a>悟空 CRM</h2><ul><li>star 数 1.3k</li><li>项目地址：<a href="https://gitee.com/wukongcrm/72crm-java" target="_blank" rel="noopener">https://gitee.com/wukongcrm/72crm-java</a></li></ul><p>悟空 CRM 是基于 jfinal + vue + ElementUI 的前后端分离 CRM 系统。</p><p>老实说，jfinal 了解下就行了，没必要认真研究，Vue + ElementUI 的组合可以认真学习下、前后端交互的方式可以认真学习下。</p><p><img src="http://img.itboyhub.com/2020/03/fe-7.png" alt></p><h2 id="paascloud-master"><a href="#paascloud-master" class="headerlink" title="paascloud-master"></a>paascloud-master</h2><ul><li>star 数 7.5k</li><li>项目地址：<a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a></li></ul><p>paascloud-master 核心技术为 SpringCloud + Vue 两个全家桶实现，采取了取自开源用于开源的目标，所以能用开源绝不用收费框架，整体技术栈只有阿里云短信服务是收费的，都是目前 java 前瞻性的框架，可以为中小企业解决微服务架构难题，可以帮助企业快速建站。由于服务器成本较高，尽量降低开发成本的原则，本项目由 10 个后端项目和 3 个前端项目共同组成。真正实现了基于 RBAC、jwt 和 oauth2 的无状态统一权限认证的解决方案，实现了异常和日志的统一管理，实现了 MQ 落地保证 100% 到达的解决方案。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-8.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>他山之石，可以攻玉。当我们学会了很多知识点之后，需要一个项目来将这些知识点融会贯通，这些开源项目就是很好的资料。现在前后端分离开发方式日渐火热，松哥也强烈建议大家有空学习下这种开发方式。虽然我们身为 Java 工程师，可是也不能固步自封，看看前端单页面应用怎么构建，看看前端工程化是怎么回事，这些都有助于我们开发出更加合理好用的后端接口。好了，七个开源项目，助力大家在全栈的路上更进一步！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中的授权操作原来这么简单</title>
    <link href="http://www.javaboy.org/2020/0408/spring-security-authorization.html"/>
    <id>http://www.javaboy.org/2020/0408/spring-security-authorization.html</id>
    <published>2020-04-07T23:14:25.000Z</published>
    <updated>2020-04-14T23:42:41.768Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><a id="more"></a><p>以下是视频笔记。</p><p>通过前面四篇文章的介绍，Spring Security 中的登录认证我们就先告一个小小段落。在本系列未来的教程中，我们还会继续涉及到 Spring Security 中的登录认证问题，这个我们以后再说。</p><p>本系列前面四篇文章给小伙伴们列一个索引出来，大家可以参考：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li></ol><p>好了，今天我们就通过一个简单的案例来看看 Spring Security 中的授权操作。</p><h2 id="1-授权"><a href="#1-授权" class="headerlink" title="1.授权"></a>1.授权</h2><p>所谓的授权，就是用户如果要访问某一个资源，我们要去检查用户是否具备这样的权限，如果具备就允许访问，如果不具备，则不允许访问。</p><h2 id="2-准备测试用户"><a href="#2-准备测试用户" class="headerlink" title="2.准备测试用户"></a>2.准备测试用户</h2><p>因为我们现在还没有连接数据库，所以测试用户还是基于内存来配置。</p><p>基于内存配置测试用户，我们有两种方式，第一种就是我们本系列前面几篇文章用的配置方式，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="hljs-string">"江南一点雨"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"123"</span>)</span><br><span class="line">            .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种配置方式。</p><p>由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。</p><p>因此我们还可以通过重写 WebSecurityConfigurerAdapter 中的 userDetailsService 方法来提供一个 UserDetailService 实例进而配置多个用户：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">    <span class="hljs-keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种基于内存定义用户的方法，大家任选一个。</p><h2 id="3-准备测试接口"><a href="#3-准备测试接口" class="headerlink" title="3.准备测试接口"></a>3.准备测试接口</h2><p>测试用户准备好了，接下来我们准备三个测试接口。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个测试接口，我们的规划是这样的：</p><ol><li>/hello 是任何人都可以访问的接口</li><li>/admin/hello 是具有 admin 身份的人才能访问的接口</li><li>/user/hello 是具有 user 身份的人才能访问的接口</li><li>所有 user 能够访问的资源，admin 都能够访问</li></ol><p><strong>注意第四条规范意味着所有具备 admin 身份的人自动具备 user 身份。</strong></p><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h2><p>接下来我们来配置权限的拦截规则，在 Spring Security 的 configure(HttpSecurity http) 方法中，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里的匹配规则我们采用了 Ant 风格的路径匹配符，Ant 风格的路径匹配符在 Spring 家族中使用非常广泛，它的匹配规则也非常简单：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">匹配多层路径</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配一层路径</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>上面配置的含义是：</p><ol><li>如果请求路径满足 <code>/admin/**</code> 格式，则用户需要具备 admin 角色。</li><li>如果请求路径满足 <code>/user/**</code> 格式，则用户需要具备 user 角色。</li><li>剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。</li></ol><p>注意代码中配置的三条规则的顺序非常重要，和 Shiro 类似，Spring Security 在匹配的时候也是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，<strong>所以拦截规则的顺序不能写错</strong>。</p><p>另一方面，如果你强制将 anyRequest 配置在 antMatchers 前面，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .and()</span><br></pre></td></tr></table></figure><p>此时项目在启动的时候，就会报错，会提示不能在 anyRequest 之后添加 antMatchers：</p><p><img src="http://img.itboyhub.com/2020/04/security-05-01.png" alt></p><p>这从语义上很好理解，anyRequest 已经包含了其他请求了，在它之后如果还配置其他请求也没有任何意义。</p><p>从语义上理解，anyRequest 应该放在最后，表示除了前面拦截规则之外，剩下的请求要如何处理。</p><p>在拦截规则的配置类 AbstractRequestMatcherRegistry 中，我们可以看到如下一些代码（部分源码）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractRequestMatcherRegistry</span>&lt;<span class="hljs-title">C</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> anyRequestConfigured = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">anyRequest</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure anyRequest after itself"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.anyRequestConfigured = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">antMatchers</span><span class="hljs-params">(HttpMethod method, String... antPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure antMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.antMatchers(method, antPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">antMatchers</span><span class="hljs-params">(String... antPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure antMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.antMatchers(antPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> List&lt;MvcRequestMatcher&gt; <span class="hljs-title">createMvcMatchers</span><span class="hljs-params">(HttpMethod method,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String... mvcPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure mvcMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> matchers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">regexMatchers</span><span class="hljs-params">(HttpMethod method, String... regexPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure regexMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.regexMatchers(method, regexPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">regexMatchers</span><span class="hljs-params">(String... regexPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure regexMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.regexMatchers(regexPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">requestMatchers</span><span class="hljs-params">(RequestMatcher... requestMatchers)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure requestMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(Arrays.asList(requestMatchers));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中，我们可以看到，在任何拦截规则之前（包括 anyRequest 自身），都会先判断 anyRequest 是否已经配置，如果已经配置，则会抛出异常，系统启动失败。</p><p>这样大家就理解了为什么 anyRequest 一定要放在最后。</p><h2 id="5-启动测试"><a href="#5-启动测试" class="headerlink" title="5.启动测试"></a>5.启动测试</h2><p>接下来，我们启动项目进行测试。</p><p>项目启动成功后，我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>具体测试效果小伙伴们可以参考松哥的视频，我就不截图了。</p><p>按照相同的方式，大家也可以测试 javaboy 用户。</p><h2 id="6-角色继承"><a href="#6-角色继承" class="headerlink" title="6.角色继承"></a>6.角色继承</h2><p>在前面松哥提到过一点，所有 user 能够访问的资源，admin 都能够访问，很明显我们目前的代码还不具备这样的功能。</p><p>要实现所有 user 能够访问的资源，admin 都能够访问，这涉及到另外一个知识点，叫做角色继承。</p><p>这在实际开发中非常有用。</p><p>上级可能具备下级的所有权限，如果使用角色继承，这个功能就很好实现，我们只需要在 SecurityConfig 中添加如下代码来配置角色继承关系即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl hierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    hierarchy.setHierarchy(<span class="hljs-string">"ROLE_admin &gt; ROLE_user"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> hierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在配置时，需要给角色手动加上 <code>ROLE_</code> 前缀。上面的配置表示 <code>ROLE_admin</code> 自动具备 <code>ROLE_user</code> 的权限。</p><p>配置完成后，重启项目，此时我们发现 javaboy 也能访问 <code>/user/hello</code> 这个接口了。</p><p>好了，今天就和小伙伴们说这么多.</p><p><strong>感谢小伙伴们的阅读，如果觉得有用，毫不犹豫的点个在看鼓励下松哥，我会以风驰电掣般的速度快速更完这个系列～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文配套视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 &lt;a href=&quot;https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 系列视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>前两天松哥收到了一份简历，10 年 Java 经验，期望薪资 25k</title>
    <link href="http://www.javaboy.org/2020/0407/25k-offer.html"/>
    <id>http://www.javaboy.org/2020/0407/25k-offer.html</id>
    <published>2020-04-06T23:14:10.000Z</published>
    <updated>2020-04-14T23:37:48.238Z</updated>
    
    <content type="html"><![CDATA[<p>工作十年，依然在一线 Coding，我觉得有 10 种人；一种是热爱，一种是无奈。</p><a id="more"></a><p>最近这行情，一个高级开发职位抛出去，都是上百份简历。在这众多简历中，有两个比较扎眼的，就是两个超 10 年经验的老哥，一个是 10 年，还有一个是 11 年，看下图。</p><p><img src="http://img.itboyhub.com/2020/04/offer-03-01.png" alt></p><p>两位老哥的简历我看了下，项目经验都是超级丰富，毕竟写了 10 年代码了，难能可贵的他们的技术栈也没有特别古老，还是紧跟潮流的。都是企业级开发中常规的技术栈，但是看来看去，总感觉哪里怪怪的。</p><p>想了半天终于想明白，这简历和只有 5、6 年经验的简历的相比好像没啥特别突出的地方，除了项目经验比较丰富，其他地方都不具备特别明显的优势。两份简历，其中一个老哥的期望薪资在 25k，另一个没写，要面谈。</p><p>老实说，十年 25k 这个薪水在深圳这个地方并不算高。名校应届生就有可能拿到这个薪水，即使是专科，只要技术不是特别差劲，脑袋灵光性格开朗，在深圳这地方拿 25k 也不用等 10 年。</p><p>大部分公司招聘在一线 Coding 的 Java 工程师一般也很少需要 10 年经验的，10 年经验基本都是架构师或者项目经理一类的岗位。</p><p>所以除非是热爱，否则在 Coding 10 年之后，还想找一个在一线 Coding 的岗位，确实蛮尴尬的，但是这种尴尬，有的人却避免不了。我们工作，即是为了赚钱，为了增长项目经验，也要不断构建自己的护城河，提高自己的核心竞争力，才有可能避免这样的尴尬。有的人觉得核心竞争力这话有点假大空，怎么提高？</p><p>我举一个刚刚发生的例子。</p><p>上周松哥发了一篇文章：<a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</a>，发文之前我反复揣度，文章可能出现的被怼的地方，都做了仔细的调整，可是没想到发文之后，还是被怼了。</p><p>发文之前我隐隐约约感觉到有人会说自己写的 Java 客户端没有 Jedis 或者 Spring Data Redis 使用方便，所以我在文章一开始就强调了，我主要是想和大家分享 RESP 协议，以及 Java 客户端是如何连接 Redis 的，同时也把一个锋芒毕露的标题改成现在这样比较中庸的标题，结果第二天一发文，还是被人怼了说这东西没用，直接用 Jedis 更方便，我瞬间感觉头一天晚上一个多小时的功夫都白费了，还是有人无法理解我的文章的目的。</p><p>Jedis、Spring Data Redis 这种工具基本上一个初级 Java 程序员都会用，人人都会的东西，你要是不会，肯定是劣势，你要是会，那也绝对不是优势，这就不是你的核心竞争力。出去面试，没人会问 Jedis 怎么用，Spring Data Redis 怎么用，问的都是原理，都是实际开发中的场景问题。</p><p>很多人会用 Jedis，但是不知道 Jedis 到底是怎么连接 Redis 服务器的，很多人也知道 Redis 有一种持久化方案叫做 AOF，他甚至把 AOF 持久化的日志都打开看过了，但是里边的字符串却一直似懂非懂，这些问题，看了松哥前面的文章就懂了。但是话说回来，这些问题即使你不懂，大部分情况下也不影响你使用 Redis，但是要因此觉得自己自己技术很厉害能够应对工作中的各种问题，未免有点夜郎自大了。</p><p>记得 2018 年底松哥的新书刚刚出版的时候，有个同事（9 年的经验的老程序员）跑来问我写博客用什么工具？我说我用 VsCode 写的 markdown，刚说完他就问了两个让我惊掉下巴的问题：1. vscode 是啥？2.markdown 又是啥？出于对前辈同事的尊重，我非常镇定并且耐心跟他解释了这两个东西。</p><p>说这两件事并不是说懂了 RESP，懂 markdown 就是大牛，不懂就是菜鸡，而是想说，程序员这个行业，需要我们不断的更新并且深化自己的技能，所有的知识不能停留在表面，也不能停留在上古时代。</p><p>核心竞争力不是说你报了某一们网课，学了某一个知识点或者一些高大上的名词就掌握了的东西。<strong>核心竞争力应该是一种骨子里的态度，永远保持钻研，保持学习的一种态度，在这样态度的驱使之下，你不可能碌碌无为。</strong> 10 年之后的自己，是 CRUD 越写越熟练了还是掌握了很多别人不具备的技能，是把 1 年重复了 10 次还是真的活了 10 年，这取决于我们今天的态度。</p><p>很多小伙伴可能知道，松哥最早是做 Android 的，记得当时 Android5.0 推出的时候，业界一片欢呼，谷歌提供了很多炫酷的 UI 组件，作为开发者再也不用写哪些复杂的事件调用了。我当时在北京出差，吃饭的时候和一位 Android 前辈说起这事，我说，虽然谷歌提供的组件越来越方便了，但是对于新手而言并不见得就是好事，他们可能只满足于调用组件，不懂原理，长此以往，他们的竞争力会越来越弱，同事笑了笑说，搞 C 的程序员也是这么看待搞 Java 的。我当时就感觉自己肤浅了，开发这条路，无论你是做底层还是做应用，永远都有学不完的东西，永远都要保持学习的心态。</p><p>真心希望松哥的读者工作 10 年之后，不用投简历找工作，也不用找只有 25k 薪水的工作。小伙伴们加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作十年，依然在一线 Coding，我觉得有 10 种人；一种是热爱，一种是无奈。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>看懂这篇文章，前后端分离再和面试官扯皮就没问题了</title>
    <link href="http://www.javaboy.org/2020/0406/springboot-vue-nginx.html"/>
    <id>http://www.javaboy.org/2020/0406/springboot-vue-nginx.html</id>
    <published>2020-04-05T23:13:54.000Z</published>
    <updated>2020-04-14T23:43:21.241Z</updated>
    
    <content type="html"><![CDATA[<p>假期一直在下雨，抽空整理了下小伙伴们问的比较多的前后端分离的部署问题。</p><a id="more"></a><h2 id="1-问题焦点"><a href="#1-问题焦点" class="headerlink" title="1.问题焦点"></a>1.问题焦点</h2><p>问题焦点主要在于跨域，开发环境和生产环境是两种完全不懂的配置思路。</p><p>如果你直接在项目中引入 Vue，像用 jQuery 那样用 Vue，那没什么问题，你应该也不会有跨域的疑问。但是如果你做的是单页面应用(SPA)，那么必然会有这样的疑问，跨域问题怎么搞！</p><p>因为在单页面应用中，前端项目可以单独通过 node 启动，它单独占用一个端口，后端项目启动后也是另外一个端口，此时从前端发送请求到后端，由于两者处于不同的端口之上，因此必然存在一个跨域问题。</p><p>但是大家想想，这个跨域有可能只是在开发环境下存在，生产环境下有可能不存在。因为当项目开发完成之后，我们对前端项目进行打包，打包后部署在 Nginx 上或者直接拷贝到后端项目中运行都可以（一般使用前者）：</p><ul><li>如果是前者，后端接口也通过 Nginx 进行映射，这个时候就不会存在跨域问题了</li><li>如果是后者，那就更简单了，部署的时候前后端代码放在一起，更不会有跨域问题了</li></ul><p>因此，解决这个所谓的 “跨域” 问题，我们不能按照传统的思路来（传统思路主要是 JSONP 或者 CORS），因为在项目真正上线后，所谓的跨域问题可能就会消失。</p><p>那么这个问题怎么解决呢？我们可以在前端 nodejs 中配置请求转发。</p><p>配置请求转发其实不难，不过 vue-cli2 和 vue-cli3 之后的写法稍有不同，我们来分别看下。</p><p>先来看开发环境配置。</p><h2 id="2-开发环境配置"><a href="#2-开发环境配置" class="headerlink" title="2.开发环境配置"></a>2.开发环境配置</h2><h3 id="2-1-vue-cli2-方案"><a href="#2-1-vue-cli2-方案" class="headerlink" title="2.1 vue-cli2 方案"></a>2.1 vue-cli2 方案</h3><p>如果我们使用的 vue-cli2 来创建的 SPA 应用，创建成功之后，在项目的 config 目录下有一个 index.js 文件，在这个文件中，我们可以进行请求转发配置，如下图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-1.png" alt></p><p>配置内容如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Paths</span></span><br><span class="line">    assetsSubDirectory: <span class="hljs-string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="hljs-string">'/'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="hljs-string">'/'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'http://localhost:8082'</span>,</span><br><span class="line">        changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-string">'/ws/*'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'ws://127.0.0.1:8082'</span>,</span><br><span class="line">        ws: <span class="hljs-literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>proxyTable 就是我们配置的转发路由表。这个里边我们一共配置了两个规则：</p><ul><li>第一个是拦截所有 HTTP 请求，将之转发到后端服务器上（前端默认端口是 8080），后端的端口是 8082。至于拦截规则 <code>/</code> ，大家可以自定义，根据实际情况来写，例如所有的 HTTP 请求都有一个统一的前缀 api，那么这里就可以写 <code>/api</code>。</li><li>第二个是拦截所有的 websocket 请求进行转发，我这里给所有的 websocket 请求取了一个统一的前缀 <code>/ws</code></li></ul><p>如果你有更多的拦截规则，继续在这里配置就可以了，这些配置只会在开发环境下生效，当项目编译打包时，这些配置是不会打包进去的，也就是说，项目发布的时候，这些配置是失效的，这个时候我们通过 Nginx 或者将前端代码拷贝到后端，就可以解决生产环境下的跨域问题了（<strong>相当于开发时候的跨域在生产环境下不存在</strong>）。</p><p>相对来说，vue-cli2 在这里的配置还比较容易。</p><h3 id="2-2-vue-cli3-方案"><a href="#2-2-vue-cli3-方案" class="headerlink" title="2.2 vue-cli3 方案"></a>2.2 vue-cli3 方案</h3><p>vue-cli3 和 vue-cli4 的思路基本一致，以 vue-cli3 为例：</p><p>使用 vue-cli3 创建的 SPA 应用，没有 config 目录了，因此请求转发的配置我们要在 vue.config.js 这个配置文件中来配置。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> proxyObj = &#123;&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/ws'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">true</span>,</span><br><span class="line">    target: <span class="hljs-string">"ws://localhost:8081"</span></span><br><span class="line">&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">false</span>,</span><br><span class="line">    target: <span class="hljs-string">"http://localhost:8081"</span>,</span><br><span class="line">    changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建一个 proxyObj 用来放各种代理对象，至于代理的内容这里的则和 vue-cli2 中的没有太多差异。要注意的是，HTTP 请求代理中，多了一个属性 <code>ws: false</code>，用过 vue-cli3 同学可能发现了，如果不加这个属性，浏览器控制台会一直报连不上 socket 的错，加上就没事了。</p><p>最后在 devServer 中指定项目的 host 和 port ，然后再配置一下 proxy 对象就可以啦。</p><p>这就是我们在 vue-cli3 中请求的配置。</p><p>不过这里的配置老实说没有什么难度，做过一次就会啦，要是没做过，头一次可能得折腾半天。</p><h2 id="3-生产环境配置"><a href="#3-生产环境配置" class="headerlink" title="3. 生产环境配置"></a>3. 生产环境配置</h2><p>很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。</p><p>但是开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了。</p><p>整体上来看，生产环境的部署，我们有两种思路：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可（推荐）。</li></ul><p>分别来看。</p><h3 id="3-1-前后端一起部署"><a href="#3-1-前后端一起部署" class="headerlink" title="3.1 前后端一起部署"></a>3.1 前后端一起部署</h3><p>这种方式比较简单，大家作为了解即可，生产环境一般采用第二种方案。</p><p>首先在前端 Vue 项目中执行 <code>npm run build</code> 命令，将前端文件进行打包。</p><p>编译打包成功后，将打包好的 js、css、html、image、fonts 等文件和文件夹拷贝到 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下，然后在 Spring Security 中对前端静态资源配置放行，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/index.html"</span>,<span class="hljs-string">"/img/**"</span>,<span class="hljs-string">"/fonts/**"</span>,<span class="hljs-string">"/favicon.ico"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将 Spring Boot 项目打包成 jar，执行命令启动即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><h3 id="3-2-前后端分开部署"><a href="#3-2-前后端分开部署" class="headerlink" title="3.2 前后端分开部署"></a>3.2 前后端分开部署</h3><p>分开部署就离不开 Nginx。</p><h4 id="3-2-1-Nginx-介绍"><a href="#3-2-1-Nginx-介绍" class="headerlink" title="3.2.1 Nginx 介绍"></a>3.2.1 Nginx 介绍</h4><h5 id="3-2-1-1-基本介绍"><a href="#3-2-1-1-基本介绍" class="headerlink" title="3.2.1.1 基本介绍"></a>3.2.1.1 基本介绍</h5><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理 <code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code> 服务。 </p><p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 <code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code> 发布于 <code>2004</code> 年 <code>10</code> 月 <code>4</code> 日。 </p><p><code>Nginx</code> 特点是占有内存少，并发能力强。</p><p>事实上 <code>nginx</code> 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 <code>Nginx</code> ，我们的项目架构可能是这样：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-3.png" alt></p><p>在这样的架构中 ， <code>Nginx</code> 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 <code>Tomcat</code> 上去。</p><p>那么这里涉及到两个概念：</p><ul><li>负载均衡服务器</li></ul><p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 <code>DNS</code> 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code> 和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code> 收购），早些年，也可以使用 <code>Apache</code> 来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是 <code>Nginx</code> 。</p><ul><li>反向代理服务器：</li></ul><p>另一个概念是反向代理服务器，得先说正向代理，看下面一张图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-4.png" alt></p><p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p><p>那么什么是反向代理呢？看下面一张图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-5.png" alt></p><p>在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。</p><p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p><h5 id="3-2-1-2-Nginx-的优势"><a href="#3-2-1-2-Nginx-的优势" class="headerlink" title="3.2.1.2 Nginx 的优势"></a>3.2.1.2 Nginx 的优势</h5><p>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p><ol><li>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</li><li>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</li><li>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。</li></ol><h5 id="3-2-1-3-Nginx-安装"><a href="#3-2-1-3-Nginx-安装" class="headerlink" title="3.2.1.3 Nginx 安装"></a>3.2.1.3 Nginx 安装</h5><p>由于基本上都是在 Linux 上使用 Nginx，因此松哥这里主要向大家展示 CentOS 7 安装 Nginx：</p><ol><li>首先下载 Nginx</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.17.0.tar.gz</span><br></pre></td></tr></table></figure><p>然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p>然后开始编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>装好之后，默认安装位置在 ：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>进入到该目录的 <code>sbin</code> 目录下，执行 <code>nginx</code> 即可启动 <code>Nginx</code> ：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-6.png" alt></p><p>Nginx 启动成功之后，在浏览器中直接访问 Nginx 地址：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-7.png" alt></p><p>看到如上页面，表示 Nginx 已经安装成功了。</p><p>如果修改了 Nginx 配置，则可以通过如下命令重新加载 Nginx 配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h5 id="3-2-1-4-为什么用-Nginx"><a href="#3-2-1-4-为什么用-Nginx" class="headerlink" title="3.2.1.4 为什么用 Nginx"></a>3.2.1.4 为什么用 Nginx</h5><p>结合 Nginx 来部署前后端分离项目算是目前的主流方案。一来部署方便，二来通过动静分离也可以有效提高项目的运行效率。</p><p>大家知道我们项目中的资源包含动态资源和静态资源两种，其中：</p><ul><li>动态资源就是那些需要经过容器处理的资源，例如 jsp、freemarker、各种接口等。</li><li>静态资源则是那些不需要经过容器处理，收到客户端请求就可以直接返回的资源，像 js、css、html 以及各种格式的图片，都属于静态资源。</li></ul><p>将动静资源分开部署，可以有效提高静态资源的加载速度以及整个系统的运行效率。</p><p>在前后端分离项目部署中，我们用 Nginx 来做一个反向代理服务器，它既可以代理动态请求，也可以直接提供静态资源访问。</p><p>无论是动态请求还是静态请求，都是首先到达 Nginx，再从 Nginx 上去查找页面或接口，这样，原本存在的所谓跨域问题现在就不存在了。</p><h4 id="3-2-2-部署步骤"><a href="#3-2-2-部署步骤" class="headerlink" title="3.2.2 部署步骤"></a>3.2.2 部署步骤</h4><h5 id="3-2-2-1-后端部署"><a href="#3-2-2-1-后端部署" class="headerlink" title="3.2.2.1 后端部署"></a>3.2.2.1 后端部署</h5><p>后端接口的部署，主要看项目的形式，如果就是普通的 SSM 项目，那就提前准备好 Tomcat ，在 Tomcat 中部署项目，如果是 Spring Boot 项目，可以通过命令直接启动 jar，如果是微服务项目，存在多个 jar 的话，可以结合 Docker 来部署（参考<a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a>），无论是那种形式，对于我们 Java 工程师来说，这都不是问题，我相信这一步大家都能搞定。</p><p>后端项目可以在一个非 80 端口上部署，部署成功之后，因为这个后端项目只是提供接口，所以我们并不会直接去访问他。而是通过 Nginx 请求转发来访问这个后端接口。</p><p>松哥这里以我 2018 年为一个律所的小程序为例，后端是一个 Spring Boot 工程，那么我可以通过 Docker 部署，也可以直接通过命令来启动，这里简单点，直接通过命令来启动 jar ，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar jinlu.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>后端启动成功之后，我并不急着直接去访问后端，而是安装并且去配置一个 Nginx，通过 Nginx 来转发请求。</p><p>这里我们在 nginx.conf 中做出如下配置：</p><p>首先配置上游服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream zqq.com&#123;</span><br><span class="line">  server 127.0.0.1:9999 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要是配置服务端的地址，如果服务端是集群化部署，那么这里就会有多个服务端地址，然后可以通过权重或者 ip hash 等方式进行请求分发。</p><p>然后我们在 server 中配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu/ &#123;</span><br><span class="line">  proxy_pass http://zqq.com;</span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置完成后，假设我目前的域名是 javaboy.org，那么用户通过 <code>http://www.javaboy.org/jinlu/**</code> 格式的地址就可以访问到我服务端的接口。</p><h5 id="3-2-2-2-前端部署"><a href="#3-2-2-2-前端部署" class="headerlink" title="3.2.2.2 前端部署"></a>3.2.2.2 前端部署</h5><p>以 Vue 为例，如果是 SPA 应用，项目打包之后，就是一个 index.html 还有几个 js、css、images 以及 fonts ，这些都是静态文件，我们将静态文件首先上传到服务器，然后在 nginx.conf 中配置静态资源访问，具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123;</span><br><span class="line">   root /usr/local/nginx/html/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>当然我这里是按照资源类型来拦截的，即后缀为 js、css、ico 等的文件，统统都不进行请求分发，直接从本地的 /usr/local/nginx/html/ 目录下读取并返回到前端（我们需要将静态资源文件上传到 <code>/usr/local/nginx/html/</code> 目录下）。</p><p>如果我们的服务器上部署了多个项目，这种写法就不太合适，因为多个项目的前端静态文件肯定要分门别类，各自放好的，这个时候我们一样可以通过路径来拦截，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu-admin/ &#123;</span><br><span class="line">   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>这样，请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 <code>/usr/local/nginx/html/jinlu-admin/</code> 目录下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。</p><p>这样部署完成之后，假设我的域名是 javaboy.org ，那么用户通过 <code>http://www.javaboy.org/jinlu-admin/**</code><br>格式的请求就可以访问到前端资源了。</p><p>此时大家发现，前端的静态资源和后端的接口现在处于同一个域之中了（请求协议、域名、端口现在都一致），这样就不存在跨域问题，所以我一开始基说<strong>不</strong>必用 JSONP 或者 CORS 去解决跨域。当然可能还有一些非常特殊情况需要在 nginx 中配置跨域，这个松哥以后再和大家细聊~</p><h2 id="4-Docker-部署"><a href="#4-Docker-部署" class="headerlink" title="4. Docker 部署"></a>4. Docker 部署</h2><p>上面的部署方案实际上可以解决大部分的项目部署，如果项目的模块比较多，也可以使用 Docker 部署，公众号后台回复 Docker，可以查看松哥的自己纯手敲的 Docker 教程。</p><p>容器化部署的话，如果模块比较多的话，我们可能还需要结合 Jenkins ，这里我就单纯的从 Docker 容器的角度来说说。</p><p>Docker 部署的话，也是两种思路，直接部署或者使用 Jib。这个松哥之前发过相关文章，这里就不再赘述。</p><ul><li><a href="https://mp.weixin.qq.com/s/7DrvNHM6MGc7lwz8JDULSQ" target="_blank" rel="noopener">部署 Spring Boot 到远程 Docker 容器</a></li><li><a href="https://mp.weixin.qq.com/s/1VMWrCZjsbEJLo34K-M6dQ" target="_blank" rel="noopener">使用 Jib 部署 Spring Boot</a></li></ul><h2 id="5-相关视频"><a href="#5-相关视频" class="headerlink" title="5.相关视频"></a>5.相关视频</h2><p>松哥之前也录制过一下部署的相关视频，大家可以作为参考。</p><p><a href="https://mp.weixin.qq.com/s/VKtt9nC7PCHmiUI8oZ1CTw" target="_blank" rel="noopener">本文配套视频地址</a></p><p>好了，看些资料看完，相信小伙伴们对于前后端分离的部署已经有一个基本的认知了。觉得有收获，记得点个在看哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假期一直在下雨，抽空整理了下小伙伴们问的比较多的前后端分离的部署问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之 Inject Language</title>
    <link href="http://www.javaboy.org/2020/0405/inject-language.html"/>
    <id>http://www.javaboy.org/2020/0405/inject-language.html</id>
    <published>2020-04-04T23:13:35.000Z</published>
    <updated>2020-04-14T23:40:43.245Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</title>
    <link href="http://www.javaboy.org/2020/0403/redis-java-client.html"/>
    <id>http://www.javaboy.org/2020/0403/redis-java-client.html</id>
    <published>2020-04-02T23:13:18.000Z</published>
    <updated>2020-04-14T23:43:44.813Z</updated>
    
    <content type="html"><![CDATA[<p>其实今天是想和小伙伴们聊一下 Redis 的通信协议 RESP。在搞懂这个通信协议的基础上，松哥手把手带领大家做一个 Redis 的 Java 客户端。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">本文配套视频地址</a></p><p>以上视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><p>Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流量，而在于内部逻辑，所以采用了这样一个费流量的文本协议，事实证明，这个费流量的文本协议并不影响 Redis 的受欢迎程度。</p><p>这个文本协议叫做 Redis Serialization Protocol，简称 RESP。</p><p>Redis 协议将传输的数据结构分为 5 种最小单元，单元结束时，加上回车换行符 \r\n。</p><ol><li>单行字符串以 + 开始，例如 +javaboy.org\r\n</li><li>多行字符串以 $ 开始，后面加上字符串长度，例如 $11\r\njavaboy.org\r\n</li><li>整数值以: 开始，例如 :1024\r\n</li><li>错误消息以 - 开始</li><li>数组以 * 开始，后面加上数组长度。</li></ol><p>需要注意的是，如果是客户端连接服务端，只能使用第 5 种。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>做两件事情：</p><p>为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中) </p><p>protected no</p><p>同时关闭密码：</p><p><code># requirepass xxxx</code></p><p>配置完成后，重启 Redis。</p><h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2. 实战"></a>2. 实战</h2><p>接下来，我们通过 Socket+RESP 来定义两个最最常见的命令 set 和 get。</p><p>首先我们在构造方法中初始化一个 Socket 连接，这将是我们 Java 代码和 Redis 通信的基础。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyRedisClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Socket socket;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaboyRedisClient</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"192.168.91.128"</span>, <span class="hljs-number">6379</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="hljs-string">"Redis 连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们先来定义 set 方法。</p><p>根据前面列出来的规则，Java 客户端发送到 Redis 中的数据格式是第 5 种，也就是一个数组，对于 set 命令而言，数组中应该有三项，第一项是命令名字 set，第二项和第三项则是对应的 key/value，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[set,key,value]</span><br></pre></td></tr></table></figure><p>结合第 1 小节的 5 条规则，我们可以先规划一下要发送的字符串，每行文本之后都有 <code>\r\n</code>。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$3\r\nkey\r\n$5\r\nvalue\r\n</span><br></pre></td></tr></table></figure><p><code>*3</code> 表示数组长度为 3（规则 5），$3 表示 set 长度为 3（规则 2），后面字符串含义类似不再赘述。 </p><p>整理好思路之后，我们来看下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 执行 Redis 中的 set 命令 [set,key,value]</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> key</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> value</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">   sb.append(<span class="hljs-string">"*3"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"set"</span>.length())</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"set"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(key.getBytes().length)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(key)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(value.getBytes().length)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(value)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">   System.out.println(sb.toString());</span><br><span class="line">   socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">   <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">   socket.getInputStream().read(buf);</span><br><span class="line">   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑很简单，就是把我们传入的参数，处理成我们上面写好的字符串，然后再通过 socket 写出去。</p><p>同理，我们还可以定制 get 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 执行 Redis 中的 get 命令 [get,key]</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="hljs-string">"*2"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"get"</span>.length())</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"get"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">            .append(key.getBytes().length)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(key)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">    socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">    socket.getInputStream().read(buf);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过如下一段代码进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String set = <span class="hljs-keyword">new</span> JavaboyRedisClient().set(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    String k1 = <span class="hljs-keyword">new</span> JavaboyRedisClient().get(<span class="hljs-string">"k1"</span>);</span><br><span class="line">    System.out.println(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，如此之后，我们就定义了一个简陋的 Java 客户端。具体的测试效果小伙伴们可以参考前面的视频。</p><p>好了，在理解 RESP 的基础上，我们可以非常容易的实现这样的客户端。小伙伴们也可以自己尝试定义一下其他的命令体验下。</p><p>如果觉得有用，记得点在看哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实今天是想和小伙伴们聊一下 Redis 的通信协议 RESP。在搞懂这个通信协议的基础上，松哥手把手带领大家做一个 Redis 的 Java 客户端。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</title>
    <link href="http://www.javaboy.org/2020/0402/spring-security-json.html"/>
    <id>http://www.javaboy.org/2020/0402/spring-security-json.html</id>
    <published>2020-04-01T23:12:56.000Z</published>
    <updated>2020-04-14T23:44:29.610Z</updated>
    
    <content type="html"><![CDATA[<p>这是本系列的第四篇，有小伙伴找不到之前文章，松哥给大家列一个索引出来：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li></ol><p><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><p>前两天有个小伙伴在微信上问松哥，这前后端分离开发后，认证这一块到底是使用传统的 session 还是使用像 JWT 这样的 token 来解决呢？</p><p>这确实代表了两种不同的方向。</p><p>传统的通过 session 来记录用户认证信息的方式我们可以理解为这是一种有状态登录，而 JWT 则代表了一种无状态登录。可能有小伙伴对这个概念还不太熟悉，我这里就先来科普一下有状态登录和无状态登录。</p><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1. 无状态登录"></a>1. 无状态登录</h2><h3 id="1-1-什么是有状态"><a href="#1-1-什么是有状态" class="headerlink" title="1.1 什么是有状态"></a>1.1 什么是有状态</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-各自优缺点"><a href="#1-4-各自优缺点" class="headerlink" title="1.4 各自优缺点"></a>1.4 各自优缺点</h3><p>使用 session 最大的优点在于方便。你不用做过多的处理，一切都是默认的即可。松哥本系列前面几篇文章我们也都是基于 session 来讲的。</p><p>但是使用 session 有另外一个致命的问题就是如果你的前端是 Android、iOS、小程序等，这些 App 天然的就没有 cookie，如果非要用 session，就需要这些工程师在各自的设备上做适配，一般是模拟 cookie，从这个角度来说，在移动 App 遍地开花的今天，我们单纯的依赖 session 来做安全管理，似乎也不是特别理想。</p><p>这个时候 JWT 这样的无状态登录就展示出自己的优势了，这些登录方式所依赖的 token 你可以通过普通参数传递，也可以通过请求头传递，怎么样都行，具有很强的灵活性。</p><p>不过话说回来，如果你的前后端分离只是网页+服务端，其实没必要上无状态登录，基于 session 来做就可以了，省事又方便。</p><p>好了，说了这么多，本文我还是先来和大家说说基于 session 的认证，关于 JWT 的登录以后我会和大家细说，如果小伙伴们等不及，也可以先看看松哥之前发的关于 JWT 的教程：<a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a>。</p><h2 id="2-登录交互"><a href="#2-登录交互" class="headerlink" title="2. 登录交互"></a>2. 登录交互</h2><p>在<a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家捋了常见的登录参数配置问题，对于登录成功和登录失败，我们还遗留了一个回调函数没有讲，这篇文章就来和大家细聊一下。</p><h3 id="2-1-前后端分离的数据交互"><a href="#2-1-前后端分离的数据交互" class="headerlink" title="2.1 前后端分离的数据交互"></a>2.1 前后端分离的数据交互</h3><p>在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。</p><p>登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。</p><p>登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。</p><p>首先把这样的思路确定了，基于这样的思路，我们来看一下登录配置。</p><h3 id="2-2-登录成功"><a href="#2-2-登录成功" class="headerlink" title="2.2 登录成功"></a>2.2 登录成功</h3><p>之前我们配置登录成功的处理是通过如下两个方法来配置的：</p><ul><li>defaultSuccessUrl</li><li>successForwardUrl</li></ul><p>这两个都是配置跳转地址的，适用于前后端不分的开发。除了这两个方法之外，还有一个必杀技，那就是 successHandler。</p><p>successHandler 的功能十分强大，甚至已经囊括了 defaultSuccessUrl 和 successForwardUrl 的功能。我们来看一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.successHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">    Object principal = authentication.getPrincipal();</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(principal));</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>successHandler 方法的参数是一个 AuthenticationSuccessHandler 对象，这个对象中我们要实现的方法是 onAuthenticationSuccess。</p><p>onAuthenticationSuccess 方法有三个参数，分别是：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>Authentication</li></ul><p>有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 HttpServletRequest 我们可以做服务端跳转，利用 HttpServletResponse 我们可以做客户端跳转，当然，也可以返回 JSON 数据。</p><p>第三个 Authentication 参数则保存了我们刚刚登录成功的用户信息。</p><p>配置完成后，我们再去登录，就可以看到登录成功的用户信息通过 JSON 返回到前端了，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-4-1.png" alt></p><p>当然用户的密码已经被擦除掉了。擦除密码的问题，松哥之前和大家分享过，大家可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">手把手带你捋一遍 Spring Security 登录流程</a></p><h3 id="2-3-登录失败"><a href="#2-3-登录失败" class="headerlink" title="2.3 登录失败"></a>2.3 登录失败</h3><p>登录失败也有一个类似的回调，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.failureHandler((req, resp, e) -&gt; &#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(e.getMessage());</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>失败的回调也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。</p><p>当然大家也看到，在微人事中，我还挨个去识别了一下异常的类型，根据不同的异常类型，我们可以给用户一个更加明确的提示：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">PrintWriter out = resp.getWriter();</span><br><span class="line">RespBean respBean = RespBean.error(e.getMessage());</span><br><span class="line"><span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p>这里有一个需要注意的点。</p><p>我们知道，当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即<strong>用户名或者密码输入错误，请重新输入</strong>，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。</p><p>但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。</p><p>在 Spring Security 中，用户名查找失败对应的异常是：</p><ul><li>UsernameNotFoundException</li></ul><p>密码匹配失败对应的异常是：</p><ul><li>BadCredentialsException</li></ul><p>但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。</p><p>这是为什么呢？松哥在之前的文章<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">手把手带你捋一遍 Spring Security 登录流程</a>中介绍过，在登录中有一个关键的步骤，就是去加载用户数据，我们再来把这个方法拎出来看一下（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"User '"</span> + username + <span class="hljs-string">"' not found"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，我们看出，在查找用户时，如果抛出了 UsernameNotFoundException，这个异常会被捕获，捕获之后，如果 hideUserNotFoundExceptions 属性的值为 true，就抛出一个 BadCredentialsException。相当于将 UsernameNotFoundException 异常隐藏了，而默认情况下，hideUserNotFoundExceptions 的值就为 true。</p><p>看到这里大家就明白了为什么无论用户还是密码写错，你收到的都是 BadCredentialsException 异常。</p><p>一般来说这个配置是不需要修改的，如果你一定要区别出来 UsernameNotFoundException 和 BadCredentialsException，我这里给大家提供三种思路：</p><ol><li>自己定义 DaoAuthenticationProvider 代替系统默认的，在定义时将 hideUserNotFoundExceptions 属性设置为 false。</li><li>当用户名查找失败时，不抛出 UsernameNotFoundException 异常，而是抛出一个自定义异常，这样自定义异常就不会被隐藏，进而在登录失败的回调中根据自定义异常信息给前端用户一个提示。</li><li>当用户名查找失败时，直接抛出 BadCredentialsException，但是异常信息为 “用户名不存在”。</li></ol><p>三种思路仅供小伙伴们参考，除非情况特殊，一般不用修改这一块的默认行为。</p><p>官方这样做的好处是什么呢？很明显可以强迫开发者给一个模糊的异常提示，这样即使是不懂行的新手，也不会将系统置于危险之中。</p><p>好了，这样配置完成后，无论是登录成功还是失败，后端都将只返回 JSON 给前端了。</p><h2 id="3-未认证处理方案"><a href="#3-未认证处理方案" class="headerlink" title="3. 未认证处理方案"></a>3. 未认证处理方案</h2><p>那未认证又怎么办呢？</p><p>有小伙伴说，那还不简单，没有认证就访问数据，直接重定向到登录页面就行了，这没错，系统默认的行为也是这样。</p><p>但是在前后端分离中，这个逻辑明显是有问题的，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。</p><p>要解决这个问题，就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.csrf().disable().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            out.write(<span class="hljs-string">"尚未登录，请先登录"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="4-注销登录"><a href="#4-注销登录" class="headerlink" title="4. 注销登录"></a>4. 注销登录</h2><p>最后我们再来看看注销登录的处理方案。</p><p>注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.logout()</span><br><span class="line">.logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">.logoutSuccessHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(<span class="hljs-string">"注销成功"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>这样，注销成功之后，前端收到的也是 JSON 了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-4-2.png" alt></p><p>好了，本文就和小伙伴们介绍下前后端分离中常见的 JSON 交互问题，<strong>小伙伴们如果觉得文章有帮助，记得点一下在看哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本系列的第四篇，有小伙伴找不到之前文章，松哥给大家列一个索引出来：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>奇怪，Spring Security 登录成功后总是获取不到登录用户信息？</title>
    <link href="http://www.javaboy.org/2020/0401/spring-security-securitycontext.html"/>
    <id>http://www.javaboy.org/2020/0401/spring-security-securitycontext.html</id>
    <published>2020-03-31T23:12:38.000Z</published>
    <updated>2020-04-14T23:44:54.213Z</updated>
    
    <content type="html"><![CDATA[<p>有好几位小伙伴小伙伴曾向松哥求助过这个问题。</p><p>一开始我觉得这可能是一个小概率 BUG，但是当问的人多了，我觉得这个问题对于新手来说还有一定的普遍性，有必要来写篇文章跟大家仔细聊一聊这个问题，防止小伙伴们掉坑。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/qUDZdTPc4-2UtmHtFI4v-g" target="_blank" rel="noopener">本文配套视频地址</a></p><h2 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h2><p>如果使用了 Spring Security，当我们登录成功后，可以通过如下方式获取到当前登录用户信息：</p><ol><li><code>SecurityContextHolder.getContext().getAuthentication()</code></li><li>在 Controller 的方法中，加入 Authentication 参数</li></ol><p>这两种办法，都可以获取到当前登录用户信息。具体的操作办法，大家可以看看松哥之前发布的教程：<a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">Spring Security 如何动态更新已登录用户信息？</a>。</p><p>正常情况下，我们通过如上两种方式的任意一种就可以获取到已经登录的用户信息。</p><p>异常情况，就是这两种方式中的任意一种，都返回 null。</p><p>都返回 null，意味着系统收到当前请求时并不知道你已经登录了（因为你没有在系统中留下任何有效信息），这会带来两个问题：</p><ol><li>无法获取到当前登录用户信息。</li><li>当你发送任何请求，系统都会给你返回 401。</li></ol><h2 id="2-顺藤摸瓜"><a href="#2-顺藤摸瓜" class="headerlink" title="2.顺藤摸瓜"></a>2.顺藤摸瓜</h2><p>要弄明白这个问题，我们就得明白 Spring Security 中的用户信息到底是在哪里存的？</p><p>前面说了两种数据获取方式，但是这两种数据获取方式，获取到的数据又是从哪里来的？</p><p>首先松哥之前和大家聊过，SecurityContextHolder 中的数据，本质上是保存在 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。</p><p>这样就带来一个问题，当不同的请求进入到服务端之后，由不同的 thread 去处理，按理说后面的请求就可能无法获取到登录请求的线程存入的数据，例如登录请求在线程 A 中将登录用户信息存入 <code>ThreadLocal</code>，后面的请求来了，在线程 B 中处理，那此时就无法获取到用户的登录信息。</p><p>但实际上，正常情况下，我们每次都能够获取到登录用户信息，这又是怎么回事呢？</p><p>这我们就要引入 Spring Security 中的 <code>SecurityContextPersistenceFilter</code> 了。</p><p>小伙伴们都知道，无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，松哥前面跟大家聊了 <code>UsernamePasswordAuthenticationFilter</code> 过滤器，在这个过滤器之前，还有一个过滤器就是 <code>SecurityContextPersistenceFilter</code>，请求在到达 <code>UsernamePasswordAuthenticationFilter</code> 之前都会先经过 <code>SecurityContextPersistenceFilter</code>。</p><p>我们来看下它的源码(部分)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextPersistenceFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request,</span><br><span class="line">response);</span><br><span class="line">SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder</span><br><span class="line">.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的方法很长，我这里列出来了比较关键的几个部分：</p><ol><li>SecurityContextPersistenceFilter 继承自 GenericFilterBean，而 GenericFilterBean 则是 Filter 的实现，所以 SecurityContextPersistenceFilter 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li><li>在 doFilter 方法中，它首先会从 repo 中读取一个 SecurityContext 出来，这里的 repo 实际上就是 HttpSessionSecurityContextRepository，读取 SecurityContext 的操作会进入到 readSecurityContextFromSession 方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 springSecurityContextKey 对象的值就是 SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个 SecurityContext 对象。</li><li>SecurityContext 是一个接口，它有一个唯一的实现类 SecurityContextImpl，这个实现类其实就是用户信息在 session 中保存的 value。</li><li>在拿到 SecurityContext 之后，通过 SecurityContextHolder.setContext 方法将这个 SecurityContext 设置到 ThreadLocal 中去，这样，在当前请求中，Spring Security 的后续操作，我们都可以直接从 SecurityContextHolder 中获取到用户信息了。</li><li>接下来，通过 chain.doFilter 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li><li>在过滤器链走完之后，数据响应给前端之后，finally 中还有一步收尾操作，这一步很关键。这里从 SecurityContextHolder 中获取到 SecurityContext，获取到之后，会把 SecurityContextHolder 清空，然后调用 repo.saveContext 方法将获取到的 SecurityContext 存入 session 中。</li></ol><p>至此，整个流程就很明了了。</p><p>每一个请求到达服务端的时候，首先从 session 中找出来 SecurityContext ，然后设置到 SecurityContextHolder 中去，方便后续使用，当这个请求离开的时候，SecurityContextHolder 会被清空，SecurityContext 会被放回 session 中，方便下一个请求来的时候获取。</p><p>搞明白这一点之后，再去解决 Spring Security 登录后无法获取到当前登录用户这个问题，就非常 easy 了。</p><h2 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3.问题解决"></a>3.问题解决</h2><p>经过上面的分析之后，我们再来回顾一下为什么会发生登录之后无法获取到当前用户信息这样的事情？</p><p>最简单情况的就是你在一个新的线程中去执行 <code>SecurityContextHolder.getContext().getAuthentication()</code>，这肯定获取不到用户信息，无需多说。例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/menu"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">            System.out.println(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="hljs-keyword">return</span> menuService.getMenusByHrId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种简单的问题相信大家都能够很容易排查到。</p><p>还有一种隐藏比较深的就是在 SecurityContextPersistenceFilter 的 doFilter 方法中没能从 session 中加载到用户信息，进而导致 SecurityContextHolder 里边空空如也。</p><p>在 SecurityContextPersistenceFilter 中没能加载到用户信息，原因可能就比较多了，例如：</p><ul><li><strong>上一个请求临走的时候，没有将数据存储到 session 中去。</strong></li><li><strong>当前请求自己没走过滤器链。</strong></li></ul><p>什么时候会发生这个问题呢？有的小伙伴可能在配置 SecurityConfig#configure(WebSecurity) 方法时，会忽略掉一个重要的点。</p><p>当我们想让 Spring Security 中的资源可以匿名访问时，我们有两种办法：</p><ol><li>不走 Spring Security 过滤器链。</li><li>继续走 Spring Security 过滤器链，但是可以匿名访问。</li></ol><p>这两种办法对应了两种不同的配置方式。其中第一种配置可能会影响到我们获取登录用户信息，第二种则不影响，所以这里我们来重点看看第一种。</p><p>不想走 Spring Security 过滤器链，我们一般可以通过如下方式配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/index.html"</span>,<span class="hljs-string">"/img/**"</span>,<span class="hljs-string">"/fonts/**"</span>,<span class="hljs-string">"/favicon.ico"</span>,<span class="hljs-string">"/verifyCode"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常这样配置是没有问题的。</p><p>如果你很不巧，把登录请求地址放进来了，那就 gg 了。虽然登录请求可以被所有人访问，但是不能放在这里（而应该通过允许匿名访问的方式来给请求放行）。<strong>如果放在这里，登录请求将不走 <code>SecurityContextPersistenceFilter</code> 过滤器，也就意味着不会将登录用户信息存入 session，进而导致后续请求无法获取到登录用户信息。</strong></p><p>这也就是一开始小伙伴遇到的问题。</p><p>好了，小伙伴们如果在使用 Spring Security 时遇到类似问题，不妨按照本文提供的思路来解决一下。<strong>如果觉得有收获，记得点一下右下角在看哦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有好几位小伙伴小伙伴曾向松哥求助过这个问题。&lt;/p&gt;
&lt;p&gt;一开始我觉得这可能是一个小概率 BUG，但是当问的人多了，我觉得这个问题对于新手来说还有一定的普遍性，有必要来写篇文章跟大家仔细聊一聊这个问题，防止小伙伴们掉坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
</feed>
