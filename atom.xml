<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2023-07-21T14:52:54.121Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩一玩编程式 AOP</title>
    <link href="http://www.javaboy.org/2023/0721/spring_code_aop.html"/>
    <id>http://www.javaboy.org/2023/0721/spring_code_aop.html</id>
    <published>2023-07-21T14:18:36.000Z</published>
    <updated>2023-07-21T14:52:54.121Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>平时我们项目中涉及到 AOP，基本上就是声明式配置一下就行了，无论是基于 XML 的配置还是基于 Java 代码的配置，都是简单配置即可使用。声明式配置有一个好处就是对源代码的侵入小甚至是零侵入。不过今天松哥要和小伙伴们聊一聊编程式的 AOP，为什么要聊这个话题呢？因为在 Spring 源码中，底层就是通过这种方式创建代理对象的，所以如果自己会通过编程式的方式进行 AOP 开发，那么在看 Spring 中相关源码的时候，就会很好理解了。</p><a id="more"></a><p>如果小伙伴们对 AOP 的基本用法还不熟悉，可以在公众号【江南一点雨】后台回复 ssm，有松哥录制的免费入门视频。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><h3 id="1-1-基于-JDK-的-AOP"><a href="#1-1-基于-JDK-的-AOP" class="headerlink" title="1.1 基于 JDK 的 AOP"></a>1.1 基于 JDK 的 AOP</h3><p>我们先来看基于 JDK 动态代理的 AOP。</p><p>假设我有如下一个计算器接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给这个接口提供一个实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + <span class="hljs-string">"+"</span> + b + <span class="hljs-string">"="</span> + (a + b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我要生成一个代理对象，利用编程式的方式，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(<span class="hljs-keyword">new</span> CalculatorImpl());</span><br><span class="line">proxyFactory.addInterface(ICalculator.class);</span><br><span class="line">proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法开始执行了。。。"</span>);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法执行结束了。。。"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ICalculator calculator = (ICalculator) proxyFactory.getProxy();</span><br><span class="line">calculator.add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br></pre></td></tr></table></figure><p>这里几个方法应该都好理解：</p><ol><li>setTarget 方法是设置真正的代理对象。这个在我们之前的 <a href="https://mp.weixin.qq.com/s/GjI4xPGXscCGQtcalwnJKQ" target="_blank" rel="noopener">@Lazy 注解为啥就能破解死循环？</a>一文中大家已经接触过了。</li><li>addInterface，基于 JDK 的动态代理是需要有接口的，这个方法就是设置代理对象的接口。</li><li>addAdvice 方法就是添加增强/通知。</li><li>最后通过 getProxy 方法获取到一个代理对象然后去执行。</li></ol><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230716201918.png" alt></p><h3 id="1-2-基于-CGLIB-的-AOP"><a href="#1-2-基于-CGLIB-的-AOP" class="headerlink" title="1.2 基于 CGLIB 的 AOP"></a>1.2 基于 CGLIB 的 AOP</h3><p>如果被代理的对象没有接口，那么可以通过基于 CGLIB 的动态代理来生成代理对象。</p><p>假设我有如下类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello javaboy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要给这个类生成代理对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(<span class="hljs-keyword">new</span> UserService());</span><br><span class="line">proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String name = invocation.getMethod().getName();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法开始执行了。。。"</span>);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法执行结束了。。。"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserService us = (UserService) proxyFactory.getProxy();</span><br><span class="line">us.hello();</span><br></pre></td></tr></table></figure><p>其实道理很简单，没有接口就不设置接口就行了。</p><h3 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h3><p>在上面生成代理对象的 getProxy 方法中，最终会执行到 createAopProxy 方法，在该方法中会根据是否有接口来决定是使用 JDK 动态代理还是 CGLIB 动态代理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中可以看到，有接口就是 JDK 动态代理，没有接口则是 CGLIB 动态代理。不过在最上面有一个 if 判断，这个判断中有三个条件，分别来和小伙伴们说一下：</p><p><strong>config.isOptimize()</strong></p><p>这个方法是判断是否需要优化。因为传统上大家都认为 CGLIB 动态代理性能高于 JDK 动态代理，不过这些年 JDK 版本更新也是非常快，现在两者性能差异已经不大了。如果这个属性设置为 true，那么系统就会去判断是否有接口，有接口就 JDK 动态代理，否则就 CGLIB 动态代理。</p><p>如果需要设置该属性，可以通过如下代码设置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyFactory.setOptimize(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>config.isProxyTargetClass()</strong></p><p>这个属性作用也是类似，我们平时在使用 AOP 的时候，有时候也会设置这个属性，这个属性如果设置为 true，则会进入到 if 分支中，但是 if 分支中的 if 则不宜满足，所以一般情况下，如果这个属性设置为 true，就意味着无论是否有接口，都使用 CGLIB 动态代理。如果这个属性为 false，则有接口就使用 JDK 动态代理，没有接口就使用 CGLIB 动态代理。</p><p><strong>hasNoUserSuppliedProxyInterfaces(config)</strong></p><p>这个方法主要做两方面的判断：</p><ol><li>当前代理对象如果没有接口，则直接返回 true。</li><li>当前代理对象有接口，但是接口是 SpringProxy，则返回 true。</li></ol><p>返回 true 基本上就意味着要使用 CGLIB 动态代理了，返回 false 则意味着使用 JDK 动态代理。</p><p>如果是基于 JDK 的动态代理，那么最终调用的就是 JdkDynamicAopProxy#getProxy() 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Creating JDK dynamic proxy: "</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="hljs-keyword">this</span>.proxiedInterfaces, <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy.newProxyInstance</code> 这就是 JDK 里边的动态代理了，这很好懂。</p><p>如果是基于 CGLIB 的动态代理，那么最终调用的就是 CglibAopProxy#getProxy() 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> buildProxy(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">buildProxy</span><span class="hljs-params">(@Nullable ClassLoader classLoader, <span class="hljs-keyword">boolean</span> classOnly)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; rootClass = <span class="hljs-keyword">this</span>.advised.getTargetClass();</span><br><span class="line">Assert.state(rootClass != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line">Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line"><span class="hljs-keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"><span class="hljs-comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="hljs-keyword">if</span> (classLoader != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader smartClassLoader &amp;&amp;</span><br><span class="line">smartClassLoader.isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setAttemptLoad(<span class="hljs-keyword">true</span>);</span><br><span class="line">enhancer.setStrategy(<span class="hljs-keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> ProxyCallbackFilter(</span><br><span class="line"><span class="hljs-keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="hljs-keyword">this</span>.fixedInterceptorMap, <span class="hljs-keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"><span class="hljs-comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="hljs-keyword">return</span> (classOnly ? createProxyClass(enhancer) : createProxyClassAndInstance(enhancer, callbacks));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"Could not generate CGLIB subclass of "</span> + <span class="hljs-keyword">this</span>.advised.getTargetClass() +</span><br><span class="line"><span class="hljs-string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-comment">// TargetSource.getTarget() failed</span></span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于直接使用 JDK 创建动态代理对象和直接使用 CGLIB 创建动态代理对象的代码我就不做过多介绍了，这些都是基本用法，松哥在之前录制的免费的 SSM 入门教程中都和小伙伴们讲过了，这里就不啰嗦了。</p><h2 id="2-Advisor"><a href="#2-Advisor" class="headerlink" title="2. Advisor"></a>2. Advisor</h2><h3 id="2-1-Advisor"><a href="#2-1-Advisor" class="headerlink" title="2.1 Advisor"></a>2.1 Advisor</h3><p>Advisor = Pointcut+Advice。</p><p>前面的案例我们只是设置了 Advice，没有设置 Pointcut，这样最终拦截下来的是所有方法。</p><p>如果有需要，我们可以直接设置一个 Advisor，这样就可以指定需要拦截哪些方法了。</p><p>我们先来看一下 Advisor 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Advisor</span> </span>&#123;</span><br><span class="line">Advice EMPTY_ADVICE = <span class="hljs-keyword">new</span> Advice() &#123;&#125;;</span><br><span class="line"><span class="hljs-function">Advice <span class="hljs-title">getAdvice</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerInstance</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里主要的就是 getAdvice 方法，这个方法用来获取一个通知/增强。另外一个 isPerInstance 目前并没有使用，默认返回 true 即可。在具体实践中，我们更关注它的一个子类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PointcutAdvisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">Pointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个子类多了一个 getPointcut 方法，PointcutAdvisor 这个接口很好的诠释了 Advisor 的作用：Pointcut+Advice。</p><h3 id="2-2-Pointcut"><a href="#2-2-Pointcut" class="headerlink" title="2.2 Pointcut"></a>2.2 Pointcut</h3><p>Pointcut 又有众多的实现类：</p><p><img src="http://img.itboyhub.com/2022/08/Pointcut_class_impl.png" alt></p><p>挑两个有意思的说一下，其他的其实也都差不多。</p><h4 id="2-2-1-Pointcut"><a href="#2-2-1-Pointcut" class="headerlink" title="2.2.1 Pointcut"></a>2.2.1 Pointcut</h4><p>首先我们先来看下这个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pointcut</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">ClassFilter <span class="hljs-title">getClassFilter</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">MethodMatcher <span class="hljs-title">getMethodMatcher</span><span class="hljs-params">()</span></span>;</span><br><span class="line">Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口里边有两个方法，看名字大概也能猜出来意思：</p><ol><li>getClassFilter：这个是类的过滤器，通过这个可以刷选出来要拦截的类。</li><li>MethodMatcher：这个是方法过滤器，通过这个可以刷选出来需要拦截的方法。</li></ol><p>至于 ClassFilter 本身其实就很好懂了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ClassFilter</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">ClassFilter TRUE = TrueClassFilter.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一个 matches 方法，传入一个 Class 对象，然后执行比较即可，返回 true 就表示要拦截，返回 false 则表示不拦截。</p><p>MethodMatcher 也类似，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodMatcher</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRuntime</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line">MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个方法，两个是做匹配的 matches 方法，当 isRuntime 方法返回 true 的时候，才会执行第二个带 args 参数的 matches 方法。</p><p>举个简单的使用案例，假设我现在要拦截所有方法，那么我可以按照如下方式定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllClassAndMethodPointcut</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pointcut</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassFilter <span class="hljs-title">getClassFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ClassFilter.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodMatcher <span class="hljs-title">getMethodMatcher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> MethodMatcher.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是自带的两个常量，表示拦截所有类和所有方法。</p><p>再假如，我要拦截 CalculatorImpl 类的 add 方法，那么我可以按照如下方式来定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ICalculatorAddPointcut</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pointcut</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassFilter <span class="hljs-title">getClassFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassFilter() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> clazz.getName().equals(<span class="hljs-string">"org.javaboy.bean.aop.CalculatorImpl"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MethodMatcher <span class="hljs-title">getMethodMatcher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        NameMatchMethodPointcut matcher = <span class="hljs-keyword">new</span> NameMatchMethodPointcut();</span><br><span class="line">        matcher.addMethodName(<span class="hljs-string">"add"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> matcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-AspectJExpressionPointcut"><a href="#2-2-2-AspectJExpressionPointcut" class="headerlink" title="2.2.2 AspectJExpressionPointcut"></a>2.2.2 AspectJExpressionPointcut</h4><p>我们平时写 AOP，比较常用的是通过表达式来定义切面，那么这里就可以使用 AspectJExpressionPointcut，这是一个类，所以可以不用继承新类，直接使用创建使用即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AspectJExpressionPointcut pointcut = <span class="hljs-keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line">pointcut.setExpression(<span class="hljs-string">"execution(* org.javaboy.bean.aop.ICalculator.add(..))"</span>);</span><br></pre></td></tr></table></figure><p>如上切点就表示拦截 ICalculator 类中的 add 方法。</p><h3 id="2-3-Advice"><a href="#2-3-Advice" class="headerlink" title="2.3 Advice"></a>2.3 Advice</h3><p>这个好说，就是增强/通知，在本文第 1.1、1.2 小节中均已演示过，不再赘述。</p><h3 id="2-4-Advisor-实践"><a href="#2-4-Advisor-实践" class="headerlink" title="2.4 Advisor 实践"></a>2.4 Advisor 实践</h3><p>接下来松哥通过一个案例来和小伙伴们演示一下如何添加一个 Advisor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(<span class="hljs-keyword">new</span> CalculatorImpl());</span><br><span class="line">proxyFactory.addInterface(ICalculator.class);</span><br><span class="line">proxyFactory.addAdvisor(<span class="hljs-keyword">new</span> PointcutAdvisor() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Pointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        AspectJExpressionPointcut pointcut = <span class="hljs-keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line">        pointcut.setExpression(<span class="hljs-string">"execution(* org.javaboy.bean.aop.ICalculator.add(..))"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> pointcut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Advice <span class="hljs-title">getAdvice</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Method method = invocation.getMethod();</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                System.out.println(name + <span class="hljs-string">" 方法开始执行了。。。"</span>);</span><br><span class="line">                Object proceed = invocation.proceed();</span><br><span class="line">                System.out.println(name + <span class="hljs-string">" 方法执行结束了。。。"</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> proceed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ICalculator calculator = (ICalculator) proxyFactory.getProxy();</span><br><span class="line">calculator.add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">calculator.minus(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br></pre></td></tr></table></figure><p>在 getPointcut 方法中，可以返回 3.2 小节中不同的切点，都是 OK 没有问题的。getAdvice 就是前面定义的通知。</p><p>其实在本文的 1.1、1.2 小节中，我们直接添加了 Advice 而没有配置 Advisor，我们自己添加的 Advice 在内部也是被自动转为了一个 Advisor，相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAdvice</span><span class="hljs-params">(Advice advice)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> pos = <span class="hljs-keyword">this</span>.advisors.size();</span><br><span class="line">addAdvice(pos, advice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Cannot add introductions this way unless the advice implements IntroductionInfo.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAdvice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, Advice advice)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> IntroductionInfo introductionInfo) &#123;</span><br><span class="line">addAdvisor(pos, <span class="hljs-keyword">new</span> DefaultIntroductionAdvisor(advice, introductionInfo));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> DynamicIntroductionAdvice) &#123;</span><br><span class="line"><span class="hljs-comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">addAdvisor(pos, <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我们传入的 Advice 对象最终被转为一个 DefaultPointcutAdvisor 对象，然后调用了 addAdvisor 方法进行添加操作。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultPointcutAdvisor</span><span class="hljs-params">(Advice advice)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>(Pointcut.TRUE, advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 DefaultPointcutAdvisor 初始化的时候，设置了 <code>Pointcut.TRUE</code>，也就是所有类的所有方法都会被拦截。也就是 Advice 最终都会被转为 Advisor。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，这个就是编程式 AOP 的一个简单用法，这篇文章主要是希望小伙伴们对编程式 AOP 有一个简单的了解，这样在后续的 AOP 源码分析中才会更加轻松一些～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;平时我们项目中涉及到 AOP，基本上就是声明式配置一下就行了，无论是基于 XML 的配置还是基于 Java 代码的配置，都是简单配置即可使用。声明式配置有一个好处就是对源代码的侵入小甚至是零侵入。不过今天松哥要和小伙伴们聊一聊编程式的 AOP，为什么要聊这个话题呢？因为在 Spring 源码中，底层就是通过这种方式创建代理对象的，所以如果自己会通过编程式的方式进行 AOP 开发，那么在看 Spring 中相关源码的时候，就会很好理解了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>@Lazy 注解为啥就能破解死循环？</title>
    <link href="http://www.javaboy.org/2023/0719/spring_lazy.html"/>
    <id>http://www.javaboy.org/2023/0719/spring_lazy.html</id>
    <published>2023-07-19T14:18:25.000Z</published>
    <updated>2023-07-21T14:52:49.646Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p><a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">上篇文章</a>松哥和大家聊了在 Spring 中并非所有的循环依赖都可以被解决，有一些循环依赖默认情况下 Spring 也是完全无法解决的。不熟悉的小伙伴可以先看看<a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">上篇文章</a>。</p><a id="more"></a><p>以<a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">上篇文章</a>第一小节的案例为例，在构造方法中互相注入对方的 Bean，此时完全就是一个死循环呀，对于这种死循环，难道真的有办法解决？</p><p>Spring 里边提供了办法来解决，但是似乎又没有解决，为什么这么说，看完本文你就明白了。</p><h2 id="1-Lazy"><a href="#1-Lazy" class="headerlink" title="1. @Lazy"></a>1. @Lazy</h2><p>如本文题目所示，<a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">上篇文章</a>涉及到的三种无法自动解决的循环依赖，都可以通过添加 @Lazy 注解来解决。</p><p>如果是构造器注入，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Lazy</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AService</span><span class="hljs-params">(BService bService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.bService = bService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> BService <span class="hljs-title">getbService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> bService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    AService aService;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Lazy</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BService</span><span class="hljs-params">(AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AService <span class="hljs-title">getaService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Lazy 注解可以添加在 AService 或者 BService 的构造方法上，也可以都添加上。</p><p>添加上之后，我们再去启动项目，就不会报错了。这样看起来问题解决了，但是其实还是差点意思，小伙伴们看一下我的启动代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"aop.xml"</span>);</span><br><span class="line">AService aService = ctx.getBean(AService.class);</span><br><span class="line">BService bService = ctx.getBean(BService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"aService.getClass() = "</span> + aService.getClass());</span><br><span class="line">System.out.println(<span class="hljs-string">"bService.getClass() = "</span> + bService.getClass());</span><br><span class="line">System.out.println(<span class="hljs-string">"aService.getbService().getClass() = "</span> + aService.getbService().getClass());</span><br><span class="line">System.out.println(<span class="hljs-string">"bService.getaService().getClass() = "</span> + bService.getaService().getClass());</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230715231434.png" alt></p><p>小伙伴们看到，我们从 AService 和 BService 中获取到的 Bean 都是正常的未被代理的对象，事实上我们的原始代码确实也没有需要代理的地方。但是，AService 中的 BService 以及 BService 中的 AService 却都是代理对象，按理说 AService 中的 BService 应该和我们从 Spring 容器中获取到的 BService 一致，BService 中的 AService 也应该和 Spring 容器中获取到的 AService 一致，但实际上，两者却并不相同。</p><p>不过这样也好懂了，为什么 Spring 能把一个死结给解开，就是因为 AService 和 BService 各自注入的 Bean 都不是原始的 Bean，都是一个代理的 Bean，AService 中注入的 BService 是一个代理对象，同理，BService 中注入的 AService 也是一个代理对象。</p><p>这也是为什么我一开始说这个问题 Spring 解决了又没解决。</p><p>其实，这就是 @Lazy 这个注解的工作原理，看名字，加了该注解的对象会被延迟加载，实际上被该注解标记的对象，会自动生成一个代理对象。</p><p><a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">上篇文章</a>中提到的另外两个问题，也可以通过 @Lazy 注解来解决，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Lazy</span></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Lazy</span></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 @Lazy 只要一个其实就能解决问题，也可以两个都添加。</p><p>对于含有 @Async 注解的情况，也可以通过 @Lazy 注解来解决：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Lazy</span></span><br><span class="line">    BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Async</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        bService.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> BService <span class="hljs-title">getbService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> bService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AService <span class="hljs-title">getaService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，循环依赖可破！</p><p><strong>总而言之一句话，@Lazy 注解是通过建立一个中间代理层，来破解循环依赖的。</strong></p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>接下来我们再来分析一下 @Lazy 注解处理的源码。</p><p>这块的源码分析我就不从头开始分析了，因为整个处理流程前面部分和之前文章 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>所介绍的内容是一致的，不熟悉的小伙伴建议先阅读 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文。我这里就借用该文的总结，带领小伙伴们稍微回顾一下属性注入的过程：</p><p><img src="http://img.itboyhub.com/2022/08/20230713220838.png" alt></p><ol><li>在创建 Bean 的时候，原始 Bean 创建出来之后，会调用 populateBean 方法进行 Bean 的属性填充。</li><li>接下来调用 postProcessAfterInstantiation 方法去判断是否需要执行后置处理器，如果不需要，就直接返回了。</li><li>调用 postProcessProperties 方法，去触发各种后置处理器的执行。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230713222337.png" alt></p><ol start="4"><li>在第 3 步的方法中，调用 findAutowiringMetadata，这个方法又会进一步触发 buildAutorwiringMetadata 方法，去找到包含了 @Autowired、@Value 以及 @Inject 注解的属性或者方法，并将之封装为 InjectedElement 返回。</li><li>调用 InjectedElement#inject 方法进行属性注入。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230713223334.png" alt></p><ol start="6"><li>接下来执行 resolvedCachedArgument 方法尝试从缓存中找到需要的 Bean 对象。</li><li>如果缓存中不存在，则调用 resolveFieldValue 方法去容器中找到 Bean。</li><li>最后调用 makeAccessible 和 set 方法完成属性的赋值。</li></ol><p>在第 7 步中，调用 resolveFieldValue 方法去解析 Bean，@Lazy 注解的相关逻辑就是在这个方法中进行处理的（对应 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文的 3.2 小节）。</p><p>resolveFieldValue 方法最终会执行到 resolveDependency 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"><span class="hljs-keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">descriptor, requestingBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先会判断注入的属性类型是 Optional、ObjectFactory 还是 JSR-330 中的注解，我们这里都不是，所以走最后一个分支。</p><p>在最后一个 else 中，首先调用 getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary 方法看一下是否需要延迟加载 Bean 对象，@Lazy 注解就是在这里进行处理的。如果能够延迟加载，那么该方法的返回值就不为 null，就可以直接返回了，就不需要执行 doResolveDependency 方法了。</p><p>ContextAnnotationAutowireCandidateResolver#getLazyResolutionProxyIfNecessary：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getLazyResolutionProxyIfNecessary</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看一下，这个方法首先会调用 isLazy 去判断一下是否需要延迟加载，如果需要，则调用 buildLazyResolutionProxy 方法构建一个延迟加载的对象；如果不需要，则直接返回一个 null 即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazy</span><span class="hljs-params">(DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Annotation ann : descriptor.getAnnotations()) &#123;</span><br><span class="line">Lazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MethodParameter methodParam = descriptor.getMethodParameter();</span><br><span class="line"><span class="hljs-keyword">if</span> (methodParam != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Method method = methodParam.getMethod();</span><br><span class="line"><span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">void</span>.class == method.getReturnType()) &#123;</span><br><span class="line">Lazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (lazy != <span class="hljs-keyword">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断方法主要是检查当前类中各种参数上是否含有 @Lazy 注解、方法、属性以及类名上是否含有 @Lazy 注解，如果有，则返回 true，否则返回 false。</p><p>再来看 buildLazyResolutionProxy 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">buildLazyResolutionProxy</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> DependencyDescriptor descriptor, <span class="hljs-keyword">final</span> @Nullable String beanName, <span class="hljs-keyword">boolean</span> classOnly)</span> </span>&#123;</span><br><span class="line">BeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="hljs-keyword">final</span> DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line">TargetSource ts = <span class="hljs-keyword">new</span> TargetSource() &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> descriptor.getDependencyType();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; autowiredBeanNames = (beanName != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>) : <span class="hljs-keyword">null</span>);</span><br><span class="line">Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; type = getTargetClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (Map.class == type) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (List.class == type) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Set.class == type || Collection.class == type) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptySet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),</span><br><span class="line"><span class="hljs-string">"Optional dependency not present for lazy injection point"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (dlbf.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">dlbf.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ProxyFactory pf = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">pf.setTargetSource(ts);</span><br><span class="line">Class&lt;?&gt; dependencyType = descriptor.getDependencyType();</span><br><span class="line"><span class="hljs-keyword">if</span> (dependencyType.isInterface()) &#123;</span><br><span class="line">pf.addInterface(dependencyType);</span><br><span class="line">&#125;</span><br><span class="line">ClassLoader classLoader = dlbf.getBeanClassLoader();</span><br><span class="line"><span class="hljs-keyword">return</span> (classOnly ? pf.getProxyClass(classLoader) : pf.getProxy(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是用来生成代理的对象的，这里构建了代理对象 TargetSource，在其 getTarget 方法中，会去执行 doResolveDependency 获取到被代理的对象（doResolveDependency 的获取逻辑可以参考 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文），而 getTarget 方法只有在需要的时候才会被调用。所以，@Lazy 注解所做的事情，就是在给 Bean 中的各个属性注入值的时候，原本需要去 Spring 容器中找注入的对象，现在不找了，先给一个代理对象顶着，需要的时候再去 Spring 容器中查找。</p><p>后续的逻辑我就不再多说了，小伙伴们参考 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文即可。</p><p>好啦，现在小伙伴们明白了 @Lazy 注解是如何解决 Spring 循环依赖了吧～虽然解决了，但是我们在日常开发中，要是能避免循环依赖还是要去避免～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;松哥和大家聊了在 Spring 中并非所有的循环依赖都可以被解决，有一些循环依赖默认情况下 Spring 也是完全无法解决的。不熟悉的小伙伴可以先看看&lt;a href=&quot;https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>Spring 能解决所有循环依赖吗？</title>
    <link href="http://www.javaboy.org/2023/0718/circular_references.html"/>
    <id>http://www.javaboy.org/2023/0718/circular_references.html</id>
    <published>2023-07-18T14:18:15.000Z</published>
    <updated>2023-07-21T14:53:23.875Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>看了<a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">上篇文章</a>的小伙伴，对于 Spring 解决循环依赖的思路应该有一个大致了解了，今天我们再来看一看，按照<a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">上篇文章</a>介绍的思路，有哪些循环依赖 Spring 处理不了。</p><a id="more"></a><blockquote><p>严格来说，其实也不是解决不了，所有问题都有办法解决，只是还需要额外配置，这个不是本文的主题，松哥后面再整文章和小伙伴们细聊。</p></blockquote><h2 id="1-基于构造器注入"><a href="#1-基于构造器注入" class="headerlink" title="1. 基于构造器注入"></a>1. 基于构造器注入</h2><p>如果依赖的对象是基于构造器注入的，那么执行的时候就会报错，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AService</span><span class="hljs-params">(BService bService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.bService = bService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BService</span><span class="hljs-params">(AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时报错如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230715110542.png" alt></p><p><strong>原因分析：</strong></p><p><a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">上篇文章</a>我们说解决循环依赖的思路是加入缓存，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/a_b_circular_1956.png" alt></p><p>我们说先把 AService 原始对象创建出来，存入到缓存池中，然后再处理 AService 中需要注入的外部 Bean 等等，但是，如果 AService 依赖的 BService 是通过构造器注入的，那就会导致在创建 AService 原始对象的时候就需要用到 BService，去创建 BService 时候又需要 AService，这样就陷入到死循环了，对于这样的循环依赖执行时候就会出错。</p><p>更进一步，如果我们在 AService 中是通过 @Autowired 来注入 BService 的，那么应该是可以运行的，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BService</span><span class="hljs-params">(AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，AService 的原始对象就可以顺利创建出来放到缓存池中，BService 创建所需的 AService 也就能从缓存中获取到，所以就可以执行了。</p><h2 id="2-prototype-对象"><a href="#2-prototype-对象" class="headerlink" title="2. prototype 对象"></a>2. prototype 对象</h2><p>循环依赖双方 scope 都是 prototype 的话，也会循环依赖失败，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环依赖运行时也会报错，报错信息如下（跟前面报错信息一样）：</p><p><img src="http://img.itboyhub.com/2022/08/20230715114711.png" alt></p><p><strong>原因分析：</strong></p><p>scope 为 prototype 意思就是说这个 Bean 每次需要的时候都现场创建，不用缓存里的。那么 AService 需要 BService，所以就去现场创建 BService，结果 BService 又需要 AService，继续现场创建，AService 又需要 BService…，所以最终就陷入到死循环了。</p><h2 id="3-Async"><a href="#3-Async" class="headerlink" title="3. @Async"></a>3. @Async</h2><p>带有 @Async 注解的 Bean 产生循环依赖，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Async</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230715121203.png" alt></p><p>其实大家从这段报错信息中也能看出来个七七八八：在 BService 中注入了 AService 的原始对象，但是 AService 在后续的处理流程中被 AOP 代理了，产生了新的对象，导致 BService 中的 AService 并不是最终的 AService，所以就出错了！</p><p>那有小伙伴要问了，<a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">上篇文章</a>我们不是说了三级缓存就是为了解决 AOP 问题吗，为什么这里发生了 AOP 却无法解决？</p><p>如下两个前置知识大家先理解一下：</p><p><strong>第一：</strong></p><p>其实大部分的 AOP 循环依赖是没有问题的，这个 @Async 只是一个特例，特别在哪里呢？一般的 AOP 都是由 AbstractAutoProxyCreator 这个后置处理器来处理的，通过这个后置处理器生成代理对象，AbstractAutoProxyCreator 后置处理器是 SmartInstantiationAwareBeanPostProcessor 接口的子类，并且 AbstractAutoProxyCreator 后置处理器重写了 SmartInstantiationAwareBeanPostProcessor 接口的 getEarlyBeanReference 方法；而 @Async 是由 AsyncAnnotationBeanPostProcessor 来生成代理对象的，AsyncAnnotationBeanPostProcessor 也是 SmartInstantiationAwareBeanPostProcessor 的子类，但是却没有重写 getEarlyBeanReference 方法，默认情况下，getEarlyBeanReference 方法就是将传进来的 Bean 原封不动的返回去。</p><p><strong>第二：</strong></p><p>在 Bean 初始化的时候，Bean 创建完成后，后面会执行两个方法：</p><ul><li>populateBean：这个方法是用来做属性填充的。</li><li>initializeBean：这个方法是用来初始化 Bean 的实例，执行工厂回调、init 方法以及各种 BeanPostProcessor。</li></ul><p>大家先把这两点搞清楚，然后我来跟大家说上面代码的执行流程。</p><ol><li>首先 AService 初始化，初始化完成之后，存入到三级缓存中。</li><li>执行 populateBean 方法进行 AService 的属性填充，填充时发现需要用到 BService，于是就去初始化 BService。</li><li>初始化 BService 发现需要用到 AService，于是就去缓存池中找，找到之后拿来用，但是！！！这里找到的 AService 不是代理对象，而是原始对象。因为在三级缓存中保存的 AService 的那个 ObjectFactory 工厂，在对 AService 进行提前 AOP 的时候，执行的是 SmartInstantiationAwareBeanPostProcessor 类型的后置处理器 中的 getEarlyBeanReference 方法，如果是普通的 AOP，调用 getEarlyBeanReference 方法最终会触发提前 AOP，但是，这里执行的是 AsyncAnnotationBeanPostProcessor 中的 getEarlyBeanReference 方法，该方法只是返回了原始的 Bean，并未做任何额外处理。</li><li>当 BService 创建完成后，AService 继续初始化，继续执行 initializeBean 方法。</li><li>在 initializeBean 方法中，执行其他的各种后置处理器，包括 AsyncAnnotationBeanPostProcessor，此时调用的是 AsyncAnnotationBeanPostProcessor 的 postProcessAfterInitialization 方法，在该方法中为 AService 生成了代理对象。</li><li>在 initializeBean 方法执行完成之后，AService 会继续去检查最终的 Bean 是不是还是一开始的 Bean，如果不是，就去检查当前 Bean 有没有被其他 Bean 引用过，如果被引用过，就会抛出来异常，也就是上图大家看到的异常信息。</li></ol><p>好啦，这就是松哥和大家分享的三种 Spring 默认无法解决的循环依赖，其实也不是无法解决，需要一些额外配置也能解决，当然，这些额外配置并非本文重点，松哥后面再来和大家介绍～</p><p>另外最近两篇关于循环依赖的文章都还没有涉及到源码分析，大家先把思路整清楚，后面松哥再出源码分析的文章～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;看了&lt;a href=&quot;https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;的小伙伴，对于 Spring 解决循环依赖的思路应该有一个大致了解了，今天我们再来看一看，按照&lt;a href=&quot;https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;介绍的思路，有哪些循环依赖 Spring 处理不了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>如何通过三级缓存解决 Spring 循环依赖</title>
    <link href="http://www.javaboy.org/2023/0717/spring_3_cache.html"/>
    <id>http://www.javaboy.org/2023/0717/spring_3_cache.html</id>
    <published>2023-07-17T14:18:05.000Z</published>
    <updated>2023-07-21T14:53:20.226Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>这个其实是一个特别高频的面试题，松哥也一直很想和大家仔细来聊一聊这个话题，网上关于这块的文章很多，但是我一直觉得要把这个问题讲清楚还有点难度，今天我来试一试，看能不能和小伙伴们把这个问题梳理清楚。</p><a id="more"></a><p>这块我是打算整几篇文章，今天，我尽量不聊源码，单纯从设计思路方面来和小伙伴们梳理循环依赖该如何解决。</p><h2 id="1-循环依赖"><a href="#1-循环依赖" class="headerlink" title="1. 循环依赖"></a>1. 循环依赖</h2><h3 id="1-1-什么是循环依赖"><a href="#1-1-什么是循环依赖" class="headerlink" title="1.1 什么是循环依赖"></a>1.1 什么是循环依赖</h3><p>首先，什么是循环依赖？这个其实好理解，就是两个 Bean 互相依赖，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AService 和 BService 互相依赖：</p><p><img src="http://img.itboyhub.com/2022/08/a_b_circular.png" alt></p><p>这个应该很好理解。</p><h3 id="1-2-循环依赖的类型"><a href="#1-2-循环依赖的类型" class="headerlink" title="1.2 循环依赖的类型"></a>1.2 循环依赖的类型</h3><p>一般来说，循环依赖有三种不同的形态，上面 1.1 小节是其中一种。</p><p>另外两种分别是三者依赖，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/a_b_c_circular.png" alt></p><p>这种循环依赖一般隐藏比较深，不易发觉。</p><p>还有自我依赖，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/a_circular.png" alt></p><blockquote><p>一般来说，如果我们的代码中出现了循环依赖，则说明我们的代码在设计的过程中可能存在问题，我们应该尽量避免循环依赖的发生。不过一旦发生了循环依赖，Spring 默认也帮我们处理好了，当然这并不能说明循环依赖这种代码就没问题。实际上在目前最新版的 Spring 中，循环依赖是要额外开启的，如果不额外配置，发生了循环依赖就直接报错了。</p></blockquote><blockquote><p><strong>另外，Spring 并不能处理所有的循环依赖，后面松哥会和大家进行分析。</strong></p></blockquote><h2 id="2-循环依赖解决思路"><a href="#2-循环依赖解决思路" class="headerlink" title="2. 循环依赖解决思路"></a>2. 循环依赖解决思路</h2><h3 id="2-1-解决思路"><a href="#2-1-解决思路" class="headerlink" title="2.1 解决思路"></a>2.1 解决思路</h3><p>那么对于循环依赖该如何解决呢？其实很简单，中加加入一个缓存就可以了，小伙伴们来看下面这张图：</p><p><img src="http://img.itboyhub.com/2022/08/a_b_circular_1956.png" alt></p><p>我们在这里引入了一个缓存池。</p><p>当我们需要创建 AService 的实例的时候，会首先通过 Java 反射创建出来一个原始的 AService，这个原始 AService 可以简单理解为刚刚 new 出来（实际是刚刚通过反射创建出来）还没设置任何属性的 AService，此时，我们把这个 AService 先存入到一个缓存池中。</p><p>接下来我们就需要给 AService 的属性设置值了，同时还要处理 AService 的依赖，这时我们发现 AService 依赖 BService，那么就去创建 BService 对象，结果创建 BService 的时候，发现 BService 依赖 AService，那么此时就先从缓存池中取出来 AService 先用着，然后继续 BService 创建的后续流程，直到 BService 创建完成后，将之赋值给 AService，此时 AService 和 BService 就都创建完成了。</p><p>可能有小伙伴会说，BService 从缓存池中拿到的 AService 是一个半成品，并不是真正的最终的 AService，但是小伙伴们要知道，咱们 Java 是引用传递（也可以认为是值传递，只不过这个值是内存地址），BService 当时拿到的是 AService 的引用，说白了就是一块内存地址而已，根据这个地址找到的就是 AService，所以，后续如果 AService 创建完成后，BService 所拿到的 AService 就是完整的 AService 了。</p><p>那么上面提到的这个缓存池，在 Spring 容器中有一个专门的名字，就叫做 earlySingletonObjects，这是 Spring 三级缓存中的二级缓存，这里保存的是刚刚通过反射创建出来的 Bean，这些 Bean 还没有经历过完整生命周期，Bean 的属性可能都还没有设置，Bean 需要的依赖都还没有注入进来。另外两级缓存分别是：</p><ul><li>singletonObjects：这是一级缓存，一级缓存中保存的是所有经历了完整生命周期的 Bean，即一个 Bean 从创建、到属性赋值、到各种处理器的执行等等，都经历过了，就存到 singletonObjects 中，当我们需要获取一个 Bean 的时候，首先会去一级缓存中查找，当一级缓存中没有的时候，才会考虑去二级缓存。</li><li>singletonFactories：这是三级缓存。在一级缓存和二级缓存中，缓存的 key 是 beanName，缓存的 value 则是一个 Bean 对象，但是在三级缓存中，缓存的 value 是一个 Lambda 表达式，通过这个 Lambda 表达式可以创建出来目标对象的一个代理对象。</li></ul><p>有的小伙伴可能会觉得奇怪，按照上文的介绍，一级缓存和二级缓存就足以解决循环依赖了，为什么还冒出来一个三级缓存？那就得考虑 AOP 的情况了！</p><h3 id="2-2-存在-AOP-怎么办"><a href="#2-2-存在-AOP-怎么办" class="headerlink" title="2.2 存在 AOP 怎么办"></a>2.2 存在 AOP 怎么办</h3><p>上面松哥给大家介绍的是普通的 Bean 创建，那确实没有问题。但是 Spring 中还有一个非常重要的能力，那就是 AOP。</p><p>说到这里，我得先和小伙伴么说一说 Spring 中 AOP 的创建流程。</p><p>正常来说是我们首先通过反射获取到一个 Bean 的实例，然后就是给这个 Bean 填充属性，属性填充完毕之后，接下来就是执行各种 BeanPostProcessor 了（不了解 BeanPostProcessor 的小伙伴可以看松哥之前发的文章 <a href="https://mp.weixin.qq.com/s/ZjN1XPamDaYZmvFbyI1KTQ" target="_blank" rel="noopener">BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</a>），如果这个 Bean 中有需要代理的方法，那么系统就会自动配置对应的后置处理器，松哥举一个简单例子，假设我有如下一个 Service：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Async</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello&gt;&gt;&gt;"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么系统就会自动提供一个名为 <code>AsyncAnnotationBeanPostProcessor</code> 的处理器，在这个处理器中，系统会生成一个代理的 UserService 对象，并用这个对象代替原本的 UserService。</p><p>那么小伙伴们要搞清楚的是，原本的 UserService 和新生成的代理的 UserService 是两个不同的对象，占两块不同的内存地址！！！</p><p>我们再来回顾下面这张图：</p><p><img src="http://img.itboyhub.com/2022/08/a_b_circular_1956.png" alt></p><p>如果 AService 最终是要生成一个代理对象的话，那么 AService 存到缓存池的其实还是原本的 AService，因为此时还没到处理 AOP 那一步（要先给各个属性赋值，然后才是 AOP 处理），这就导致 BService 从缓存池里拿到的 AService 是原本的 AService，等到 BService 创建完毕之后，AService 的属性赋值才完成，接下来在 AService 后续的创建流程中，AService 会变成了一个代理对象了，不是缓存池里的 AService 了，最终就导致 BService 所依赖的 AService 和最终创建出来的 AService 不是同一个。</p><p>为了解决这个问题，Spring 引入了三级缓存 singletonFactories。</p><p>singletonFactories 的工作机制是这样的（假设 AService 最终是一个代理对象）：</p><p>当我们创建一个 AService 的时候，通过反射刚把原始的 AService 创建出来之后，先去判断当前一级缓存中是否存在当前 Bean，如果不存在，则：</p><ol><li>首先向三级缓存中添加一条记录，记录的 key 就是当前 Bean 的 beanName，value 则是一个 Lambda 表达式 ObjectFactory，通过执行这个 Lambda 可以给当前 AService 生成代理对象。</li><li>然后如果二级缓存中存在当前 AService Bean，则移除掉。</li></ol><p>现在继续去给 AService 各个属性赋值，结果发现 AService 需要 BService，然后就去创建 BService，创建 BService 的时候，发现 BService 又需要用到 AService，于是就先去一级缓存中查找是否有 AService，如果有，就使用，如果没有，则去二级缓存中查找是否有 AService，如果有，就使用，如果没有，则去三级缓存中找出来那个 ObjectFactory，然后执行这里的 getObject 方法，这个方法在执行的过程中，会去判断是否需要生成一个代理对象，如果需要就生成代理对象返回，如果不需要生成代理对象，则将原始对象返回即可。最后，把拿到手的对象存入到二级缓存中以备下次使用，同时删除掉三级缓存中对应的数据。这样 AService 所依赖的 BService 就创建好了。</p><p>接下来继续去完善 AService，去执行各种后置的处理器，此时，有的后置处理器想给 AService 生成代理对象，发现 AService 已经是代理对象了，就不用生成了，直接用已有的代理对象去代替 AService 即可。</p><p>至此，AService 和 BService 都搞定。</p><p><strong>本质上，singletonFactories 是把 AOP 的过程提前了。</strong></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>总的来说，Spring 解决循环依赖把握住两个关键点：</p><ul><li><strong>提前暴露</strong>：刚刚创建好的对象还没有进行任何赋值的时候，将之暴露出来放到缓存中，供其他 Bean 提前引用（二级缓存）。</li><li><strong>提前 AOP</strong>：A 依赖 B 的时候，去检查是否发生了循环依赖（检查的方式就是将正在创建的 A 标记出来，然后 B 需要 A，B 去创建 A 的时候，发现 A 正在创建，就说明发生了循环依赖），如果发生了循环依赖，就提前进行 AOP 处理，处理完成后再使用（三级缓存）。</li></ul><blockquote><p>原本 AOP 这个过程是属性赋完值之后，再由各种后置处理器去处理 AOP 的（<code>AbstractAutoProxyCreator</code>），但是如果发生了循环依赖，就先 AOP，然后属性赋值，最后等到后置处理器执行的时候，就不再做 AOP 的处理了。</p></blockquote><p>不过需要注意，三级缓存并不能解决所有的循环依赖，这个松哥后面继续整文章和大家细聊。</p><p>好啦，今天这篇文章需要一定的 Spring 源码基础方能理解哦，后面松哥会再整一篇文章从源码的角度和小伙伴们验证本文的每一个细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;这个其实是一个特别高频的面试题，松哥也一直很想和大家仔细来聊一聊这个话题，网上关于这块的文章很多，但是我一直觉得要把这个问题讲清楚还有点难度，今天我来试一试，看能不能和小伙伴们把这个问题梳理清楚。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>@Autowired 到底是怎么把变量注入进来的？</title>
    <link href="http://www.javaboy.org/2023/0714/spring_autowired.html"/>
    <id>http://www.javaboy.org/2023/0714/spring_autowired.html</id>
    <published>2023-07-14T14:17:55.000Z</published>
    <updated>2023-07-21T14:53:15.436Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>以下内容基于 Spring6.0.4。</p><a id="more"></a><p>在 Spring 容器中，当我们想给某一个属性注入值的时候，有多种不同的方式，例如可以通过构造器注入、可以通过 set 方法注入，也可以使用 @Autowired、@Inject、@Resource 等注解注入。</p><p>今天松哥就来和小伙伴们聊一聊，@Autowired 到底是如何把数据注入进来的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-Bean-的创建"><a href="#1-Bean-的创建" class="headerlink" title="1. Bean 的创建"></a>1. Bean 的创建</h2><p>这个问题我们就得从 Bean 的创建开始了，本文主要是和小伙伴们聊 @Autowired，所以 Bean 的创建我就不从第一步开始了，咱们直接来看关键的方法，那就是 AbstractAutowireCapableBeanFactory#doCreateBean 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//....</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先会创建原始的 Bean 对象，创建出来之后，会调用一个 populateBean 方法，这个方法就是给 Bean 的各个属性赋值的方法，标注了 @Autowired 注解的属性被自动赋值也是在这个方法中完成的。</p><h2 id="2-populateBean"><a href="#2-populateBean" class="headerlink" title="2. populateBean"></a>2. populateBean</h2><p>populateBean 方法内容比较多，我们来看一些关键的地方：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="hljs-comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="hljs-comment">// to support styles of field injection.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"><span class="hljs-keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里松哥贴出来的是部分关键代码。</p><p>首先来看上面有一个 if，这个 if 主要是判断是否需要后置处理器进行处理，如果不需要，那么就直接 return 掉了，默认情况下，这里并不会 return 掉，而是会继续走后面的流程，因为 postProcessAfterInstantiation 方法默认返回 true。</p><p>接下来第二个 if 就是比较关键的一个地方了，在这里会遍历所有相关的后置处理器，尝试通过这些处理器去获取到需要的 value。</p><p>负责处理 @Autowired 注解的后置处理器是 AutowiredAnnotationBeanPostProcessor，所以现在，我们就来到 AutowiredAnnotationBeanPostProcessor#postProcessProperties 方法了。</p><h2 id="3-postProcessProperties"><a href="#3-postProcessProperties" class="headerlink" title="3. postProcessProperties"></a>3. postProcessProperties</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实就两步，第一步 findAutowiringMetadata，第二步 inject，就这两件事。分别来看。</p><h3 id="3-1-findAutowiringMetadata"><a href="#3-1-findAutowiringMetadata" class="headerlink" title="3.1 findAutowiringMetadata"></a>3.1 findAutowiringMetadata</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">findAutowiringMetadata</span><span class="hljs-params">(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line"><span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">InjectionMetadata metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line"><span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">metadata = <span class="hljs-keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line"><span class="hljs-keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">metadata.clear(pvs);</span><br><span class="line">&#125;</span><br><span class="line">metadata = buildAutowiringMetadata(clazz);</span><br><span class="line"><span class="hljs-keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会先尝试从缓存中获取 metadata，如果能够从缓存中获取到，那就直接返回，缓存中没有的话，那么最终会调用到 buildAutowiringMetadata 方法，去重新构建 metadata，并将构建结果存入到缓存中，以备下一次使用。</p><p>那么我们来看下 metadata 到底是如何构建出来的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> InjectionMetadata <span class="hljs-title">buildAutowiringMetadata</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="hljs-keyword">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line"><span class="hljs-keyword">if</span> (ann != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">currElements.add(<span class="hljs-keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line"><span class="hljs-keyword">if</span> (ann != <span class="hljs-keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (method.getParameterCount() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">currElements.add(<span class="hljs-keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">elements.addAll(<span class="hljs-number">0</span>, currElements);</span><br><span class="line">targetClass = targetClass.getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (targetClass != <span class="hljs-keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"><span class="hljs-keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，我来和大家说一下核心逻辑。</p><p>首先会调用 isCandidateClass 方法判断当前类是否为一个候选类，判断的依据就是 autowiredAnnotationTypes 变量的值，这个变量在该类的构造方法中进行了初始化，大家来看下这个构造方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AutowiredAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">ClassUtils.forName(<span class="hljs-string">"jakarta.inject.Inject"</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">logger.trace(<span class="hljs-string">"'jakarta.inject.Inject' annotation found and supported for autowiring"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// jakarta.inject API not available - simply skip.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">ClassUtils.forName(<span class="hljs-string">"javax.inject.Inject"</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">logger.trace(<span class="hljs-string">"'javax.inject.Inject' annotation found and supported for autowiring"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// javax.inject API not available - simply skip.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，autowiredAnnotationTypes 集合中有两个注解是固定的：@Autowired 和 @Value，另外就是如果项目引入了 JSR-330 依赖，则 @Inject 注解也会被加入进来，以前 @Inject 存在于 javax 包中，现在最新版 @Inject 注解存在于 jakarta 包中，这里把两种情况都列出来了。</p><p>所以，isCandidateClass 方法实际上就是判断当前类在类、属性、方法等层面上是否存在上述三个注解，如果存在，则就是候选类，否则就不是候选类。如果不是候选类则返回一个空的 InjectionMetadata 对象，否则就继续后面的流程。</p><p>后面的流程，首先是一个 do{}while() 结构，通过这个循环把当前类以及当前类的父类中的满足条件的注解都找出来。具体的找法就是首先调用 ReflectionUtils.doWithLocalFields 方法，这个方法会遍历当前类的所有属性，找到那些包含了 autowiredAnnotationTypes 中定义的注解的属性，并将之封装为 AutowiredFieldElement 对象，然后存入到集合中，接下来就是调用 ReflectionUtils.doWithLocalMethods，这个是找到当前类中包含了上述三个注解的方法，然后把找到的满足条件的方法封装为 AutowiredMethodElement 然后存入到集合中。</p><p>另外大家需要注意，无论是 AutowiredFieldElement 还是 AutowiredMethodElement，都是 <code>InjectionMetadata.InjectedElement</code> 的子类。</p><p>这就是 findAutowiringMetadata 方法所做的事情，整体上来看，就是查找到添加了 @Autowired 或者 @Value 或者 @Inject 注解的属性或者方法，并将之存入到集合中。</p><h3 id="3-2-inject"><a href="#3-2-inject" class="headerlink" title="3.2 inject"></a>3.2 inject</h3><p>接下来就该调用 metadata.inject 了，我们来看下该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="hljs-keyword">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="hljs-keyword">null</span> ? checkedElements : <span class="hljs-keyword">this</span>.injectedElements);</span><br><span class="line"><span class="hljs-keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">element.inject(target, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是遍历刚刚上一步收集到的 InjectedElement，然后挨个调用其 inject 方法进行属性注入。以本文一开始的 demo 为例，@Autowired 注解加在属性上面，所以我们这里实际上调用的是 AutowiredFieldElement#inject 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Field field = (Field) <span class="hljs-keyword">this</span>.member;</span><br><span class="line">Object value;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cached) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">value = resolvedCachedArgument(beanName, <span class="hljs-keyword">this</span>.cachedFieldValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Unexpected removal of target bean for cached argument -&gt; re-resolve</span></span><br><span class="line">value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">field.set(bean, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先会调用 resolvedCachedArgument 方法尝试从缓存中获取想要的对象，如果缓存中存在，则可以直接使用，如果缓存中没有，则调用 resolveFieldValue 方法去获取。获取到之后，通过反射调用 set 方法进行赋值就可以了。所以关键步骤又来到了 resolveFieldValue 方法中。</p><blockquote><p>用缓存的好处就是，获取到对象存入到缓存之后，如果相同的 Bean 在多个类中注入，那么只有第一次需要去加载，以后就直接用缓存中的数据即可。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">resolveFieldValue</span><span class="hljs-params">(Field field, Object bean, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">Object value;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心其实就是通过 beanFactory.resolveDependency 方法获取到想要的 Bean 对象，我们直接来看这个核心方法，由于 BeanFactory 是一个接口，所以这个方法的实现实际上是在 DefaultListableBeanFactory#resolveDependency：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"><span class="hljs-keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">descriptor, requestingBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里一共是四个分支，处理四种不同的情况，分别是 Optional、ObjectFactory、JSR-330 以及其他情况，很明显，文章开头的案例应该属于第四种情况，我们继续来看 doResolveDependency 方法。</p><h3 id="3-3-doResolveDependency"><a href="#3-3-doResolveDependency" class="headerlink" title="3.3 doResolveDependency"></a>3.3 doResolveDependency</h3><p>这个方法也是比较长，我列出来了一些关键的部分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line"><span class="hljs-keyword">if</span> (multipleBeans != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> multipleBeans;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String autowiredBeanName;</span><br><span class="line">Object instanceCandidate;</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line"><span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line"><span class="hljs-comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// We have exactly one match.</span></span><br><span class="line">Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">autowiredBeanName = entry.getKey();</span><br><span class="line">instanceCandidate = entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">Object result = instanceCandidate;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是调用 resolveMultipleBeans 方法去查找多个 Bean，这是因为我们在注入的时候，可以注入数组、集合和 Map，例如像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService bService;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    BService[] bServices;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    List&lt;BService&gt; bServiceList;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    Map&lt;String, BService&gt; bServiceMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体查找方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">resolveMultipleBeans</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"><span class="hljs-keyword">if</span> (descriptor <span class="hljs-keyword">instanceof</span> StreamDependencyDescriptor streamDependencyDescriptor) &#123;</span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line"><span class="hljs-keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line"><span class="hljs-keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line"><span class="hljs-keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line"><span class="hljs-keyword">return</span> matchingBeans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会首先判断你的数据类型，针对 Stream、数组、集合 以及 Map 分别处理，处理代码都很好懂，以集合为例，首先获取到集合中的泛型，然后调用 findAutowireCandidates 方法根据泛型去查找到 Bean，处理一下返回就行了，其他几种数据类型也都差不多。</p><p>至于 findAutowireCandidates 方法的逻辑，我们就不去细看了，我大概和小伙伴们说一下，就是先根据 Bean 的类型，调用 BeanFactoryUtils.beanNamesForTypeIncludingAncestors 方法去当前容器连同父容器中，查找到所有满足条件的 Bean，处理之后返回。</p><p>接下来回到本小节一开始的源码中，处理完集合之后，接下来也是调用 findAutowireCandidates 方法去查找满足条件的 Bean，但是这个方法查找出来的 Bean 可能有多个，如果存在多个，则要通过 @Primary 注解或者其他优先级顺序，去确定到底使用哪一个（执行 determineAutowireCandidate 方法），如果查找到一个 Bean，那就把找到的 Bean 返回即可。</p><p>这就是 @Autowired 一个完整的解析过程。</p><h2 id="4-时序图"><a href="#4-时序图" class="headerlink" title="4. 时序图"></a>4. 时序图</h2><p>最后，结合如下时序图，我再和小伙伴们梳理一下上面的过程。</p><p><img src="http://img.itboyhub.com/2022/08/20230713220838.png" alt></p><ol><li>在创建 Bean 的时候，原始 Bean 创建出来之后，会调用 populateBean 方法进行 Bean 的属性填充。</li><li>接下来调用 postProcessAfterInstantiation 方法去判断是否需要执行后置处理器，如果不需要，就直接返回了。</li><li>调用 postProcessProperties 方法，去触发各种后置处理器的执行。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230713222337.png" alt></p><ol start="4"><li>在第 3 步的方法中，调用 findAutowiringMetadata，这个方法又会进一步触发 buildAutorwiringMetadata 方法，去找到包含了 @Autowired、@Value 以及 @Inject 注解的属性或者方法，并将之封装为 InjectedElement 返回。</li><li>调用 InjectedElement#inject 方法进行属性注入。</li></ol><p><img src="http://img.itboyhub.com/2022/08/20230713223334.png" alt></p><ol start="6"><li>接下来执行 resolvedCachedArgument 方法尝试从缓存中找到需要的 Bean 对象。</li><li>如果缓存中不存在，则调用 resolveFieldValue 方法去容器中找到 Bean。</li><li>最后调用 makeAccessible 和 set 方法完成属性的赋值。</li></ol><p>整体上的流程就是这样，细节小伙伴们参考第二小节内容。</p><p>今天内容有点多，小伙伴们周末可以细细 DEBUG 验证一遍～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>用 Spring 管理 Controller，你觉得可行吗？</title>
    <link href="http://www.javaboy.org/2023/0713/spring_controller.html"/>
    <id>http://www.javaboy.org/2023/0713/spring_controller.html</id>
    <published>2023-07-13T14:17:43.000Z</published>
    <updated>2023-07-21T14:53:11.159Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p><a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>和小伙伴们聊了 Spring 容器中的父子容器问题，也和小伙伴们梳理了 Spring 容器和 SpringMVC 容器之间的关系，其中，Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器中的 Bean，但是父容器无法访问子容器中的 Bean。</p><a id="more"></a><p>在一个 SSM 项目中，你可以单纯使用 SpringMVC 容器，这个没问题，项目可以正常运行。但是，有的小伙伴可能要问了，如果把所有的 Bean 都扫描到 Spring 容器中行不行？</p><p>先来说结论：可以！但是需要额外配置。</p><p>阅读本文需要先了解 Spring 容器的父子容器哦，如果还不了解的话建议先阅读<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>。</p><p>为什么不能把所有 Bean 都注册到 Spring 容器中呢？按照我们<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>中的分析，所有 Bean 都注册到 Spring 容器之后，Spring 容器作为父容器，SpringMVC 作为子容器，按理说，由于子容器可以访问父容器中的 Bean，所以 SpringMVC 是可以正常访问 Spring 容器中的 Bean 的，所以，似乎把所有的 Bean 都扫描到 Spring 容器应该是没有问题的？</p><p>其实不然！</p><p>问题就出在 SpringMVC 容器查找 Controller 的方式上，SpringMVC 容器查找 Controller，默认情况下，只在当前容器中查找，并不会去父容器中查找，所以如果把 Controller 都扫描到父容器的话，对于 SpringMVC 来说，相当于系统中就没有 Controller 了，所以你一访问，直接就 404 了。</p><p>接下来，我结合源码和小伙伴们分析一下。</p><p>首先，小伙伴们知道，在 SpringMVC 中，当请求到达服务端之后，需要由处理器映射器 HandlerMapping 来确定这个请求应该由哪个处理器来处理，所以，按理说，HandlerMapping 中就会记录所有的处理器信息，也就是 Controller 的信息。一般我们在 SpringMVC 中使用的 HandlerMapping 都是 RequestMappingHandlerMapping，所以这里我们就通过 RequestMappingHandlerMapping 的初始化来看一下，SpringMVC 到底是如何查找 Controller 的。</p><p>在 RequestMappingHandlerMapping#afterPropertiesSet 方法中，调用了父类的 afterPropertiesSet 方法，我们来看下：</p><p>AbstractHandlerMethodMapping#afterPropertiesSet：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">processCandidateBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initHandlerMethods 方法就是初始化处理器的方法，也就是在这个方法中，去尝试找到所有的 Controller，并且把每一个接口方法都封装成 HandlerMethod 对象。</p><p>我们来看下 getCandidateBeanNames 方法，这个方法用来找到所有的候选的 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> String[] getCandidateBeanNames() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就在这了，这里首先去判断 detectHandlerMethodsInAncestorContexts 变量的值，如果这个变量为 true，则调用 BeanFactoryUtils.beanNamesForTypeIncludingAncestors 方法去查询 Bean，这个方法在<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>中松哥和大家分享过，用来查找 Bean 的名称，包括父容器中的 Bean 都会查找到并返回；如果 detectHandlerMethodsInAncestorContexts 变量为 false，则调用 getBeanNamesForType 方法去查找 Bean，getBeanNamesForType 方法我们<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>也讲过，这个方法只找当前容器的 Bean，不会去父容器中查找。</p><p>所以现在问题的关键就在于 detectHandlerMethodsInAncestorContexts 变量了，这个变量默认是 false，<strong>即，默认情况下，只去当前容器（SpringMVC 容器）查找 Bean。</strong></p><p>这里找到的 beanName 是当前容器中所有的 beanName，所以接下来还要去 processCandidateBean 方法走一圈，这个方法会去判断这个 Bean 是否是一个 Controller，如果是就将之收集到一起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCandidateBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="hljs-keyword">null</span>;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHandler</span><span class="hljs-params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有这类上有 <code>@Controller</code> 注解，这个类才会被留下来。</p><p>好啦，剩下的逻辑我们就不看了。</p><p>现在大家已经了解到这样一个情况：</p><p>SpringMVC 容器在初始化 HandlerMapping 的时候，会去查找所有的 Controller 并完成初始化，但是在默认情况下，只会去当前容器中查找，并不会去父容器中查找。</p><p>所以，如果把 Controller 让 Spring 容器扫描并管理，那么就会导致在默认情况下，SpringMVC 容器找不到 Controller，进而导致所有的请求 404。</p><p>在前面的讲解中，松哥都强调了<strong>默认情况</strong>，意思就是说这个事情还有转圜的余地，看了前面源码的小伙伴应该也发现了，只要我们把 detectHandlerMethodsInAncestorContexts 变量改为 true，那么 HandlerMapping 就会去父容器中查找 Bean，这样即使被 Spring 容器扫描并管理的 Bean，也就能够查找到了。</p><p>修改方式如下：</p><p>spring-servlet.xml：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"detectHandlerMethodsInAncestorContexts"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Spring 容器中直接扫描所有 Bean：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"org.javaboy.web"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>web.xml 中加载这两个配置文件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置之后，就可以把所有 Bean 都扫描到 Spring 容器中了。</p><p>好啦，今天这篇文章<strong>目的不是为了让小伙伴们去在 Spring 容器中管理 Controller，只是想借这样一个契机，一起来捋一捋 SpringMVC 中 HanderMapping 的原理。</strong></p><p>如果感觉本文阅读有点吃力，可以先看看<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">上篇文章</a>哦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;和小伙伴们聊了 Spring 容器中的父子容器问题，也和小伙伴们梳理了 Spring 容器和 SpringMVC 容器之间的关系，其中，Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器中的 Bean，但是父容器无法访问子容器中的 Bean。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中的父子容器是咋回事？</title>
    <link href="http://www.javaboy.org/2023/0712/parent_child_container.html"/>
    <id>http://www.javaboy.org/2023/0712/parent_child_container.html</id>
    <published>2023-07-12T14:17:34.000Z</published>
    <updated>2023-07-21T14:53:07.922Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>以下内容基于 Spring6.0.4。</p><p>相信有小伙伴也听说过，在 SSM 项目中，Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean。</p><a id="more"></a><p>更近一步，有小伙伴可能也了解过，不用父子容器，单纯就用一个 SpringMVC 容器似乎也可以，项目也能运行。</p><p>那么现在问题来了：既然单纯一个 SpringMVC 容器就能使项目跑起来，那我们为什么还要用父子容器？父子容器的优势是什么？</p><p>带着这个问题，今天松哥来和小伙伴们聊一聊父子容器。</p><h2 id="1-父子容器"><a href="#1-父子容器" class="headerlink" title="1. 父子容器"></a>1. 父子容器</h2><p>首先，其实父子这种设计很常见，松哥记得在之前的 Spring Security 的系列文章中，Spring Security 中的 AuthenticationManager 其实也是类似的设计，估计那里就是借鉴了 Spring 中的父子容器设计。</p><p>当使用了父子容器之后，如果去父容器中查找 Bean，那么就单纯的在父容器中查找 Bean；如果是去子容器中查找 Bean，那么就会先在子容器中查找，找到了就返回，没找到则继续去父容器中查找，直到找到为止（把父容器都找完了还是没有的话，那就只能抛异常出来了）。</p><h2 id="2-为什么需要父子容器"><a href="#2-为什么需要父子容器" class="headerlink" title="2. 为什么需要父子容器"></a>2. 为什么需要父子容器</h2><h3 id="2-1-问题呈现"><a href="#2-1-问题呈现" class="headerlink" title="2.1 问题呈现"></a>2.1 问题呈现</h3><p>为什么需要父子容器？老老实实使用一个容器不行吗？</p><p>既然 Spring 容器中有父子容器，那么这个玩意就必然有其使用场景。</p><p>松哥举一个简单的例子。</p><p>假设我有一个多模块项目，其中有商家模块和客户模块，商家模块和客户模块中都有角色管理 RoleService，项目结构如下图：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">├── admin</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── resources</span><br><span class="line">├── consumer</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   │   └── org</span><br><span class="line">│       │   │       └── javaboy</span><br><span class="line">│       │   │           └── consumer</span><br><span class="line">│       │   │               └── RoleService.java</span><br><span class="line">│       │   └── resources</span><br><span class="line">│       │       └── consumer_beans.xml</span><br><span class="line">├── merchant</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   │   └── org</span><br><span class="line">│       │   │       └── javaboy</span><br><span class="line">│       │   │           └── merchant</span><br><span class="line">│       │   │               └── RoleService.java</span><br><span class="line">│       │   └── resources</span><br><span class="line">│       │       └── merchant_beans.xml</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure><p>现在 consumer 和 merchant 中都有一个 RoleService 类，然后在各自的配置文件中，都将该类注册到 Spring 容器中。</p><p>org.javaboy.consumer.RoleService：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello consumer"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.javaboy.merchant.RoleService：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello merchant"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer_beans.xml 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.consumer.RoleService"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"roleService"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>merchant_beans.xml 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.merchant.RoleService"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"roleService"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大家注意，这两个 Bean 同名。</p><p>现在，在 admin 模块中，同时依赖 consumer 和 merchant，同时加载这两个配置文件，那么能不能同时向 Spring 容器中注册两个来自不同模块的同名 Bean 呢？</p><p>代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">ctx.setConfigLocations(<span class="hljs-string">"consumer_beans.xml"</span>, <span class="hljs-string">"merchant_beans.xml"</span>);</span><br><span class="line">ctx.refresh();</span><br><span class="line">org.javaboy.merchant.RoleService rs1 = ctx.getBean(org.javaboy.merchant.RoleService.class);</span><br><span class="line">org.javaboy.consumer.RoleService rs2 = ctx.getBean(org.javaboy.consumer.RoleService.class);</span><br></pre></td></tr></table></figure><p>这个执行之后会抛出如下问题：</p><p><img src="http://img.itboyhub.com/2022/08/20230710214416.png" alt></p><p>小伙伴们看到，这个是找不到 <code>org.javaboy.consumer.RoleService</code> 服务，但是另外一个 RoleService 其实是找到了，因为默认情况下后面定义的同名 Bean 把前面的覆盖了，所以有一个 Bean 就找不到了。</p><p>如果不允许 Bean 的覆盖，那么可以进行如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">ctx.setConfigLocations(<span class="hljs-string">"consumer_beans.xml"</span>, <span class="hljs-string">"merchant_beans.xml"</span>);</span><br><span class="line">ctx.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">false</span>);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure><p>此时一启动就直接报错了：</p><p><img src="http://img.itboyhub.com/2022/08/20230710214655.png" alt></p><p>意思也说的比较明确了，Bean 的定义冲突了，所以定义失败。</p><p>那么有没有办法能够优雅的解决上面这个问题呢？答案就是父子容器！</p><h3 id="2-2-父子容器"><a href="#2-2-父子容器" class="headerlink" title="2.2 父子容器"></a>2.2 父子容器</h3><p>对于上面的问题，我们可以将 consumer 和 merchant 配置成父子关系或者兄弟关系，就能很好的解决这个问题了。</p><h4 id="2-2-1-兄弟关系"><a href="#2-2-1-兄弟关系" class="headerlink" title="2.2.1 兄弟关系"></a>2.2.1 兄弟关系</h4><p>先来看兄弟关系，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">ClassPathXmlApplicationContext child1 = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"consumer_beans.xml"</span>);</span><br><span class="line">ClassPathXmlApplicationContext child2 = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"merchant_beans.xml"</span>);</span><br><span class="line">child1.setParent(ctx);</span><br><span class="line">child2.setParent(ctx);</span><br><span class="line">ctx.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">false</span>);</span><br><span class="line">ctx.refresh();</span><br><span class="line">org.javaboy.consumer.RoleService rs1 = child1.getBean(org.javaboy.consumer.RoleService.class);</span><br><span class="line">org.javaboy.merchant.RoleService rs2 = child2.getBean(org.javaboy.merchant.RoleService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"rs1.hello() = "</span> + rs1.hello());</span><br><span class="line">System.out.println(<span class="hljs-string">"rs2.hello() = "</span> + rs2.hello());</span><br></pre></td></tr></table></figure><p>小伙伴们看一下，这种针对 consumer 和 merchant 分别创建了容器，这种容器关系就是兄弟容器，这两个兄弟有一个共同的 parent 就是 ctx，现在可以在各个容器中获取到自己的 Bean 了。</p><p>需要注意的是，上面这种结构中，子容器可以获取到 parent 的 Bean，但是无法获取到兄弟容器的 Bean，即如果 consumer 中引用了 merchant 中的 Bean，那么上面这个配置就有问题了。</p><h4 id="2-2-2-父子关系"><a href="#2-2-2-父子关系" class="headerlink" title="2.2.2 父子关系"></a>2.2.2 父子关系</h4><p>现在假设用 consumer 做 parent 容器，merchant 做 child 容器，那么配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext parent = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"consumer_beans.xml"</span>);</span><br><span class="line">ClassPathXmlApplicationContext child = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"merchant_beans.xml"</span>);</span><br><span class="line">child.setParent(parent);</span><br><span class="line">child.refresh();</span><br><span class="line">org.javaboy.consumer.RoleService rs1 = parent.getBean(org.javaboy.consumer.RoleService.class);</span><br><span class="line">org.javaboy.merchant.RoleService rs2 = child.getBean(org.javaboy.merchant.RoleService.class);</span><br><span class="line">org.javaboy.consumer.RoleService rs3 = child.getBean(org.javaboy.consumer.RoleService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"rs1.hello() = "</span> + rs1.hello());</span><br><span class="line">System.out.println(<span class="hljs-string">"rs2.hello() = "</span> + rs2.hello());</span><br><span class="line">System.out.println(<span class="hljs-string">"rs3.hello() = "</span> + rs3.hello());</span><br></pre></td></tr></table></figure><p>首先创建两个容器，分别是 parent 和 child，然后为 child 容器设置 parent，设置完成后记得要刷新 child 容器。</p><p>现在我们就可以从 parent 容器中去获取 parent 容器中原本就存在的 Bean，也可以从 child 容器中去获取 child 容器原本的 Bean 或者是 parent 的 Bean 都可以。</p><p>这就是父子容器。</p><p><strong>父容器和子容器本质上是相互隔离的两个不同的容器，所以允许同名的 Bean 存在。当子容器调用 getBean 方法去获取一个 Bean 的时候，如果当前容器没找到，就会去父容器查找，一直往上找，找到为止。</strong></p><p>核心就是 BeanFactory，这个松哥之前文章已经和小伙伴们介绍过了（<a href="https://mp.weixin.qq.com/s/ZjN1XPamDaYZmvFbyI1KTQ" target="_blank" rel="noopener">BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</a>），BeanFactory 有一个子类 HierarchicalBeanFactory，看名字就是带有层级关系的 BeanFactory：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Return the parent bean factory, or &#123;<span class="hljs-doctag">@code</span> null&#125; if there is none.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">BeanFactory <span class="hljs-title">getParentBeanFactory</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Return whether the local bean factory contains a bean of the given name,</span></span><br><span class="line"><span class="hljs-comment"> * ignoring beans defined in ancestor contexts.</span></span><br><span class="line"><span class="hljs-comment"> * &lt;p&gt;This is an alternative to &#123;<span class="hljs-doctag">@code</span> containsBean&#125;, ignoring a bean</span></span><br><span class="line"><span class="hljs-comment"> * of the given name from an ancestor bean factory.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> whether a bean with the given name is defined in the local factory</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> BeanFactory#containsBean</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsLocalBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是 HierarchicalBeanFactory 的子类就能配置父子关系。父子关系图如下：</p><p><img src="http://img.itboyhub.com/2022/08/parent_child_container.png" alt></p><h3 id="2-3-特殊情况"><a href="#2-3-特殊情况" class="headerlink" title="2.3 特殊情况"></a>2.3 特殊情况</h3><p>需要注意的是，并不是所有的获取 Bean 的方法都支持父子关系查找，有的方法只能在当前容器中查找，并不会去父容器中查找：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext parent = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"consumer_beans.xml"</span>);</span><br><span class="line">ClassPathXmlApplicationContext child = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"merchant_beans.xml"</span>);</span><br><span class="line">child.setParent(parent);</span><br><span class="line">child.refresh();</span><br><span class="line">String[] names1 = child.getBeanNamesForType(org.javaboy.merchant.RoleService.class);</span><br><span class="line">String[] names2 = child.getBeanNamesForType(org.javaboy.consumer.RoleService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"names1 = "</span> + Arrays.toString(names1));</span><br><span class="line">System.out.println(<span class="hljs-string">"names2 = "</span> + Arrays.toString(names2));</span><br></pre></td></tr></table></figure><p>如上，根据类型去查找 Bean 名称的时候，我们所用的是 getBeanNamesForType 方法，这个方法是由 ListableBeanFactory 接口提供的，而该接口和 HierarchicalBeanFactory 接口并无继承关系，所以 getBeanNamesForType 方法并不支持去父容器中查找 Bean，它只在当前容器中查找 Bean。</p><p>但是！如果你确实有需求，希望能够根据类型查找 Bean 名称，并且还能够自动去父容器中查找，那么可以使用 Spring 给我们提供的工具类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext parent = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"consumer_beans.xml"</span>);</span><br><span class="line">ClassPathXmlApplicationContext child = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">child.setParent(parent);</span><br><span class="line">child.refresh();</span><br><span class="line">String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(child, org.javaboy.consumer.RoleService.class);</span><br><span class="line"><span class="hljs-keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个查找，对于父子容器中同名的 Bean 是查找不出来名字的。</p><h3 id="2-4-Spring-和-SpringMVC"><a href="#2-4-Spring-和-SpringMVC" class="headerlink" title="2.4 Spring 和 SpringMVC"></a>2.4 Spring 和 SpringMVC</h3><p>上面的内容理解了，Spring 和 SpringMVC 之间的关系就好理解了，Spring 是父容器，SpringMVC 则是子容器。</p><p>在 SpringMVC 中，初始化 DispatcherServlet 的时候，会创建出 SpringMVC 容器，并且为 SpringMVC 容器设置 parent，相关代码如下：</p><p>FrameworkServlet#initWebApplicationContext：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">initWebApplicationContext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="hljs-keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext cwac &amp;&amp; !cwac.isActive()) &#123;</span><br><span class="line"><span class="hljs-comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="hljs-comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="hljs-comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="hljs-comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="hljs-comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="hljs-comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 rootContext 就是父容器，wac 就是子容器，无论哪种方式得到的子容器，都会尝试给其设置一个父容器。</p><p>如果我们在一个 Web 项目中，不单独配置 Spring 容器，直接配置 SpringMVC 容器，然后将所有的 Bean 全部都扫描到 SpringMVC 容器中，这样做是没有问题的，项目是可以正常运行的。但是一般项目中我们还是会把这两个容器分开，分开有如下几个好处：</p><ol><li>方便管理，SpringMVC 主要处理控制层相关的 Bean，如 Controller、视图解析器、参数处理器等等，而 Spring 层则主要控制业务层相关的 Bean，如 Service、Mapper、数据源、事务、权限等等相关的 Bean。</li><li>对于新手而言，两个容器分开配置，可以更好的理解 Controller、Service 以及 Dao 层的关系，也可以避免写出来在 Service 层注入 Controller 这种荒唐代码。</li></ol><p>另外再额外说一句，有的小伙伴可能会问，如果全部 Bean 都扫描到 Spring 容器中不用 SpringMVC 容器行不行？这其实也可以！但是需要一些额外的配置，这个松哥下篇文章再来和小伙伴们细述。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，Spring 容器中的父子容器现在大家应该明白了吧？可以给非 ListableBeanFactory 容器设置父容器，父容器不可以访问子容器的 Bean，但是子容器可以访问父容器的 Bean。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;相信有小伙伴也听说过，在 SSM 项目中，Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>Spring5 中更优雅的第三方 Bean 注入</title>
    <link href="http://www.javaboy.org/2023/0711/bean_injected.html"/>
    <id>http://www.javaboy.org/2023/0711/bean_injected.html</id>
    <published>2023-07-11T14:17:23.000Z</published>
    <updated>2023-07-21T14:53:04.331Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>小伙伴们知道，当我们使用 Spring 容器的时候，如果遇到一些特殊的 Bean，一般来说可以通过如下三种方式进行配置：</p><a id="more"></a><ul><li>静态工厂方法</li><li>实例工厂方法</li><li>FactoryBean</li></ul><p>不过从 Spring5 开始，在 AbstractBeandefinition 类中多了一个属性，对于特殊的 Bean 我们有了更多的选择：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Specify a callback for creating an instance of the bean,</span></span><br><span class="line"><span class="hljs-comment"> * as an alternative to a declaratively specified factory method.</span></span><br><span class="line"><span class="hljs-comment"> * &lt;p&gt;If such a callback is set, it will override any other constructor</span></span><br><span class="line"><span class="hljs-comment"> * or factory method metadata. However, bean property population and</span></span><br><span class="line"><span class="hljs-comment"> * potential annotation-driven injection will still apply as usual.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 5.0</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setConstructorArgumentValues(ConstructorArgumentValues)</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setPropertyValues(MutablePropertyValues)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInstanceSupplier</span><span class="hljs-params">(@Nullable Supplier&lt;?&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.instanceSupplier = instanceSupplier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Return a callback for creating an instance of the bean, if any.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 5.0</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">public</span> Supplier&lt;?&gt; getInstanceSupplier() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.instanceSupplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来松哥就来和大家简单聊一聊这个话题。</p><h2 id="1-传统解决方案"><a href="#1-传统解决方案" class="headerlink" title="1. 传统解决方案"></a>1. 传统解决方案</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><p>不知道各位小伙伴们有没有用过 OkHttp，这是一个专门做网络请求的工具，在微服务的 HTTP 调用组件中，我们可以配置底层使用 OkHttp 这个工具。</p><p>一般来说，如果我们想直接使用 OkHttp，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br><span class="line">Request getReq = <span class="hljs-keyword">new</span> Request.Builder().get().url(<span class="hljs-string">"http://www.javaboy.org"</span>).build();</span><br><span class="line">Call call = client.newCall(getReq);</span><br><span class="line">call.enqueue(<span class="hljs-keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(@NotNull Call call, @NotNull IOException e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"e.getMessage() = "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(@NotNull Call call, @NotNull Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"response.body().string() = "</span> + response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先通过建造者模式创建出来一个 OkHttpClient 对象，然后还是建造者模式创建出来 Request 对象，接下来去发送请求就可以了。那么对于这样的代码，我们可以将 OkHttpClient 对象交由 Spring 容器统一管理，那么该如何将 OkHttpClient 注册到 Spring 容器中呢？</p><h3 id="1-2-静态工厂方法"><a href="#1-2-静态工厂方法" class="headerlink" title="1.2 静态工厂方法"></a>1.2 静态工厂方法</h3><p>首先可以采用静态工厂方法，也就是工厂方法是一个静态方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpStaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OkHttpClient okHttpClient;</span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OkHttpClient <span class="hljs-title">getOkHttpClient</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> okHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Spring 配置文件中进行注入：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.OkHttpStaticFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getOkHttpClient"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"httpClient"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>静态工厂的特点是静态方法可以直接调用，并不必要获取到工厂类的实例，所以上面配置的时候只需要指定 <code>factory-method</code> 就可以了。</p><p>这就可以了，将来我们去 Spring 容器中查找一个名为 httpClient 的对象，拿到手的就是 OkHttpClient 了。</p><h3 id="1-3-实例工厂方法"><a href="#1-3-实例工厂方法" class="headerlink" title="1.3 实例工厂方法"></a>1.3 实例工厂方法</h3><p>实例工厂方法意思就是说工厂方法是一个实例方法。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpInstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> OkHttpClient <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (okHttpClient == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (OkHttpInstanceFactory.class) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (okHttpClient == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                            .connectTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                            .readTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> okHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的单例模式。但是这里的工厂方法是一个实例方法，实例方法的调用必须得先获取到对象然后才能调用实例方法，因此配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.OkHttpInstanceFactory"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"httpInstanceFactory"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"httpInstanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getInstance"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"httpClient"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>好啦，接下来我们就可以去 Spring 容器中获取一个名为 httpClient 的对象了，拿到手的就是 OkHttpClient 实例。</p><h3 id="1-4-FactoryBean"><a href="#1-4-FactoryBean" class="headerlink" title="1.4 FactoryBean"></a>1.4 FactoryBean</h3><p>当然，也可以通过 FactoryBean 来解决上述问题，FactoryBean 松哥在之前的文章中刚刚和大家介绍过，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClientFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">OkHttpClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> OkHttpClient <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> OkHttpClient.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 Spring 中配置即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.OkHttpClientFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"httpClient"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个就不做过多解释了，不熟悉的小伙伴可以翻看前面的文章。</p><p>上面这三种方案都是传统方案。</p><p>特别是前两种，其实我们用的比较少，前两种有一个缺陷，就是我们配置的的 factory-method 都是通过反射来调用的，通过反射调用的话，多多少少性能受点影响。</p><p>这种 factory-method 在 Spring 中处理的源码执行时序图如下：</p><p><img src="http://img.itboyhub.com/2022/08/factory_method_sequence.png" alt></p><p>所以最终反射是在 <code>SimpleInstantiationStrategy#instantiate</code> 方法中执行的，就是大家非常熟悉的反射代码了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Object factoryBean, <span class="hljs-keyword">final</span> Method factoryMethod, Object... args)</span> </span>&#123;</span><br><span class="line">ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result = <span class="hljs-keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (priorInvokedFactoryMethod != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这是传统的解决方案。</p><h2 id="2-Spring5-解决方案"><a href="#2-Spring5-解决方案" class="headerlink" title="2. Spring5 解决方案"></a>2. Spring5 解决方案</h2><p>Spring5 中开始提供了 Supplier，可以通过接口回调获取到一个 Bean 的实例，这种方式显然性能更好一些。</p><p>如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">GenericBeanDefinition definition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">definition.setBeanClass(Book.class);</span><br><span class="line">definition.setInstanceSupplier((Supplier&lt;Book&gt;) () -&gt; &#123;</span><br><span class="line">    Book book = <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    book.setName(<span class="hljs-string">"深入浅出 Spring Security"</span>);</span><br><span class="line">    book.setAuthor(<span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> book;</span><br><span class="line">&#125;);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"b1"</span>, definition);</span><br><span class="line">ctx.refresh();</span><br><span class="line">Book b = ctx.getBean(<span class="hljs-string">"b1"</span>, Book.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br></pre></td></tr></table></figure><p>关键就是通过调用 BeanDefinition 的 setInstanceSupplier 方法去设置回调。当然，上面这段代码还可以通过 Lambda 进一步简化：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSupplier</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBook</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Book book = <span class="hljs-keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="hljs-string">"深入浅出 Spring Security"</span>);</span><br><span class="line">        book.setAuthor(<span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用这个方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">GenericBeanDefinition definition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">definition.setBeanClass(Book.class);</span><br><span class="line">BookSupplier bookSupplier = <span class="hljs-keyword">new</span> BookSupplier();</span><br><span class="line">definition.setInstanceSupplier(bookSupplier::getBook);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"b1"</span>, definition);</span><br><span class="line">ctx.refresh();</span><br><span class="line">Book b = ctx.getBean(<span class="hljs-string">"b1"</span>, Book.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br></pre></td></tr></table></figure><p>这是不是更有一点 Lambda 的感觉了～</p><p>在 Spring 源码中，处理获取 Bean 实例的时候，有如下一个分支，就是处理 Supplier 这种情况的：</p><p>AbstractAutowireCapableBeanFactory#createBeanInstance</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">obtainInstanceFromSupplier</span><span class="hljs-params">(Supplier&lt;?&gt; supplier, String beanName)</span> </span>&#123;</span><br><span class="line">String outerBean = <span class="hljs-keyword">this</span>.currentlyCreatedBean.get();</span><br><span class="line"><span class="hljs-keyword">this</span>.currentlyCreatedBean.set(beanName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (supplier <span class="hljs-keyword">instanceof</span> InstanceSupplier&lt;?&gt; instanceSupplier) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instanceSupplier.get(RegisteredBean.of((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>, beanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (supplier <span class="hljs-keyword">instanceof</span> ThrowingSupplier&lt;?&gt; throwableSupplier) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> throwableSupplier.getWithException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 obtainFromSupplier 这个方法，最终会调用到第二个方法。第二个方法中的 <code>supplier.get();</code> 其实最终就调用到我们自己写的 getBook 方法了。</p><p>好啦，这是从 Spring5 开始结合 Lamdba 的一种 Bean 注入方式，感兴趣的小伙伴可以试试哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;小伙伴们知道，当我们使用 Spring 容器的时候，如果遇到一些特殊的 Bean，一般来说可以通过如下三种方式进行配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>每一个开发者都了不起</title>
    <link href="http://www.javaboy.org/2023/0710/2023hdc.html"/>
    <id>http://www.javaboy.org/2023/0710/2023hdc.html</id>
    <published>2023-07-10T14:17:12.000Z</published>
    <updated>2023-07-21T14:55:19.535Z</updated>
    
    <content type="html"><![CDATA[<p>记得松哥刚开始学习 Java 的时候，抱着 Java 圣经《Java 编程思想》啃，书的前言里边有一句话令我印象深刻：<strong>一切皆对象</strong>。</p><a id="more"></a><p>十年之后，华为喊出了一个类似的口号：<strong>一切皆服务</strong>。基础设施即服务，让业务全球可达；技术即服务，让创新触手可及；经验即服务，让优秀得以复制。</p><p>在刚刚过去的三天里，华为在东莞开了三天的开发者大会，发布了盘古大模型 3.0，也开了一系列的圆桌会议和专题会议，松哥也有幸被邀请与会，接下来小伙伴们就跟随松哥的脚步一起来体验一把华为东莞松山湖欧洲小镇之旅吧～</p><p>之前因为三年疫情的影响，华为很多活动要么规模缩水要么由线下改为线上，这次算是疫情结束后第一次办开发者大会，会场又来到了东莞松山湖，这个地方真的不错，像是成人的童话世界，来几张图片小伙伴们感受下：</p><p><img src="http://img.itboyhub.com/2022/08/20230709174947.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230709172515.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230709172952.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230709174731.png" alt></p><p>这个是园区小火车，连通园区不同区域：</p><!--火车视频--><p>有小伙伴戏称这里都可以当成景点卖门票了～可不是吗！如果是专门的参观团体，华为会配有专门的“导游”带你逛松山湖欧洲小镇的。</p><p>这次开发者大会的话题之王算是盘古大模型 3.0 了。</p><p>我记得 2021 年在深圳大学城当时开的华为开发者大会，当时余承东就在会上发布了盘古大模型，下面这张图是当时 2021 年开发者大会拍的：</p><p><img src="http://img.itboyhub.com/2022/08/20230709121735.png" alt></p><p>今年由于 ChatGPT 的爆火，引燃了国内 AI 这个行业，所以，这次发布的盘古大模型 3.0 引发的讨论感觉远远超出当年第一次发布盘古大模型的时候，松哥在朋友圈看到有好多小伙伴在转发相关的文章或者视频，有的小伙伴可能会误以为华为今年刚开始做盘古大模型，其实不是的，这次发布的是盘古大模型 3.0，1.0 版本几年前就发布了。</p><blockquote><p>不得不说，取名字这块华为还是牛，国内目前几个叫得出名字的如百度的文心一言，阿里的通义千问，科大讯飞的讯飞星火，感觉还是盘古大模型这个名字听起来就牛X哄哄的。</p></blockquote><p>要说华为盘古大模型和别家的大模型有什么区别的话，我觉得发布会上有一句话特别能代表盘古大模型的特点：<strong>不会写诗，只会做事</strong>。</p><p><img src="http://img.itboyhub.com/2022/08/20230709123639.png" alt></p><p>说到大模型大家很容易想到的是 ChatGPT 这种对话式 AI，每个人可以注册账号然后就可以使用了，这种可以回答我们很多问题，甚至可以写诗，然而华为的盘古大模型要做的则是重塑千行百业，为各个传统行业如金融、政务、制造、矿山、气象、铁路等赋能，促进传统行业的数字化，盘古大模型要做的是 ToB 而不是 ToC。</p><p>利用华为盘古大模型去预测天气预报，这种预测精度甚至超过了号称全球最强的欧洲气象中心的 IFS 系统，传统上都是通过数值去预测天气，AI 预测天气一直不怎准，现在华为用 AI 预测天气算是取得了突破，华为相关的研究成果还发表在 Nature 上，据说这是近年来中国科技公司首篇作为唯一署名单位发表的《Nature》正刊论文。另一方面还有盘古大模型在医药行业的应用，将药物的研发周期从数年缩短至几个月，研发成本降低 70% 。</p><p>通过上面两个案例小伙伴们可以看到，其实官方给出来的这些应用案例都是 ToB 的，这样华为长期积累的企业客户在 AI 时代还能继续合作发光发热。</p><p>所以华为盘古大模型并不能像有的小伙伴所想的那样：“ChatGPT 的克星来啦，以后就用盘古大模型代替 ChatGPT！”至少目前来说，还做不到这一点。甚至你说去官网申请个账号体验一下盘古大模型，抱歉，目前不行，现在主要是对接企业客户，不对接个人。</p><p>在第二天的圆桌会议中，有一个小伙伴在讨论时提到了能不能给开发者提供账号体验一把盘古大模型，因为有的开发者从 2021 年发布盘古大模型追到现在盘古大模型 3.0，一直没机会真正体验一把，然而官方给的答复是下来会考虑，但是目前还做不到，目前对接企业客户都是专人对接的，现在还不支持普通开发者网页上点一下配置一下就能在 console 中使用这种情况。</p><p><img src="http://img.itboyhub.com/2022/08/20230709165455.png" alt="猜一猜哪个是松哥？"></p><p>在圆桌会议中，华为软件工程首席科学家（就是中间那个加拿大老外）有一句话令我印象深刻，他说计算器的出现并没有导致数学家失业，反而促进了他们的工作，所以 AI 会成为我们工作的帮手，而不是抢我们饭碗（大概是这个意思）。</p><p><img src="http://img.itboyhub.com/2022/08/20230709175233.png" alt></p><p>后续的很多活动基本上都是围绕着华为 AI 和企业的业务实践来展开的，有很多中小企业与会，介绍他们在华为云上的实践以及面临的一些问题。</p><p>在结束了严肃烧脑的圆桌会议和训练营之后，第二天晚上有一个嘉年华活动：</p><p><img src="http://img.itboyhub.com/2022/08/20230709180403.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230709180423.png" alt></p><p>随手录了一个小视频，小伙伴们将就看一下吧：</p><!--嘉年华视频--><p>这是嘉年华现场发的荧光棒：</p><p><img src="http://img.itboyhub.com/2022/08/20230709180754.png" alt></p><p>老实说，荧光棒上几个字在那一瞬间确实有点触动我了。大学刚毕业的时候意气风发，相信程序员用代码改变世界，然而八年过去了，当初的激情早已不在，敲代码越来越像是一个糊口的手艺，人也越来越像一个老油条，但是看到荧光棒上几个字，大学毕业时候的初心似乎又被唤起，看到现场很多充满激情的年轻人，我感觉我又行了。</p><p>往后的日子里，希望还是能够永葆初心，才能让生活多一些念想多一些期盼，月亮与六便士都要，和各位共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得松哥刚开始学习 Java 的时候，抱着 Java 圣经《Java 编程思想》啃，书的前言里边有一句话令我印象深刻：&lt;strong&gt;一切皆对象&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="HDC" scheme="http://www.javaboy.org/categories/HDC/"/>
    
    
      <category term="华为" scheme="http://www.javaboy.org/tags/%E5%8D%8E%E4%B8%BA/"/>
    
      <category term="HDC" scheme="http://www.javaboy.org/tags/HDC/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中 BeanFactory 和 FactoryBean 有何区别？</title>
    <link href="http://www.javaboy.org/2023/0706/beanfactory_factorybean.html"/>
    <id>http://www.javaboy.org/2023/0706/beanfactory_factorybean.html</id>
    <published>2023-07-06T14:17:01.000Z</published>
    <updated>2023-07-21T14:53:01.215Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>这也是 Spring 面试时一道经典的面试问题，今天我们来聊一聊这个话题。</p><a id="more"></a><p>其实从名字上就能看出来个一二，BeanFactory 是 Factory 而 FactoryBean 是一个 Bean，我们先来看下总结：</p><ul><li>BeanFactory 是 Spring 框架的核心接口之一，用于管理和获取应用程序中的 Bean 实例。它是一个工厂模式的实现，负责创建、配置和管理 Bean 对象。BeanFactory 是 Spring IoC 容器的基础，它可以从配置元数据（如 XML 文件）中读取 Bean 的定义，并在需要时实例化和提供这些 Bean。</li><li>FactoryBean 是一个特殊的 Bean，它是一个工厂对象，用于创建和管理其他 Bean 的实例。FactoryBean 接口定义了一种创建 Bean 的方式，它允许开发人员在 Bean 的创建过程中进行更多的自定义操作。通过实现 FactoryBean 接口，开发人员可以创建复杂的 Bean 实例，或者在 Bean 实例化之前进行一些额外的逻辑处理。</li></ul><p>区别在于，BeanFactory 是 Spring 框架的核心接口，用于管理和提供 Bean 实例，而 FactoryBean 是一个特殊的 Bean，用于创建和管理其他 Bean 的实例。FactoryBean 在 Bean 的创建过程中提供更多的自定义能力，允许进行额外的逻辑处理。</p><p>可能有的小伙伴看的还不是很清楚，我们再来详细看下。</p><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h2><p>BeanFactory 看名字就知道这是一个 Bean 工厂，小伙伴们知道，Spring IoC 容器帮我们完成了 Bean 的创建、管理等操作，那么这些操作都离不开 BeanFactory。</p><p>我们来简单看下 BeanFactory 的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法基本上都见名知义：</p><ul><li>FACTORY_BEAN_PREFIX：这个变量其实是说，如果当前 Bean 不是像 User、Book 这种普通 Bean，而是一个 FactoryBean，就给这个 Bean 名字加一个 <code>&amp;</code> 前缀，这个我在第二小节和小伙伴们演示。</li><li>getBean：这个方法就是根据 Bean 的名字、类型等去查询 Bean。</li><li>getBeanProvider：这个方法可以获取一个 ObjectProvider，ObjectProvider 是 Spring 框架中的一个接口，用于获取 Bean 对象的实例。它提供了一种延迟加载 Bean 的方式，可以在需要时动态地获取 Bean 实例（懒加载）。</li><li>containsBean：判断是否包含某个 Bean。</li><li>isSingleton：判断某个 Bean 是否是单例的。</li><li>isPrototype：判断某个 Bean 是否是多例的。</li><li>isTypeMatch：判断某一个 Bean 的类型是否是给定类型。</li><li>getType：获取 Bean 的类型。</li><li>getAliases：获取 Bean 的别名。</li></ul><p>可以看到，很多都是大家日常开发中常见常用的方法。</p><p>很多小伙伴刚开始接触 Spring 的时候，都会用到一个对象 <code>ClassPathXmlApplicationContext</code>，这其实就是 BeanFactory 的一个子类。我们来看下 BeanFactory 的继承图：</p><p><img src="http://img.itboyhub.com/2022/08/BeanFactory_arch.png" alt></p><p>继承类比较多，我说几个大家可能比较熟悉的：</p><ol><li>ClassPathXmlApplicationContext：这个是 Spring 容器启动时，从当前类路径下去加载 XML 配置文件，参数就是 classpath 下 XML 的文件路径。</li><li>FileSystemXmlApplicationContext：这个是 Spring 容器启动时，从文件系统中去加载 XML 配置文件，参数一个绝对路径。</li><li>AnnotationConfigApplicationContext：这个是如果我们使用 Java 代码去做 Spring 容器的配置的话，通过这个配置类去加载 Java 配置类。</li><li>DefaultListableBeanFactory：这个默认实现了 ListableBeanFactory 和 BeanDefinitionRegistry 接口，是一个比较成熟的 BeanFactory。</li></ol><p>好啦，这就是 BeanFactory 的特点，大家明白了吧～</p><h2 id="2-FactoryBean"><a href="#2-FactoryBean" class="headerlink" title="2. FactoryBean"></a>2. FactoryBean</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h3><p>FactoryBean 其实很多小伙伴可能都见过，只是可能没去总结归纳。我给小伙伴们举几个例子。</p><p>在 SSM 项目中，如果我们要配置 MyBatis 到项目中，一般需要配置下面这个 Bean：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"typeAliasesPackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.javaboy.shirodemo.model"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapperLocations"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath*:org/javaboy/shirodemo/mapper/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在配置 Shiro 的时候，一般都要配置如下 Bean：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/index"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/unauthorizedUrl"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /index=anon</span><br><span class="line">            /doLogin=anon</span><br><span class="line">            /hello=user</span><br><span class="line">            /**=authc</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们前端传递的参数是 key-value 格式，并且有一个日期，那么小伙伴们知道，服务端 SpringMVC 默认无法处理这个日期，需要配置一个日期转换器，一般我们在 Spring 容器中添加如下 Bean（对这个不熟悉的小伙伴可以在公众号【江南一点雨】后台回复 ssm，有松哥录制的免费入门视频）：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"conversionService"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"myDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>小伙伴们观察上面三个 Bean 有一个共同的特点，<strong>那就是 Bean 的名字都是 xxxFactoryBean。</strong></p><p>为什么要用 xxxFactoryBean 而不直接把需要的 Bean 注入到 Spring 容器中去呢？以 MyBatis 为例：</p><p>手动配置过 MyBatis 的小伙伴应该都知道，MyBatis 有两个重要的类，一个是 SqlSessionFactory，还有一个是 SqlSession，通过 SqlSessionFactory 可以获取到一个 SqlSession。但是不知道小伙伴们是否还记得配置代码，手动配置代码如下（对这个不熟悉的小伙伴可以在公众号【江南一点雨】后台回复 ssm，有松哥录制的免费入门视频）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionFactoryUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory SQLSESSIONFACTORY = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSessionFactory <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (SQLSESSIONFACTORY == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                SQLSESSIONFACTORY = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(<span class="hljs-string">"mybatis-config.xml"</span>));</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> SQLSESSIONFACTORY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory factory = SqlSessionFactoryUtils.getInstance();</span><br><span class="line">        SqlSession sqlSession = factory.openSession();</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="hljs-string">"org.javaboy.mybatis01.mapper.UserMapper.getAllUser"</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，无论是 SqlSessionFactory 还是 SqlSession，都不是正经 new 出来的，其实这两个都是接口，显然不可能 new 出来，前者通过建造者模式去配置各种属性，最后生成一个 SqlSessionFactory 的实例，后者则通过前者这个工厂去生成，最终拿到的都是这两个接口的子类的对象。</p><p>所以，对于 SqlSessionFactory 和 SqlSession 就没法在 Spring 容器中直接进行配置，那么对于这样的 Bean，就可以通过 xxxFactoryBean 来进行配置。</p><p>我们来看下 SqlSessionFactoryBean 类，源码很长，我挑了重要的出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">SqlSessionFactory</span>&gt;, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sqlSessionFactory == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-keyword">public</span> Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory == <span class="hljs-keyword">null</span> ? SqlSessionFactory.class : <span class="hljs-keyword">this</span>.sqlSessionFactory.getClass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看一下，SqlSessionFactoryBean 需要实现 FactoryBean 接口，并且在实现接口的时候指定泛型是 SqlSessionFactory，也就是 SqlSessionFactoryBean 最终产出的 Bean 是 SqlSessionFactory。实现了 FactoryBean 接口之后，就需要实现接口中的三个方法：</p><ul><li>getObject：这个方法返回的对象，就是真正要注册到 Spring 容器中的对象，在这个方法中，我们就可以按照各种方式对 Bean 进行各种配置了。</li><li>getObjectType：这个方法返回注册到 Spring 容器中的对象类型。</li><li>isSingleton：这个方法用来返回注册到 Spring 容器中的 Bean 是否是单例的。</li></ul><p>这就是 FactoryBean 的特点，由于某一个 Bean 的初始化过于复杂，那么就可以通过 FactoryBean 来帮助注册到 Spring 容器中去。</p><h3 id="2-2-实践"><a href="#2-2-实践" class="headerlink" title="2.2 实践"></a>2.2 实践</h3><p>松哥再写一个简单的例子给小伙伴们体验一把 FactoryBean。</p><p>假设我有如下类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Author</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Author <span class="hljs-title">init</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        Author author = <span class="hljs-keyword">new</span> Author();</span><br><span class="line">        author.setAge(age);</span><br><span class="line">        author.setName(name);</span><br><span class="line">        <span class="hljs-keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter/toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的特点就是构造方法是私有的，你没法从外面去 new，现在我想将这个类的对象注册到 Spring 容器中，那么我可以提供一个 AuthorFactoryBean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Author</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Author <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Author.init(<span class="hljs-string">"javaboy"</span>, <span class="hljs-number">99</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Author.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Spring 容器中配置 AuthorFactoryBean 即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.AuthorFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"author"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以从容器中去获取 Author 对象了，但是要注意，通过 author 这个名字拿到的是 Author 对象，而不是 AuthorFactoryBean 对象，如果想要获取到 AuthorFactoryBean 对象，那么要通过 <code>&amp;author</code> 这个名字去获取（回顾第一小节所讲内容）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);</span><br><span class="line">        Object author = ctx.getBean(<span class="hljs-string">"author"</span>);</span><br><span class="line">        Object authorFactoryBean = ctx.getBean(<span class="hljs-string">"&amp;author"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"author.getClass() = "</span> + author.getClass());</span><br><span class="line">        System.out.println(<span class="hljs-string">"authorFactoryBean.getClass() = "</span> + authorFactoryBean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下最终运行结果：</p><p><img src="http://img.itboyhub.com/2022/08/20230705121329.png" alt></p><p>跟我们所想的一致吧～</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>经过前面的介绍，相信小伙伴们已经能够区分 BeanFactory 和 FactoryBean 了，再来回顾一下本文开头的内容：</p><ul><li>BeanFactory 是 Spring 框架的核心接口之一，用于管理和获取应用程序中的 Bean 实例。它是一个工厂模式的实现，负责创建、配置和管理 Bean 对象。BeanFactory 是 Spring IoC 容器的基础，它可以从配置元数据（如 XML 文件）中读取 Bean 的定义，并在需要时实例化和提供这些 Bean。</li><li>FactoryBean 是一个特殊的 Bean，它是一个工厂对象，用于创建和管理其他 Bean 的实例。FactoryBean 接口定义了一种创建 Bean 的方式，它允许开发人员在 Bean 的创建过程中进行更多的自定义操作。通过实现 FactoryBean 接口，开发人员可以创建复杂的 Bean 实例，或者在 Bean 实例化之前进行一些额外的逻辑处理。</li></ul><p>区别在于，BeanFactory 是 Spring 框架的核心接口，用于管理和提供 Bean 实例，而 FactoryBean 是一个特殊的 Bean，用于创建和管理其他 Bean 的实例。FactoryBean 在 Bean 的创建过程中提供更多的自定义能力，允许进行额外的逻辑处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;这也是 Spring 面试时一道经典的面试问题，今天我们来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</title>
    <link href="http://www.javaboy.org/2023/0705/beanfactorypostprocessor_beanpostprocessor.html"/>
    <id>http://www.javaboy.org/2023/0705/beanfactorypostprocessor_beanpostprocessor.html</id>
    <published>2023-07-05T14:16:50.000Z</published>
    <updated>2023-07-21T14:52:57.693Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>松哥最近身体抱恙，去医院检查倒无大碍。小伙伴们也要注意身体，健康饮食，多运动呀～</p><a id="more"></a><hr><p>研究 Spring 源码的小伙伴可能会发现，Spring 源码中有很多名称特别相近的 Bean，我就不挨个举例了，今天我是想和小伙伴们聊一聊 Spring 中 BeanFactoryPostProcessor 和 BeanPostProcessor 两个处理器的区别。</p><p>我将从以下几个方面来和小伙伴们分享。</p><h2 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h2><p>这两个接口说白了都是 Spring 在初始化 Bean 时对外暴露的扩展点，因为 Spring 框架提供的功能不一定能够满足我们所有的需求，有的时候我们需要对其进行扩展，那么这两个接口就是用来做扩展功能的。</p><p>其实不用看源码，单纯从字面上看，大家应该也能理解个差不多：</p><ol><li>BeanFactoryPostProcessor 是针对 BeanFactory 的处理器。</li><li>BeanPostProcessor 则是针对 Bean 的处理器。</li></ol><p>我们先来看下 BeanFactoryPostProcessor 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的参数实际上就是一个 BeanFactory，在这个地方，我们可以对 BeanFactory 进行修改，重新进行定制。例如可以修改一个 Bean 的作用域，可以修改属性值等。</p><p>再来看看 BeanPostProcessor 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里是两个方法，这两个方法都有一个 bean 对象，说明这里被触发的时候，Spring 已经将 Bean 初始化了，然后才会触发这里的两个方法，我们可以在这里对已经到手的 Bean 进行额外的处理。其中：</p><ul><li>postProcessBeforeInitialization：这个方法在 <code>InitializingBean#afterPropertiesSet</code> 和 <code>init-method</code> 方法之前被触发。</li><li>postProcessAfterInitialization：这个方法在 <code>InitializingBean#afterPropertiesSet</code> 和 <code>init-method</code> 方法之后被触发。</li></ul><p>总结一下：</p><p>在 Spring 中，BeanFactoryPostProcessor 和 BeanPostProcessor 是两个不同的接口，它们在 Bean 的生命周期中扮演不同的角色。</p><ul><li>BeanFactoryPostProcessor 接口用于在 Bean 工厂实例化 Bean 之前对 Bean 的定义进行修改。它可以读取和修改 Bean 的定义元数据，例如修改 Bean 的属性值、添加额外的配置信息等。BeanFactoryPostProcessor 在 Bean 实例化之前执行，用于对 Bean 的定义进行预处理。</li><li>BeanPostProcessor 接口用于在 Bean 实例化后对 Bean 进行增强或修改。它可以在 Bean 的初始化过程中对 Bean 进行后处理，例如对 Bean 进行代理、添加额外的功能等。BeanPostProcessor 在 Bean 实例化完成后执行，用于对 Bean 实例进行后处理。</li></ul><p>一言以蔽之，BeanFactoryPostProcessor 主要用于修改 Bean 的定义，而 BeanPostProcessor 主要用于增强或修改 Bean 的实例。</p><h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2. 代码实践"></a>2. 代码实践</h2><h3 id="2-1-BeanFactoryPostProcessor"><a href="#2-1-BeanFactoryPostProcessor" class="headerlink" title="2.1 BeanFactoryPostProcessor"></a>2.1 BeanFactoryPostProcessor</h3><p>BeanFactoryPostProcessor 在 Spring 容器中有一个非常典型的应用。</p><p>当我们在 Spring 容器中配置数据源的时候，一般都是按照下面这样的方式进行配置的。</p><p>首先创建 db.properties，将数据源各种信息写入进去：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.username=root</span><br><span class="line">db.password=123</span><br><span class="line">db.url=jdbc:mysql:///db01?serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>然后在 Spring 的配置文件中，首先把这个配置文件加载进来，然后就可以在 Spring Bean 中去使用对应的值了，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是大家知道，对于 DruidDataSource 来说，毫无疑问，它要的是具体的 username、password 以及 url，而上面的配置很明显中间还有一个转换的过程，即把 <code>${db.username}</code>、<code>${db.password}</code> 以及 <code>${db.url}</code> 转为具体对应的值。那么这个转换是怎么实现的呢？</p><p>这就得分析 <code>&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</code> 配置了，小伙伴们知道，这个配置实际上是一个简化的配置，点击去可以看到真正配置的 Bean 是 <code>PropertySourcesPlaceholderConfigurer</code>，而 <code>PropertySourcesPlaceholderConfigurer</code> 恰好就是 <code>BeanFactoryPostProcessor</code> 的子类，我们来看下这里是如何重写 postProcessBeanFactory 方法的：</p><p>源码比较长，松哥这里把一些关键部分列出来和小伙伴们展示：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertySources == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">//这里主要是如果没有加载到 properties 文件，就会尝试从环境中加载</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//这个就是具体的属性转换的方法了</span></span><br><span class="line">processProperties(beanFactory, <span class="hljs-keyword">new</span> PropertySourcesPropertyResolver(<span class="hljs-keyword">this</span>.propertySources));</span><br><span class="line"><span class="hljs-keyword">this</span>.appliedPropertySources = <span class="hljs-keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 这个属性转换方法中，对配置文件又做了一些预处理，最后调用 doProcessProperties 方法处理属性</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ConfigurablePropertyResolver propertyResolver)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">propertyResolver.setPlaceholderPrefix(<span class="hljs-keyword">this</span>.placeholderPrefix);</span><br><span class="line">propertyResolver.setPlaceholderSuffix(<span class="hljs-keyword">this</span>.placeholderSuffix);</span><br><span class="line">propertyResolver.setValueSeparator(<span class="hljs-keyword">this</span>.valueSeparator);</span><br><span class="line">StringValueResolver valueResolver = strVal -&gt; &#123;</span><br><span class="line">String resolved = (<span class="hljs-keyword">this</span>.ignoreUnresolvablePlaceholders ?</span><br><span class="line">propertyResolver.resolvePlaceholders(strVal) :</span><br><span class="line">propertyResolver.resolveRequiredPlaceholders(strVal));</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.trimValues) &#123;</span><br><span class="line">resolved = resolved.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (resolved.equals(<span class="hljs-keyword">this</span>.nullValue) ? <span class="hljs-keyword">null</span> : resolved);</span><br><span class="line">&#125;;</span><br><span class="line">doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doProcessProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">StringValueResolver valueResolver)</span> </span>&#123;</span><br><span class="line">BeanDefinitionVisitor visitor = <span class="hljs-keyword">new</span> BeanDefinitionVisitor(valueResolver);</span><br><span class="line">String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String curName : beanNames) &#123;</span><br><span class="line"><span class="hljs-comment">// Check that we're not parsing our own bean definition,</span></span><br><span class="line"><span class="hljs-comment">// to avoid failing on unresolvable placeholders in properties file locations.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(curName.equals(<span class="hljs-keyword">this</span>.beanName) &amp;&amp; beanFactoryToProcess.equals(<span class="hljs-keyword">this</span>.beanFactory))) &#123;</span><br><span class="line">BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">visitor.visitBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.</span></span><br><span class="line">beanFactoryToProcess.resolveAliases(valueResolver);</span><br><span class="line"><span class="hljs-comment">// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.</span></span><br><span class="line">beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第三个 doProcessProperties 方法我要稍微和小伙伴们说两句：</p><p>使用 PropertySourcesPlaceholderConfigurer 对配置中的占位符进行处理，虽然我们只是在 DruidDataSource 中用到了相关变量，但是系统在处理的时候，除了当前这个配置类之外，其他的 Bean 都要处理（因为你可以在任意 Bean 中注入那三个变量）。</p><p>这就是 BeanFactoryPostProcessor 一个经典实践，即在 Bean 初始化之前，把 Bean 定义时候的一些占位符给改过来。</p><h3 id="2-2-照猫画虎"><a href="#2-2-照猫画虎" class="headerlink" title="2.2 照猫画虎"></a>2.2 照猫画虎</h3><p>上面的源码看完了，如果小伙伴们还觉得不过瘾，我们自己也来写一个试试。</p><p>我自己的需求是这样，假设我配置 Bean 的时候，按照下面这种方式来配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.User"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"^username"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>^username</code> 是我自定义的一个特殊的占位符，这个占位符表示 javaboy，我希望最终从 Spring 容器中拿到的 User Bean 的 username 属性值是 javaboy。</p><p>为了实现这个需求，我可以自定义一个 BeanFactoryPostProcessor，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPropBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanDefinitionName);</span><br><span class="line">            BeanDefinitionVisitor beanDefinitionVisitor = <span class="hljs-keyword">new</span> BeanDefinitionVisitor(strVal -&gt; &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-string">"^username"</span>.equals(strVal)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-string">"javaboy666"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> strVal;</span><br><span class="line">            &#125;);</span><br><span class="line">            beanDefinitionVisitor.visitBeanDefinition(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Bean 基本上是照着前面 2.1 小节的 Bean 来写的。我跟大家来大致说一下我的逻辑：</p><ol><li>首先获取到所有的 Bean 定义对象，然后进行遍历。</li><li>遍历的时候创建一个 BeanDefinitionVisitor 对象，这个对象需要一个字符解析器，也就是 lambda 表达式那一段，我这里就是说，如果传进来的字符串是 <code>^username</code>，那么我就返回 javaboy，如果传进来其他值，那我原封不动，不做修改。</li><li>最后调用 visitBeanDefinition 方法去重新设置一下 Bean 的定义。</li></ol><p>上面这几行代码基本上就是照着 2.1 小节敲的，最后，我们把 MyPropBeanFactoryPostProcessor 注册到 Spring 容器中就行了：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.User"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"^username"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.MyPropBeanFactoryPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>看下执行效果：</p><p><img src="http://img.itboyhub.com/2022/08/20230704212427.png" alt></p><h3 id="2-3-BeanPostProcessor"><a href="#2-3-BeanPostProcessor" class="headerlink" title="2.3 BeanPostProcessor"></a>2.3 BeanPostProcessor</h3><p>BeanPostProcessor 主要是对一个已经初始化的 Bean 做一些额外的配置，这个接口中包含两个方法，执行时间如下图：</p><p><img src="http://img.itboyhub.com/2022/08/bean_post_processor_f.png" alt></p><p>我写一个简单例子我们来验证下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"UserService&gt;Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"UserService&gt;init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"UserService&gt;afterPropertiesSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再开发一个 BeanPostProcessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"postProcessBeforeInitialization:beanName"</span>+beanName+<span class="hljs-string">";beanClass:"</span>+bean.getClass());</span><br><span class="line">        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"postProcessAfterInitialization:beanName"</span>+beanName+<span class="hljs-string">";beanClass:"</span>+bean.getClass());</span><br><span class="line">        <span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将这两个 Bean 都注册到 Spring 容器中：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.MyBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.UserService"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"us"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后启动容器，来看下控制台打印的内容：</p><p><img src="http://img.itboyhub.com/2022/08/20230704214040.png" alt></p><p>可以看到，跟我们所预想的是一样的。在 MyBeanPostProcessor 中，第一个参数其实就是已经初始化的 Bean 了，如果想在这里针对 Bean 做任何修改都是可以的。</p><h3 id="2-4-典型应用"><a href="#2-4-典型应用" class="headerlink" title="2.4 典型应用"></a>2.4 典型应用</h3><p>BeanPostProcessor 其实有很多经典的应用，我在写文章的时候，想到一个地方，就是我们在 SpringMVC 中做数据验证的时候，往往只需要加几个注解就可以了（对此不熟悉的小伙伴可以在公众号后台回复 ssm 有松哥录制的 ssm 入门视频），那么这个注解是在哪里进行的校验的呢？就是 BeanPostProcessor，我们来看一眼源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanValidationPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> afterInitialization = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAfterInitialization</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> afterInitialization)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.afterInitialization = afterInitialization;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.validator == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.afterInitialization) &#123;</span><br><span class="line">doValidate(bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.afterInitialization) &#123;</span><br><span class="line">doValidate(bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Perform validation of the given bean.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> bean the bean instance to validate</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> jakarta.validation.Validator#validate</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doValidate</span><span class="hljs-params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实很好懂，可以看到，我们可以控制是在具体是在 postProcessBeforeInitialization 还是 postProcessAfterInitialization 方法中进行数据校验。</p><p>好了，现在小伙伴们应该搞懂 BeanFactoryPostProcessor 和 BeanPostProcessor 的区别了吧？</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>我再把前文的小结内容拿过来，小伙伴们现在看是不是更清晰了？</p><p>在 Spring 中，BeanFactoryPostProcessor 和 BeanPostProcessor 是两个不同的接口，它们在 Bean 的生命周期中扮演不同的角色。</p><ul><li>BeanFactoryPostProcessor 接口用于在 Bean 工厂实例化 Bean 之前对 Bean 的定义进行修改。它可以读取和修改 Bean 的定义元数据，例如修改 Bean 的属性值、添加额外的配置信息等。BeanFactoryPostProcessor 在 Bean 实例化之前执行，用于对 Bean 的定义进行预处理。</li><li>BeanPostProcessor 接口用于在 Bean 实例化后对 Bean 进行增强或修改。它可以在 Bean 的初始化过程中对 Bean 进行后处理，例如对 Bean 进行代理、添加额外的功能等。BeanPostProcessor 在 Bean 实例化完成后执行，用于对 Bean 实例进行后处理。</li></ul><p>一言以蔽之，BeanFactoryPostProcessor 主要用于修改 Bean 的定义，而 BeanPostProcessor 主要用于增强或修改 Bean 的实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;松哥最近身体抱恙，去医院检查倒无大碍。小伙伴们也要注意身体，健康饮食，多运动呀～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring6" scheme="http://www.javaboy.org/categories/Spring6/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Spring6" scheme="http://www.javaboy.org/tags/Spring6/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security6 全新写法，大变样！</title>
    <link href="http://www.javaboy.org/2023/0614/spring_security_6.html"/>
    <id>http://www.javaboy.org/2023/0614/spring_security_6.html</id>
    <published>2023-06-14T14:16:38.000Z</published>
    <updated>2023-07-21T14:53:45.519Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Spring Security 在最近几个版本中配置的写法都有一些变化，很多常见的方法都废弃了，并且将在未来的 Spring Security7 中移除，因此松哥在去年旧文的基础之上，又补充了一些新的内容，重新发一下，供各位使用 Spring Security 的小伙伴们参考。</p><a id="more"></a><p>接下来，我把从 Spring Security5.7 开始（对应 Spring Boot2.7 开始），各种已知的变化都来和小伙伴们梳理一下。</p><h2 id="1-WebSecurityConfigurerAdapter"><a href="#1-WebSecurityConfigurerAdapter" class="headerlink" title="1. WebSecurityConfigurerAdapter"></a>1. WebSecurityConfigurerAdapter</h2><p><img src="http://img.itboyhub.com/2021/10/tran/20220605122037.png" alt></p><p>首先第一点，就是各位小伙伴最容易发现的 WebSecurityConfigurerAdapter 过期了，在目前最新的 Spring Security6.1 中，这个类已经完全被移除了，想凑合着用都不行了。</p><p>准确来说，Spring Security 是在 5.7.0-M2 这个版本中将 WebSecurityConfigurerAdapter 过期的，过期的原因是因为官方想要鼓励各位开发者使用基于组件的安全配置。</p><p>那么什么是基于组件的安全配置呢？我们来举几个例子：</p><p>以前我们配置 SecurityFilterChain 的方式是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests((authz) -&gt; authz</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .httpBasic(withDefaults());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么以后就要改为下面这样了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests((authz) -&gt; authz</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .httpBasic(withDefaults());</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果懂之前的写法的话，下面这个代码其实是很好理解的，我就不做过多解释了，不过还不懂 Spring Security 基本用法的小伙伴，可以在公众号后台回复 ss，有松哥写的教程。</p><p>以前我们配置 WebSecurity 是这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/ignore1"</span>, <span class="hljs-string">"/ignore2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后就得改成下面这样了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> WebSecurityCustomizer <span class="hljs-title">webSecurityCustomizer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (web) -&gt; web.ignoring().antMatchers(<span class="hljs-string">"/ignore1"</span>, <span class="hljs-string">"/ignore2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一个就是关于 AuthenticationManager  的获取，以前可以通过重写父类的方法来获取这个 Bean，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后就只能自己创建这个 Bean 了，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider daoAuthenticationProvider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        daoAuthenticationProvider.setUserDetailsService(userService);</span><br><span class="line">        ProviderManager pm = <span class="hljs-keyword">new</span> ProviderManager(daoAuthenticationProvider);</span><br><span class="line">        <span class="hljs-keyword">return</span> pm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以从 HttpSecurity 中提取出来 AuthenticationManager，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AuthenticationManagerBuilder authenticationManagerBuilder = http.getSharedObject(AuthenticationManagerBuilder.class);</span><br><span class="line">        authenticationManagerBuilder.userDetailsService(userDetailsService);</span><br><span class="line">        authenticationManager = authenticationManagerBuilder.build();</span><br><span class="line"></span><br><span class="line">        http.csrf().disable().cors().disable().authorizeHttpRequests().antMatchers(<span class="hljs-string">"/api/v1/account/register"</span>, <span class="hljs-string">"/api/v1/account/auth"</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .authenticationManager(authenticationManager)</span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是一种办法。</p><p>我们来看一个具体的例子。</p><p>首先我们新建一个 Spring Boot 工程，引入 Web 和 Spring Security 依赖，注意 Spring Boot 选择最新版。</p><p>接下来我们提供一个简单的测试接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello 江南一点雨!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们知道，在 Spring Security 中，默认情况下，只要添加了依赖，我们项目的所有接口就已经被统统保护起来了，现在启动项目，访问 <code>/hello</code> 接口，就需要登录之后才可以访问，登录的用户名是 user，密码则是随机生成的，在项目的启动日志中。</p><p>现在我们的第一个需求是使用自定义的用户，而不是系统默认提供的，这个简单，我们只需要向 Spring 容器中注册一个 UserDetailsService 的实例即可，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager users = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以了。</p><p>当然我现在的用户是存在内存中的，如果你的用户是存在数据库中，那么只需要提供 UserDetailsService 接口的实现类并注入 Spring 容器即可，这个之前在 vhr 视频中讲过多次了（公号后台回复 666 有视频介绍），这里就不再赘述了。</p><p>但是假如说我希望 <code>/hello</code> 这个接口能够匿名访问，并且我希望这个匿名访问还不经过 Spring Security 过滤器链，要是在以前，我们可以重写 <code>configure(WebSecurity)</code> 方法进行配置，但是现在，得换一种玩法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager users = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">WebSecurityCustomizer <span class="hljs-title">webSecurityCustomizer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebSecurityCustomizer() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">                web.ignoring().antMatchers(<span class="hljs-string">"/hello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前位于 <code>configure(WebSecurity)</code> 方法中的内容，现在位于 WebSecurityCustomizer Bean 中，该配置的东西写在这里就可以了。</p><p>那如果我还希望对登录页面，参数等，进行定制呢？继续往下看：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager users = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Filter&gt; filters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSecurityFilterChain(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/**"</span>), filters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 的底层实际上就是一堆过滤器，所以我们之前在 configure(HttpSecurity) 方法中的配置，实际上就是配置过滤器链。现在过滤器链的配置，我们通过提供一个 SecurityFilterChain Bean 来配置过滤器链，SecurityFilterChain 是一个接口，这个接口只有一个实现类 DefaultSecurityFilterChain，构建 DefaultSecurityFilterChain 的第一个参数是拦截规则，也就是哪些路径需要拦截，第二个参数则是过滤器链，这里我给了一个空集合，也就是我们的 Spring Security 会拦截下所有的请求，然后在一个空集合中走一圈就结束了，相当于不拦截任何请求。</p><p>此时重启项目，你会发现 <code>/hello</code> 也是可以直接访问的，就是因为这个路径不经过任何过滤器。</p><p>其实我觉得目前这中新写法比以前老的写法更直观，更容易让大家理解到 Spring Security 底层的过滤器链工作机制。</p><p>有小伙伴会说，这写法跟我以前写的也不一样呀！这么配置，我也不知道 Spring Security 中有哪些过滤器，其实，换一个写法，我们就可以将这个配置成以前那种样子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager users = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        users.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写，就跟以前的写法其实没啥大的差别了。</p><h2 id="2-使用-Lambda"><a href="#2-使用-Lambda" class="headerlink" title="2. 使用 Lambda"></a>2. 使用 Lambda</h2><p>在最新版中，小伙伴们发现，很多常见的方法废弃了，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230610144348.png" alt></p><p>包括大家熟悉的用来连接各个配置项的 and() 方法现在也废弃了，并且按照官方的说法，将在 Spring Security7 中彻底移除该方法。</p><p><img src="http://img.itboyhub.com/2022/08/20230610144404.png" alt></p><p>也就是说，你以后见不到类似下面这样的配置了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InMemoryUserDetailsManager users = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">    users.createUser(User.withUsername(<span class="hljs-string">"javagirl"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .userDetailsService(users);</span><br><span class="line">    http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and() 方法将被移除！</p><blockquote><p>其实，松哥觉得移除 and 方法是个好事，对于很多初学者来说，光是理解 and 这个方法就要好久。</p></blockquote><p>从上面 and 方法的注释中小伙伴们可以看到，官方现在是在推动基于 Lambda 的配置来代替传统的链式配置，所以以后我们的写法就得改成下面这样啦：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; auth.requestMatchers(<span class="hljs-string">"/hello"</span>).hasAuthority(<span class="hljs-string">"user"</span>).anyRequest().authenticated())</span><br><span class="line">                .formLogin(form -&gt; form.loginProcessingUrl(<span class="hljs-string">"/login"</span>).usernameParameter(<span class="hljs-string">"name"</span>).passwordParameter(<span class="hljs-string">"passwd"</span>))</span><br><span class="line">                .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">                .sessionManagement(session -&gt; session.maximumSessions(<span class="hljs-number">1</span>).maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>));</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这里的几个方法倒不是啥新方法，只不过有的小伙伴可能之前不太习惯用上面这几个方法进行配置，习惯于链式配置。可是往后，就得慢慢习惯上面这种按照 Lambda 的方式来配置了，配置的内容倒很好理解，我觉得没啥好解释的。</p><h2 id="3-自定义-JSON-登录"><a href="#3-自定义-JSON-登录" class="headerlink" title="3. 自定义 JSON 登录"></a>3. 自定义 JSON 登录</h2><p>自定义 JSON 登录也和之前旧版不太一样了。</p><h3 id="3-1-自定义-JSON-登录"><a href="#3-1-自定义-JSON-登录" class="headerlink" title="3.1 自定义 JSON 登录"></a>3.1 自定义 JSON 登录</h3><p>小伙伴们知道，Spring Security 中默认的登录接口数据格式是 key-value 的形式，如果我们想使用 JSON 格式来登录，那么就必须自定义过滤器或者自定义登录接口，下面松哥先来和小伙伴们展示一下这两种不同的登录形式。</p><h4 id="3-1-1-自定义登录过滤器"><a href="#3-1-1-自定义登录过滤器" class="headerlink" title="3.1.1 自定义登录过滤器"></a>3.1.1 自定义登录过滤器</h4><p>Spring Security 默认处理登录数据的过滤器是 UsernamePasswordAuthenticationFilter，在这个过滤器中，系统会通过 <code>request.getParameter(this.passwordParameter)</code> 的方式将用户名和密码读取出来，很明显这就要求前端传递参数的形式是 key-value。</p><p>如果想要使用 JSON 格式的参数登录，那么就需要从这个地方做文章了，我们自定义的过滤器如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//获取请求头，据此判断请求参数类型</span></span><br><span class="line">        String contentType = request.getContentType();</span><br><span class="line">        <span class="hljs-keyword">if</span> (MediaType.APPLICATION_JSON_VALUE.equalsIgnoreCase(contentType) || MediaType.APPLICATION_JSON_UTF8_VALUE.equalsIgnoreCase(contentType)) &#123;</span><br><span class="line">            <span class="hljs-comment">//说明请求参数是 JSON</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">            &#125;</span><br><span class="line">            String username = <span class="hljs-keyword">null</span>;</span><br><span class="line">            String password = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//解析请求体中的 JSON 参数</span></span><br><span class="line">                User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), User.class);</span><br><span class="line">                username = user.getUsername();</span><br><span class="line">                username = (username != <span class="hljs-keyword">null</span>) ? username.trim() : <span class="hljs-string">""</span>;</span><br><span class="line">                password = user.getPassword();</span><br><span class="line">                password = (password != <span class="hljs-keyword">null</span>) ? password : <span class="hljs-string">""</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//构建登录令牌</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username,</span><br><span class="line">                    password);</span><br><span class="line">            <span class="hljs-comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">            setDetails(request, authRequest);</span><br><span class="line">            <span class="hljs-comment">//执行真正的登录操作</span></span><br><span class="line">            Authentication auth = <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            <span class="hljs-keyword">return</span> auth;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过松哥之前的 Spring Security 系列文章的小伙伴，这段代码应该都是非常熟悉了。</p><ol><li>首先我们获取请求头，根据请求头的类型来判断请求参数的格式。</li><li>如果是 JSON 格式的参数，就在 if 中进行处理，否则说明是 key-value 形式的参数，那么我们就调用父类的方法进行处理即可。</li><li>JSON 格式的参数的处理逻辑和 key-value 的处理逻辑是一致的，唯一不同的是参数的提取方式不同而已。</li></ol><p>最后，我们还需要对这个过滤器进行配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JsonLoginFilter <span class="hljs-title">jsonLoginFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JsonLoginFilter filter = <span class="hljs-keyword">new</span> JsonLoginFilter();</span><br><span class="line">        filter.setAuthenticationSuccessHandler((req,resp,auth)-&gt;&#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            <span class="hljs-comment">//获取当前登录成功的用户对象</span></span><br><span class="line">            User user = (User) auth.getPrincipal();</span><br><span class="line">            user.setPassword(<span class="hljs-keyword">null</span>);</span><br><span class="line">            RespBean respBean = RespBean.ok(<span class="hljs-string">"登录成功"</span>, user);</span><br><span class="line">            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        &#125;);</span><br><span class="line">        filter.setAuthenticationFailureHandler((req,resp,e)-&gt;&#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            RespBean respBean = RespBean.error(<span class="hljs-string">"登录失败"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"用户名或者密码输入错误，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户被禁用，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"密码过期，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户过期，登录失败"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">                respBean.setMessage(<span class="hljs-string">"账户被锁定，登录失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">        &#125;);</span><br><span class="line">        filter.setAuthenticationManager(authenticationManager());</span><br><span class="line">        filter.setFilterProcessesUrl(<span class="hljs-string">"/login"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider daoAuthenticationProvider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        daoAuthenticationProvider.setUserDetailsService(userService);</span><br><span class="line">        ProviderManager pm = <span class="hljs-keyword">new</span> ProviderManager(daoAuthenticationProvider);</span><br><span class="line">        <span class="hljs-keyword">return</span> pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//开启过滤器的配置</span></span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                <span class="hljs-comment">//任意请求，都要认证之后才能访问</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="hljs-comment">//开启表单登录，开启之后，就会自动配置登录页面、登录接口等信息</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                <span class="hljs-comment">//和登录相关的 URL 地址都放行</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="hljs-comment">//关闭 csrf 保护机制，本质上就是从 Spring Security 过滤器链中移除了 CsrfFilter</span></span><br><span class="line">                .csrf().disable();</span><br><span class="line">        http.addFilterBefore(jsonLoginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是配置一个 JsonLoginFilter 的 Bean，并将之添加到 Spring Security 过滤器链中即可。</p><p>在 Spring Boot3 之前（Spring Security6 之前），上面这段代码就可以实现 JSON 登录了。</p><p>但是从 Spring Boot3 开始，这段代码有点瑕疵了，直接用已经无法实现 JSON 登录了，具体原因松哥下文分析。</p><h4 id="3-1-2-自定义登录接口"><a href="#3-1-2-自定义登录接口" class="headerlink" title="3.1.2 自定义登录接口"></a>3.1.2 自定义登录接口</h4><p>另外一种自定义 JSON 登录的方式是直接自定义登录接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLogin</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken unauthenticated = UsernamePasswordAuthenticationToken.unauthenticated(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(unauthenticated);</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticate);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"error:"</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接自定义登录接口，请求参数通过 JSON 的形式来传递。拿到用户名密码之后，调用 AuthenticationManager#authenticate 方法进行认证即可。认证成功之后，将认证后的用户信息存入到 SecurityContextHolder 中。</p><p>最后再配一下登录接口就行了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        provider.setUserDetailsService(userService);</span><br><span class="line">        ProviderManager pm = <span class="hljs-keyword">new</span> ProviderManager(provider);</span><br><span class="line">        <span class="hljs-keyword">return</span> pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                <span class="hljs-comment">//表示 /doLogin 这个地址可以不用登录直接访问</span></span><br><span class="line">                .requestMatchers(<span class="hljs-string">"/doLogin"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated().and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也算是一种使用 JSON 格式参数的方案。在 Spring Boot3 之前（Spring Security6 之前），上面这个方案也是没有任何问题的。</p><p>从 Spring Boot3（Spring Security6） 开始，上面这两种方案都出现了一些瑕疵。</p><p>具体表现就是：<strong>当你调用登录接口登录成功之后，再去访问系统中的其他页面，又会跳转回登录页面，说明访问登录之外的其他接口时，系统不知道你已经登录过了。</strong></p><h3 id="3-2-原因分析"><a href="#3-2-原因分析" class="headerlink" title="3.2 原因分析"></a>3.2 原因分析</h3><p>产生上面问题的原因，主要在于 Spring Security 过滤器链中有一个过滤器发生变化了：</p><p>在 Spring Boot3 之前，Spring Security 过滤器链中有一个名为 SecurityContextPersistenceFilter 的过滤器，这个过滤器在 Spring Boot2.7.x 中废弃了，但是还在使用，在 Spring Boot3 中则被从 Spring Security 过滤器链中移除了，取而代之的是一个名为 SecurityContextHolderFilter 的过滤器。</p><p>在第一小节和小伙伴们介绍的两种 JSON 登录方案在 Spring Boot2.x 中可以运行在 Spring Boot3.x 中无法运行，就是因为这个过滤器的变化导致的。</p><p>所以接下来我们就来分析一下这两个过滤器到底有哪些区别。</p><p>先来看 SecurityContextPersistenceFilter 的核心逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request, response);</span><br><span class="line">SecurityContext contextBeforeChainExecution = <span class="hljs-keyword">this</span>.repo.loadContext(holder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"><span class="hljs-keyword">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里只贴出来了一些关键的核心代码：</p><ol><li>首先，这个过滤器位于整个 Spring Security 过滤器链的第三个，是非常靠前的。</li><li>当登录请求经过这个过滤器的时候，首先会尝试从 SecurityContextRepository（上文中的 this.repo）中读取到 SecurityContext 对象，这个对象中保存了当前用户的信息，第一次登录的时候，这里实际上读取不到任何用户信息。</li><li>将读取到的 SecurityContext 存入到 SecurityContextHolder 中，默认情况下，SecurityContextHolder 中通过 ThreadLocal 来保存 SecurityContext 对象，也就是当前请求在后续的处理流程中，只要在同一个线程里，都可以直接从 SecurityContextHolder 中提取到当前登录用户信息。</li><li>请求继续向后执行。</li><li>在 finally 代码块中，当前请求已经结束了，此时再次获取到 SecurityContext，并清空 SecurityContextHolder 防止内存泄漏，然后调用 <code>this.repo.saveContext</code> 方法保存当前登录用户对象（实际上是保存到 HttpSession 中）。</li><li>以后其他请求到达的时候，执行前面第 2 步的时候，就读取到当前用户的信息了，在请求后续的处理过程中，Spring Security 需要知道当前用户的时候，会自动去 SecurityContextHolder 中读取当前用户信息。</li></ol><p>这就是 Spring Security 认证的一个大致流程。</p><p>然而，到了 Spring Boot3 之后，这个过滤器被 SecurityContextHolderFilter 取代了，我们来看下 SecurityContextHolderFilter 过滤器的一个关键逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">Supplier&lt;SecurityContext&gt; deferredContext = <span class="hljs-keyword">this</span>.securityContextRepository.loadDeferredContext(request);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.setDeferredContext(deferredContext);</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.clearContext();</span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，前面的逻辑基本上还是一样的，不一样的是 finally 中的代码，finally 中少了一步向 HttpSession 保存 SecurityContext 的操作。</p><p>这下就明白了，用户登录成功之后，用户信息没有保存到 HttpSession，导致下一次请求到达的时候，无法从 HttpSession 中读取到 SecurityContext 存到 SecurityContextHolder 中，在后续的执行过程中，Spring Security 就会认为当前用户没有登录。</p><p>这就是问题的原因！</p><p>找到原因，那么问题就好解决了。</p><h3 id="3-3-问题解决"><a href="#3-3-问题解决" class="headerlink" title="3.3 问题解决"></a>3.3 问题解决</h3><p>首先问题出在了过滤器上，直接改过滤器倒也不是不可以，但是，既然 Spring Security 在升级的过程中抛弃了之前旧的方案，我们又费劲的把之前旧的方案写回来，好像也不合理。</p><p>其实，Spring Security 提供了另外一个修改的入口，在 org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#successfulAuthentication 方法中，源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">SecurityContext context = <span class="hljs-keyword">this</span>.securityContextHolderStrategy.createEmptyContext();</span><br><span class="line">context.setAuthentication(authResult);</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextHolderStrategy.setContext(context);</span><br><span class="line"><span class="hljs-keyword">this</span>.securityContextRepository.saveContext(context, request, response);</span><br><span class="line"><span class="hljs-keyword">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当前用户登录成功之后的回调方法，小伙伴们看到，在这个回调方法中，有一句 <code>this.securityContextRepository.saveContext(context, request, response);</code>，这就表示将当前登录成功的用户信息存入到 HttpSession 中。</p><p>在当前过滤器中，securityContextRepository 的类型是 RequestAttributeSecurityContextRepository，这个表示将 SecurityContext 存入到当前请求的属性中，那很明显，在当前请求结束之后，这个数据就没了。在 Spring Security 的自动化配置类中，将 securityContextRepository 属性指向了 DelegatingSecurityContextRepository，这是一个代理的存储器，代理的对象是 RequestAttributeSecurityContextRepository 和 HttpSessionSecurityContextRepository，所以在默认的情况下，用户登录成功之后，在这里就把登录用户数据存入到 HttpSessionSecurityContextRepository 中了。</p><p>当我们自定义了登录过滤器之后，就破坏了自动化配置里的方案了，这里使用的 securityContextRepository 对象就真的是 RequestAttributeSecurityContextRepository 了，所以就导致用户后续访问时系统以为用户未登录。</p><p>那么解决方案很简单，我们只需要为自定义的过滤器指定 securityContextRepository 属性的值就可以了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">JsonLoginFilter <span class="hljs-title">jsonLoginFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    JsonLoginFilter filter = <span class="hljs-keyword">new</span> JsonLoginFilter();</span><br><span class="line">    filter.setAuthenticationSuccessHandler((req,resp,auth)-&gt;&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-comment">//获取当前登录成功的用户对象</span></span><br><span class="line">        User user = (User) auth.getPrincipal();</span><br><span class="line">          user.setPassword(<span class="hljs-keyword">null</span>);</span><br><span class="line">        RespBean respBean = RespBean.ok(<span class="hljs-string">"登录成功"</span>, user);</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationFailureHandler((req,resp,e)-&gt;&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        RespBean respBean = RespBean.error(<span class="hljs-string">"登录失败"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"用户名或者密码输入错误，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户被禁用，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"密码过期，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户过期，登录失败"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">            respBean.setMessage(<span class="hljs-string">"账户被锁定，登录失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationManager(authenticationManager());</span><br><span class="line">    filter.setFilterProcessesUrl(<span class="hljs-string">"/login"</span>);</span><br><span class="line">    filter.setSecurityContextRepository(<span class="hljs-keyword">new</span> HttpSessionSecurityContextRepository());</span><br><span class="line">    <span class="hljs-keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，最后调用 setSecurityContextRepository 方法设置一下就行。</p><blockquote><p>Spring Boot3.x 之前之所以不用设置这个属性，是因为这里虽然没保存最后还是在 SecurityContextPersistenceFilter 过滤器中保存了。</p></blockquote><p>那么对于自定义登录接口的问题，解决思路也是类似的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLogin</span><span class="hljs-params">(@RequestBody User user, HttpSession session)</span> </span>&#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken unauthenticated = UsernamePasswordAuthenticationToken.unauthenticated(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(unauthenticated);</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticate);</span><br><span class="line">            session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, SecurityContextHolder.getContext());</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"error:"</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，在登录成功之后，开发者自己手动将数据存入到 HttpSession 中，这样就能确保下个请求到达的时候，能够从 HttpSession 中读取到有效的数据存入到 SecurityContextHolder 中了。</p><p>好啦，Spring Boot 新旧版本交替中，一个小小的问题，希望小伙伴们能够有所收获。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Spring Security 在最近几个版本中配置的写法都有一些变化，很多常见的方法都废弃了，并且将在未来的 Spring Security7 中移除，因此松哥在去年旧文的基础之上，又补充了一些新的内容，重新发一下，供各位使用 Spring Security 的小伙伴们参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>手把手教大家玩一款基于 ChatGPT-4 的 IDEA 智能助手</title>
    <link href="http://www.javaboy.org/2023/0612/bito_chatgpt4.html"/>
    <id>http://www.javaboy.org/2023/0612/bito_chatgpt4.html</id>
    <published>2023-06-12T14:16:27.000Z</published>
    <updated>2023-07-21T14:54:12.955Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>原谅我后知后觉，相信阅读文章的小伙伴有一部分可能已经安装了这个插件了，我是最近被领导强烈安利安装了这个插件，我体验了一把，感觉还不错，因此和各位小伙伴们分享一下。</p><a id="more"></a><h2 id="1-Bito-AI"><a href="#1-Bito-AI" class="headerlink" title="1. Bito AI"></a>1. Bito AI</h2><p>一款基于GPT-4和ChatGPT模型的人工智能工具，可用于编写代码、理解语法、编写测试用例、解释代码、注释等。这款插件的愿景是让你的开发效率提升百倍，并且每天为你节省一小时。</p><blockquote><p>Be a 100x dev and save an hour a day!</p></blockquote><p>Bito AI 都能做哪些事情呢？别急，我们一件一件来看。</p><p>首先，我们先把这个插件装上，这个插件目前还是预览版，是免费的，以后怎么收费现在未可知。</p><p>IDEA 在插件市场搜索 Bito AI，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230610123209.png" alt></p><p>安装之后记得重启一下项目。重启之后，创建新的项目，在右边就可以看到 Bito 的选项了，点开如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230610124001.png" alt></p><p>官网上明明说的让你的开发效率提升 100 倍，到这里又变成 10 倍了，不知道是疏忽还是插件作者心里也没底～</p><p>点击下方的 <code>Sign up or Sign-in</code> 进行注册，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230610124301.png" alt></p><p>输入邮箱地址，Bito 会给你发一个验证码，输入验证码进行校验就行了，然后创建一个 Workspace 就可以开始工作了。</p><p><img src="http://img.itboyhub.com/2022/08/20230610124522.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230610124620.png" alt></p><p>创建工作空间之后，可以邀请团队的人加入进来，可以填入团队人员的邮箱，或者将这里给的链接发给团队人员让他们自行加入，如果只是自己使用的话，点击 <code>Skip for now</code> 即可：</p><p><img src="http://img.itboyhub.com/2022/08/20230610124721.png" alt></p><h2 id="2-体验"><a href="#2-体验" class="headerlink" title="2. 体验"></a>2. 体验</h2><h3 id="2-1-代码生成"><a href="#2-1-代码生成" class="headerlink" title="2.1 代码生成"></a>2.1 代码生成</h3><p>先来看代码生成功能：</p><p><img src="http://img.itboyhub.com/2022/08/20230610125547.png" alt></p><p>但是这个是用 NodeJS 写的，于是我继续提问：</p><p><img src="http://img.itboyhub.com/2022/08/20230610125809.png" alt></p><p>截图截不全，但是大家看一下，代码是没有任何问题的。</p><h3 id="2-2-生成单元测试"><a href="#2-2-生成单元测试" class="headerlink" title="2.2 生成单元测试"></a>2.2 生成单元测试</h3><p><img src="http://img.itboyhub.com/2022/08/20230610130530.png" alt></p><p>大家看一下，这里会自动生成一个单元测试的提问，这里给生成了两个测试用例，一正一反：</p><p><img src="http://img.itboyhub.com/2022/08/20230610130733.png" alt></p><p>最下面还有一段英文解释，其实很好懂，如果不懂的话，也可以让它翻译。</p><h3 id="2-3-代码解释"><a href="#2-3-代码解释" class="headerlink" title="2.3 代码解释"></a>2.3 代码解释</h3><p><img src="http://img.itboyhub.com/2022/08/20230610131400.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20230610131505.png" alt></p><h3 id="2-4-生成注释"><a href="#2-4-生成注释" class="headerlink" title="2.4 生成注释"></a>2.4 生成注释</h3><p>再来看下如何生成代码注释：</p><p><img src="http://img.itboyhub.com/2022/08/20230610131634.png" alt><br><img src="http://img.itboyhub.com/2022/08/20230610131745.png" alt></p><h3 id="2-5-其他问题"><a href="#2-5-其他问题" class="headerlink" title="2.5 其他问题"></a>2.5 其他问题</h3><p>比如有的小伙伴刚上班，不知道 git 分支怎么合并，那么可以直接使用 Bito 来提问：</p><p><img src="http://img.itboyhub.com/2022/08/20230610130213.png" alt></p><p>另外，Bito 还能帮我们做代码性能检测、安全性检测、提高代码可读性、代码格式检测等工作，用法跟前面提到的都差不多，我就不挨个解释了～</p><p>感兴趣的小伙伴感觉去体验一把吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;原谅我后知后觉，相信阅读文章的小伙伴有一部分可能已经安装了这个插件了，我是最近被领导强烈安利安装了这个插件，我体验了一把，感觉还不错，因此和各位小伙伴们分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+WebSocket一个小问题</title>
    <link href="http://www.javaboy.org/2023/0608/springboot_websocket.html"/>
    <id>http://www.javaboy.org/2023/0608/springboot_websocket.html</id>
    <published>2023-06-08T14:16:16.000Z</published>
    <updated>2023-07-21T14:53:56.619Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴在做 vhr 的时候遇到一个问题，Spring Boot + WebSocket 实现即时通信，关于 Spring Boot+WebSocket 即时通信的问题，松哥之前和小伙伴们多次聊过了，感兴趣的小伙伴可以在公众号后台回复 666 获取相关教程。</p><a id="more"></a><p>今天我想说一个由于版本升级原因导致的报错问题。第一次有小伙伴问这个问题是好早之前了，由于拖延症一直没写文章和大家统一梳理这个问题，刚好最近又有人问，就来和大家梳理一下。</p><p><img src="http://img.itboyhub.com/2022/08/20230608200413.png" alt></p><p>下图是具体的报错：</p><p><img src="http://img.itboyhub.com/2022/08/20230608200427.png" alt></p><p>小伙伴们知道，前端工程化之后，webpack 提供了一个非常好用的功能就是热加载，我们写完 Vue 的代码之后，并不需要重启前端工程，也不需要自己手动去刷新浏览器，浏览器自然就更新了，这个做过 Vue 开发的小伙伴相信都知道。</p><p>当 Vue 代码更新之后，浏览器是怎么知道 Vue 代码更新了呢？这就涉及到松哥之前跟大家聊过的 WebSocket 了，WebSocket 可以实现一个全双工通信，通过 WebSocket 可以实现客户端和服务端互发消息。所以，前端的热更新实际上就是在浏览器和 NodeJS 之间，建立了一个 WebSocket 连接，当 Vue 代码更新之后，服务端 NodeJS 就会通过 WebSocket 告诉浏览器：“Vue 代码更新了，你赶紧重新加载一下吧”！这样我们在浏览器上就可以看到更新后的前端页面了。</p><p>现在新版的 Vue 构建工具，在建立浏览器和服务端通信的 WebSocket 连接时，WebSocket 的通信地址是 <code>http://localhost:8080/ws</code>（老实说我也忘记了以前旧版的通信地址是啥了，知道的小伙伴可以在评论区说一下）。所以如果我们自己项目中也有涉及到 WebSocket 通信的话，就不能使用 <code>/ws</code> 通信了。</p><p>在前后端分离开发中，我们往往要给前端项目配置请求转发，一般是在 vue.config.js 文件中配置的，WebSocket 的请求转发配置如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> proxyObj = &#123;&#125;;</span><br><span class="line"><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"compression-webpack-plugin"</span>);</span><br><span class="line">proxyObj[<span class="hljs-string">'/ws'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">true</span>,</span><br><span class="line">    target: <span class="hljs-string">"ws://localhost:8081"</span></span><br><span class="line">&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">false</span>,</span><br><span class="line">    target: <span class="hljs-string">'http://localhost:8081'</span>,</span><br><span class="line">    changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    <span class="hljs-keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">                        test: <span class="hljs-regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">                        threshold: <span class="hljs-number">1024</span>,</span><br><span class="line">                        deleteOriginalAssets: <span class="hljs-literal">false</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们自己的 WebSocket 通信地址也是 <code>/ws</code> 的话，那么就按照上面这个配置来，但是，上面这个配置同时也会代理热更新的 WebSocket，热更新本来是浏览器和 NodeJS 之间的事，现在这样一配置，就变成了浏览器和我们 Spring Boot 之间的事了，所以就会出现文章开头所说的错误。</p><p>找到了错误的原因，那么问题也很好解决了，我们自己如果项目中涉及到 WebSocket 通信，那么请勿使用 <code>/ws</code> 作为通信地址，换一个地址即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴在做 vhr 的时候遇到一个问题，Spring Boot + WebSocket 实现即时通信，关于 Spring Boot+WebSocket 即时通信的问题，松哥之前和小伙伴们多次聊过了，感兴趣的小伙伴可以在公众号后台回复 666 获取相关教程。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>什么时候 MySQL 查询会变慢？</title>
    <link href="http://www.javaboy.org/2023/0606/slow_query.html"/>
    <id>http://www.javaboy.org/2023/0606/slow_query.html</id>
    <published>2023-06-06T14:15:56.000Z</published>
    <updated>2023-07-21T14:53:31.753Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章和小伙伴们聊的基本上都是从索引的角度去优化 MySQL 查询，然而，索引创建的好，并不意味着查询就一定快，影响查询效率的因素特别多，今天我们就来聊一聊这些可能影响到查询的因素。</p><h2 id="1-查询流程"><a href="#1-查询流程" class="headerlink" title="1. 查询流程"></a>1. 查询流程</h2><a id="more"></a><p>开始今天的内容之前，先来和小伙伴们大概捋一捋 MySQL 的查询流程。我们来看如下一张图：</p><p><img src="http://img.itboyhub.com/2022/08/mysql_search_sequence.png" alt></p><ol><li>首先，用户通过连接器和服务端之间建立通信连接，这个说白了就是一个 Socket 通信，用户名/密码的校验，用户权限的判断等等，都是在这个连接器中完成的。</li><li>接下来需要对我么传入的 SQL 进行解析，这块跟代码的执行流程其实差不多，先做词法分析，识别出各种关键字，然后再做语法分析，语法分析就是根据 MySQL 的各种语法规则，去判断 SQL 是否满足语法规则。</li><li>接下来就是查询优化器出场，查询优化器就是分析要执行的 SQL，判断应该选择哪一个索引，包括在多表联合查询的时候，各个表的连接顺序也是由查询优化器来决定的，优化器执行完毕之后，会生成查询执行计划，我们平时通过 explain 关键字查看到的就是这个。</li><li>最后就是执行器了，执行器调用搜索引擎提供的具体接口去获取数据。</li></ol><p>这张图大家大概有个印象，在后续的 MySQL 查询和优化中，很多东西就容易理解了。</p><p>接下来我们就来看看什么情况下查询会变慢。</p><h2 id="2-查询了不需要的记录"><a href="#2-查询了不需要的记录" class="headerlink" title="2. 查询了不需要的记录"></a>2. 查询了不需要的记录</h2><p>数据按需取用。有时候我们会忽略多拿数据对查询性能的影响，然而优化是一个锱铢必较的事情，需要多少数据就查询多少，要尽量避免数据库查询 100 条，结果前端只展示 10 条这种情况。如有需要，可以通过 limit 来限制数据库查询出来的数据总量。</p><blockquote><p>如果在查询的时候使用了唯一性索引的话，那么查询到记录之后 MySQL 就停止扫描了；但是如果查询的时候使用的是非唯一性索引的话，那么扫描到第一条记录之后，还会继续向后扫描，直到扫描到第一条不满足条件的记录为止，对于这种情况，如果我们确定查询的结果只有一条，则可以通过 limit 进行限制，设置 limit 1，那么扫描到第一条满足条件的记录之后，就不会继续扫描了。</p></blockquote><h2 id="3-返回需要的列"><a href="#3-返回需要的列" class="headerlink" title="3. 返回需要的列"></a>3. 返回需要的列</h2><p>查询的时候尽量避免 <code>select *</code>，这个问题在之前的文章中松哥其实和大家聊过了，因为很多时候我们在前端其实并不需要使用到那么多字段，可能只是为了查询简单，直接来一个 <code>select *</code>，有时候列数和数据总量都比较少的时候，这么写也看不出来性能明显的差异，但是当列数和数据量大了，那么 <code>select *</code> 带来的影响就会比较大了。</p><p>特别是有的时候多表联合查询，如果用 <code>select *</code> 就会把多张表的查询结果拼接到一起，那么此时查询结果的列数就会成倍增加。</p><p>在前面的文章中，松哥也和大家提到过覆盖索引，如果索引设计得当，那么在查询的时候可以通过覆盖索引来提高查询的性能，但是如果使用了 <code>select *</code> 那么大概率是用不了覆盖索引了。</p><h2 id="4-恰到好处的缓存"><a href="#4-恰到好处的缓存" class="headerlink" title="4. 恰到好处的缓存"></a>4. 恰到好处的缓存</h2><p>这里举一个 TienChin 项目的例子，用户登录成功之后，在后续的流程中，经常会用到当前登录用户的信息，如果每次都去数据库查询，每次查询返回结果都是一致的，没有必要，此时我们可以将用户信息存入到 Redis 缓存中，需要的时候从 Redis 中提取就可以了。</p><p>在项目中，对于这些需要多次频繁查询，且每次查询返回结果一样的数据，都可以选择将之存入到缓存中以提高查询性能。</p><h2 id="5-关注扫描行数"><a href="#5-关注扫描行数" class="headerlink" title="5. 关注扫描行数"></a>5. 关注扫描行数</h2><p>在查询的时候，我们可以通过 explain 来查看执行计划，执行计划中有一个指标是扫描行数，如下图中的 rows，这个就表示查询优化器预估要扫描多少行记录，filtered 则表示预估满足条件的比例。</p><p><img src="http://img.itboyhub.com/2022/08/20230604131116.png" alt></p><blockquote><p>一般在单表查询时候我们并不会特别关注 filtered 字段，在多表联合查询的时候会比较关注该字段的值。</p></blockquote><h2 id="6-关注扫描类型"><a href="#6-关注扫描类型" class="headerlink" title="6. 关注扫描类型"></a>6. 关注扫描类型</h2><p>这一条实际上就是让大家关注前面查询计划中的 type 字段的值，type 字段的取值有很多种，例如常见的 index、ALL、range、const 以及 ref，还有一些不常见的如 system、eq_ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery 等，每一种都代表了不同的查询计划，再结合查询计划中的 Extra 字段中的值，我们大致上可以将查询分为三种类型：</p><ol><li>直接调用存储引擎层进行查询，查询结果在 MySQL Server 层不需要额外处理，直接返回给客户端即可。</li><li>直接从索引中过滤出来想要的值并返回给客户端，这种时候，过滤虽然发生在 MySQL Server 层，但是由于不需要回表，效率也还过得去。</li><li>从数据表中查询到相应的记录，然后在 MySQL Server 层进行过滤，过滤的同时可能还需要回表，此时效率就会低一些。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇文章和小伙伴们聊的基本上都是从索引的角度去优化 MySQL 查询，然而，索引创建的好，并不意味着查询就一定快，影响查询效率的因素特别多，今天我们就来聊一聊这些可能影响到查询的因素。&lt;/p&gt;
&lt;h2 id=&quot;1-查询流程&quot;&gt;&lt;a href=&quot;#1-查询流程&quot; class=&quot;headerlink&quot; title=&quot;1. 查询流程&quot;&gt;&lt;/a&gt;1. 查询流程&lt;/h2&gt;
    
    </summary>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/categories/MySQL8/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 启动注解分析</title>
    <link href="http://www.javaboy.org/2023/0602/spring_boot_start_annotation.html"/>
    <id>http://www.javaboy.org/2023/0602/spring_boot_start_annotation.html</id>
    <published>2023-06-02T14:15:45.000Z</published>
    <updated>2023-07-21T14:53:53.059Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>虽然我们在日常开发中，Spring Boot 使用非常多，算是目前 Java 开发领域一个标配了，但是小伙伴们仔细想想自己的面试经历，和 Spring Boot 相关的面试题都有哪些？个人感觉应该是比较少的，Spring Boot 本质上还是曾经 SSM 那一套，只是通过各种 starter 简化了配置而已，其他都是一模一样的，所以 Spring Boot 中很多面试题还是得回归到 Spring 中去解答！当然这并不是说 Spring Boot 中没什么可问的，Spring Boot 中其实也有一个非常经典的面试题，那就是 Spring Boot 中的自动化配置是怎么实现的？今天松哥就来和各位小伙伴聊一下这个问题。</p><a id="more"></a><p>其实松哥之前和小伙伴们聊过相关的问题，不过都是零散的，没有系统梳理过，之前也带领小伙伴们自定义过一个 starter，相信各位小伙伴对于 starter 的原理也有一定了解，所以今天这篇文章一些过于细节的内容我就不赘述了，大家可以翻看之前的文章。</p><h2 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1.  @SpringBootApplication"></a>1.  @SpringBootApplication</h2><p>要说 Spring Boot 的自动化配置，那必须从项目的启动类 <code>@SpringBootApplication</code> 说起，这是整个 Spring Boot 宇宙的起点，我们先来看下这个注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Inherited</span></span><br><span class="line"><span class="hljs-meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="hljs-meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>@SpringBootApplication</code> 注解组合了多个常见注解的功能，其中：</p><ul><li>前四个是元注解，这里我们不做讨论。</li><li>第五个 <code>@SpringBootConfiguration</code> 是一个支持配置类的注解，这里我们也不做讨论。</li><li>第六个 <code>@EnableAutoConfiguration</code> 这个注解就表示开启自动化配置，这是我们今天要聊得重点。</li><li>第七个 <code>@ComponentScan</code> 是一个包扫描注解，为什么 <code>Spring Boot</code> 项目中的 <code>Bean</code> 只要放对位置就会被自动扫描到，和这个注解有关。</li></ul><p>别看这里注解多，其实真正由 <code>Spring Boot</code> 提供的注解一共就两个，分别是 <code>@SpringBootConfiguration</code> 和 <code>@EnableAutoConfiguration</code> 两个，其他注解在 <code>Spring Boot</code> 出现之前就已经存在多年了。</p><h2 id="2-EnableAutoConfiguration"><a href="#2-EnableAutoConfiguration" class="headerlink" title="2. @EnableAutoConfiguration"></a>2. @EnableAutoConfiguration</h2><p>接下来我们来看看 <code>@EnableAutoConfiguration</code> 是如何实现自动化配置的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Inherited</span></span><br><span class="line"><span class="hljs-meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解起关键作用的就是两个东西：</p><ol><li><code>@AutoConfigurationPackage</code>：这个表示自动扫描各种第三方的注解，在之前的文章中松哥已经和大家聊过这个注解的作用了，传送门：<a href="https://mp.weixin.qq.com/s/wwOiC9H-W7JmxcKS3npSyg" target="_blank" rel="noopener">@AutoConfigurationPackage 和 @ComponentScan 有何区别？</a></li><li><code>@Import</code> 则是在导入 <code>AutoConfigurationImportSelector</code> 配置类，这个配置类里边就是去加载各种自动化配置类的。</li></ol><h2 id="3-AutoConfigurationImportSelector"><a href="#3-AutoConfigurationImportSelector" class="headerlink" title="3. AutoConfigurationImportSelector"></a>3. AutoConfigurationImportSelector</h2><p><code>AutoConfigurationImportSelector</code> 类中的方法比较多，入口的地方则是 process 方法，所以我们这里就从 process 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">() -&gt; String.format(<span class="hljs-string">"Only %s implementations are supported, got %s"</span>,</span><br><span class="line">AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">deferredImportSelector.getClass().getName()));</span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line"><span class="hljs-keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类名就可以看出来，跟自动化配置相关的对象是由 <code>AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);</code> 进行加载的。</p><p>当然这里的 <code>getAutoConfigurationEntry</code> 方法实际上就是当前类提供的方法，我们来看下该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里源码的方法命名都做的不错，基本上都能做到见名知意，小伙伴们日常开发中，应该向这样的命名思路看齐。接下来我们就来挨个看一下这里的关键方法。</p><h3 id="3-1-isEnabled"><a href="#3-1-isEnabled" class="headerlink" title="3.1 isEnabled"></a>3.1 isEnabled</h3><p>首先调用 isEnabled 方法去判断自动化配置到底有没有开启，这个主要是因为我们及时在项目中引入了 spring-boot-starter-xxx 之后，我们也可以通过在 application.properties 中配置 <code>spring.boot.enableautoconfiguration=false</code> 来关闭所有的自动化配置。</p><p>相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getClass() == AutoConfigurationImportSelector.class) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-getCandidateConfigurations-x20"><a href="#3-2-getCandidateConfigurations-x20" class="headerlink" title="3.2 getCandidateConfigurations&#x20;"></a>3.2 getCandidateConfigurations&#x20;</h3><p>接下来调用 <code>getCandidateConfigurations</code> 方法去获取所有候选的自动化配置类，这些候选的自动化配置类主要来自两个地方：</p><ol><li>在之前的自定义 <code>starter</code> 中松哥和大家聊过，我们需要在 <code>claspath\:META-INF/spring.factories</code> 中定义出来所有的自动化配置类，这是来源一。</li><li><code>Spring Boot</code> 自带的自动化配置类，这个在之前的 vhr 视频中也和小伙伴们多次讲过，<code>Spring Boot</code> 自带的自动化配置类位于 <code>spring-boot-autoconfigure-3.0.6.jar!\META-INF\spring\org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中。</li></ol><p>相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you "</span></span><br><span class="line">+ <span class="hljs-string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加载到的自动化配置类的全路径被存入到 <code>configurations</code> 对象中，该对象有两个获取的地方：</p><ol><li>调用 <code>SpringFactoriesLoader.loadFactoryNames</code> 方法获取，这个方法细节我就不带大家看了，比较简单，本质上就是去加载 <code>META-INF/spring.factories</code> 文件，这个文件中定义了大量的自动化配置类的全路径。</li><li>调用 <code>ImportCandidates.load</code> 方法去加载，这个就是加载 <code>spring-boot-autoconfigure-3.0.6.jar!\META-INF\spring\org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中的自动化配置类。</li></ol><p>如果这两个地方都没有加载到任何自动化配置类，那么就会抛出一个异常。</p><h3 id="3-3-removeDuplicates"><a href="#3-3-removeDuplicates" class="headerlink" title="3.3 removeDuplicates"></a>3.3 removeDuplicates</h3><p><code>removeDuplicates</code> 方法表示移除候选自动化配置类中重复的类，移除的思路也很有意思，就用一个 <code>LinkedHashSet</code> 中转一下就行了，源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这些源码里有时候一些解决思路也很有意思。</p><h3 id="3-4-getExclusions"><a href="#3-4-getExclusions" class="headerlink" title="3.4 getExclusions"></a>3.4 getExclusions</h3><p><code>getExclusions</code> 方法表示需要获取到所有被排除的自动化配置类，这些被排除的自动化配置类可以从三个地方获取：</p><ol><li>当前注解的 <code>exclude</code> 属性。</li><li>当前注解的 <code>excludeName</code> 属性。</li><li><code>application.properties</code> 配置文件中的 <code>spring.autoconfigure.exclude</code> 属性。</li></ol><p>来看一下相关源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">getExclusions</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; excluded = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">excluded.addAll(asList(attributes, <span class="hljs-string">"exclude"</span>));</span><br><span class="line">excluded.addAll(asList(attributes, <span class="hljs-string">"excludeName"</span>));</span><br><span class="line">excluded.addAll(getExcludeAutoConfigurationsProperty());</span><br><span class="line"><span class="hljs-keyword">return</span> excluded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面讲解的三点刚好对应。</p><h3 id="3-5-checkExcludedClasses"><a href="#3-5-checkExcludedClasses" class="headerlink" title="3.5 checkExcludedClasses"></a>3.5 checkExcludedClasses</h3><p>这个方法是检查所有被排除的自动化配置类，由于 <code>Spring Boot</code> 中的自动化配置类可以自定义，并不需要统一实现某一个接口或者统一继承某一个类，所以在写排除类的时候，如果写错了编译是校验不出来的，像下面这种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span>(exclude = HelloController.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>HelloController</code> 并不是一个自动化配置类，所以这样写项目启动的时候就会报错，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230601202225.png" alt></p><p>这个异常从哪来的呢？其实就是来自 <code>checkExcludedClasses</code> 方法，我们来看下该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkExcludedClasses</span><span class="hljs-params">(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; invalidExcludes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(exclusions.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (String exclusion : exclusions) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) &amp;&amp; !configurations.contains(exclusion)) &#123;</span><br><span class="line">invalidExcludes.add(exclusion);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!invalidExcludes.isEmpty()) &#123;</span><br><span class="line">handleInvalidExcludes(invalidExcludes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInvalidExcludes</span><span class="hljs-params">(List&lt;String&gt; invalidExcludes)</span> </span>&#123;</span><br><span class="line">StringBuilder message = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line"><span class="hljs-keyword">for</span> (String exclude : invalidExcludes) &#123;</span><br><span class="line">message.append(<span class="hljs-string">"\t- "</span>).append(exclude).append(String.format(<span class="hljs-string">"%n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(String.format(</span><br><span class="line"><span class="hljs-string">"The following classes could not be excluded because they are not auto-configuration classes:%n%s"</span>,</span><br><span class="line">message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>checkExcludedClasses</code> 方法中，会首先找到所有位于当前类路径下但是却不包含在 <code>configurations</code> 中的所有被排除的自动化配置类，由于 <code>configurations</code> 中的就是所有的自动化配置类了，所以这些不存在于 <code>configurations</code> 中的类都是有问题的，都不是自动化配置类，将这些有问题的类收集起来，存入到 <code>invalidExcludes</code> 变量中，然后再进行额外的处理。</p><p>所谓额外的处理就是在 <code>handleInvalidExcludes</code> 方法中抛出异常，前面截图中的异常就是来自这里。</p><h3 id="3-6-removeAll"><a href="#3-6-removeAll" class="headerlink" title="3.6 removeAll"></a>3.6 removeAll</h3><p>这个方法就一个任务，就是从 <code>configurations</code> 中移除掉那些被排除的自动化配置类。<code>configurations</code> 本身就是 <code>List</code> 集合，<code>exclusions</code> 则是一个 <code>Set</code> 集合，所以这里直接移除即可。</p><h3 id="3-7-filter"><a href="#3-7-filter" class="headerlink" title="3.7 filter"></a>3.7 filter</h3><p>现在我们已经加载了所有的自动化配置类了，但是这些配置类并不是都会生效，具体是否生效，还要看你的项目是否使用了具体的依赖。</p><p>例如，现在加载的自动化配置里里边就包含了 RedisAutoConfiguration，这个是自动配置 Redis 的，但是由于我的项目中并没有使用 Redis，所以这个自动化配置类并不会生效。这个过程就是由 <code>getConfigurationClassFilter().filter(configurations);</code> 来完成的。</p><p>先说一个预备知识：</p><p>由于我们项目中的自动化配置类特别多，每一个自动化配置类都会依赖别的类，当别的类存在时，这个自动化配置类才会生效，这一堆互相之间的依赖关系，存在于 <code>spring-boot-autoconfigure-3.0.6.jar!/META-INF/spring-autoconfigure-metadata.properties</code> 文件之中，我随便举一个该文件中的配置：</p><ul><li><code>org.springframework.boot.autoconfigure.amqp.RabbitAnnotationDrivenConfiguration.ConditionalOnClass=org.springframework.amqp.rabbit.annotation.EnableRabbit</code> 表示 RabbitAnnotationDrivenConfiguration 类要生效有一个必备条件就是当前项目类路径下要存在 <code>org.springframework.amqp.rabbit.annotation.EnableRabbit</code>。</li></ul><p>我们来看看 RabbitAnnotationDrivenConfiguration 类的注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(EnableRabbit.class)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitAnnotationDrivenConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类和配置文件中的内容一致。</p><p>这个预备知识搞懂了，接下来的内容就好理解了。</p><p>先来看 getConfigurationClassFilter 方法，这个就是获取所有的过滤器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ConfigurationClassFilter <span class="hljs-title">getConfigurationClassFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.configurationClassFilter == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;AutoConfigurationImportFilter&gt; filters = getAutoConfigurationImportFilters();</span><br><span class="line"><span class="hljs-keyword">for</span> (AutoConfigurationImportFilter filter : filters) &#123;</span><br><span class="line">invokeAwareMethods(filter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.configurationClassFilter = <span class="hljs-keyword">new</span> ConfigurationClassFilter(<span class="hljs-keyword">this</span>.beanClassLoader, filters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.configurationClassFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里获取到的过滤器都是 AutoConfigurationImportFilter 类型的，这个类型的过滤器只有三个实例，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/AutoConfigurationImportFilter.png" alt></p><p>从这三个实例的名字中，基本上就能看出来各自的作用：</p><ul><li>OnClassCondition：这个就是条件注解 <code>@ConditionalOnClass</code> 的判定条件，看名字就知道用来判断当前 classpath 下是否存在某个类。</li><li>OnWebApplicationCondition：这个是条件注解 <code>ConditionalOnWebApplication</code> 的判定条件，用来判断当前系统环境是否是一个 Web 环境。</li><li>OnBeanCondition：这个是条件注解 <code>@ConditionalOnBean</code> 的判定条件，就是判断当前系统下是否存在某个 Bean。</li></ul><p>这里获取到的三个 AutoConfigurationImportFilter 过滤器其实就是上面这三个。接下来执行 filter 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">List&lt;String&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;String&gt; configurations)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">String[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line"><span class="hljs-keyword">boolean</span> skipped = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (AutoConfigurationImportFilter filter : <span class="hljs-keyword">this</span>.filters) &#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span>[] match = filter.match(candidates, <span class="hljs-keyword">this</span>.autoConfigurationMetadata);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!match[i]) &#123;</span><br><span class="line">candidates[i] = <span class="hljs-keyword">null</span>;</span><br><span class="line">skipped = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!skipped) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line"><span class="hljs-keyword">for</span> (String candidate : candidates) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (candidate != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是遍历这三个过滤器，然后分别调用各自的 match 方法和 144 个自动化配置类进行匹配，如果这些自动化配置类所需要的条件得到满足，则 match 数组对应的位置就为 true，否则就为 false。</p><p>然后遍历 match 数组，将不满足条件的自动化配置类置为 null，最后再把这些 null 移除掉。</p><p>这样就获取到了我们需要进行自动化配置的类了。</p><p>最后一句 fireAutoConfigurationImportEvents 则是触发自动化配置类导入事件，这个没啥好说的～</p><p>当这些自动化配置类加载进来之后，接下来就是各种条件注解来决定这些配置类是否生效了，这些都比较简单了，之前在 vhr 种也和小伙伴们讲过多次了，这里就不再啰嗦了~</p><p>好啦，经过上面的梳理相信小伙伴们对 Spring Boot 自动化配置类的加载有一个大概的认知了吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;虽然我们在日常开发中，Spring Boot 使用非常多，算是目前 Java 开发领域一个标配了，但是小伙伴们仔细想想自己的面试经历，和 Spring Boot 相关的面试题都有哪些？个人感觉应该是比较少的，Spring Boot 本质上还是曾经 SSM 那一套，只是通过各种 starter 简化了配置而已，其他都是一模一样的，所以 Spring Boot 中很多面试题还是得回归到 Spring 中去解答！当然这并不是说 Spring Boot 中没什么可问的，Spring Boot 中其实也有一个非常经典的面试题，那就是 Spring Boot 中的自动化配置是怎么实现的？今天松哥就来和各位小伙伴聊一下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>delete 清空表之后，磁盘空间未发生变化？</title>
    <link href="http://www.javaboy.org/2023/0530/delete_table.html"/>
    <id>http://www.javaboy.org/2023/0530/delete_table.html</id>
    <published>2023-05-30T14:15:35.000Z</published>
    <updated>2023-07-21T14:53:38.118Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6xo-p0z3HIE4tlsIWqqFBg" target="_blank" rel="noopener">上篇文章</a>结尾和小伙伴们留了一个小问题，就是关于 <code>optimize table</code> 命令，今天我想花点时间再来和小伙伴们聊一聊这个话题。</p><h2 id="1-删除空洞"><a href="#1-删除空洞" class="headerlink" title="1. 删除空洞"></a>1. 删除空洞</h2><a id="more"></a><h3 id="1-1-案例展示"><a href="#1-1-案例展示" class="headerlink" title="1.1 案例展示"></a>1.1 案例展示</h3><p>首先我们先来看这样一个例子。</p><p>我现在有一个名为 sakila 的数据库，该库中有一个 film 表，这个表中有 1000 条记录，我么先来看下这 1000 条记录占用了多少存储空间：</p><p><img src="http://img.itboyhub.com/2022/08/20230528192315.png" alt></p><p>小伙伴们可以看到，这个文件大小是 <code>360448</code> 个字节。</p><p>我们现在执行 delete 命令将这个表清空：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> film;</span><br></pre></td></tr></table></figure><p>然后再来查看这个文件的大小：</p><p><img src="http://img.itboyhub.com/2022/08/20230528192705.png" alt></p><p>小伙伴们看到，这个表中的数据没有减少，甚至还增加了！这是咋回事？</p><h3 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h3><blockquote><p>以下所说的删除皆指通过 delete 命令删除，不包括通过 truncate/drop 删除。</p></blockquote><p>MySQL 中的数据删除操作有点像我们平日里做业务开发时用的逻辑删除，当你想要删除掉一行数据的时候，这行数据其实并没有被真正的删除掉，只是暂时给标记为删除了而已。</p><p>经过前面文章的介绍，小伙伴们应该已经清楚，MySQL 表中的数据最终是以 B+Tree 的形式保存在磁盘中的，当你要删除一条记录的时候，那么对应的叶子上的数据就会被标记为已删除，类似下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/mysql8_clustered_index_delete_table_data.png" alt></p><p>当 ID 为 6 的记录被删除掉之后，这块空间并不会立马被释放出来，MySQL 只是在这个位置做一个删除标记，将来要是还有一个 ID 为 6 的数据被插入进来，就会插入到这里。</p><p>因此我们看到，一张表在经过 N 多次删除之后，就会出现大量这种情况，这种就称之为删除空洞。</p><h2 id="2-插入空洞"><a href="#2-插入空洞" class="headerlink" title="2. 插入空洞"></a>2. 插入空洞</h2><p>前面所说的删除会造成空洞，其实插入也会造成空洞。</p><p>松哥在之前的文章中和小伙伴们分享过，InnoDB 引擎的表中不建议使用随机字符串作为 ID，因为随机字符串插入会造成页分裂。页分裂之后，在分裂之前的叶子中，也有可能会空出来新的空间，造成空洞。</p><p>例如下面这个例子：</p><p><img src="http://img.itboyhub.com/2022/08/20230529204051.png" alt></p><p>在上图这个 B+Tree 中，继续插入 5，就会造成页分裂，页分裂之后，2 所在的数据页（InnoDB 操作磁盘的最小单位是数据页）就会有空余，这也是空洞的一种。</p><p><img src="http://img.itboyhub.com/2022/08/20230529204229.png" alt></p><p>当然更新索引上的值也会造成空洞，因为更新相当于插入+删除。</p><h2 id="3-optimize-table"><a href="#3-optimize-table" class="headerlink" title="3. optimize table"></a>3. optimize table</h2><p>想要解决这个问题，我们可以使用 optimize table 命令来实现。该命令可以用来重新整理表空间，并优化文件碎片。接下来我们针对前面 1.1 小节中的案例，来试试 optimize table 命令是否有效：</p><p><img src="http://img.itboyhub.com/2022/08/20230529210535.png" alt></p><p>这上面有一句提示，说 <code>Table does not support optimize, doing recreate + analyze instead</code>，看这个意思，似乎是说当前这个 InndoDB 引擎的表不支持 optimize 操作，不过我们不用管，我们现在去查看表文件大小：</p><p><img src="http://img.itboyhub.com/2022/08/20230529210918.png" alt></p><p>可以看到，表文件数据其实已经减少了。</p><p>那么这句提示是咋回事呢？</p><p>我们以 MySQL 官方文档介绍为准来看下：</p><p><img src="http://img.itboyhub.com/2022/08/20230529211829.png" alt></p><p>从这段话中可以看到，在 InnoDB 中使用 optimize 命令，相关的操作最终会被映射为 <code>alter table ...</code>，这个操作松哥在<a href="https://mp.weixin.qq.com/s/6xo-p0z3HIE4tlsIWqqFBg" target="_blank" rel="noopener">上篇文章</a>中和小伙伴们介绍过了，这也可以实现索引的重整并且释放掉未使用的空间，所以，网上有人说 optimize table 命令不适用于 InnoDB 引擎的表这个说法是不正确的。</p><p>同时，官方文档中这段介绍还提到了 optimize 操作是 online DDL 的。online DDL 意味着在执行 optimize 重整表的时候，并不会阻塞正在进行的 CURD 操作。具体流程如下：</p><ol><li>首先建立一个临时文件，这个临时文件用来扫描表原始表主键的所有数据页。</li><li>根据第一步获取到的表记录生成一个 B+Tree，将这个生成的 B+Tree 存储到临时文件中。</li><li>由于第二步会比较耗时，在第二步执行过程中，如果有针对原始表的 CRUD 操作，则先将操作记录到一个日志文件中，等到第二步的临时文件生成后，在把日志文件应用到临时文件中，就可以获取到一个最新的数据表了。</li></ol><p>好啦，这就是关于 optimize table 的操作细节，小伙伴们 GET 到了吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6xo-p0z3HIE4tlsIWqqFBg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;结尾和小伙伴们留了一个小问题，就是关于 &lt;code&gt;optimize table&lt;/code&gt; 命令，今天我想花点时间再来和小伙伴们聊一聊这个话题。&lt;/p&gt;
&lt;h2 id=&quot;1-删除空洞&quot;&gt;&lt;a href=&quot;#1-删除空洞&quot; class=&quot;headerlink&quot; title=&quot;1. 删除空洞&quot;&gt;&lt;/a&gt;1. 删除空洞&lt;/h2&gt;
    
    </summary>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/categories/MySQL8/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>分享几个索引创建的小 Tips</title>
    <link href="http://www.javaboy.org/2023/0523/index_suggest.html"/>
    <id>http://www.javaboy.org/2023/0523/index_suggest.html</id>
    <published>2023-05-23T14:15:22.000Z</published>
    <updated>2023-07-21T14:52:38.851Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>关于 MySQL 中的索引，松哥前面已经和小伙伴们聊了不少了，不过在索引使用的时候，还是有一些需要注意的细节，如果忽略了这些细节，可能会让索引的使用效果大打折扣。</p><a id="more"></a><h2 id="1-冗余索引"><a href="#1-冗余索引" class="headerlink" title="1. 冗余索引"></a>1. 冗余索引</h2><p>注意我这里使用了冗余索引，没有使用重复索引，因为我觉得在小伙伴们使用索引的过程中，创建重复索引的概率应该还是比较小，同一个字段上创建多个一模一样的索引，应该很少有人会犯这种错误。但是，会有一些容易被大家忽略的冗余索引，我们来捋一捋。</p><h3 id="1-1-联合索引左边列"><a href="#1-1-联合索引左边列" class="headerlink" title="1.1 联合索引左边列"></a>1.1 联合索引左边列</h3><p>例如我创建了一个联合索引 (A,B,C)，按照我们之前跟大家讲的最左匹配原则，当我们使用 A、（A、B）或者 （A、B、C）去查询数据的时候，都会用到这个联合索引，所以我们就没有必要再去单独针对 A 字段创建一个索引，或者针对 A、B 字段创建一个联合索引。</p><h3 id="1-2-索引中加入主键"><a href="#1-2-索引中加入主键" class="headerlink" title="1.2 索引中加入主键"></a>1.2 索引中加入主键</h3><p>假设我有一张表，该表有如下字段 （ID、A、B、C），其中 ID 是主键，现在又针对 A 和 ID 两个字段创建了联合索引（A、ID）。</p><p>根据松哥前面的介绍，小伙伴们知道，在二级索引中，叶子结点上存储的数据就是 ID，所以，这个联合索引中的 ID 字段显然是多余的。</p><p>大部分情况下我们都不需要冗余索引，但是也有一些特殊情况可能让我们不得不创建一些冗余索引，这个小伙伴们还是要具体问题具体分析。</p><blockquote><p>另外需要注意一点，针对相同的字段，如果索引类型不同，则不能算是重复索引，例如一个普通索引和一个全文索引，同一个字段上同时有这两个索引，不算重复索引。</p></blockquote><h2 id="2-隐藏的索引排序"><a href="#2-隐藏的索引排序" class="headerlink" title="2. 隐藏的索引排序"></a>2. 隐藏的索引排序</h2><p>上篇文章松哥刚刚和大家聊了索引排序的问题。</p><p>结合上篇文章的内容，小伙伴们思考这样一个问题：假设我有一张表，表中包含如下字段（ID、A、B），其中 ID 是主键，现在我针对 A 字段建立一个索引，如果我有如下查询 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> A=xxx <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">ID</span></span><br></pre></td></tr></table></figure><p>由于在 A 这个二级索引中就包含了 ID 字段，所以上面这个查询是可以使用到索引排序的。此时，如果由于其他需求，我们将 A 这个索引扩展成联合索引（A、B）了，那么很明显，再执行上面的查询的时候就用不了索引排序了，只能 filesort 了。这样的问题小伙伴们在创建或者修改索引的时候很容易忽略，所以一定要仔细。</p><h2 id="3-删除不使用的索引"><a href="#3-删除不使用的索引" class="headerlink" title="3. 删除不使用的索引"></a>3. 删除不使用的索引</h2><p>有的索引可能是由于过度考虑创建了，创建成功之后就没用过，这样的索引也应该删除掉。</p><blockquote><p>小伙伴们知道，索引虽然可以提高查询速度，但是却会降低插入和修改速度。</p></blockquote><p>在 MySQL 的元数据库 sys 中有一个名为 schema_unused_indexes 的视图，该视图中就保存了各种创建了但是未使用的索引：</p><p><img src="http://img.itboyhub.com/2022/08/20230523125131.png" alt></p><h2 id="4-手动更新索引统计信息"><a href="#4-手动更新索引统计信息" class="headerlink" title="4. 手动更新索引统计信息"></a>4. 手动更新索引统计信息</h2><p>当我们想要查看一条 SQL 的执行计划时，这个执行计划中会展示出来这个 SQL 执行过程中大概会扫描多少行数据，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230523125349.png" alt></p><p>这个预估的扫描行数非常重要，这是 MySQL 优化器在执行 SQL 的时候一个重要的参考指标，如果表没有这个统计信息，或者统计信息不准确，那么就有可能导致优化器做出错误的决定。</p><p>当满足如下条件的时候，这个统计信息会自动生成或者更新：</p><ul><li>首次打开表。</li><li>表大小发生变化。</li><li>执行 SHOW TABLE STATUS</li><li>执行 SHOW INDEX</li><li>MySQL 客户端开启自动补全功能</li><li>打开 infomation_schema 库中一些相关的表</li></ul><p>这些行为都会触发统计信息的自动更新，如果表中数据量比较大，担心以上行为降低表的性能，那么也可以修改 innodb_stats_on_metadata 参数来关闭以上行为。</p><p><img src="http://img.itboyhub.com/2022/08/20230523125623.png" alt></p><p>当然，我们也可以手动执行 <code>analyze table</code> 命令来更新索引的统计信息。</p><p><img src="http://img.itboyhub.com/2022/08/20230523125454.png" alt></p><h2 id="5-适时优化表"><a href="#5-适时优化表" class="headerlink" title="5. 适时优化表"></a>5. 适时优化表</h2><p>InnoDB 中的索引是一个 B+Tree，这个我们在之前的文章中就和小伙伴们聊过了。B+Tree 通过一个多路平衡查找树将数据组织在一起，然而这个树中的各个结点在存储的时候在物理分布上却并不一定连续，如果是连续的，则在数据操作的时候就会快很多，如果不需连续，数据操作性能必然会有下降，一般来说，存在这样几种不同的碎片形式：</p><ol><li>行碎片：数据行分布在不同的地方，读取数据行的时候涉及到多次随机 IO。</li><li>行间碎片：逻辑上应该是连续的行或者数据页，在磁盘上存储时并不连续。原本全表扫描的时候是顺序 IO，现在变成了随机 IO。</li><li>剩余空间碎片：小伙伴们知道，InnoDB 操作数据表最基本单位是页，一页是 16KB，也就是 InnoDB 从磁盘上读、往磁盘上写，最低单位都是 16KB，有时候这 16KB 中，有效数据很少，其他地方都是剩余空间，就会让 InnoDB 在读写数据的时候造成很大浪费。</li></ol><p>对于以上情况，我们可以通过执行 optimize table 来重新整理数据，如果存储引擎不支持 optimize table 命令，那么我们也可以通过执行 <code>alter table &lt;table&gt; engine=xxx</code> 命令来实现数据的重整（命令中的 xxx 就是表原本的引擎）。</p><p><img src="http://img.itboyhub.com/2022/08/20230523130022.png" alt></p><p>当然，optimize table 命令在执行的过程中还有一些细节问题，这个松哥后面再整文章和小伙伴们分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;关于 MySQL 中的索引，松哥前面已经和小伙伴们聊了不少了，不过在索引使用的时候，还是有一些需要注意的细节，如果忽略了这些细节，可能会让索引的使用效果大打折扣。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/categories/MySQL8/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
  </entry>
  
  <entry>
    <title>@AutoConfigurationPackage 和 @ComponentScan 有何区别？</title>
    <link href="http://www.javaboy.org/2023/0517/autoconfigurationpackage_componentscan.html"/>
    <id>http://www.javaboy.org/2023/0517/autoconfigurationpackage_componentscan.html</id>
    <published>2023-05-17T14:15:06.000Z</published>
    <updated>2023-07-21T14:53:49.008Z</updated>
    
    <content type="html"><![CDATA[<p>面试真是越来越卷了，最近又有小伙伴在微信上问到松哥这样一个面试题，想到这两个的区别其实还有点意思，因为整一篇文章和小伙伴们捋一捋。</p><a id="more"></a><p>首先，从名字上看，这两个注解意义特别接近，<code>@AutoConfigurationPackage</code> 就是自动配置包，自动配置包的目的是能让系统扫描到包内的 Bean；<code>@ComponentScan</code> 则是组件扫描，这个松哥在之前的教程中也多次提到过了，就不再赘述了，所以这里就有一个问题，这两个注解有啥区别？</p><p>首先大家思考这样一个问题：</p><p>现在大多数项目可能都是用的 MyBatis 或者 MyBatis-Plus 这样的数据持久化框架，当我们在 Spring Boot 中使用 MyBatis 的时候，我们一般需要在 Mapper 接口上添加一个 @Mapper 注解，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在启动类上加 Mapper 扫描注解去统一扫描所有的 Mapper 接口，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@MapperScan</span>(basePackages = <span class="hljs-string">"org.javaboy.auto_package"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoPackageApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AutoPackageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平时我们都这样写，没有任何问题，现在假设我们换一个写法，假如我的类结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── org</span><br><span class="line">│   │       └── javaboy</span><br><span class="line">│   │           └── auto_package</span><br><span class="line">│   │               ├── config</span><br><span class="line">│   │               │   ├── AutoPackageApplication.java</span><br><span class="line">│   │               │   └── UserController.java</span><br><span class="line">│   │               ├── mapper</span><br><span class="line">│   │               │   └── UserMapper.java</span><br><span class="line">│   │               └── service</span><br><span class="line">│   │                   └── UserService.java</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我把启动类和 UserController 放在一个单独的包中，UserMapper 和 UserService 也分别位于不同的包中，其中在 UserController 中注入了 UserService，在 UserService 中则注入了 UserMapper，大致上就这么一个关系。</p><p>按照我们之前对 Spring Boot 的理解，这个项目启动肯定会报错，因为默认情况下，系统扫描的 Bean 是启动类所在的包以及子包下的所有 Bean（因为 <code>@SpringBootApplication</code> 注解在启动类上），所以上面这个项目启动的时候，能扫描到 UserController，但是扫描不到 UserService，所以启动的时候会报错，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230515225430.png" alt></p><p>大家看下，这意思很明确，UserService 找不到，所以启动失败。</p><p>解决这个问题的办法很简单，要么将启动类放到根包下面，这样所有的 Bean 默认就都能扫描到了，要么我们重新配置包扫描，这里我采用第二种方案，我们在启动类上加 <code>@ComponentScan</code> 注解，重新指定扫描的包，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy.auto_package"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoPackageApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AutoPackageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上之后，我们再次启动，发现又报错了，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230515225857.png" alt></p><p>虽然再次出错，但是跟之前的错误并不一样，这次是没找到 UserMapper 这个 Bean，说明 UserService 是找到了！</p><p>从这里我们就可以看出来，<code>@ComponentScan</code> 注解扫描组件是不会扫描到 @Mapper 注解的！</p><p>事实上，<code>@ComponentScan</code> 注解主要是扫描 Spring 家族的各种 Bean，如 @Controller、@Service、@Component、@Repository 以及由此衍生出来的一些其他的 Bean，对于 Spring 家族之外的 Bean，如 MyBatis 的 @Mapper、@MapperScan，JPA 的 @Entity 等，<code>@ComponentScan</code> 都扫不到！</p><p>谁能扫到呢？那就是我们今天的另外一个主角 <code>@AutoConfigurationPackage</code>，这个注解其实就是专门用来扫这些第三方的各种 Bean 的。</p><p>现在，我们在项目启动上加上 <code>@AutoConfigurationPackage</code> 注解，并设置需要扫描的位置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@AutoConfigurationPackage</span>(basePackages = <span class="hljs-string">"org.javaboy.auto_package"</span>)</span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy.auto_package"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoPackageApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AutoPackageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，项目就可以成功启动了，因为 <code>@AutoConfigurationPackage(basePackages = &quot;org.javaboy.auto_package&quot;)</code> 注解可以扫描到 @Mapper 注解。</p><blockquote><p>当然，这里只是为了给大家演示问题，实际场景下直接在启动类上加 <code>@MapperScan(basePackages = &quot;org.javaboy.auto_package&quot;)</code> 注解就可以了。因为 @MapperScan 注解是 mybatis-spring 提供的，而 @Mapper 是 MyBatis 自己提供的，两个注解的出处本身就不同。</p></blockquote><p>默认情况下，Spring Boot 项目的启动注解中，实际上已经包含了 <code>@AutoConfigurationPackage</code> 注解，具体位置在 <code>@SpringBootApplication</code>-&gt;<code>@EnableAutoConfiguration</code>-&gt;<code>@AutoConfigurationPackage</code>，默认该注解没有指定 basePackages 属性，表示使用启动类所在的包作为根包，扫描该包下的所有第三方 Bean，所以我们平时在 Spring Boot 中使用 MyBatis 的时候，是不需要额外加 <code>@AutoConfigurationPackage</code> 注解的。</p><p>经过上面问题的演示，相信小伙伴们已经搞明白了 <code>@AutoConfigurationPackage</code> 和 <code>@ComponentScan</code> 的区别了吧？</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总结一下：</p><ol><li>两者都是用来扫描 Bean 的。</li><li><code>@ComponentScan</code> 主要用来扫描和 Spring 容器相关的 Bean。</li><li><code>@AutoConfigurationPackage</code> 主要用来扫描第三方的 Bean。</li></ol><p>仅此而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试真是越来越卷了，最近又有小伙伴在微信上问到松哥这样一个面试题，想到这两个的区别其实还有点意思，因为整一篇文章和小伙伴们捋一捋。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 如何确保消息顺序？</title>
    <link href="http://www.javaboy.org/2023/0515/mq_message_sequence.html"/>
    <id>http://www.javaboy.org/2023/0515/mq_message_sequence.html</id>
    <published>2023-05-15T14:14:53.000Z</published>
    <updated>2023-07-21T14:52:42.285Z</updated>
    
    <content type="html"><![CDATA[<p>之前有小伙伴说面试中被问到了这个问题，消息中间件如何确保消息顺序，因为松哥之前出过一个 RabbitMQ 的系列教程（公号【江南一点雨】后台回复 <code>rabbitmq</code>），所以他就跑来微信上问我，那么今天我们就来稍微捋一捋这个话题。</p><a id="more"></a><p>怎么说呢，感觉在面试中，如果涉及到消息中间件，两个频率比较高的问题，一个是如何确保消息的可靠性，另一个就是如何确保消息有序，如何确保消息可靠性，这个松哥之前已经写过了，公众号后台回复 2020 有文章索引。</p><h2 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1. 整体思路"></a>1. 整体思路</h2><p>首先，我们先来聊聊在确保消息有序这件事上的一个整体思路。</p><p>大家先来看下面一张图，这是官方提供的 RabbitMQ 消息发送流程图：</p><p><img src="http://img.itboyhub.com/2021/07/20210805191750.png" alt></p><p>大家可以看到，消息从 Publisher 出来之后，先被发送到 Exchange，然后 Exchange 将消息转到 Queue 队列上，最后，消费者消费 Queue 上的消息，大致上就是这样一个流程。</p><p>那么要确保消息的顺序，只需要确保两点即可：</p><ol><li>发送有序。</li><li>消费有序。</li></ol><p>其实只要这两点就够了。</p><p>因为当消息发送成功到达队列之后，队列本身就是有序的，先进先出，所以正常情况下，我们是不必考虑队列中消息顺序的问题的。</p><p>不过需要小伙伴们注意的是，如果你的消息发送到不同的队列中，那么消息出队的顺序就无法保证了。</p><p>所以，<strong>从这里我们就总结出第一个规则，就是如果要确保消息有序，相同类型的消息至少得发到一个队列中，不能发到多个队列中。</strong></p><h2 id="2-发送有序"><a href="#2-发送有序" class="headerlink" title="2. 发送有序"></a>2. 发送有序</h2><p>正常来说，我们发送消息的时候都是按照既定的业务顺序发送的，这点是无疑的。所以发送有序本来不是啥大事，问题在于，有的时候我们的项目是集群化部署，同一个项目有多个实例，当多个不同的实例分布于不同的服务器上运行的时候，都向 MQ 发消息，此时就无法确保消息的有序了。</p><p>那么对于这种情况，我们可以考虑使用 Redis 分布式锁来实现，发送消息之前，先去 Redis 上获取到锁，能拿到锁，然后再去发送消息，避免并发发送。至于 Redis 做分布式锁的具体用法我这里就不啰嗦了，之前的 vhr 视频里都讲过了，公号后台回复 vhr 可以查看视频介绍。</p><p>这是一个思路。</p><h2 id="3-消费有序"><a href="#3-消费有序" class="headerlink" title="3. 消费有序"></a>3. 消费有序</h2><p>接下来就是消费有序了。</p><p>消费有序这里要注意的细节就比较多。</p><p>首先，同一个队列只能有一个消费者，如果存在多个消费者，则消费顺序就无法保证了。</p><p>其次，同一个队列不能开启并发消费，例如像下面这样的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME,concurrency = <span class="hljs-string">"10"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="hljs-string">"msg:&#123;&#125;"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个相当于建立了 10 个 channel 去同时消费消息，对于这种情况，也是没法保证消费的有序的，因为本地代码执行的快慢、是否抛异常等等，都有可能会影响到消息的顺序。</p><p>无法并发消费，就会导致消费性能下降，如果确实对性能又有比较高的要求，那么我们相同类型的队列可以创建多个，然后依然是每一个队列一个消费者即可。</p><blockquote><p>举个简单的例子，比如电商下单的时候，需要给同一个队列发送多条消息，正常发送这些消息当然都是有序的。如果想提高并发能力，那么我们可以设置多个消息队列，跟一个用户相关的订单都发送到同一个消息队列中，然后一个队列对应一个消费者，这样就能保证消息的有序。</p></blockquote><p>好啦，大概就这么多细节。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>最后，我们再稍微总结下：</p><ol><li>消息发送，自己确保是有序的；集群化部署的话，可以通过分布式锁确保消息有序。</li><li>消息到达队列之后，默认就是有序的。</li><li>消息消费，一个队列对应一个消费者，并且一个消费者一个 channel，不能并发消费，就可以确保消息有序。</li></ol><p>好啦，以上就是确保 RabbitMQ 消息有序的几个细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有小伙伴说面试中被问到了这个问题，消息中间件如何确保消息顺序，因为松哥之前出过一个 RabbitMQ 的系列教程（公号【江南一点雨】后台回复 &lt;code&gt;rabbitmq&lt;/code&gt;），所以他就跑来微信上问我，那么今天我们就来稍微捋一捋这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
