<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-03-27T03:39:19.368Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>松哥手把手教你入门 Spring Cloud Alibaba Nacos</title>
    <link href="http://www.javaboy.org/2020/0327/spring-cloud-alibaba-nacos.html"/>
    <id>http://www.javaboy.org/2020/0327/spring-cloud-alibaba-nacos.html</id>
    <published>2020-03-27T02:08:40.000Z</published>
    <updated>2020-03-27T03:39:19.368Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 的问题我先说一下，视频和文章松哥都在积极准备中，因为都是业余搞，每天下班后都是火急火燎，为了给小伙伴们呈现一段完美的表演，每一个视频都要花不少时间，所以新一期的 Spring Security 估计下周能和小伙伴们见面。</p><a id="more"></a><p>今天就和小伙伴们分享一个存货–Spring Cloud Alibaba Nacos！</p><p>一起来看大屏幕（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>）：</p><p><a href="https://mp.weixin.qq.com/s/o_M3IEC4ysOHPgUAfanswA" target="_blank" rel="noopener">视频地址</a></p><p>好啦视频看完啦，如果小伙伴们觉得有收获，记得点一下右下角在看哦。</p><p>以下是视频笔记：</p><p>Nacos 主要提供了服务发现、服务配置以及服务管理。</p><p>基本特性：</p><ul><li>服务发现</li><li>动态配置</li><li>动态 DNS 服务</li><li>服务及元数据管理</li></ul><h2 id="1-安装-配置中心"><a href="#1-安装-配置中心" class="headerlink" title="1. 安装+配置中心"></a>1. 安装+配置中心</h2><ul><li>Docker 安装</li><li>下载源码自己编译安装/下载编译好的安装包</li></ul><p>首先下载安装包：<a href="https://github.com/alibaba/nacos/releases/download/1.2.0-beta.1/nacos-server-1.2.0-beta.1.tar.gz" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases/download/1.2.0-beta.1/nacos-server-1.2.0-beta.1.tar.gz</a></p><p>然后解压，解压后，如果 win，直接在 bin 目录下双击 startup.cmd 启动。<br>如果Linux，bin 目录下执行 sh startup.sh -m standalone.</p><p><strong>注意，系统一定要配置好 jdk，测试一下 java 和 javac 两个命令要存在。</strong></p><p>Nacos 启动成功后，浏览器输入：<a href="http://192.168.91.128:8848/nacos" target="_blank" rel="noopener">http://192.168.91.128:8848/nacos</a> 就能看到启动页面。</p><p>如果有登录页面，登录的默认用户名/密码都是 nacos。</p><p>先来看配置中心，类似于 Spring Cloud Config</p><p>首先在服务端配置，点击配置管理-&gt;配置列表-&gt;+</p><p>这里主要配置三个东西，Data ID、Group 以及要配置的内容。</p><p>Data Id 的格式是 <code>${prefix}-${spring.profile.active}.${file-extension}</code></p><p>${prefix} 的值，默认为 spring.application.name 的值<br>${spring.profile.active} 表示项目当前所处的和环境<br>${file-extension} 表示配置文件的扩展名</p><p>配置完成后，新建 Spring Boot 项目，加入 Nacos 依赖：</p><p><img src="http://img.itboyhub.com//2020/03/nacos-1.png" alt></p><p>然后，新建 bootstrap.properties 配置文件，配置 nacos 信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=nacos</span><br><span class="line">spring.cloud.nacos.server-addr=192.168.91.128:8848</span><br><span class="line">spring.cloud.nacos.config.file-extension=properties</span><br></pre></td></tr></table></figure><p>最后再提供一个测试 Controller：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RefreshScope</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;name&#125;"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-注册中心"><a href="#2-注册中心" class="headerlink" title="2. 注册中心"></a>2. 注册中心</h2><p>Nacos 做注册中心，可以代替 Eureka。</p><p>创建 Spring Boot 项目，添加依赖：</p><p><img src="http://img.itboyhub.com//2020/03/nacos-2.png" alt></p><p>添加配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=nacos01</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=192.168.91.128:8848</span><br></pre></td></tr></table></figure><p>然后再提供一个测试 Controller：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello:"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将项目打包，启动两个实例。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure><p>这样，两个 provider 实例就启动了。</p><p>再来创建一个 consumer ，配置基本与 nacos01 一致。然后再 consumer 中访问 provider 查看负载均衡效果，具体小伙伴们参考视频，我就不重复写啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 的问题我先说一下，视频和文章松哥都在积极准备中，因为都是业余搞，每天下班后都是火急火燎，为了给小伙伴们呈现一段完美的表演，每一个视频都要花不少时间，所以新一期的 Spring Security 估计下周能和小伙伴们见面。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
      <category term="Nacos" scheme="http://www.javaboy.org/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你用 Redis 做延迟消息队列</title>
    <link href="http://www.javaboy.org/2020/0326/redis-delay-queue.html"/>
    <id>http://www.javaboy.org/2020/0326/redis-delay-queue.html</id>
    <published>2020-03-26T02:06:54.000Z</published>
    <updated>2020-03-27T03:39:30.995Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。</p><a id="more"></a><p>松哥之前也有两篇介绍的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a></li><li><a href="https://mp.weixin.qq.com/s/SMPyyZlRvvKM-kSMbOOQAw" target="_blank" rel="noopener">Spring Boot 整合 RabbitMQ，消息重复消费怎么办？</a></li></ol><p>但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接使用 Redis 来做消息队列。</p><p>Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极高的追求，那么不适合使用 Redis 做消息队列。</p><p>好了，我们一起来撸代码（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>）：</p><p><a href="https://mp.weixin.qq.com/s/ej_9f4iBOAEPIXxxhFcm-A" target="_blank" rel="noopener">视频地址</a></p><p>以下是视频笔记：</p><h2 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列"></a>1.消息队列</h2><p>Redis 做消息队列，使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入队，然后使用 lpop/rpop 来实现出队。</p><p>回顾一下：</p><p><img src="http://img.itboyhub.com/2020/03/redis-7-1.png" alt></p><p>在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop 。</p><h2 id="2-延迟消息队列"><a href="#2-延迟消息队列" class="headerlink" title="2.延迟消息队列"></a>2.延迟消息队列</h2><p>延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，然后通过轮询的方式，去不断的读取消息出来。</p><p>首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们使用 JSON 来实现序列化和反序列化。</p><p>所以，首先在项目中，添加 JSON 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，构造一个消息对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"JavaboyMessage&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"id='"</span> + id + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", data="</span> + data +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来封装一个消息队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayMsgQueue</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="hljs-keyword">private</span> String queue;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelayMsgQueue</span><span class="hljs-params">(Jedis jedis, String queue)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="hljs-keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 消息入队</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 要发送的消息</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queue</span><span class="hljs-params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//构造一个 JavaboyMessage</span></span><br><span class="line">        JavaboyMessage msg = <span class="hljs-keyword">new</span> JavaboyMessage();</span><br><span class="line">        msg.setId(UUID.randomUUID().toString());</span><br><span class="line">        msg.setData(data);</span><br><span class="line">        <span class="hljs-comment">//序列化</span></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(msg);</span><br><span class="line">            System.out.println(<span class="hljs-string">"msg publish:"</span> + <span class="hljs-keyword">new</span> Date());</span><br><span class="line">            <span class="hljs-comment">//消息发送，score 延迟 5 秒</span></span><br><span class="line">            jedis.zadd(queue, System.currentTimeMillis() + <span class="hljs-number">5000</span>, s);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 消息消费</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="hljs-comment">//读取 score 在 0 到当前时间戳之间的消息</span></span><br><span class="line">            Set&lt;String&gt; zrange = jedis.zrangeByScore(queue, <span class="hljs-number">0</span>, System.currentTimeMillis(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (zrange.isEmpty()) &#123;</span><br><span class="line">                <span class="hljs-comment">//如果消息是空的，则休息 500 毫秒然后继续</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">500</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//如果读取到了消息，则直接读取消息出来</span></span><br><span class="line">            String next = zrange.iterator().next();</span><br><span class="line">            <span class="hljs-keyword">if</span> (jedis.zrem(queue, next) &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//抢到了，接下来处理业务</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    JavaboyMessage msg = <span class="hljs-keyword">new</span> ObjectMapper().readValue(next, JavaboyMessage.class);</span><br><span class="line">                    System.out.println(<span class="hljs-string">"receive msg:"</span> + msg);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayMsgTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="hljs-keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis -&gt; &#123;</span><br><span class="line">            <span class="hljs-comment">//构造一个消息队列</span></span><br><span class="line">            DelayMsgQueue queue = <span class="hljs-keyword">new</span> DelayMsgQueue(jedis, <span class="hljs-string">"javaboy-delay-queue"</span>);</span><br><span class="line">            <span class="hljs-comment">//构造消息生产者</span></span><br><span class="line">            Thread producer = <span class="hljs-keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">                        queue.queue(<span class="hljs-string">"www.javaboy.org&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="hljs-comment">//构造一个消息消费者</span></span><br><span class="line">            Thread consumer = <span class="hljs-keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    queue.loop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="hljs-comment">//启动</span></span><br><span class="line">            producer.start();</span><br><span class="line">            consumer.start();</span><br><span class="line">            <span class="hljs-comment">//休息 7 秒后，停止程序</span></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">7000</span>);</span><br><span class="line">                consumer.interrupt();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们利用 Java 代码结合 Redis 中的 zset 就非常方便的实现了延迟消息队列。</p><p><strong>小伙伴们有没有 GET 到呢？如果感觉有收获，记得点一下右下角的在看哦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手带你入门 Spring Security，别再问密码怎么解密了</title>
    <link href="http://www.javaboy.org/2020/0325/spring-security-form-login.html"/>
    <id>http://www.javaboy.org/2020/0325/spring-security-form-login.html</id>
    <published>2020-03-25T02:06:39.000Z</published>
    <updated>2020-03-27T03:03:03.797Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前有小伙伴在松哥群里讨论如何给微人事的密码解密，我看到聊天记录后就惊呆了。</p><p>无论如何我也得写一篇文章，带大家入门 Spring Security!当我们在一个项目中引入 Spring Security 相关依赖后，默认的就是表单登录，因此我们就从表单登录开始讲起。</p><a id="more"></a><p><strong>Spring Security 初体验</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV117411y7Wc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p><strong>通过 Java 类定义用户</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV1m7411y7Jw&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p><strong>自定义登录表单</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV1m7411y77X&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><h2 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h2><p>首先新建一个 Spring Boot 项目，创建时引入 Spring Security 依赖和 web 依赖，如下图：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-1.png" alt></p><p>项目创建成功后，Spring Security 的依赖就添加进来了，在 Spring Boot 中我们加入的是 <code>spring-boot-starter-security</code> ，其实主要是这两个：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-2.png" alt></p><p>项目创建成功后，我们添加一个测试的 HelloController，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来什么事情都不用做，我们直接来启动项目。</p><p>在项目启动过程中，我们会看到如下一行日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: 30abfb1f-36e1-446a-a79b-f70024f589ab</span><br></pre></td></tr></table></figure><p>这就是 Spring Security 为默认用户 user 生成的临时密码，是一个 UUID 字符串。</p><p>接下来我们去访问 <code>http://localhost:8080/hello</code> 接口，就可以看到自动重定向到登录页面了：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-3.png" alt></p><p>在登录页面，默认的用户名就是 user，默认的登录密码则是项目启动时控制台打印出来的密码，输入用户名密码之后，就登录成功了，登录成功后，我们就可以访问到 /hello 接口了。</p><p>在 Spring Security 中，默认的登录页面和登录接口，都是 <code>/login</code> ，只不过一个是 get 请求（登录页面），另一个是 post 请求（登录接口）。</p><p><strong>大家可以看到，非常方便，一个依赖就保护了所有接口。</strong></p><p>有人说，你怎么知道知道生成的默认密码是一个 UUID 呢？</p><p>这个其实很好判断。</p><p>和用户相关的自动化配置类在 <code>UserDetailsServiceAutoConfiguration</code> 里边，在该类的 <code>getOrDeducePassword</code> 方法中，我们看到如下一行日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (user.isPasswordGenerated()) &#123;</span><br><span class="line">logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，我们在控制台看到的日志就是从这里打印出来的。打印的条件是 isPasswordGenerated 方法返回 true，即密码是默认生成的。</p><p>进而我们发现，user.getPassword 出现在 SecurityProperties 中，在 SecurityProperties 中我们看到如下定义：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default user name.</span><br><span class="line"> */</span><br><span class="line">private String name = &quot;user&quot;;</span><br><span class="line">/**</span><br><span class="line"> * Password for the default user name.</span><br><span class="line"> */</span><br><span class="line">private String password = UUID.randomUUID().toString();</span><br><span class="line">private boolean passwordGenerated = true;</span><br></pre></td></tr></table></figure><p>可以看到，默认的用户名就是 user，默认的密码则是 UUID，而默认情况下，passwordGenerated 也为 true。</p><h2 id="2-用户配置"><a href="#2-用户配置" class="headerlink" title="2.用户配置"></a>2.用户配置</h2><p>默认的密码有一个问题就是每次重启项目都会变，这很不方便。</p><p>在正式介绍数据库连接之前，松哥先和大家介绍两种非主流的用户名/密码配置方案。</p><h3 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h3><p>我们可以在 application.properties 中配置默认的用户名密码。</p><p>怎么配置呢？大家还记得上一小节我们说的 SecurityProperties，默认的用户就定义在它里边，是一个静态内部类，我们如果要定义自己的用户名密码，必然是要去覆盖默认配置，我们先来看下 SecurityProperties 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.security"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>这就很清晰了，我们只需要以 spring.security.user 为前缀，去定义用户名密码即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>这就是我们新定义的用户名密码。</p><p>在 properties 中定义的用户名密码最终是通过 set 方法注入到属性中去的，这里我们顺便来看下 SecurityProperties.User#setPassword 方法:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.passwordGenerated = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。</p><p>此时重启项目，就可以使用自己定义的用户名/密码登录了。</p><h3 id="2-2-配置类"><a href="#2-2-配置类" class="headerlink" title="2.2 配置类"></a>2.2 配置类</h3><p>除了上面的配置文件这种方式之外，我们也可以在配置类中配置用户名/密码。</p><p>在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。</p><p>考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。</p><h4 id="2-2-1-为什么要加密"><a href="#2-2-1-为什么要加密" class="headerlink" title="2.2.1 为什么要加密"></a>2.2.1 为什么要加密</h4><p>2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p><p>这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：</p><ul><li><code>ppnn13%dkstFeb.1st</code> 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。</li><li><code>csbt34.ydhl12s</code> 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声</li><li>…</li></ul><p>等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。</p><h4 id="2-2-2-加密方案"><a href="#2-2-2-加密方案" class="headerlink" title="2.2.2 加密方案"></a>2.2.2 加密方案</h4><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p><p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。 </p><p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p><p>不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。</p><p>而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。</p><h4 id="2-2-3-PasswordEncoder"><a href="#2-2-3-PasswordEncoder" class="headerlink" title="2.2.3 PasswordEncoder"></a>2.2.3 PasswordEncoder</h4><p>PasswordEncoder 这个接口中就定义了三个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>encode 方法用来对明文密码进行加密，返回加密之后的密文。</li><li>matches 方法是一个密码校对方法，在用户登录的时候，将用户传来的明文密码和数据库中保存的密文密码作为参数，传入到这个方法中去，根据返回的 Boolean 值判断用户密码是否输入正确。</li><li>upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。</li></ol><p>通过下图我们可以看到 PasswordEncoder 的实现类：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-4.png" alt></p><h4 id="2-2-4-配置"><a href="#2-2-4-配置" class="headerlink" title="2.2.4 配置"></a>2.2.4 配置</h4><p>预备知识讲完后，接下来我们来看具体如何配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy.org"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先我们自定义 SecurityConfig 继承自 WebSecurityConfigurerAdapter，重写里边的 configure 方法。</li><li>首先我们提供了一个 PasswordEncoder 的实例，因为目前的案例还比较简单，因此我暂时先不给密码进行加密，所以返回 NoOpPasswordEncoder 的实例即可。</li><li>configure 方法中，我们通过 inMemoryAuthentication 来开启在内存中定义用户，withUser 中是用户名，password 中则是用户密码，roles 中是用户角色。</li><li>如果需要配置多个用户，用 and 相连。</li></ol><p>为什么用 and 相连呢？</p><blockquote><p>在没有 Spring Boot 的时候，我们都是 SSM 中使用 Spring Security，这种时候都是在 XML 文件中配置 Spring Security，既然是 XML 文件，标签就有开始有结束，现在的 and 符号相当于就是 XML 标签的结束符，表示结束当前标签，这是个时候上下文会回到 inMemoryAuthentication 方法中，然后开启新用户的配置。</p></blockquote><p>配置完成后，再次启动项目，Java 代码中的配置会覆盖掉 XML 文件中的配置，此时再去访问 /hello 接口，就会发现只有 Java 代码中的用户名/密码才能访问成功。</p><h2 id="3-自定义表单登录页"><a href="#3-自定义表单登录页" class="headerlink" title="3.自定义表单登录页"></a>3.自定义表单登录页</h2><p>默认的表单登录有点丑（实际上现在默认的表单登录比以前的好多了，以前的更丑）。</p><p>但是很多时候我们依然绝对这个登录页面有点丑，那我们可以自定义一个登录页面。</p><p>一起来看下。</p><h3 id="3-1-服务端定义"><a href="#3-1-服务端定义" class="headerlink" title="3.1 服务端定义"></a>3.1 服务端定义</h3><p>然后接下来我们继续完善前面的 SecurityConfig 类，继续重写它的 <code>configure(WebSecurity web)</code> 和 <code>configure(HttpSecurity http)</code> 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/images/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。</li><li>如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 <code>&lt;http&gt;</code>，HttpSecurity 提供的配置方法 都对应了该标签。</li><li>authorizeRequests 对应了 <code>&lt;intercept-url&gt;</code>。</li><li>formLogin 对应了 <code>&lt;formlogin&gt;</code>。</li><li>and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。</li><li>permitAll 表示登录相关的页面/接口不要被拦截。</li><li>最后记得关闭 csrf ，关于 csrf 问题我到后面专门和大家说。</li></ol><p>当我们定义了登录页面为 /login.html 的时候，Spring Security 也会帮我们自动注册一个 /login.html 的接口，这个接口是 POST 请求，用来处理登录逻辑。</p><h3 id="3-2-前端定义"><a href="#3-2-前端定义" class="headerlink" title="3.2 前端定义"></a>3.2 前端定义</h3><p>松哥这里准备了一个还过得去的登录页面，如下：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-6.png" alt></p><p>我们将登录页面的相关静态文件拷贝到 Spring Boot 项目的 resources/static 目录下：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-7.png" alt></p><p>前端页面比较长，这里我把核心部分列出来（完整代码我会上传到 GitHub：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a>）：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login.html"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"pass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>form 表单中，注意 action 为 <code>/login.html</code> ，其他的都是常规操作，我就不重复介绍了。</p><p>好了，配置完成后，再去重启项目，此时访问任意页面，就会自动重定向到我们定义的这个页面上来，输入用户名密码就可以重新登录了。</p><h2 id="4-小节"><a href="#4-小节" class="headerlink" title="4.小节"></a>4.小节</h2><p>这篇文章和大家简单聊一下 Spring Security 入门，表单配置还有很多细节，下篇文章我们继续。</p><p><strong>如果文章帮助到小伙伴了，记得右下角点个在看哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前有小伙伴在松哥群里讨论如何给微人事的密码解密，我看到聊天记录后就惊呆了。&lt;/p&gt;
&lt;p&gt;无论如何我也得写一篇文章，带大家入门 Spring Security!当我们在一个项目中引入 Spring Security 相关依赖后，默认的就是表单登录，因此我们就从表单登录开始讲起。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>挖一个大坑，Spring Security 开搞！</title>
    <link href="http://www.javaboy.org/2020/0324/spring-security-guide.html"/>
    <id>http://www.javaboy.org/2020/0324/spring-security-guide.html</id>
    <published>2020-03-24T02:06:13.000Z</published>
    <updated>2020-03-27T03:18:20.399Z</updated>
    
    <content type="html"><![CDATA[<p>自从 Spring Boot、Spring Cloud 火起来之后，Spring Security 也跟着沾了一把光！</p><a id="more"></a><p>其实我一直觉得 Spring Security 是一个比 Shiro 优秀很多的权限管理框架，但是重量级、配置繁琐、门槛高这些问题一直困扰着 Spring Security 的开发者，也让很多初学者望而却步。直到 Spring Boot 横空出世，这些问题统统都得到缓解。</p><p>在 Spring Boot 或者 Spring Cloud 中，如果想选择一个权限管理框架，几乎毫无疑问的选择 Spring Security，Shiro 在这个环境下已经不具备优势了。</p><p>但是市面上关于 Spring Security 成体系的教程很少，大部分都比较零散，因此，松哥就来劲了，我想把自己这几年使用 Spring Security 的经验整理一下，写一个系列教程，从基本用法，到 OAuth2 再到 Spring Social 对接，都涉及到，目前暂定是图文+视频的形式发布，会在公众号【江南一点雨】上首发，欢迎小伙伴们保持关注。</p><p>这是一个略显宏大的工程，也是松哥比较擅长的事情，因为各种系列教程已经出的太多了。当然，因为工程量比较大，因此需要小伙伴们多给松哥一点时间。</p><h2 id="1-现有资料"><a href="#1-现有资料" class="headerlink" title="1.现有资料"></a>1.现有资料</h2><p>关于 Spring Security，松哥也不是第一次写/录了，但是之前的教程都不够完整，所以我才想出一个完整的，已有的教程主要是两方面的：</p><ol><li>松哥网站上的图文教程</li></ol><p>在网站 <a href="http://www.javaboy.org">www.javaboy.org</a> 上，有一个 Spring Boot 模块，里边的安全管理一栏中，松哥大概写了十篇左右的文章来介绍 Spring Security 。当然这个教程也有离线版，大家在公众号【江南一点雨】的后台回复 SpringBoot，可以获取这个教程的 PDF 版。</p><ol start="2"><li>松哥录制的视频教程</li></ol><p>第二个就是松哥之前录制的 Spring Boot 系列视频教程里边的第十章，视频目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─第 10 章 Spring Boot 安全管理</span><br><span class="line">│      01.安全管理介绍.mp4</span><br><span class="line">│      02.Spring  Security 初体验.mp4</span><br><span class="line">│      03.手工配置用户名密码.mp4</span><br><span class="line">│      04.HttpSecurity 配置.mp4</span><br><span class="line">│      05.登录表单详细配置.mp4</span><br><span class="line">│      06.注销登录配置.mp4</span><br><span class="line">│      07.多个 HttpSecurity.mp4</span><br><span class="line">│      08.密码加密.mp4</span><br><span class="line">│      09.方法安全.mp4</span><br><span class="line">│      10.基于数据库的认证.mp4</span><br><span class="line">│      11.角色继承.mp4</span><br><span class="line">│      12.动态配置权限.mp4</span><br><span class="line">│      13.OAuth2 简介.mp4</span><br><span class="line">│      14.Spring Security 结合 OAuth2.mp4</span><br><span class="line">│      15.整合 Shiro 方式一.mp4</span><br><span class="line">│      16.整合 Shiro 方式二.mp4</span><br><span class="line">│      17.Spring Security 使用 JSON 登录.mp4</span><br></pre></td></tr></table></figure><p>这个视频是为了微人事项目提供支持的，也就是做微人事项目，这系列视频里边录制的知识点够用了。如果大家对这套视频感兴趣，可以查看这里👉<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">松哥自制视频教程</a></p><p>这是松哥之前提供的 Spring Security 相关的教程。</p><h2 id="2-Spring-Security-介绍"><a href="#2-Spring-Security-介绍" class="headerlink" title="2. Spring Security 介绍"></a>2. Spring Security 介绍</h2><p>Java 领域老牌的权限管理框架当属 Shiro 了。</p><p>Shiro 有着众多的优点，例如轻量、简单、易于集成等。</p><p>当然 Shiro 也有不足，例如对 OAuth2 支持不够，在 Spring Boot 面前无法充分展示自己的优势等等，特别是随着现在 Spring Boot 和 Spring Cloud 的流行，Spring Security 正在走向舞台舞台中央。</p><h3 id="2-1-陈年旧事"><a href="#2-1-陈年旧事" class="headerlink" title="2.1 陈年旧事"></a>2.1 陈年旧事</h3><p>Spring Security 最早不叫 Spring Security ，叫 Acegi Security，叫 Acegi Security 并不是说它和 Spring 就没有关系了，它依然是为 Spring 框架提供安全支持的。事实上，Java 领域的框架，很少有框架能够脱离 Spring 框架独立存在。</p><p>Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理，但是最广为人诟病的则是它臃肿繁琐的配置，这一问题最终也遗传给了 Spring Security。</p><p>在 Acegi Security 时代，网上流传一句话：“每当有人要使用 Acegi Security，就会有一个精灵死去。”足见 Acegi Security 的配置是多么可怕。</p><p>当 Acegi Security 投入 Spring 怀抱之后，先把这个名字改了，这就是大家所见到的 Spring Security 了，然后配置也得到了极大的简化。</p><p>但是和 Shiro 相比，人们对 Spring Security 的评价依然中重量级、配置繁琐。</p><p>直到有一天 Spring Boot 像谜一般出现在江湖边缘，彻底颠覆了 JavaEE 的世界。一人得道鸡犬升天，Spring Security 也因此飞上枝头变凤凰。</p><p>到现在，要不要学习 Spring Security 已经不是问题了，无论是 Spring Boot 还是 Spring Cloud，你都有足够多的机会接触到 Spring Security，现在的问题是如何快速掌握 Spring Security？那么看松哥的教程就对了。</p><h3 id="2-2-核心功能"><a href="#2-2-核心功能" class="headerlink" title="2.2 核心功能"></a>2.2 核心功能</h3><p>对于一个权限管理框架而言，无论是 Shiro 还是 Spring Security，最最核心的功能，无非就是两方面：</p><ul><li>认证</li><li>授权</li></ul><p>通俗点说，认证就是我们常说的登录，授权就是权限鉴别，看看请求是否具备相应的权限。</p><p>虽然就是一个简简单单的登录，可是也能玩出很多花样来。</p><p>Spring Security 支持多种不同的认证方式，这些认证方式有的是 Spring Security 自己提供的认证功能，有的是第三方标准组织制订的，主要有如下一些：</p><p>一些比较常见的认证方式：</p><ul><li>HTTP BASIC authentication headers：基于IETF RFC 标准。</li><li>HTTP Digest authentication headers：基于IETF RFC 标准。</li><li>HTTP X.509 client certificate exchange：基于IETF RFC 标准。</li><li>LDAP：跨平台身份验证。</li><li>Form-based authentication：基于表单的身份验证。</li><li>Run-as authentication：用户用户临时以某一个身份登录。</li><li>OpenID authentication：去中心化认证。</li></ul><p>除了这些常见的认证方式之外，一些比较冷门的认证方式，Spring Security 也提供了支持。</p><ul><li>Jasig Central Authentication Service：单点登录。</li><li>Automatic “remember-me” authentication：记住我登录（允许一些非敏感操作）。</li><li>Anonymous authentication：匿名登录。</li><li>……</li></ul><p>作为一个开放的平台，Spring Security 提供的认证机制不仅仅是上面这些。如果上面这些认证机制依然无法满足你的需求，我们也可以自己定制认证逻辑。当我们需要和一些“老破旧”的系统进行集成时，自定义认证逻辑就显得非常重要了。</p><p>除了认证，剩下的就是授权了。</p><p>Spring Security 支持基于 URL 的请求授权（例如微人事）、支持方法访问授权以及对象访问授权。</p><h2 id="3-怎么学"><a href="#3-怎么学" class="headerlink" title="3.怎么学"></a>3.怎么学</h2><p>安全这一块从来都有说不完的话题，一个简单的注册登录很好做，但是你要是考虑到各种各样的攻击，XSS、CSRF 等等，一个简单的注册登录也能做的很复杂。</p><p>幸运的是，即使你对各种攻击不太熟悉，只要你用了 Spring Security，就能自动避免掉很多攻击了，因为 Spring Security 已经自动帮我们完成很多防护了。</p><p>从这个角度讲，我们学习 Spring Security，不仅仅是学习 Spring Security 的各种用法，也是去了解去熟悉各种网络攻击。</p><p>松哥在未来，将会通过文章+视频的形式来向小伙伴们逐一展示 Spring Security 的用法，从基本的注册登录，到复杂的 OAuth2、Spring Social 登录等，都会和大家介绍。</p><p>本教程会默认大家有 Spring Boot 基础，如果小伙伴们对 Spring Boot 尚不熟悉，可以在公众号【江南一点雨】后台回复 SpringBoot，获取松哥纯手敲 Spring Boot 教程。</p><p>好了，本文就当是一个引子吧，下篇文章我们就开干。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从 Spring Boot、Spring Cloud 火起来之后，Spring Security 也跟着沾了一把光！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>微人事首页加载速度提高了 5 倍，我都做了什么？</title>
    <link href="http://www.javaboy.org/2020/0324/spring-boot-vue-nginx.html"/>
    <id>http://www.javaboy.org/2020/0324/spring-boot-vue-nginx.html</id>
    <published>2020-03-24T02:05:57.000Z</published>
    <updated>2020-03-27T03:17:51.094Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文之前发过，但是比较零散，这里我把用到的方案都汇总一下，方便大家索引，有需要的小伙伴可以收藏下方便查找。里边提到的几种方案，大家都可以对照着视频试一下</strong></p><a id="more"></a><p>问题重现：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1XE411c7u6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>ElementUI 按需加载：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c71o&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>SpringBoot 开启 gzip：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c7Wz&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>Nginx 开启 gzip：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c7NC&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>前后端分离项目如果做成 SPA（单页面）的形式，就必然面临一个首屏加载的问题，因为默认情况下首页文件比较大，可能超过 1 MB，进而带来首页加载很慢的问题。所以我们要通过优化，来提高首页的加载速度。</p><p>问题的解决，一般来说有这样几种思路：</p><ol><li>UI 组件按需加载</li><li>路由懒加载</li><li>组件重复打包</li><li>gzip</li></ol><p>这些加载方式中，UI 组件按需加载和 gzip 是两种比较常用的方案，另外两种优化方式则要结合具体的项目，看看是否具备相关条件。</p><p>所以，本文松哥就先来和大家聊一聊 UI 组件懒加载和 gzip。</p><h2 id="1-ElementUI-按需加载"><a href="#1-ElementUI-按需加载" class="headerlink" title="1. ElementUI 按需加载"></a>1. ElementUI 按需加载</h2><h3 id="1-1-问题复现"><a href="#1-1-问题复现" class="headerlink" title="1.1 问题复现"></a>1.1 问题复现</h3><p>先来看松哥录制的一段视频：</p><!--more--><p>不做任何优化，我们一般是在 main.js 中按照如下方式来引入 ElementUI 的：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line">Vue.use(ElementUI,&#123;<span class="hljs-attr">size</span>:<span class="hljs-string">'small'</span>&#125;);</span><br></pre></td></tr></table></figure><p>css 这个不用说，肯定得引入。但是按照上面这种引入方式，除了 css，其他组件全部都引入到项目中了，最新版的 ElementUI 中的组件已经接近 60 个了，但是我们项目中用的组件可能没有这么多，这些最终没用上的组件就会造成资源浪费。</p><p>在不做任何优化的情况下，我们通过如下命令对项目生成 report.html 用来帮助我们分析包内容：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-cli-service build --report</span><br></pre></td></tr></table></figure><p>该命令执行的日志如下(截取了关键部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> warning  </span><br><span class="line"></span><br><span class="line">entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.</span><br><span class="line">Entrypoints:</span><br><span class="line">  app (1.17 MiB)</span><br><span class="line">      css/chunk-vendors.9948ce82.css</span><br><span class="line">      js/chunk-vendors.11959501.js</span><br><span class="line">      css/app.4e8a7623.css</span><br><span class="line">      js/app.ce6f575c.js</span><br><span class="line"></span><br><span class="line">  File                                    Size              Gzipped</span><br><span class="line"></span><br><span class="line">  dist/js/chunk-vendors.11959501.js       840.77 KiB        227.94 KiB</span><br><span class="line">  dist/js/app.ce6f575c.js                 99.08 KiB         30.95 KiB</span><br><span class="line">  dist/js/chunk-64435448.d0a0516e.js      26.52 KiB         5.87 KiB</span><br><span class="line">  dist/js/chunk-0c17a57a.d553638c.js      23.79 KiB         5.49 KiB</span><br><span class="line">  dist/js/chunk-a3fdbb9c.ddc4c008.js      13.30 KiB         3.45 KiB</span><br><span class="line">  dist/js/chunk-54277bc7.2882c4cd.js      10.40 KiB         2.95 KiB</span><br><span class="line">  dist/js/chunk-4e552d82.c64f4d10.js      1.78 KiB          0.63 KiB</span><br><span class="line">  dist/js/chunk-18458ebc.32fb57c9.js      1.54 KiB          0.62 KiB</span><br><span class="line">  dist/js/chunk-2d0d03c8.3a093d55.js      0.52 KiB          0.36 KiB</span><br><span class="line">  dist/js/chunk-2d237c54.0b312051.js      0.43 KiB          0.33 KiB</span><br><span class="line">  dist/css/chunk-vendors.9948ce82.css     258.19 KiB        41.36 KiB</span><br><span class="line">  dist/css/app.4e8a7623.css               3.46 KiB          1.09 KiB</span><br><span class="line">  dist/css/chunk-0c17a57a.9fe19f94.css    0.86 KiB          0.35 KiB</span><br><span class="line">  dist/css/chunk-64435448.3755e146.css    0.30 KiB          0.15 KiB</span><br></pre></td></tr></table></figure><p>从这段日志中我们可以看到，项目入口文件的大小超出了官方建议的 244KB，而这可能会影响网页的表现。</p><p>此时我们把打包后的文件拷贝到 Spring Boot 的 resources/static 目录下，启动后端项目，来看下浏览器的加载情况：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-1.png" alt></p><p>可以看到，最大的 chunk-vendors.11959501.js 文件加载用了 369ms。</p><p>同时大家注意到，此时在前端 dist 目录下还有一个文件叫做 report.html，这是生成的打包报告，我们在浏览器打开这个页面，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-2.png" alt></p><p>在这个 html 页面中，通过可视化页面向我们展示了到底是谁把 js 文件撑大的，从图中我们可以看到，chunk-vendors.11959501.js 文件之所以比较大，是因为它里边的 element-ui.commons.js 这个文件比较大。</p><blockquote><p>实际上，每个模块都可以去想办法优化，但是枪打出头鸟，因为 element-ui.commons.js 实在太大了，我们就先把它给优化了。</p></blockquote><h3 id="1-2-问题解决"><a href="#1-2-问题解决" class="headerlink" title="1.2 问题解决"></a>1.2 问题解决</h3><p>优化办法其实很简单，ElementUI 官网也给出了办法，首先我们加载安装 babel-plugin-component：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure><p>然后修改 babel.config.js 文件，如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        <span class="hljs-string">'@vue/app'</span>,</span><br><span class="line">        [<span class="hljs-string">'@babel/preset-env'</span>, &#123;</span><br><span class="line">            modules: <span class="hljs-literal">false</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [</span><br><span class="line">            <span class="hljs-string">"component"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-string">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>,</span><br><span class="line">                <span class="hljs-string">"styleLibraryName"</span>: <span class="hljs-string">"theme-chalk"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，再去修改 main.js 文件，将我们需要用到的组件一个一个引入进来：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123;</span><br><span class="line">    Button,</span><br><span class="line">    Input,</span><br><span class="line">    Table,</span><br><span class="line">    TableColumn,</span><br><span class="line">    Dialog,</span><br><span class="line">    Card,</span><br><span class="line">    Container,</span><br><span class="line">    Icon,</span><br><span class="line">    Select,</span><br><span class="line">    Form,</span><br><span class="line">    Tag,</span><br><span class="line">    Tree,</span><br><span class="line">    Pagination,</span><br><span class="line">    Badge,</span><br><span class="line">    Loading,</span><br><span class="line">    Message,</span><br><span class="line">    MessageBox,</span><br><span class="line">    Menu,</span><br><span class="line">    Tabs,</span><br><span class="line">    TabPane,</span><br><span class="line">    Breadcrumb,</span><br><span class="line">    BreadcrumbItem,</span><br><span class="line">    Dropdown,</span><br><span class="line">    Steps,</span><br><span class="line">    Tooltip,</span><br><span class="line">    Popover,</span><br><span class="line">    Collapse,</span><br><span class="line">    FormItem,</span><br><span class="line">    Checkbox,</span><br><span class="line">    Header,</span><br><span class="line">    DropdownMenu,</span><br><span class="line">    DropdownItem,</span><br><span class="line">    Aside,</span><br><span class="line">    Main,</span><br><span class="line">    MenuItem,</span><br><span class="line">    Submenu,</span><br><span class="line">    Option,</span><br><span class="line">    Col,</span><br><span class="line">    Row,</span><br><span class="line">    Upload,</span><br><span class="line">    Radio,</span><br><span class="line">    DatePicker,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    CollapseItem,</span><br><span class="line">    Switch</span><br><span class="line">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line">Vue.prototype.$ELEMENT = &#123;<span class="hljs-attr">size</span>: <span class="hljs-string">'small'</span>, <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3000</span>&#125;;</span><br><span class="line">Vue.use(Switch);</span><br><span class="line">Vue.use(CollapseItem);</span><br><span class="line">Vue.use(Radio);</span><br><span class="line">Vue.use(RadioGroup);</span><br><span class="line">Vue.use(DatePicker);</span><br><span class="line">Vue.use(Upload);</span><br><span class="line">Vue.use(Row);</span><br><span class="line">Vue.use(Col);</span><br><span class="line">Vue.use(Option);</span><br><span class="line">Vue.use(Submenu);</span><br><span class="line">Vue.use(MenuItem);</span><br><span class="line">Vue.use(Header);</span><br><span class="line">Vue.use(DropdownMenu);</span><br><span class="line">Vue.use(DropdownItem);</span><br><span class="line">Vue.use(Aside);</span><br><span class="line">Vue.use(Main);</span><br><span class="line">Vue.use(Checkbox);</span><br><span class="line">Vue.use(FormItem);</span><br><span class="line">Vue.use(Collapse);</span><br><span class="line">Vue.use(Popover);</span><br><span class="line">Vue.use(Menu);</span><br><span class="line">Vue.use(Tabs);</span><br><span class="line">Vue.use(TabPane);</span><br><span class="line">Vue.use(Breadcrumb);</span><br><span class="line">Vue.use(BreadcrumbItem);</span><br><span class="line">Vue.use(Dropdown);</span><br><span class="line">Vue.use(Steps);</span><br><span class="line">Vue.use(Tooltip);</span><br><span class="line">Vue.use(Tree);</span><br><span class="line">Vue.use(Pagination);</span><br><span class="line">Vue.use(Badge);</span><br><span class="line">Vue.use(Loading);</span><br><span class="line">Vue.use(Button);</span><br><span class="line">Vue.use(Input);</span><br><span class="line">Vue.use(Table);</span><br><span class="line">Vue.use(TableColumn);</span><br><span class="line">Vue.use(Dialog);</span><br><span class="line">Vue.use(Card);</span><br><span class="line">Vue.use(Container);</span><br><span class="line">Vue.use(Icon);</span><br><span class="line">Vue.use(Select);</span><br><span class="line">Vue.use(Form);</span><br><span class="line">Vue.use(Tag);</span><br><span class="line">Vue.prototype.$alert = MessageBox.alert</span><br><span class="line">Vue.prototype.$confirm = MessageBox.confirm</span><br></pre></td></tr></table></figure><p>这里的代码倒是不难，有两个需要注意的地方：</p><ol><li>MessageBox 的引入方式和其他组件不太一样，需要注意。</li><li>给组件统一定制 size 和 zIndex 的方式有所变化。</li></ol><p>配置完成后，我们再次执行 <code>vue-cli-service build --report</code> ，查看打包结果：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.</span><br><span class="line">Entrypoints:</span><br><span class="line">  app (1.03 MiB)</span><br><span class="line">      css/chunk-vendors.26d2c5b9.css</span><br><span class="line">      js/chunk-vendors.e2a11728.js</span><br><span class="line">      css/app.4e8a7623.css</span><br><span class="line">      js/app.c5dd78e5.js</span><br><span class="line"></span><br><span class="line">  File                                    Size              Gzipped</span><br><span class="line"></span><br><span class="line">  dist/js/chunk-vendors.e2a11728.js       683.05 KiB        177.91 KiB</span><br><span class="line">  dist/js/app.c5dd78e5.js                 101.70 KiB        31.90 KiB</span><br><span class="line">  dist/js/chunk-64435448.d0a0516e.js      26.52 KiB         5.87 KiB</span><br><span class="line">  dist/js/chunk-0c17a57a.d553638c.js      23.79 KiB         5.49 KiB</span><br><span class="line">  dist/js/chunk-33b8cd94.7bbae1a0.js      13.30 KiB         3.46 KiB</span><br><span class="line">  dist/js/chunk-df7e035a.414b548f.js      10.40 KiB         2.95 KiB</span><br><span class="line">  dist/js/chunk-4e552d82.c64f4d10.js      1.78 KiB          0.63 KiB</span><br><span class="line">  dist/js/chunk-18458ebc.32fb57c9.js      1.54 KiB          0.62 KiB</span><br><span class="line">  dist/js/chunk-2d0d03c8.3a093d55.js      0.52 KiB          0.36 KiB</span><br><span class="line">  dist/js/chunk-2d237c54.0b312051.js      0.43 KiB          0.33 KiB</span><br><span class="line">  dist/css/chunk-vendors.26d2c5b9.css     262.71 KiB        42.11 KiB</span><br><span class="line">  dist/css/app.4e8a7623.css               3.46 KiB          1.09 KiB</span><br><span class="line">  dist/css/chunk-0c17a57a.9fe19f94.css    0.86 KiB          0.35 KiB</span><br><span class="line">  dist/css/chunk-64435448.3755e146.css    0.30 KiB          0.15 KiB</span><br></pre></td></tr></table></figure><p>和前面的日志比较后发现，将 ElementUI 按需引入后，还是有效果的，只是效果不太明显。这个时候我们再来打开 report.html 页面来看下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-3.png" alt></p><p>可以看到，规模庞大的 element-ui.commons.js 已经不见了，取而代之的是一众小喽啰。相关文件大小也减少了 150kb 左右。</p><p>这感觉效果有限。</p><h2 id="2-gzip"><a href="#2-gzip" class="headerlink" title="2. gzip"></a>2. gzip</h2><p>所以，在前面代码的基础上，我们来通过 gzip 继续压缩。</p><p>通过 gzip 来压缩，我们有两种思路。这两种思路和前后端分离的两种不同部署方式有关。</p><ol><li>前端编译打包后拷贝到后端，直接部署后端项目即可</li><li>前后端分离部署，前端通过 Nginx 来部署（推荐）</li></ol><h3 id="2-1-服务端配置"><a href="#2-1-服务端配置" class="headerlink" title="2.1 服务端配置"></a>2.1 服务端配置</h3><p>如果使用第一种方式，前端可以不用做额外工作，还是之前编译后的文件。我们在后端 application.yml 中添加如下配置，开启 gzip 压缩：</p><figure class="highlight yml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">server:</span></span><br><span class="line"><span class="hljs-attr">  compression:</span></span><br><span class="line"><span class="hljs-attr">    enabled:</span> <span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启后端项目，访问项目首页，如下，可以看到文件基本上都被压缩了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-6.png" alt></p><p>点开一个请求，可以看到 gzip 已经生效了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-7.png" alt></p><h3 id="2-2-前端配置"><a href="#2-2-前端配置" class="headerlink" title="2.2 前端配置"></a>2.2 前端配置</h3><p>Nginx 中配置前端的 gzip 压缩，有两种思路：</p><ol><li>Nginx 动态压缩，静态文件还是普通文件，请求来了再压缩，然后返回给前端。</li><li>Nginx 静态压缩，提前把文件压缩成 .gz 格式，请求来了，直接返回即可。</li></ol><p>如果大家对于 Nginx 还不熟悉，可以先看看松哥这篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><h4 id="2-2-1-Nginx-动态压缩"><a href="#2-2-1-Nginx-动态压缩" class="headerlink" title="2.2.1 Nginx 动态压缩"></a>2.2.1 Nginx 动态压缩</h4><p>动态压缩 Vue 还是使用普通的打包编译后的文件，将前端编译打包后的文件拷贝到 Nginx 的 html 目录下，然后访问 nginx：<a href="http://192.168.91.129" target="_blank" rel="noopener">http://192.168.91.129</a></p><p>确保 nginx 运行成功后，接下来对 nginx 进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip  on;  # 开启 gzip</span><br><span class="line">gzip_min_length 2k;# 超过 2kb 进行压缩</span><br><span class="line">gzip_disable msie6; # ie6 不适用 gzip</span><br><span class="line">gzip_types text/css application/javascript text/javascript image/jpeg image/png image/gif; # 需要处理的文件</span><br></pre></td></tr></table></figure><p>配置完成后，重启 Nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p>启动成功后，再去访问前端页面，就可以看到压缩效果了。</p><h4 id="2-2-2-Nginx-静态压缩"><a href="#2-2-2-Nginx-静态压缩" class="headerlink" title="2.2.2 Nginx 静态压缩"></a>2.2.2 Nginx 静态压缩</h4><p>上面的动态压缩有一个问题，就是每次请求响应的时候都要压缩，其实都是相同的文件，总是压缩有点浪费资源。</p><p>我们可以提前将文件压缩好，就保存在服务端，需要用的时候直接返回，就会方便很多。</p><p>这需要我们首先在前端安装压缩插件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装成功之后，接下来在 vue.config.js 中进行配置：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"compression-webpack-plugin"</span>)</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    <span class="hljs-keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">                        test: <span class="hljs-regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">                        threshold: <span class="hljs-number">1024</span>,</span><br><span class="line">                        deleteOriginalAssets: <span class="hljs-literal">false</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>threshold 表示超过 1kb 的文件就进行压缩。</li><li>deleteOriginalAssets 表示压缩后是否删除原文件。</li></ul><p>配置完成后，再次执行打包命令 <code>vue-cli-service build</code>。这次打包完成后，我们可以在 js 目录下看到 .gz 文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-5.png" alt></p><p>接下来将文件上传到 Nginx 服务器，然后对 Nginx 重新进行编译打包。想让 Nginx 返回已经压缩好的文件，需要用到 Nginx 中的 http_gzip_static_module 模块，这个模块可以发送以 <code>.gz</code> 作为文件扩展名的预压缩文件，所以我们要对 Nginx 重新进行编译打包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后在 Nginx 配置文件中开启 gzip_static，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip_static  on;</span><br></pre></td></tr></table></figure><p>注意，开启了 gzip_static 后，gzip_types 就失效了，所以也没必要配置这个属性了。</p><p>配置完成后，重启 Nginx，再去访问，查看浏览器日志，就会发现 gzip 已经生效了。</p><p><strong>注意：</strong></p><p>静态压缩返回的 gzip 压缩文件都是提前准备好的，没有 .gz 格式的文件就会自动返回原文件。这是一种和动态压缩不同的响应策略。动态压缩是根据 Nginx 中的配置，超过配置的大小就会自动进行压缩。</p><p>好了，这一波操作下来，首屏加载速度提高了 5 倍左右。</p><p>当然，还有后招，松哥抽空再和大家聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文之前发过，但是比较零散，这里我把用到的方案都汇总一下，方便大家索引，有需要的小伙伴可以收藏下方便查找。里边提到的几种方案，大家都可以对照着视频试一下&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>疫情对我们普通人意味着什么？松哥的一份经历，和小伙伴们共勉</title>
    <link href="http://www.javaboy.org/2020/0323/life.html"/>
    <id>http://www.javaboy.org/2020/0323/life.html</id>
    <published>2020-03-23T02:05:41.000Z</published>
    <updated>2020-03-27T03:22:23.814Z</updated>
    
    <content type="html"><![CDATA[<p>眼看着国内的疫情控制住了，国外的疫情又成燎原之势，今年的大环境不佳，传统的跳槽高峰金三银四现在也没了。</p><a id="more"></a><p>因为疫情的原因，松哥有个大学同学最近失业了，他们公司是做 2C 业务的，现在很多商场、饭店都没开门，公司的订单量只有平时的十分之一，最早的时候他跟我讲 2 月份的薪水只发 2000，后来又得到消息说年终奖没了，再后来说公司裁员 40%。。。。。。最近没消息了，应该在投简历吧。</p><p>疫情期间跳槽还是挺闹心的，深圳这边大厂的社招基本上没有缩减，甚至还有扩大的迹象，但是一些中小公司则确实蛮艰难的。所以我其实非常理解大家跳槽所面临的问题。</p><p>无论是面临校招还是面临跳槽的小伙伴，受疫情影响工作肯定不如往年好找，我们原本的生活节奏被疫情打乱了，这是坏事，但是也可能是机会，关键看自己怎么把握了。</p><p>前两天松哥看到高中班主任老师在扣扣空间发的一篇文章，勉励高三学生疫情期间在家认真复习，把握好高考前的一段时间，松哥看完后满是感慨，想起了自己中考时候类似的经历。</p><p>松哥是 2008 年参加中考的，那一年刚好赶上了 512 大地震。地震发生的时候，离中考大概还有不到两个月的时间。</p><p>地震发生之前，小伙伴们都在紧锣密鼓的复习作准备，虽然不像高考那么紧张，但也是有模有样。</p><p>学校每周都会有模拟考试，每天下午都会多加一节课，周末也会额外多上一天课，就是大家可能都经历过的那种考试前的紧张状态，这种紧张状态被地震打破了。</p><p>因为松哥在西安，地震之后，刚开始的时候还有余震，有的余震震感还是很明显，而且我们当时的教室还是那种砖木结构，地震来临的时候还是蛮危险的，所以学校经常放假。</p><p>一放假，原本学校安排的一些复习计划就被打乱了，只能靠大家自己自觉复习，一些自律性较差的人可能就放羊了。</p><p>老实说，我当时也不懂自律啥的这些大道理，就是有考试的压力在，另一方面，就是我感觉这是一个弯道超车的机会，因为当大家都放松懈怠的时候，你只需要稍微努力一下，就能超过他们。</p><p>所以在当时一个比较乱套的时候，松哥依然保持了地震前的学习状态。</p><p>因为地震，大家都不太敢呆在家里，但是在院子里很难保持一个学习的状态，我当时租住在一个地下室里，听说地下室不容易感知到地震，于是就在桌子旁边倒立了一个啤酒瓶，然后呆在家里学习。这真是拿生命在学习，还好没有发生特别强烈的余震。抱着这样一种略带侥幸的心理，我一直保持着最初的学习状态没变，每天依然保持早起，该复习的科目，该做的练习题，一样不落。</p><p>印象深刻的是有一天新闻说当晚可能会有较强的余震（那段时间总是有砖家出来神预测），我一个人在地下室也不敢睡呀。后来就去了一个小伙伴家里，跟他睡在他家二楼，第二天早上我还是六点多起来回家早读去了，以至于那个小伙伴后来见到我一个劲追问你竟然起那么早学习？</p><p>第二天到学校之后，班里的同学又在说地震的事情，昨天又没复习吧啦吧啦，我也不知道真假，他们可能真的去玩了，也可能在家里学习然后到了学校放烟雾弹迷惑竞争对手（高中的时候，才知道这叫“学习骗子”）。反正不管别人怎么样吧，自己该怎么样就怎么样，地震肯定是有让一些人的学习落下，也给了另一些人超车的机会。比如松哥。</p><p>中考结果出来的时候，我考了学校第一县里第二，这样松哥就顺利的从小镇上去了西安免费读了三年高中，这是后话了。</p><p>我刚上初中的时候，就默默立了一个考全校第一的目标，虽然一直成绩还不错，但是却从来没拿过第一，没想到临走的时候，满足了。</p><p>虽然不能将最终的考试结果完全归功于地震期间的学习状态，前期的积累肯定还是要有的，但是在地震期间如果懈怠了，后面到底能考什么样的结果也未可知。事后回想起地震后的那一段学习时间，满满的充实感。</p><p>今天，每当回忆起 2008 年的大地震，有的人感叹这场地震影响了自己的中考/高考，而我会感叹，地震在千军万马的竞争中撕裂了一个口子，给我了超越其他人的机会。</p><p>回到当下，现在疫情对小伙伴们的影响其实也是相同的道理。</p><p>因为疫情，可能有小伙伴还没开工，也没什么事，甚至失业赋闲在家。这其实就是一个很好的弯道超车的机会，与其整天刷抖音发呆，不如把平时落下的只是恶补一下，有的小伙伴平时抱怨因为加班没时间学习，现在大把的时间摆在你的面前，不正是梳理、总结、提高的大好机会么？</p><p>若干年后，当你回忆起 2020 年的新冠肺疫，不是抱怨疫情夺走了你的工作，拉低了你的薪水，而是感叹疫情给你带来了一个自我学习提升的机会，进而带来了一波大幅加薪升职的机会！这多好。</p><p>说到自我学习提升，如果你对松哥自己录制的 Spring Boot+Vue+微人事+Spring Cloud+Redis 教程感兴趣，可以戳这里看看👉<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">松哥自制视频教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;眼看着国内的疫情控制住了，国外的疫情又成燎原之势，今年的大环境不佳，传统的跳槽高峰金三银四现在也没了。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之 Maven 依赖自动提示</title>
    <link href="http://www.javaboy.org/2020/0321/idea-maven.html"/>
    <id>http://www.javaboy.org/2020/0321/idea-maven.html</id>
    <published>2020-03-21T02:15:44.000Z</published>
    <updated>2020-03-27T03:24:28.016Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/h-Up7RVAMkCxokG_ExZV2A" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/h-Up7RVAMkCxokG_ExZV2A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>离职半年了，老东家又发 offer，回不回？</title>
    <link href="http://www.javaboy.org/2020/0318/life.html"/>
    <id>http://www.javaboy.org/2020/0318/life.html</id>
    <published>2020-03-18T02:04:56.000Z</published>
    <updated>2020-03-27T03:22:28.921Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴问松哥这个问题，他在上海某公司，在离职了几个月后，前公司的领导联系到他，希望他能够返聘回去，他很纠结要不要回去？</p><a id="more"></a><p>俗话说好马不吃回头草，但是这个小伙伴既然感到纠结了，我觉得至少说明了两个问题：1.曾经的公司还不错；2.现在的日子也不是很如意。否则应该就不会纠结了。</p><p>老实说，松哥之前也有过类似的经历，今天就来和小伙伴们聊聊回头草到底吃不吃。</p><p>首先一个基本观点，就是离职了也没必要和老东家弄的苦大仇深不共戴天，其实分手了还是可以做朋友的，从做人做事两方面来说，都应该是这样：</p><ol><li>从做人方面来说，做人要厚道。小伙伴们出去面试，大家都知道面试的时候比较忌讳说上家公司的坏话，就是这个原因。另一方面，不停的说上家公司的坏话，也会让人间接的感觉到你本身有很多问题。</li></ol><p><img src="http://img.itboyhub.com/2020/03/offer-1.png" alt></p><ol start="2"><li>从做事方面来讲，出于种种原因考虑，大部分时候我们跳槽可能都会选择相同的行业，比如医疗、金融、erp 等等，有的行业圈子大，有的行业圈子小，跳来跳去，你极有可能遇到自己的老同事老领导。所以和前同事和老东家搞好关系，在行业里留一个好名声，对自己未来的发展也很有好处。</li></ol><p>基于这两点，我们都应该尽量处理好离职的事情，不管以后还见不见，多个朋友总比多个敌人好。</p><p>不过，也不排除会遇到一些不良公司，这种时候，作为个人，我觉得还是要做好自己，总不能因为遇到了一个不良公司我们就变成了一个不良员工。</p><p>我在 2017 年的时候，从一家效力了两年多的公司离职，当时因为公司业务调整，我被从广州调岗到深圳分公司，从广州把行李搬到了深圳，在深圳人生地不熟，干的挺郁闷的，于是没过几个月就离职了。</p><p>离职的时候就要办离职手续，这里涉及到一个小问题。</p><p>在我任职期间，公司有过一次大规模的薪资体系调整，在调整之前，公司对加班几乎是没有限制的，晚上加完班之后，第二天找自己的主管领导签字，加班满 8 个小时可以调休一天，加班只能调休无法折算成薪水，而我当时刚毕业，一个人呆在广州，晚上回家也没啥事情，干脆就呆在公司学习，所以没过多久我就成了公司加班时长最多的人，在薪资体系调整之前，我的加班大概一共可以折算成 30 天左右的假期。</p><p>薪资体系调整之后，公司开始严格控制加班，加班时长即可以调休也可以在离职的时候折算成薪水了。所以我 30 多天的加班如果不调休的话，都是有机会折算成薪水的。</p><p>后来等到我离职的时候，调休的大概还剩 22 天左右的加班时长，作为一个将要离职的人，我对于将 22 天的加班时长转为薪水没有抱有太大的希望，只是嘱咐了一下跟我办理离职手续的 hr，如果能帮我争取一下就尽量帮我争取一下。</p><p>一个月后，我收到了最后一个月的薪水，连同 22 天的加班和 5 天的年假，全部折算成薪水发给我了，这波操作顿时就把松哥收买了。</p><p><img src="http://img.itboyhub.com/2020/03/offer.png" alt></p><p>正是因为这件事，所以在后来老东家再次找到我希望我回去的时候，我犹豫了。</p><p>在我离职了大概五个月的时候，新公司也干了快五个月了，老东家广州那边的领导联系到我，希望我能回去。</p><p>我当时在新公司收入也不低，但是新公司的业务不是很稳定，加上我一直比较喜欢广州的生活气息，所以也有一点点想回广州，当然仅仅这些东西是不足以让我做出回广州的决定的。</p><p>老东家广州分公司的负责人和我打过多次电话，有一次打了两个多小时电话，聊了很多东西，他讲了自己是如何从一个普通程序员走到现在的分公司负责人的，我这次入职后对我未来的规划、包括入职后的各项福利待遇、工龄接着之前的不中断等等，两个大男人就这样聊到了凌晨 1 点多，然后我就很不争气的被感动的一塌糊涂。</p><p>第二天起来我就做了一个重要的决定：回广州！我把我在深圳的电磁炉等一众做饭的家伙什儿送给了在深圳的大学同学，其他的衣服、书等行李打包用物流寄回了广州公司，让以前的同事先帮我收着。我自己则打算在国庆节之后回广州。接着广州那边的 hr 就给我发了 offer，我就先收着了。</p><p>结果，国庆节刚过，女票就在校招中拿到了深圳某大厂的 offer。女票是我大学同学，毕业后又在西安读了研究生，校招的时候本来可以有更好的选择，但是因为我在深圳，所以她当时北京上海杭州考虑的比较少，主要是广州深圳，她在 10 月初拿到了 offer，参加过秋招的小伙伴都知道，秋招越往后大厂越少，而且她在 10 月底还要去昆士兰大学访学，时间也很紧张。</p><p>所以我又不能回广州了。</p><p>给广州那边打了电话，满怀愧疚说明了情况，对方也表示理解，毕竟和女朋友相比，工作只能排第二位。</p><p>就这样，回头草没吃成。</p><p>我这个人比较随和，离职只是因为有更好的选择，跟公司没有仇怨，所以再回去心里也能接受。</p><p>在职的时候和同事们保持一个好点的关系，工作认真负责，在同事中留一个好点的口碑，离职后该说的说，不该说的不说，再见我们还是好同事，当然如果公司本身比较坑爹，那早点走人吧！但是也别和人结怨。</p><p>小伙伴你呢 ？有没有遇到这样的事情 ？你有回去吗 ？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴问松哥这个问题，他在上海某公司，在离职了几个月后，前公司的领导联系到他，希望他能够返聘回去，他很纠结要不要回去？&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Vue前后端分离，如何避免前端页面 404</title>
    <link href="http://www.javaboy.org/2020/0317/springboot-vue-404.html"/>
    <id>http://www.javaboy.org/2020/0317/springboot-vue-404.html</id>
    <published>2020-03-17T02:04:42.000Z</published>
    <updated>2020-03-27T03:29:53.185Z</updated>
    
    <content type="html"><![CDATA[<p>问题倒不难，但是这个问题之前被松哥忽略了。前两天有小伙伴提出这个疑问，我觉得有必要写篇文章和大家捋一捋这个问题。</p><a id="more"></a><p>先来看一个简短的视频：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1e7411Z7zX&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>一个简单的配置就解决掉 404 问题了，接下来，我再来把这件事的来龙去脉和大家仔细捋一捋。</p><h2 id="1-职责划分"><a href="#1-职责划分" class="headerlink" title="1.职责划分"></a>1.职责划分</h2><p>在传统的前后端不分的开发中，权限管理主要通过过滤器或者拦截器来进行（权限管理框架本身也是通过过滤器链来实现功能），如果用户不具备某一个角色或者某一个权限，则无法访问某一个页面。</p><p>但是在前后端分离中，页面的跳转统统交给前端去做，后端只提供数据，这种时候，权限管理不能再按照之前的思路来。</p><p>首先要明确一点，前端是展示给用户看的，所有的菜单显示或者隐藏目的不是为了实现权限管理，而是为了给用户一个良好的体验（把用户没有权限的按钮隐藏起来，避免用户点击后提示 403，提高用户体验），不能依靠前端隐藏控件来实现权限管理，即数据安全不能依靠前端。</p><p>这就像普通的表单提交一样，前端做数据校验是为了提高效率，提高用户体验，后端才是真正的确保数据完整性。</p><p>所以，真正的数据安全管理是在后端实现的，后端在接口设计的过程中，就要确保每一个接口都是在满足某种权限的基础上才能访问，也就是说，不怕将后端数据接口地址暴露出来，即使暴露出来，只要你没有相应的角色/权限，也是访问不了的。</p><p>前端为了良好的用户体验，需要将用户不能访问的接口或者菜单隐藏起来。页面的跳转，按钮的隐藏/展示等等，统统在前端来实现。</p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2.存在的问题"></a>2.存在的问题</h2><p>当前后端分离之后，对于前端所承担的职责，大家可能会面临一个问题：如果用户直接在地址拦输入某一个页面的路径，怎么办？</p><p>此时，如果没有做任何额外的处理的话，用户确实可以通过直接输入某一个路径进入到系统中的某一个页面中，但是，不用担心数据泄露问题，因为没有相关的角色/权限，就无法访问相关的接口，即使进入到相关的页面，也看不到数据。</p><p>但是，如果用户非这样操作，进入到一个空白的页面，用户体验不好，冒出来一个空白页面，有的用户就手足无措了。</p><p>此时，我们可以使用 Vue 中的前置路由导航守卫，来监听页面跳转，如果用户想要去一个未获授权的页面，则直接在前置路由导航守卫中将之拦截下来，重定向到登录页，或者直接就停留在当前页，不让用户跳转，也可以顺手再给用户一点点未获授权的提示信息。</p><p>以 vhr 中的代码为例，我在 main.js 中定义了前置路由导航守卫：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (to.path == <span class="hljs-string">'/'</span>) &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.sessionStorage.getItem(<span class="hljs-string">"user"</span>)) &#123;</span><br><span class="line">            initMenu(router, store);</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            next(<span class="hljs-string">'/?redirect='</span>+to.path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个方法有点类似于 Java 中的过滤器，to 表示要去哪里，有点像 HttpServletResponse；from 表示从哪来，有点像 HttpServletRequest；next 表示一个请求继续向下执行的方法，有点类似于 FilterChain。</p><p>这里会监控到所有的页面路由/跳转，主要逻辑是这样：</p><ol><li>如果要去的地址是 ‘/‘，即要去的地方是登录页面，则直接执行 next 方法表示放行。</li><li>如果要去的地址不是 ‘/‘，那就要看用户是否登录了，如果已经登录了，则先初始化菜单，然后调用 next 方法继续向下走，想去哪去哪。</li><li>如果没有登录，则调用 next 方法，跳转路径是 ‘/‘，即回到登录页面，同时携带上一个 redirect 参数，这个是重定向的地址，这个参数的作用是这样：例如我本来输入 ‘/aa/bb’，结果因为没有登录，自动跳转到项目登录页面，当我登录成功后，自动跳回 ‘/aa/bb’。</li></ol><p>有这个配置之后，就不怕用户乱跳转了，如果没有登录随意输入一个地址，就会回到登录页面。</p><h2 id="3-404问题"><a href="#3-404问题" class="headerlink" title="3. 404问题"></a>3. 404问题</h2><p>上面的配置还存在一个 404 问题。</p><p>在用户还没有登录的时候，如果他在浏览器输入一个不存在的地址，就会自动回到登录页面，这没有问题，但是用户如果已经登录了，在浏览器输入一个不存在的地址，这个时候就会发生 404，当你没做任何定义的时候，所谓的 404 页面其实就是一片空白。</p><p>要解决这个问题，很多小伙伴第一个思路就是能不能在前置路由导航守卫里边做一个判断，当你要跳转的时候，先去判断一个跳转的路径是否存在，如果存在再去跳转，否则就不去跳转。</p><h3 id="3-1-动态路由"><a href="#3-1-动态路由" class="headerlink" title="3.1 动态路由"></a>3.1 动态路由</h3><p>这个思路看起来没问题，但实际上还有更简便的办法，那就是使用 vue-router 中的动态路由。</p><p>举一个简单的例子，我们有一个用户展示的页面，这个页面会根据不同的用户 id 来展示不同的用户数据，所以我们在 router.js 中可以按如下方式来定义路由：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    <span class="hljs-comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>, <span class="hljs-attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>注意这里标记的参数 id 前面有一个 <code>:</code> 。定义完成后，以后像 <code>/user/1</code>、<code>/user/2</code> 都会映射到相同的路由。而像地中的 1 、2 等参数，我们则可以通过 <code>this.$route.params.id</code> 获取。</p><p>上面这种是设置一个参数，我们也可以设置多个参数，我们可以参考官方给出的一个表格：</p><p><img src="http://img.itboyhub.com/2020/03/vue-router-1.png" alt></p><p>如果有多个参数，也可以通过 <code>this.$route.params</code> 来获取参数的值。</p><p><strong>注意，在动态路由匹配时，如果我们从 <code>/user/1</code> 切换到 <code>/user/2</code> ，原有的 User 组件是不会销毁的，这也意味着组件的生命周期钩子函数不会再被调用</strong>，那么要怎么刷新数据呢？这个时候我们可以采用 beforeRouteUpdate 导航守卫，在导航守卫中完成数据更新：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeRouteUpdate(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//刷新数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-2-解决-404"><a href="#3-2-解决-404" class="headerlink" title="3.2 解决 404"></a>3.2 解决 404</h3><p>最后，就是我们本文要说的 404 问题了。看懂了前面，如何解决 404 其实就很容易明白了。</p><p>我们可以使用通配符 <code>*</code> 来匹配任意路径，例如下面这段匹配格式：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-comment">// 会匹配所有路径</span></span><br><span class="line">  path: <span class="hljs-string">'*'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个匹配规则会匹配到所有路径，通常就是用来解决前端页面的 404 问题。也可以自己定义一些前缀，例如下面这样：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-comment">// 会匹配以 `/javaboy-` 开头的任意路径</span></span><br><span class="line">  path: <span class="hljs-string">'/javaboy-*'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用通配符的时候，可以通过 <code>this.$route.params.pathMatch</code> 来获取通配符匹配到的路径，例如用户请求路径是 <code>/javaboy-aaa</code>，则 <code>this.$route.params.pathMatch</code> 的值就为 <code>aaa</code>。</p><p>另外还有一个比较重要的点，就是通配符路径的顺序问题。<strong>如果路径带有通配符，一般来说要放在路由的最后面。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题倒不难，但是这个问题之前被松哥忽略了。前两天有小伙伴提出这个疑问，我觉得有必要写篇文章和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>视频教程录制即将收尾，抽一波签名书！</title>
    <link href="http://www.javaboy.org/2020/0316/springboot-vue-video.html"/>
    <id>http://www.javaboy.org/2020/0316/springboot-vue-video.html</id>
    <published>2020-03-16T02:04:22.000Z</published>
    <updated>2020-03-27T03:11:01.715Z</updated>
    
    <content type="html"><![CDATA[<p>刚过完年一直在各种忙，即使在家里远程办公也一直没歇着。忙里偷闲，还是抽空把 Spring Cloud 视频教程录完了，并且 Redis 教程也已经开始录制了，给小伙伴们承诺的四套视频教程，即将迎来大结局。</p><a id="more"></a><p>当目前为止：</p><p><strong>Spring Boot 视频教程一共是 129 集，约 20 个小时：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">├─第 0 章 准备工作</span><br><span class="line">│      01.回顾 XML 配置 Spring.mp4</span><br><span class="line">│      02.Java配置SSM-1.mp4</span><br><span class="line">│      03.Java配置SSM-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 01 章 Spring Boot 入门</span><br><span class="line">│      01.SpringBoot介绍.mp4</span><br><span class="line">│      02.SpringBoot项目的三种创建方式.mp4</span><br><span class="line">│      03.SpringBoot启动类上的注解.mp4</span><br><span class="line">│      04.SpringBoot中parent的理解-1.mp4</span><br><span class="line">│      05.SpringBoot中parent的理解-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 02 章 Spring Boot 基础配置</span><br><span class="line">│      01.Banner配置.mp4</span><br><span class="line">│      02.容器相关配置.mp4</span><br><span class="line">│      03.Spring属性注入.mp4</span><br><span class="line">│      04.类型安全的属性注入.mp4</span><br><span class="line">│      05.YAML配置.mp4</span><br><span class="line">│      06.Profile.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 03 章 Spring Boot 整合视图层技术</span><br><span class="line">│      01.SpringBoot 整合视图层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 Freemarker.mp4</span><br><span class="line">│      03.Feemarker 常用指令.mp4</span><br><span class="line">│      04.整合 Thymeleaf.mp4</span><br><span class="line">│      05.整合 jsp.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 04 章 Spring Boot 整合 Web 开发</span><br><span class="line">│      01.Spring Boot 默认的 JSON 解析方案.mp4</span><br><span class="line">│      02.使用 Gson 处理 JSON.mp4</span><br><span class="line">│      03.Spring Boot 整合 Fastjson.mp4</span><br><span class="line">│      04.Spring Boot 默认的静态资源访问方案.mp4</span><br><span class="line">│      05.两种方式自定义静态资源位置.mp4</span><br><span class="line">│      06.Spring Boot 文件上传.mp4</span><br><span class="line">│      07.Ajax 实现文件上传.mp4</span><br><span class="line">│      08.多文件上传.mp4</span><br><span class="line">│      09.@ControllerAdvice 的三种用法.mp4</span><br><span class="line">│      10.@ControllerAdvice 处理全局异常_1.mp4</span><br><span class="line">│      11.@ControllerAdvice 预设全局数据.mp4</span><br><span class="line">│      12.@ControllerAdvice 请求参数预处理.mp4</span><br><span class="line">│      13.Spring Boot 自定义错误页.mp4</span><br><span class="line">│      14.Spring Boot 异常处理源码分析.mp4</span><br><span class="line">│      15.Spring Boot 自定义异常数据.mp4</span><br><span class="line">│      16.Spring Boot 自定义异常视图.mp4</span><br><span class="line">│      17.Spring Boot 通过 CORS 实现跨域.mp4</span><br><span class="line">│      18.Spring Boot 中加载 XML 配置.mp4</span><br><span class="line">│      19.Spring Boot 中注册拦截器.mp4</span><br><span class="line">│      20.CommandLineRunner 实现系统启动任务.mp4</span><br><span class="line">│      21.ApplicationRunner 实现系统启动任务.mp4</span><br><span class="line">│      22.Spring Boot 整合 Web 基础组件.mp4</span><br><span class="line">│      23.Spring Boot 路径映射.mp4</span><br><span class="line">│      24.Spring Boot 中使用类型转换器.mp4</span><br><span class="line">│      25.Spring Boot 整合 AOP.mp4</span><br><span class="line">│      26.Spring Boot 自定义欢迎页.mp4</span><br><span class="line">│      27.Spring Boot 自定义 favicon.mp4</span><br><span class="line">│      28.Spring Boot 除去自动化配置.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 05 章 Spring Boot 整合持久层技术</span><br><span class="line">│      01.Spring Boot 整合持久层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 JdbcTemplate.mp4</span><br><span class="line">│      03.Spring Boot 整合 JdbcTemplate 多数据源.mp4</span><br><span class="line">│      04.Spring Boot 整合 MyBatis.mp4</span><br><span class="line">│      05.Spring Boot 整合 MyBatis 多数据源.mp4</span><br><span class="line">│      06.Spring Data 和 Jpa 简介.mp4</span><br><span class="line">│      07.Spring Boot 整合 Spring Data Jpa.mp4</span><br><span class="line">│      08.Spring Data Jpa 关键字定义查询方法.mp4</span><br><span class="line">│      09.Spring Data Jpa 自定义查询 SQL.mp4</span><br><span class="line">│      10.Spring Data Jpa 自定义数据修改 SQL.mp4</span><br><span class="line">│      11.Spring Boot 整合 Jpa 多数据源.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 06 章 Spring Boot 整合 NoSQL</span><br><span class="line">│      01.Spring Boot 整合 NoSQL.mp4</span><br><span class="line">│      02.Spring Boot 整合 Redis.mp4</span><br><span class="line">│      03.为什么需要 session 共享.mp4</span><br><span class="line">│      04.Nginx 简介.mp4</span><br><span class="line">│      05.Spring Session 实现 Session 共享.mp4</span><br><span class="line">│      06.引入 Nginx 负载均衡.mp4</span><br><span class="line">│      07.MongoDB 安装.mp4</span><br><span class="line">│      08.Spring Boot 整合 MongoDB.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 07 章 构建 REST 服务</span><br><span class="line">│      01.RESTful 简介.mp4</span><br><span class="line">│      02.搭建 Jpa 环境.mp4</span><br><span class="line">│      03.Spring Boot 中 REST 默认提供的增删改查.mp4</span><br><span class="line">│      04.Spring Boot 中 REST 自定义查询方法.mp4</span><br><span class="line">│      05.REST 配置 CORS.mp4</span><br><span class="line">│      06.自定义 REST 配置.mp4</span><br><span class="line">│      07.MongoDB 实现 REST.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 08 章 开发者工具与单元测试</span><br><span class="line">│      01.Devtools 简介.mp4</span><br><span class="line">│      02.devtools 工作原理-.mp4</span><br><span class="line">│      03.自定义监控资源.mp4</span><br><span class="line">│      04.LiveReload 自动刷新页面.mp4</span><br><span class="line">│      05.禁用自动重启.mp4</span><br><span class="line">│      06.项目重启中的全局配置.mp4</span><br><span class="line">│      07.Spring Boot 单元测试介绍.mp4</span><br><span class="line">│      08.Service 测试.mp4</span><br><span class="line">│      09.Controller 测试.mp4</span><br><span class="line">│      10.JSON 测试.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 09 章 Spring Boot 缓存</span><br><span class="line">│      01.Spring Cache 介绍.mp4</span><br><span class="line">│      02.Spring Cache 整合 Redis.mp4</span><br><span class="line">│      03.Spring Cache 整合 Ehcache.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 10 章 Spring Boot 安全管理</span><br><span class="line">│      01.安全管理介绍.mp4</span><br><span class="line">│      02.Spring  Security 初体验.mp4</span><br><span class="line">│      03.手工配置用户名密码.mp4</span><br><span class="line">│      04.HttpSecurity 配置.mp4</span><br><span class="line">│      05.登录表单详细配置.mp4</span><br><span class="line">│      06.注销登录配置.mp4</span><br><span class="line">│      07.多个 HttpSecurity.mp4</span><br><span class="line">│      08.密码加密.mp4</span><br><span class="line">│      09.方法安全.mp4</span><br><span class="line">│      10.基于数据库的认证.mp4</span><br><span class="line">│      11.角色继承.mp4</span><br><span class="line">│      12.动态配置权限.mp4</span><br><span class="line">│      13.OAuth2 简介.mp4</span><br><span class="line">│      14.Spring Security 结合 OAuth2.mp4</span><br><span class="line">│      15.整合 Shiro 方式一.mp4</span><br><span class="line">│      16.整合 Shiro 方式二.mp4</span><br><span class="line">│      17.Spring Security 使用 JSON 登录.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 11 章 Spring Boot 整合 WebSocket</span><br><span class="line">│      01.WebSocket 介绍.mp4</span><br><span class="line">│      02.WebSocket 实现在线群聊.mp4</span><br><span class="line">│      03.WebSocket 实现在线单聊.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 12 章 消息服务</span><br><span class="line">│      01.消息服务.mp4</span><br><span class="line">│      02.ActiveMQ 安装.mp4</span><br><span class="line">│      03.Spring Boot 整合 ActiveMQ.mp4</span><br><span class="line">│      04.RabbitMQ 简介并安装.mp4</span><br><span class="line">│      05.Spring Boot 整合 RabbitMQ.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 13 章 企业开发</span><br><span class="line">│      01.邮件协议简介.mp4</span><br><span class="line">│      02.申请 QQ 邮箱授权码.mp4</span><br><span class="line">│      03.发送简单邮件.mp4</span><br><span class="line">│      04.发送带附件的邮件.mp4</span><br><span class="line">│      05.发送带图片资源的邮件.mp4</span><br><span class="line">│      06.Thymeleaf 做邮件模板.mp4</span><br><span class="line">│      07.Freemarker 做邮件模板.mp4</span><br><span class="line">│      08.Spring Boot 定时任务实现方案一(@Scheduled).mp4</span><br><span class="line">│      09.Spring Boot 定时任务实现方案二(Quartz).mp4</span><br><span class="line">│      10.Spring Boot 整合 Swagger2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 14 章 应用监控</span><br><span class="line">│      01.应用端点.mp4</span><br><span class="line">│      02.Health 端点.mp4</span><br><span class="line">│      03.Info 端点.mp4</span><br><span class="line">│      04.监控信息可视化.mp4</span><br><span class="line">│      05.邮件报警.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 15 章 项目构建与部署</span><br><span class="line">│      01.jar.mp4</span><br><span class="line">│      02.war.mp4</span><br></pre></td></tr></table></figure><p><strong>微人事是 141 集约 32 个小时（含 Vue 入门）：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">└─第 16 章 微人事项目实战</span><br><span class="line">        001.项目介绍.mp4</span><br><span class="line">        002.项目技术架构.mp4</span><br><span class="line">        003.Vue 学习规划.mp4</span><br><span class="line">        004.Vue 初体验.mp4</span><br><span class="line">        005.Vue 条件指令.mp4</span><br><span class="line">        006.Vue 循环指令.mp4</span><br><span class="line">        007.Vue 处理用户输入.mp4</span><br><span class="line">        008.Vue 处理用户输入.mp4</span><br><span class="line">        009.Vue 组件初体验.mp4</span><br><span class="line">        010.Vue 实例.mp4</span><br><span class="line">        011.Vue 模板语法.mp4</span><br><span class="line">        012.Vue 计算属性.mp4</span><br><span class="line">        013.Vue 侦听器.mp4</span><br><span class="line">        014.Vue Class 绑定.mp4</span><br><span class="line">        015.Vue Style 绑定.mp4</span><br><span class="line">        016.Vue 条件渲染.mp4</span><br><span class="line">        017.Vue 列表渲染.mp4</span><br><span class="line">        018.Vue 事件处理.mp4</span><br><span class="line">        019.Vue 表单输入绑定.mp4</span><br><span class="line">        020.Vue 组件基础.mp4</span><br><span class="line">        021.Vue 总结.mp4</span><br><span class="line">        022.Spa 单页面应用介绍.mp4</span><br><span class="line">        023.node 和 npm.mp4</span><br><span class="line">        024.创建一个单页面应用.mp4</span><br><span class="line">        025.Vue 工程目录介绍.mp4</span><br><span class="line">        026.Vue 单页面项目运行.mp4</span><br><span class="line">        027.Vue 工程代码解析.mp4</span><br><span class="line">        028.vue-cli3 构建 Vue 项目.mp4</span><br><span class="line">        029.vue-cli3 项目结构介绍.mp4</span><br><span class="line">        030.微人事登录页面制作.mp4</span><br><span class="line">        031.处理前端登录事件.mp4</span><br><span class="line">        032.服务端环境搭建.mp4</span><br><span class="line">        033.服务端登录接口制作(一).mp4</span><br><span class="line">        034.服务端登录接口制作(二).mp4</span><br><span class="line">        035.前后端接口对接.mp4</span><br><span class="line">        036.登录页面跳转.mp4</span><br><span class="line">        037.前端请求方法封装.mp4</span><br><span class="line">        038.Home 页 title 制作.mp4</span><br><span class="line">        039.左边导航菜单制作.mp4</span><br><span class="line">        040.菜单项接口介绍.mp4</span><br><span class="line">        041.服务端菜单接口设计.mp4</span><br><span class="line">        042.Vuex 介绍与安装.mp4</span><br><span class="line">        043.Vuex 配置.mp4</span><br><span class="line">        044.菜单请求工具类封装.mp4</span><br><span class="line">        045.前端页面添加并完善菜单请求.mp4</span><br><span class="line">        046.左边导航菜单加载.mp4</span><br><span class="line">        047.页面加载问题解决.mp4</span><br><span class="line">        048.微人事首页完善.mp4</span><br><span class="line">        049.前后端分离权限管理思路探讨.mp4</span><br><span class="line">        050.后端接口权限设计.mp4</span><br><span class="line">        051.权限问题解决.mp4</span><br><span class="line">        052.权限管理继续完善.mp4</span><br><span class="line">        053.基础信息设置.mp4</span><br><span class="line">        054.职位管理前端页面设计.mp4</span><br><span class="line">        055.职位管理后端接口设计.mp4</span><br><span class="line">        056.职位管理前后端接口对接.mp4</span><br><span class="line">        057.职位管理前后端对接问题解决.mp4</span><br><span class="line">        058.职位修改操作.mp4</span><br><span class="line">        059.职位批量删除实现.mp4</span><br><span class="line">        060.职称管理前端页面设计.mp4</span><br><span class="line">        061.职称管理后端接口设计.mp4</span><br><span class="line">        062.职称管理前后端接口对接.mp4</span><br><span class="line">        063.职称批量删除实现.mp4</span><br><span class="line">        064.解决职位管理中的一个小问题.mp4</span><br><span class="line">        065.权限组前端页面制作.mp4</span><br><span class="line">        066.权限组用户角色前后端接口对接.mp4</span><br><span class="line">        067.权限组菜单树展示.mp4</span><br><span class="line">        068.菜单角色关系修改.mp4</span><br><span class="line">        069.权限组角色添加.mp4</span><br><span class="line">        070.权限组角色删除.mp4</span><br><span class="line">        071.[补充]登录问题完善.mp4</span><br><span class="line">        072.部门管理数据展示和搜索.mp4</span><br><span class="line">        073.部门树展示添加与删除.mp4</span><br><span class="line">        074.部门树的动态修改[添加].mp4</span><br><span class="line">        075.部门树的动态修改[删除].mp4</span><br><span class="line">        076.操作员管理接口设计.mp4</span><br><span class="line">        077.操作员管理页面展示.mp4</span><br><span class="line">        078.用户状态更新操作.mp4</span><br><span class="line">        079.操作员角色更新.mp4</span><br><span class="line">        080.操作员搜索.mp4</span><br><span class="line">        081.操作员删除.mp4</span><br><span class="line">        082.[补充]增加数据加载进度条.mp4</span><br><span class="line">        083.员工管理后端接口设计.mp4</span><br><span class="line">        084.员工管理工具栏展示.mp4</span><br><span class="line">        085.员工管理员工数据展示.mp4</span><br><span class="line">        086.员工管理员工数据分页.mp4</span><br><span class="line">        087.员工管理之员工搜索.mp4</span><br><span class="line">        088.员工添加接口设计.mp4</span><br><span class="line">        089.员工添加页面绘制.mp4</span><br><span class="line">        090.员工添加页面下拉框数据加载.mp4</span><br><span class="line">        091.员工添加页面工号加载.mp4</span><br><span class="line">        092.员工添加页面部门列表展示.mp4</span><br><span class="line">        093.员工添加.mp4</span><br><span class="line">        094.员工添加数据校验.mp4</span><br><span class="line">        095.[问题处理]部门管理问题处理.mp4</span><br><span class="line">        096.员工删除.mp4</span><br><span class="line">        097.员工信息更新.mp4</span><br><span class="line">        098.[问题处理]自动计算合同期限问题.mp4</span><br><span class="line">        099.[问题处理]权限组取消角色的所有权限.mp4</span><br><span class="line">        100.员工数据导出(Excel 导出).mp4</span><br><span class="line">        101.员工数据导入(Excel 上传).mp4</span><br><span class="line">        102.员工数据导入(Excel 解析).mp4</span><br><span class="line">        103.员工数据导入(插入数据库).mp4</span><br><span class="line">        104.员工高级搜索页面设计.mp4</span><br><span class="line">        105.员工高级搜索页面动画.mp4</span><br><span class="line">        106.禁用普通搜索.mp4</span><br><span class="line">        107.员工高级搜索功能.mp4</span><br><span class="line">        108.项目模块化改造.mp4</span><br><span class="line">        109.准备 RabbitMQ 消息中间件.mp4</span><br><span class="line">        110.搭建邮件服务.mp4</span><br><span class="line">        111.自动发送员工入职欢迎邮件.mp4</span><br><span class="line">        112.[号外]开发环境的变化.mp4</span><br><span class="line">        113.工资账套服务端接口设计.mp4</span><br><span class="line">        114.工资账套前端页面设计.mp4</span><br><span class="line">        115.添加工资账套页面设计.mp4</span><br><span class="line">        116.工资账套添加页面设计.mp4</span><br><span class="line">        117.工资账套添加前后端接口对接.mp4</span><br><span class="line">        118.工资账套删除.mp4</span><br><span class="line">        119.工资账套编辑与刷新.mp4</span><br><span class="line">        120.员工账套数据展示.mp4</span><br><span class="line">        121.员工工资账套调整页面设计.mp4</span><br><span class="line">        122.员工工资账套更新.mp4</span><br><span class="line">        123.员工工资账套设置分页.mp4</span><br><span class="line">        124.修改工资账套问题解决.mp4</span><br><span class="line">        125.聊天页面方案介绍.mp4</span><br><span class="line">        126.项目首页增加聊天入口.mp4</span><br><span class="line">        127.聊天页面绘制.mp4</span><br><span class="line">        128.调整聊天页面个人信息.mp4</span><br><span class="line">        129.用户列表展示.mp4</span><br><span class="line">        130.服务端消息处理配置.mp4</span><br><span class="line">        131.前端的聊天配置.mp4</span><br><span class="line">        132.消息首发测试.mp4</span><br><span class="line">        133.用户列表优化.mp4</span><br><span class="line">        134.消息发送处理.mp4</span><br><span class="line">        135.消息接收处理.mp4</span><br><span class="line">        136.聊天数据展示.mp4</span><br><span class="line">        137.聊天消息自动刷新.mp4</span><br><span class="line">        138.聊天完善.mp4</span><br><span class="line">        139.聊天消息提示.mp4</span><br><span class="line">        140.新消息提示红点.mp4</span><br><span class="line">        141.聊天消息动态提示.mp4</span><br></pre></td></tr></table></figure><p><strong>Spring Cloud 是 95 集 约 22 个小时：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">├─第 01 章 微服务概述</span><br><span class="line">│      01.课程介绍.mp4</span><br><span class="line">│      02.微服务介绍.mp4</span><br><span class="line">│      03.SpringCloud 介绍.mp4</span><br><span class="line">│      04.Spring Cloud 体系.mp4</span><br><span class="line">│      05.[号外]视频案例下载办法.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 02 章 服务注册中心</span><br><span class="line">│      01.注册中心介绍.mp4</span><br><span class="line">│      02.Eureka 介绍.mp4</span><br><span class="line">│      03.Eureka 基本搭建.mp4</span><br><span class="line">│      04.Eureka 集群搭建.mp4</span><br><span class="line">│      05.查看视频的 demo.mp4</span><br><span class="line">│      06.Eureka 工作细节.mp4</span><br><span class="line">│      07.Eureka 集群原理.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 03 章 服务注册与消费</span><br><span class="line">│      01.服务注册.mp4</span><br><span class="line">│      02.服务消费.mp4</span><br><span class="line">│      03.服务消费升级改造.mp4</span><br><span class="line">│      04.RestTemplate-GET.mp4</span><br><span class="line">│      05.RestTemplate-POST.mp4</span><br><span class="line">│      06.RestTemplate-PUT.mp4</span><br><span class="line">│      07.RestTemplate-DELETE.mp4</span><br><span class="line">│      08.客户端负载均衡.mp4</span><br><span class="line">│      09.负载均衡原理.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 04 章 Consul</span><br><span class="line">│      01.Consul 介绍.mp4</span><br><span class="line">│      02.Consul 安装.mp4</span><br><span class="line">│      03.Consul 单节点注册.mp4</span><br><span class="line">│      04.Consul 集群注册.mp4</span><br><span class="line">│      05.Consul 消费.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 05 章 Hystrix</span><br><span class="line">│      01.Hystrix 简单介绍.mp4</span><br><span class="line">│      02.Hystrix 简单应用.mp4</span><br><span class="line">│      03.Hystrix 效果展示.mp4</span><br><span class="line">│      04.Hystrix 请求命令.mp4</span><br><span class="line">│      05.Hystrix 注解实现异步调用.mp4</span><br><span class="line">│      06.Hystrix 容错[请求命令方式].mp4</span><br><span class="line">│      07.Hystrix 异常处理.mp4</span><br><span class="line">│      08.Hystrix 请求缓存.mp4</span><br><span class="line">│      09.Hystrix 请求合并.mp4</span><br><span class="line">│      10.Hystrix 请求合并[注解方式].mp4</span><br><span class="line">│      </span><br><span class="line">├─第 06 章 OpenFeign</span><br><span class="line">│      01.OpenFeign 简介.mp4</span><br><span class="line">│      02.HelloWorld.mp4</span><br><span class="line">│      03.OpenFeign 参数传递.mp4</span><br><span class="line">│      04.OpenFeign 继承特性.mp4</span><br><span class="line">│      05.OpenFeign 日志配置.mp4</span><br><span class="line">│      06.OpenFeign 数据压缩.mp4</span><br><span class="line">│      07.OpenFeign 服务降级.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 07 章 Resilience4j</span><br><span class="line">│      01.Resilience4j 介绍.mp4</span><br><span class="line">│      02.断路器使用演示.mp4</span><br><span class="line">│      03.RateLimiter 示例.mp4</span><br><span class="line">│      04.Retry 示例.mp4</span><br><span class="line">│      05.微服务中的重试.mp4</span><br><span class="line">│      06.微服务中的断路器.mp4</span><br><span class="line">│      07.微服务中的限流.mp4</span><br><span class="line">│      08.监控简介[复习Spring Boot第14章].mp4</span><br><span class="line">│      09.Prometheus.mp4</span><br><span class="line">│      10.Grafana.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 08 章 Zuul</span><br><span class="line">│      01.服务网关介绍.mp4</span><br><span class="line">│      02.Zuul 简介.mp4</span><br><span class="line">│      03.HelloWorld.mp4</span><br><span class="line">│      04.Zuul 请求过滤.mp4</span><br><span class="line">│      05.Zuul 中的其他配置.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 09 章 Spring Cloud Gateway</span><br><span class="line">│      01.Spring Cloud Gateway 介绍.mp4</span><br><span class="line">│      02.Spring Cloud Gateway 基本用法.mp4</span><br><span class="line">│      03.Spring Cloud Gateway 结合微服务.mp4</span><br><span class="line">│      04.Predicate.mp4</span><br><span class="line">│      05.Filter.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 10 章 Spring Cloud Config</span><br><span class="line">│      01.Spring Cloud Config 介绍.mp4</span><br><span class="line">│      02.准备配置文件.mp4</span><br><span class="line">│      03.ConfigServer 搭建.mp4</span><br><span class="line">│      04.ConfigClient 搭建.mp4</span><br><span class="line">│      05.ConfigServer 简单配置.mp4</span><br><span class="line">│      06.常见加密方式介绍.mp4</span><br><span class="line">│      07.配置文件对称加密.mp4</span><br><span class="line">│      08.配置文件非对称加密.mp4</span><br><span class="line">│      09.ConfigServer安全管理.mp4</span><br><span class="line">│      10.配置服务化.mp4</span><br><span class="line">│      11.配置文件动态刷新.mp4</span><br><span class="line">│      12.请求失败重试.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 11 章 Spring Cloud Bus</span><br><span class="line">│      01.Spring Cloud Bus 实现配置文件自动刷新.mp4</span><br><span class="line">│      02.Spring Cloud Bus 刷新单个配置文件.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 12 章 Spring Cloud Stream</span><br><span class="line">│      01.Spring Cloud Stream 环境搭建.mp4</span><br><span class="line">│      02.Spring Cloud Stream 自定义消息通道.mp4</span><br><span class="line">│      03.Spring Cloud Stream 消息分组.mp4</span><br><span class="line">│      04.Spring Cloud Stream 消息分区.mp4</span><br><span class="line">│      05.Spring Cloud Stream 定时任务.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 13 章 链路追踪</span><br><span class="line">│      01.Spring Cloud Sleuth 简介.mp4</span><br><span class="line">│      02.Spring Cloud Sleuth 初体验.mp4</span><br><span class="line">│      03.Spring Cloud Sleuth 异步任务信息收集.mp4</span><br><span class="line">│      04.Zipkin 简单介绍.mp4</span><br><span class="line">│      05.Zipkin 安装.mp4</span><br><span class="line">│      06.Zipkin 体验.mp4</span><br><span class="line">│      </span><br><span class="line">└─第 14 章 Spring Cloud Alibaba</span><br><span class="line">        01.Spring Cloud Alibaba 简介.mp4</span><br><span class="line">        02.Nacos 安装+配置中心.mp4</span><br><span class="line">        03.Nacos 做注册中心.mp4</span><br><span class="line">        04.Sentinel 介绍.mp4</span><br><span class="line">        05.Sentinel 安装.mp4</span><br><span class="line">        06.Sentinel 基本用法.mp4</span><br><span class="line">        07.Nacos 中配置流控规则.mp4</span><br></pre></td></tr></table></figure><p>完整的视频目录大家可以在公众号后台回复 <code>视频目录</code> 获取百度网盘地址查看。</p><p><strong>单纯看这整整齐齐的目录就知道，这套视频松哥绝对用心做了。</strong> </p><p>为了这套视频松哥牺牲了太多休息时间和陪女票的时间，我一般都是下班后回到家就开始录视频，女票只能安安静静呆在一边，不发出一点声音，就这样积少成多，一步一步积攒成约 74 个小时的视频教程。</p><p>之前有小伙伴问松哥哪来那么多时间写文章录视频？还能从哪里来？熬夜呗。</p><p><img src="http://img.itboyhub.com//2020/03/video-1.jpg" alt></p><p>刚开始录制的时候，松哥经验也不是很丰富，我的 Windows 电脑用了 8 年了，录制出来的视频有 呲呲呲呲 的电流声，于是我又去学习了 Adobe Premiere Pro ，把录制的视频用 pr 统一处理了一遍，把噪音降低到最小：</p><p><img src="http://img.itboyhub.com//2020/03/video-2.jpg" alt></p><p>刚开始因为没经验，我对这个问题也束手无策，只能通过软件解决，后来经过小伙伴提醒，松哥花大价钱入手了一个专业的麦，从此彻底解决了视频音质问题。</p><p><img src="http://img.itboyhub.com//2020/03/video-3.jpg" alt></p><p>当然，对于视频教程而言，比这些更重要的是视频的质量，讲的思路是否清晰，小伙伴是否能听懂这才是关键。</p><p>其实录视频和写博客有着异曲同工之妙，只是一个知识点的不同展示形式而已。如果你觉得松哥平时的博客写的还不错，能看懂，那么视频基本上也能看懂。这不是我自卖自夸，有小伙伴的评价为证，随便列举一例：</p><p><img src="http://img.itboyhub.com//2020/03/video-10.png" alt></p><p>但是要提醒大家的是，学习松哥这套视频教程<strong>需要有 ssm 基础和 js 基础</strong>，如果你对 ssm 尚不熟悉，可以先看看松哥的自己手敲 5万 余字的 ssm 入门教程，在<strong>公众号后台回复 ssm</strong> 可以获取下载链接。</p><p>无论是时间还是精力，在这套视频教程上松哥都投入了很多，所以视频是付费视频。<strong>按照我们之前的约定，每有一套课程完结的时候，就会调整一下价格，现在 Spring Cloud 完结了，所以视频价格也要调整到 199 了，虽然价格调整了下，但是老实说，依然不贵，Spring Boot+Vue+Spring Cloud+Redis+微人事，四套视频，大家可以在慕课网或者 csdn 学院对比下价格就知道了。</strong></p><p>松哥去年出版了 《Spring Boot+Vue全栈开发实战》，迄今为止这本书加印了多次，今年春节过后，有好几个高校老师加我微信，跟老师们聊天后得知，有两所北京的 985 高校用这本书做了项目实践的教材，其他高校老师的微信也加了不少，还是蛮有成就感的。那么<strong>凡是在今明两天（2020.03.16-2020.03.17 23:59）购买视频的小伙伴，可以参加松哥组织的一波抽奖活动，中奖概率是 1/5，奖品是一本签名版的《Spring Boot+Vue全栈开发实战》,包邮到家。</strong></p><p>按照惯例，接下来我要秀一波小伙伴们对视频的评价：</p><p><img src="http://img.itboyhub.com//2020/03/video-5.png" alt><br><img src="http://img.itboyhub.com//2020/03/video-6.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-7.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-8.jpg" alt></p><p>秀完之后，接下来再把视频常见问题和大家捋一捋：</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：以后录的视频都可以看吗？</strong></p><p>这次松哥一共计划出四套视频课程，Spring Boot、微人事、Spring Cloud 以及 Redis，其中前三个目前已经录完了，大家在公众号后台回复 <code>视频目录</code> 可以查看已经录完的视频详情，Redis 从三月份开始更新，现在也已经更新到第四章了。也就是 199 一共可以看这四套视频。</p><p><strong>Q4：视频可以试看吗？</strong></p><p>其实我平时在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。小伙伴们也可以在公众号后台回复 <code>vhr试看</code> 获取试看合集。</p><p><strong>Q5：可以砍价吗？</strong></p><p>不可以。</p><p><strong>Q6：星球是怎么回事？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问。</p><p><strong>Q7：付费视频和免费视频有什么区别？</strong></p><p>免费视频是我在网上搜集别人录制的视频，大家在公众号后台回复 <code>2TB</code> 可以获取，付费视频是我自己录制的，录完之后都有二次剪辑，去噪，花费了很大功夫，因此是付费的。</p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频适合哪些人看？</strong></p><p>学习这套视频，后端需要有 SSM 基础，前端需要有 js 基础（可以不懂 Vue，第十六章视频会讲）。要是不懂 SSM，可以先看松哥之前手敲 5 万余字的 SSM 教程，公众号后台回复 ssm 可以获取下载链接。</p><p>好了，加松哥微信(<strong>a_java_boy</strong>)，发红包 199，和众多小伙伴一起撸 Spring Boot + Vue +Spring Cloud 以及微人事项目吧。</p><p><img src="http://img.itboyhub.com//2020/03/a_java_boy.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚过完年一直在各种忙，即使在家里远程办公也一直没歇着。忙里偷闲，还是抽空把 Spring Cloud 视频教程录完了，并且 Redis 教程也已经开始录制了，给小伙伴们承诺的四套视频教程，即将迎来大结局。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之 Postfix Completion</title>
    <link href="http://www.javaboy.org/2020/0314/idea-postfix-completion.html"/>
    <id>http://www.javaboy.org/2020/0314/idea-postfix-completion.html</id>
    <published>2020-03-14T02:04:05.000Z</published>
    <updated>2020-03-27T03:24:50.159Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/_ZL7q87PglBvnKiiWMuxaQ" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/_ZL7q87PglBvnKiiWMuxaQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何动态更新已登录用户信息？松哥来和大家捋一捋</title>
    <link href="http://www.javaboy.org/2020/0313/spring-security-update-info.html"/>
    <id>http://www.javaboy.org/2020/0313/spring-security-update-info.html</id>
    <published>2020-03-13T02:03:37.000Z</published>
    <updated>2020-03-27T03:39:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>前两天松哥发了一篇文章，和大家仔细的过了一遍 Spring Security 的登录流程：</p><ul><li><a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a></li></ul><a id="more"></a><p>在这篇文章中，我和大家详细分享了 Spring Security 的登录流程，在登录成功的最后一步，进入到 successfulAuthentication 回调中，在该回调方法中，小伙伴们看到了用户信息的保存位置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br></pre></td></tr></table></figure><p>这样一行简单的保存代码，至少带给我们两方面的信息：</p><ol><li>以后在任何地方，只要想获取用户信息，只需要调用 <code>SecurityContextHolder.getContext().getAuthentication()</code> 就可以获取到。</li><li>以后在任何地方，只要想更新用户信息，只要调用 <code>SecurityContextHolder.getContext().setAuthentication(authResult);</code> 就可以更新。</li></ol><h2 id="1-获取用户登录信息"><a href="#1-获取用户登录信息" class="headerlink" title="1.获取用户登录信息"></a>1.获取用户登录信息</h2><p>用户信息的获取，其实办法很多，上面提到的 <code>SecurityContextHolder.getContext().getAuthentication()</code> 是一个静态方法，也就是利用这个方法，我们可以随时随地拿到用户信息（需要注意 ThreadLocal 的限制）。</p><p>除了这种方式之外，我们也可以在 Controller 中的方法上，直接就可以注入 Authentication 对象，进而获取到当前用户信息，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hr/info"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Hr <span class="hljs-title">getCurrentHr</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ((Hr) authentication.getPrincipal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，关于用户信息获取的方式之前已经和大家聊过了，这里我就不再赘述，如果对如何获取 Spring Security 中用户信息还不熟悉，大家可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a></p><p>今天主要是想和大家聊一下如何修改用户信息。</p><h2 id="2-修改用户登录信息"><a href="#2-修改用户登录信息" class="headerlink" title="2.修改用户登录信息"></a>2.修改用户登录信息</h2><p>在 Spring Security 中，当用户登录成功之后，如果前端提供了修改用户信息的功能，在前端修改完用户信息之后，存储在 Spring Security 中的用户信息也要及时修改，以防止在后面其他的请求中获取到错误的用户信息，Spring Security 中用户信息要如何修改呢？</p><p>一起来看大屏幕：</p><p><a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">视频地址</a></p><p>好了，不知道小伙伴们有没有 GET 到呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天松哥发了一篇文章，和大家仔细的过了一遍 Spring Security 的登录流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;松哥手把手带你捋一遍 Spring Security 登录流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Redis 做分布式锁你会几种姿势？松哥来给大家介绍两种</title>
    <link href="http://www.javaboy.org/2020/0312/redis-distribute.html"/>
    <id>http://www.javaboy.org/2020/0312/redis-distribute.html</id>
    <published>2020-03-12T08:55:29.000Z</published>
    <updated>2020-03-12T09:01:43.673Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 简简单单的几种数据类型，一个 key/value 数据库，现在又是分布式锁、又是限流工具、又是消息队列……，感觉都要被玩坏了。不过话说回来，Redis 在这么多场合被开发者们喜欢，还是得益于它极高的性能与使用的简洁性。</p><a id="more"></a><p>在面试的时候，说到 Redis ，很多人第一反应就是缓存，其实除了缓存，Redis 还有非常多丰富的使用场景，这些使用场景，松哥在未来都会和大家一一分享。</p><p>今天就先来看一个简单的，用 Redis 做分布式锁。</p><h2 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1.什么是分布式锁"></a>1.什么是分布式锁</h2><p>首先我们来看一个问题场景：</p><blockquote><p>例如一个简单的用户操作，一个线程去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。</p></blockquote><p>解决这个问题，我们就需要锁，对于锁，大家应该不会陌生，在 Java 中的 synchronized 以及 ReentrantLock 可重入锁都是我们比较常见的，但是这种锁都是本地锁，现在微服务、分布式系统思想大行其道，在这样的系统中，本地锁显然是不够用的，于是大家纷纷想办法，如何在分布式环境下解决锁的问题。想出来的办法很多，我们可以通过 MySQL、可以通过 ZK、也可以通过 Redis ，都可以用来解决分布式锁的问题，这里我们主要来看看如何通过 Redis 解决分布式锁问题。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><h3 id="2-1-整体思路"><a href="#2-1-整体思路" class="headerlink" title="2.1 整体思路"></a>2.1 整体思路</h3><p><strong>分布式锁实现的思路很简单，就是进来一个线城先占位，当别的线城进来操作时，发现已经有人占位了，就会放弃或者稍后再试。</strong></p><p>在 Redis 中，占位一般使用 setnx 指令，先进来的线程先占位，线程的操作执行完成后，再调用 del 指令释放位子。同时为了防止死锁，我们一般还要给锁加一个过期时间，到期了自动释放。</p><p>基于这样的思路，我们来看两种不同的实现方式：</p><h3 id="2-2-解决方案一"><a href="#2-2-解决方案一" class="headerlink" title="2.2 解决方案一"></a>2.2 解决方案一</h3><p>基于我们前面所说的思路，可以使用 setnx 和 expire 实现分布式锁，但是 setnx 和设置过期时间 expire 这是两个操作，这两个操作一起的话就不具备原子性（除非自己写 Lua 脚本），为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了，这个命令就是 set，set 中多了一个参数:</p><p><img src="http://img.itboyhub.com/2020/03/dis-redis-1.png" alt></p><p>从图中大家可以看到，在 key/value 之后，还有一个 EX 5 表示以秒计的过期时间（PX 表示以毫秒计的过期时间），最后的 NX 就是说如果 k1 不存在，这条命令执行成功，否则执行失败，这就相当于 setnx 的效果了。</p><p>因此，我们封装的锁如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="hljs-keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis-&gt;&#123;</span><br><span class="line">            String set = jedis.set(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"v1"</span>, <span class="hljs-keyword">new</span> SetParams().nx().ex(<span class="hljs-number">5</span>));</span><br><span class="line">            <span class="hljs-keyword">if</span> (set !=<span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">"OK"</span>.equals(set)) &#123;</span><br><span class="line">                <span class="hljs-comment">//没人占位</span></span><br><span class="line">                jedis.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">                String name = jedis.get(<span class="hljs-string">"name"</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                jedis.del(<span class="hljs-string">"k1"</span>);<span class="hljs-comment">//释放资源</span></span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                <span class="hljs-comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，大家重点看思路，不必深究代码细节：</p><ol><li>首先构造一个 Redis 实例，然后调用 execute 方法，这个是我自己封装的方法，目的是为了配置 Jedis 连接池并及时回收使用过的资源。这一块小伙伴们测试的时候可以直接使用自己创建的 Jedis 实例，效果是一样的。</li><li>调用 jedis 中的 set 方法，注意第三个参数，我们设置了 nx 同时 设置了过期时间为 5 秒，这就相当于 setnx 和 expire 两个命令的结合体。</li><li>如果成功执行了 set 命令，在 if 中就可以去写自己的业务了。如果没能抢到锁，则可以进入到一个延迟消息队列中，停一会再去尝试（用 Redis 实现延迟消息队列，松哥会在后面的文章中向大家介绍）。</li></ol><p>但是这样的封装，又带来了一个新的问题，那就是超时问题，关于超时问题，松哥通过一个视频教程来和大家分享（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot+Vue+Spring Cloud+Redis 系列视频教程</a>）：</p><p><img src="https://mp.weixin.qq.com/s/NKiLt2Ebofa1Wq1k5sFscA" alt="视频地址"></p><h3 id="2-3-解决方案二"><a href="#2-3-解决方案二" class="headerlink" title="2.3 解决方案二"></a>2.3 解决方案二</h3><p>上面的代码写着还是蛮长的，那么有没有简单一点的办法呢？当然是有的！那就是 Redisson。</p><p>相对于 Jedis 这种原生态的应用，Redisson 对 Redis 请求做了较多的封装，对于锁，也提供了对应的方法可以直接使用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="hljs-keyword">new</span> Config();</span><br><span class="line"><span class="hljs-comment">//配置 Redis 基本连接信息</span></span><br><span class="line">config.useSingleServer().setAddress(<span class="hljs-string">"redis://127.0.0.1:6379"</span>).setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line"><span class="hljs-comment">//获取一个 RedissonClient 对象</span></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line"><span class="hljs-comment">//获取一个锁对象实例</span></span><br><span class="line">RLock lock = redisson.getLock(<span class="hljs-string">"lock"</span>); </span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//获取锁</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = lock.tryLock(<span class="hljs-number">500</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="hljs-keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="hljs-comment">//获取到锁了，开始写业务</span></span><br><span class="line">        RBucket&lt;Object&gt; bucket = redisson.getBucket(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        bucket.set(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        Object o = bucket.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"没拿到锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//释放锁</span></span><br><span class="line">    lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，核心的就是 <code>lock.tryLock(500, 1000, TimeUnit.MILLISECONDS);</code>，第一个参数是尝试加锁的等待时间为 500 毫秒，第二个参数表示锁的超时时间为 1000 毫秒，也就是这个锁在 1000 毫秒后会自动失效。</p><p>小伙伴们发现，这和我们在方案一里边配置的参数是一样的，其实思路是不变的，Redisson 只不过是将我们写的和锁相关的方法封装起来了而已。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>当然，这里我只是先简单介绍下加锁的思路以及在 Redis 单机中如何加锁，后面松哥再和大家分享 Redis 集群中如何加锁。如果小伙伴们对于 Redis 的基本用法还不太熟悉的话，可以在松哥公众号后台回复 redis，获取松哥手敲的 Redis 入门教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 简简单单的几种数据类型，一个 key/value 数据库，现在又是分布式锁、又是限流工具、又是消息队列……，感觉都要被玩坏了。不过话说回来，Redis 在这么多场合被开发者们喜欢，还是得益于它极高的性能与使用的简洁性。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
      <category term="分布式锁" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</title>
    <link href="http://www.javaboy.org/2020/0312/springboot-fastdfs.html"/>
    <id>http://www.javaboy.org/2020/0312/springboot-fastdfs.html</id>
    <published>2020-03-12T08:32:02.452Z</published>
    <updated>2020-03-12T08:53:10.682Z</updated>
    
    <content type="html"><![CDATA[<p>本文上周日发过，但是有小伙伴看了之后表示 FastDFS 老是安装失败！松哥这犟脾气，绝对不能忍，一定要教会大家，这不赶紧抽空录了一个视频手把手教大家安装 FastDFS，并且实现通过 Java 代码上传/下载文件的功能。小伙伴们一起来看下，这次一定要学会呀！</p><a id="more"></a><p>FastDFS 介绍：</p><iframe src="//player.bilibili.com/player.html?aid=95352488&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>安装 FastDFS 并实现文件上传：</p><iframe src="//player.bilibili.com/player.html?aid=95353225&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>安装 Nginx 模块并实现文件访问：</p><iframe src="//player.bilibili.com/player.html?aid=95353463&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>解决文件安全管理问题：</p><iframe src="//player.bilibili.com/player.html?aid=95353728&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（<code>Taobao File System</code> 和 <code>Tencent File System</code>）。</p><p>相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。因此，松哥今天就来和大家简单聊一聊这个问题。</p><p>如果小伙伴们还不懂在传统的开发环境下如何进行文件上传，可以参考松哥之前发的文件上传教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li></ul><h2 id="1-什么是-FastDFS"><a href="#1-什么是-FastDFS" class="headerlink" title="1.什么是 FastDFS"></a>1.什么是 FastDFS</h2><h3 id="1-1-FastDFS-简介"><a href="#1-1-FastDFS-简介" class="headerlink" title="1.1 FastDFS 简介"></a>1.1 FastDFS 简介</h3><p>FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。</p><p>这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。</p><p>FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。</p><h3 id="1-2-为什么需要-FastDFS"><a href="#1-2-为什么需要-FastDFS" class="headerlink" title="1.2 为什么需要 FastDFS"></a>1.2 为什么需要 FastDFS</h3><p>传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。</p><p>但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。</p><h3 id="1-3-FastDFS-架构"><a href="#1-3-FastDFS-架构" class="headerlink" title="1.3 FastDFS 架构"></a>1.3 FastDFS 架构</h3><p>作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能：</p><ul><li>文件存储</li><li>文件同步</li><li>文件上传</li><li>文件下载</li></ul><p>这个方面的功能，基本上就能搞定我们常见的文件管理需求了。</p><p>下面这是一张来自 FastDFS 官网的系统架构图：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-1.png" alt></p><p>从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。</p><p>我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。</p><p>Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。</p><h2 id="2-FastDFS-安装"><a href="#2-FastDFS-安装" class="headerlink" title="2.FastDFS 安装"></a>2.FastDFS 安装</h2><p>介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。</p><p>我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。</p><p>图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装我将从三个方面来介绍：</p><ul><li>Tracker 安装</li><li>Storage 安装</li><li>Nginx 安装</li></ul><h3 id="2-1-Tracker-安装"><a href="#2-1-Tracker-安装" class="headerlink" title="2.1 Tracker 安装"></a>2.1 Tracker 安装</h3><p>安装，我们首先需要准备一个环境两个库以及一个安装包。</p><p><strong>1.一个环境</strong></p><p>先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p><strong>2.两个库</strong></p><p>再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libevent</span><br></pre></td></tr></table></figure><p>另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。</p><p>libfastcommon 下载地址：<a href="https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下，然后依次执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.0.43.tar.gz</span><br><span class="line">cd libfastcommon-1.0.43/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p><strong>3.一个安装包</strong></p><p>接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。</p><p>安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：<a href="https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载成功后，将下载文件拷贝到 /usr/local 目录下，然后依次执行如下命令安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V6.06.tar.gz</span><br><span class="line">cd fastdfs-6.06/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p>安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd conf/</span><br><span class="line">cp ./* /etc/fdfs/</span><br></pre></td></tr></table></figure><p><strong>4.配置</strong></p><p>接下来进入 /etc/fdfs/ 目录下进行配置：</p><p>打开 tracker.conf 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi tracker.conf</span><br></pre></td></tr></table></figure><p>修改如下配置：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-2.png" alt></p><p>默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。</p><p><strong>5.启动</strong></p><p>接下来执行如下命令启动 Tracker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</span><br></pre></td></tr></table></figure><p>如此之后，我们的 Tracker 就算安装成功了。</p><h3 id="2-2-Storage-安装"><a href="#2-2-Storage-安装" class="headerlink" title="2.2 Storage 安装"></a>2.2 Storage 安装</h3><p>简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里我不在细说。</p><p>Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。</p><p>唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi storage.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-3.png" alt></p><p>这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。</p><p>配置完成后，执行如下命令启动 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start</span><br></pre></td></tr></table></figure><p>这两个启动完成后，现在就可以做文件的上传了，但是一般如果是图片文件，我们还需要提供一个图片的访问功能，目前来说最佳方案当然是 Nginx 了，所以我们这里连同 Nginx 一起配置好，再来做测试。</p><h3 id="2-3-Nginx-安装"><a href="#2-3-Nginx-安装" class="headerlink" title="2.3 Nginx 安装"></a>2.3 Nginx 安装</h3><p>Nginx 可以算是 FastDFS 的重要搭档。</p><p>Nginx 的安装分为两个步骤：</p><ul><li>安装 Nginx</li><li>首先在 Storage 下安装 fastdfs-nginx-module</li></ul><p>第一步简单，松哥之前专门写过一篇文章扫盲 Nginx，所以 Nginx 安装大家直接参考这里：<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></p><p>接下来看第二步。</p><p>首先下载 fastdfs-nginx-module，下载地址：<a href="https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载完成后，将下载的文件拷贝到 /usr/local 目录下。然后进入 /usr/local 目录，分别执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.22.tar.gz</span><br></pre></td></tr></table></figure><p>然后将 <code>/usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf</code> 文件拷贝到 <code>/etc/fdfs/</code> 目录下，并修改该文件的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/mod_fastdfs.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-4.png" alt></p><p>接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/src</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完成后，修改 nginx 的配置文件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-5.png" alt></p><p>在这里配置 nginx 请求转发。</p><p>配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_fastdfs_set pid=9908</span><br></pre></td></tr></table></figure><p><strong>疑问：fastdfs-nginx-module 有啥用</strong></p><p>看了整个安装过程之后，很多小伙伴有疑问，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？</p><p>前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。</p><p>安装成功了。</p><h2 id="3-Java-客户端调用"><a href="#3-Java-客户端调用" class="headerlink" title="3.Java 客户端调用"></a>3.Java 客户端调用</h2><p>安装成功后，接下来我们就用 Java 客户端来测试一下文件上传下载。</p><p>首先我们来创建一个普通的 Maven 工程，添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.27.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在项目的 resources 目录下添加 FastDFS 的配置文件 fastdfs-client.properties，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastdfs.connect_timeout_in_seconds = 5</span><br><span class="line">fastdfs.network_timeout_in_seconds = 30</span><br><span class="line">fastdfs.charset = UTF-8</span><br><span class="line">fastdfs.http_anti_steal_token = false</span><br><span class="line">fastdfs.http_secret_key = FastDFS1234567890</span><br><span class="line">fastdfs.http_tracker_http_port = 80</span><br><span class="line">fastdfs.tracker_servers = 192.168.91.128:22122</span><br><span class="line">fastdfs.connection_pool.enabled = true</span><br><span class="line">fastdfs.connection_pool.max_count_per_entry = 500</span><br><span class="line">fastdfs.connection_pool.max_idle_time = 3600</span><br><span class="line">fastdfs.connection_pool.max_wait_time_in_ms = 1000</span><br></pre></td></tr></table></figure><p>这里的配置基本上都能见名知义，我就不挨个解释了。这里先配置下 fastdfs.tracker_servers，这是 Tracker 的地址，根据实际情况配置即可。</p><p>fastdfs.http_secret_key 配置这里先不用管它，后面我会跟大家解释。</p><h3 id="3-1-文件上传"><a href="#3-1-文件上传" class="headerlink" title="3.1 文件上传"></a>3.1 文件上传</h3><p>配置完成后，先来看文件上传，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        NameValuePair nvp[] = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-comment">//上传到文件系统</span></span><br><span class="line">        String fileId = client.upload_file1(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\1.png"</span>, <span class="hljs-string">"png"</span>,</span><br><span class="line">                nvp);</span><br><span class="line">        logger.info(fileId);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。</p><p>最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息，这个方法的返回值，就是上传文件的访问路径。执行该方法，打印日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-29 17:46:03.017  INFO 6184 --- [           main] o.j.fastdfs.FastdfsApplicationTests      : group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</span><br></pre></td></tr></table></figure><p>group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png 就是文件的路径，此时，在浏览器中输入 <a href="http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png" target="_blank" rel="noopener">http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</a> 就可以看到上传的图片了。</p><h3 id="3-2-文件下载"><a href="#3-2-文件下载" class="headerlink" title="3.2 文件下载"></a>3.2 文件下载</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDownload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] bytes = client.download_file1(<span class="hljs-string">"group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\666.png"</span>));</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就很好理解了，直接调用 download_file1 方法获取到一个 byte 数组，然后通过 IO 流写出到本地文件即可。</p><h2 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h2><p>现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。</p><p>首先我们在服务端开启令牌校验：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/http.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-6.png" alt></p><p>配置完成后，记得重启服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>接下来，在前端准备一个获取令牌的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ts = (<span class="hljs-keyword">int</span>) Instant.now().getEpochSecond();</span><br><span class="line">    String token = ProtoCommon.getToken(<span class="hljs-string">"M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>, ts, <span class="hljs-string">"FastDFS1234567890"</span>);</span><br><span class="line">    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="hljs-string">"?token="</span>).append(token);</span><br><span class="line">    sb.append(<span class="hljs-string">"&amp;ts="</span>).append(ts);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，<strong>注意，这个地址里边不包含 group，千万别搞错了；</strong>第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。</p><p>将生成的字符串拼接，追加到访问路径后面，如：<code>http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854</code>。<strong>此时访问路径里边如果没有令牌，会访问失败。</strong></p><p>好了，大功告成！下次和大家讲我如何在 Spring Boot 中玩这个东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文上周日发过，但是有小伙伴看了之后表示 FastDFS 老是安装失败！松哥这犟脾气，绝对不能忍，一定要教会大家，这不赶紧抽空录了一个视频手把手教大家安装 FastDFS，并且实现通过 Java 代码上传/下载文件的功能。小伙伴们一起来看下，这次一定要学会呀！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>程序员写书到底赚钱吗</title>
    <link href="http://www.javaboy.org/2020/0311/book.html"/>
    <id>http://www.javaboy.org/2020/0311/book.html</id>
    <published>2020-03-11T08:55:17.000Z</published>
    <updated>2020-03-12T11:02:25.220Z</updated>
    
    <content type="html"><![CDATA[<p>年前的时候松哥发了一篇文章，说新书交稿后入手了一台 MacBook Pro（<a href="https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ" target="_blank" rel="noopener">MacBook Pro 入手一年了，到底香不香？</a>），于是有小伙伴问松哥，出书是不是赚翻了？</p><a id="more"></a><p>老实说，这本书到现在赚的钱，买一台 MacBook Pro 肯定是够了，但是你要说赚翻了，我想这里肯定存在一些误解。今天我就来和大家聊一聊程序员的出书流程，收入结算，以及如果你也想在未来有一天自己的书摆在大学的图书馆，你现在该做些什么。</p><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>出书这个事情，绝非一日之功。如果你有这方面的计划，那么现在就开始写博客吧。写博客有两方面的好处：</p><ol><li>自己做技术积累，文字积累，写作功底积累</li><li>打造个人品牌，被出版社的编辑发掘</li></ol><p>技术积累，这个好说，你要写书，你首先肚子里得有货，那这就是一个长期积累的过程。写作功底的积累，这个不是说要写的多么优美，毕竟写技术图书不是写散文，把一个复杂的技术点，能够清晰明了的讲出来，让读者一看就懂，这才是关键。我记得我在 2016 年写过一个读书笔记，有个读者给了下面一句评论：</p><p><img src="http://img.itboyhub.com/2020/03/book-1.png" alt></p><p>这个评价我看到还是蛮开心的，技术上的事，自己懂是一回事，教会别人又是另一回事。所以如果你打算未来也能有一本自己的书，那么就开始写博客吧，学着去把一个复杂的知识点细化，然后把它讲清楚，让别人能够看懂看明白。</p><p>写博客的另外一个好处，就是打造个人品牌，使自己更易被出版社编辑发掘。</p><p>现在的出版社基本上都是自负盈亏的，所以对出版社来说，他肯定会考虑一本书是否能够盈利，一本书要能够盈利，那么他在选作者的时候，会重点关注两方面：</p><ol><li>作者是否在某一个技术领域深耕多年，对该领域有一些自己的见解</li><li>作者是否自带流量</li></ol><p>这两点中，第一点比第二点重要。那么如何让出版社的编辑知道你在某一领域深耕多年呢？这就要看平时的日常积累了，其实也就是你的博客。至于第二点，如果作者自带流量，那么书出版之后，销售压力要小很多，所以这也算是一个优势吧。我 2018 年写书的时候，公众号还被我晾在一边，根本就没有流量，但是最终书也出版了，所以第二点是锦上添花。</p><h2 id="如何让出版社找到我"><a href="#如何让出版社找到我" class="headerlink" title="如何让出版社找到我"></a>如何让出版社找到我</h2><p>家有梧桐树，引得凤凰来。</p><p>各大出版社的编辑，就像侦探一样，潜伏在各大博客平台上，像 CSDN、博客园、慕课手记、sf 等，你在这些平台上写博客，就会被各大出版社的编辑注意到，如果没联系你，可能时机还未成熟，也可能是你火候未到。不过只要你坚持写下去，机会肯定是有的，你要是不写，那机会几乎为 0 了。</p><p>除了出版社的编辑潜伏在博客平台之外，还有一些第三方的出书公司也潜伏在博客平台，出书公司我没合作过，也不太懂他们的流程。他们相当于是中介，最终也是和出版社合作的，只不过你自己不用接触出版社，直接和他们对接即可，他们大多潜伏在慕课手记上。但是我不太建议和第三方公司合作，辛辛苦苦大半年，到头来竟然是和一个中介合作。</p><p>所以这个问题大家不用担心，只要你坚持写博客做积累，该来的总会来的。</p><h2 id="稿费怎么算"><a href="#稿费怎么算" class="headerlink" title="稿费怎么算"></a>稿费怎么算</h2><p>稿费这块，有多种结算方式，给大家看看我当时签订的合同：</p><p><img src="http://img.itboyhub.com/2020/03/book-3.png" alt></p><p>可以看到，稿费有多种结算方式，但是一般来说，大部分都是选择第一种。</p><p>其实稿费这块，我觉得作者议价空间很有限，大部分出版社给到作者的稿酬都是 8%。有的小伙伴可能觉得这也太低了，但是目前的图书市场就是这样。作为一个参考，1991 年北京三联书店签下金庸 15 部武侠小说在内地 10 年的出版权，当时的版税率是 15%。</p><p>现在写书你只要写就行了，写完之后，剩下的事情都是交给出版社去做，三审三校、排版印刷、物流、铺货，销售渠道、营销等等，这些都要花钱，而这些你都不用管，出版社会做好。</p><p>所以，一本售价 ¥70 的书，到作者手上就是 ¥5.6 ，这还不算个人所得税，除去个人所得税，这个数字还要更低一些。</p><p>现在技术图书，特别是一些热点技术相关的图书，销量过万基本上就算是畅销书了，这样算下来，一本书的稿费可能就是程序员一两个月的薪水而已。</p><p>所以，如果为了赚钱，还不如去平台上开网课（例如 GitChat 之类），这种虽然平台也要抽成，但是作者的收益可能还略高于出书。</p><h2 id="出版要多久"><a href="#出版要多久" class="headerlink" title="出版要多久"></a>出版要多久</h2><p>写作的时间这个不好说，每个人的效率都不太一样，我这里主要说交稿之后的时间。正常来说交稿之后，出版社那边的流程大概要走 3 个月左右，然后书就可以上市销售了，一些特殊情况，出版社可能会赶工，这样出版时间可能还会压缩至两个月左右。</p><h2 id="出版社的选择"><a href="#出版社的选择" class="headerlink" title="出版社的选择"></a>出版社的选择</h2><p>国内虽然出版社众多，不过每家出版社都有自己擅长的领域，技术图书一般就是清华大学出版社、机械工业出版社、电子工业出版社、人民邮电出版社等几家，在这些出版社中，清华社的教材渠道做的很好，也就是说他打通了和学校之间的渠道，在清华社出版的书容易被高校选做教材，其他出版社这方面稍弱，当然这只是相对而言，每家出版社都有自己擅长的地方，你所了解的一些大名鼎鼎的书，一方面和书的质量有关，另一方面也和出版社的营销力度有关。</p><h2 id="大致的出版流程"><a href="#大致的出版流程" class="headerlink" title="大致的出版流程"></a>大致的出版流程</h2><p>一般出版的流程是这样，首先作者提交选题单（选题单包含作者信息登记表、书的目录大纲以及样章等），然后出版社那边的流程主要有<strong>选题论证-&gt;选题审批-&gt;签订出版合同-&gt;自己写作-&gt;交稿-&gt;排版-&gt;三审三校-&gt;书稿送作者审校与统稿-&gt;出版</strong>。</p><p>说了这么多，其实前两点是最重要的，做好前面两点，后面都是很容易的事情了。感兴趣的小伙伴可以看看，即使不出书，感受一把被约稿也是不错的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不过老实说，写书的意义不在于赚钱。仅仅从赚钱的角度来说，出网课可能更划算一些。但是如果想给自己的职业生涯留点东西，写书意义大于出网课。最后，建议小伙伴们看看松哥之前这篇文章：<a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年前的时候松哥发了一篇文章，说新书交稿后入手了一台 MacBook Pro（&lt;a href=&quot;https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacBook Pro 入手一年了，到底香不香？&lt;/a&gt;），于是有小伙伴问松哥，出书是不是赚翻了？&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="程序员" scheme="http://www.javaboy.org/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手带你捋一遍 Spring Security 登录流程</title>
    <link href="http://www.javaboy.org/2020/0310/springsecurity-login.html"/>
    <id>http://www.javaboy.org/2020/0310/springsecurity-login.html</id>
    <published>2020-03-10T08:55:04.000Z</published>
    <updated>2020-03-12T10:32:30.812Z</updated>
    
    <content type="html"><![CDATA[<p>为什么想和大家捋一捋 Spring Security 登录流程呢？这是因为之前小伙伴们的一个提问：如何在 Spring Security 中动态修改用户信息？</p><a id="more"></a><p>如果你搞清楚了 Spring Security 登录流程，这其实不是问题。但是在很多新手小伙伴多次询问之后，松哥还是决定来和大家仔细捋一捋这个问题。</p><p>我们先来大致描述一下问题场景：</p><blockquote><p>你在服务端的安全管理使用了 Spring Security，用户登录成功之后，Spring Security 帮你把用户信息保存在 Session 里，但是具体保存在哪里，要是不深究你可能就不知道， 这带来了一个问题，如果用户在前端操作修改了当前用户信息，在不重新登录的情况下，如何获取到最新的用户信息？这就是松哥今天要和搭建介绍的问题。</p></blockquote><h2 id="1-无处不在的-Authentication"><a href="#1-无处不在的-Authentication" class="headerlink" title="1.无处不在的 Authentication"></a>1.无处不在的 Authentication</h2><p>玩过 Spring Security 的小伙伴都知道，在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它有很多实现类：</p><p><img src="http://img.itboyhub.com/2020/03/authentication-1.png" alt></p><p>在这众多的实现类中，我们最常用的就是 UsernamePasswordAuthenticationToken 了，但是当我们打开这个类的源码后，却发现这个类平平无奇，他只有两个属性、两个构造方法以及若干个 get/set 方法；当然，他还有更多属性在它的父类上。</p><p>但是从它仅有的这两个属性中，我们也能大致看出，这个类就保存了我们登录用户的基本信息。那么我们的登录信息是如何存到这两个对象中的？这就要来梳理一下登录流程了。</p><h2 id="2-登录流程"><a href="#2-登录流程" class="headerlink" title="2.登录流程"></a>2.登录流程</h2><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 UsernamePasswordAuthenticationFilter，篇幅问题，我这里列出来该类中几个重要方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/login"</span>, <span class="hljs-string">"POST"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;</span><br><span class="line">authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这段源码我们可以看出：</p><ol><li>首先通过 obtainUsername 和 obtainPassword 方法提取出请求里边的用户名/密码出来，提取方式就是 request.getParameter ，这也是为什么 Spring Security 中默认的表单登录要通过 key/value 的形式传递参数，而不能传递 JSON 参数，如果像传递 JSON 参数，修改这里的逻辑即可。</li><li>获取到请求里传递来的用户名/密码之后，接下来就构造一个 UsernamePasswordAuthenticationToken 对象，传入 username 和 password，username 对应了 UsernamePasswordAuthenticationToken 中的 principal 属性，而 password 则对应了它的 credentials 属性。</li><li>接下来 setDetails 方法给 details 属性赋值，UsernamePasswordAuthenticationToken 本身是没有 details 属性的，这个属性在它的父类 AbstractAuthenticationToken 中。details 是一个对象，这个对象里边放的是 WebAuthenticationDetails 实例，该实例主要描述了两个信息，请求的 remoteAddress 以及请求的 sessionId。</li><li>最后一步，就是调用 authenticate 方法去做校验了。</li></ol><p>好了，从这段源码中，大家可以看出来请求的各种信息基本上都找到了自己的位置，找到了位置，这就方便我们未来去获取了。</p><p>接下来我们再来看请求的具体校验操作。</p><p>在前面的 attemptAuthentication 方法中，该方法的最后一步开始做校验，校验操作首先要获取到一个 AuthenticationManager，这里拿到的是 ProviderManager ，所以接下来我们就进入到 ProviderManager 的 authenticate 方法中，当然这个方法也比较长，我这里仅仅摘列出来几个重要的地方：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line"><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; parent != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result = parentResult = parent.authenticate(authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="hljs-keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (parentResult == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就比较魔幻了，因为几乎关于认证的重要逻辑都将在这里完成：</p><ol><li>首先获取 authentication 的 Class，判断当前 provider 是否支持该 authentication。</li><li>如果支持，则调用 provider 的 authenticate 方法开始做校验，校验完成后，会返回一个新的 Authentication。一会来和大家捋这个方法的具体逻辑。</li><li>这里的 provider 可能有多个，如果 provider 的 authenticate 方法没能正常返回一个 Authentication，则调用 provider 的 parent 的 authenticate 方法继续校验。</li><li>copyDetails 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来。</li><li>接下来会调用 eraseCredentials 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 credentials 属性置空。</li><li>最后通过 publishAuthenticationSuccess 方法将登录成功的事件广播出去。</li></ol><p>大致的流程，就是上面这样，在 for 循环中，第一次拿到的 provider 是一个 AnonymousAuthenticationProvider，这个 provider 压根就不支持 UsernamePasswordAuthenticationToken，也就是会直接在 provider.supports 方法中返回 false，结束 for 循环，然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。</p><p>而 parent 就是 ProviderManager，所以会再次回到这个 authenticate 方法中。再次回到 authenticate 方法中，provider 也变成了 DaoAuthenticationProvider，这个 provider 是支持 UsernamePasswordAuthenticationToken 的，所以会顺利进入到该类的 authenticate 方法去执行，而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider 并且没有重写 authenticate 方法，所以 我们最终来到 AbstractUserDetailsAuthenticationProvider#authenticate 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = (authentication.getPrincipal() == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"><span class="hljs-keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑就比较简单了：</p><ol><li>首先从 Authentication 提取出登录用户名。</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象，可以参考微人事的 org/javaboy/vhr/service/HrService.java#L34。</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li>additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期。</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken。</li></ol><p>好了，那么登录的校验流程现在就基本和大家捋了一遍了。那么接下来还有一个问题，登录的用户信息我们去哪里查找？</p><h2 id="3-用户信息保存"><a href="#3-用户信息保存" class="headerlink" title="3.用户信息保存"></a>3.用户信息保存</h2><p>要去找登录的用户信息，我们得先来解决一个问题，就是上面我们说了这么多，这一切是从哪里开始被触发的？</p><p>我们来到 UsernamePasswordAuthenticationFilter 的父类 AbstractAuthenticationProcessingFilter 中，这个类我们经常会见到，因为很多时候当我们想要在 Spring Security 自定义一个登录验证码或者将登录参数改为 JSON 的时候，我们都需自定义过滤器继承自 AbstractAuthenticationProcessingFilter ，毫无疑问，UsernamePasswordAuthenticationFilter#attemptAuthentication 方法就是在 AbstractAuthenticationProcessingFilter 类的 doFilter 方法中被触发的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">Authentication authResult;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到，当 attemptAuthentication 方法被调用时，实际上就是触发了 UsernamePasswordAuthenticationFilter#attemptAuthentication 方法，当登录抛出异常的时候，unsuccessfulAuthentication 方法会被调用，而当登录成功的时候，successfulAuthentication 方法则会被调用，那我们就来看一看 successfulAuthentication 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="hljs-comment">// Fire event</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一段很重要的代码，就是 <code>SecurityContextHolder.getContext().setAuthentication(authResult);</code> ，登录成功的用户信息被保存在这里，也就是说，在任何地方，如果我们想获取用户登录信息，都可以从 <code>SecurityContextHolder.getContext()</code> 中获取到，想修改，也可以在这里修改。</p><p>最后大家还看到有一个 successHandler.onAuthenticationSuccess，这就是我们在 SecurityConfig 中配置登录成功回调方法，就是在这里被触发的，这块大家也可以参考微人事里边的配置 <code>org/javaboy/vhr/config/SecurityConfig</code>。</p><p>真相大白！</p><h2 id="4-视频讲解"><a href="#4-视频讲解" class="headerlink" title="4.视频讲解"></a>4.视频讲解</h2><p>最后，松哥也录了一个简单的视频教程，来和大家捋一捋：</p><p>并且基于这个知识点，我给微人事添加了一个个人中心的功能，一起来看下：</p><iframe src="//player.bilibili.com/player.html?aid=95352488&cid=162784593&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>好了，不知道小伙伴们有没有学会呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么想和大家捋一捋 Spring Security 登录流程呢？这是因为之前小伙伴们的一个提问：如何在 Spring Security 中动态修改用户信息？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Vue+FastDFS 实现前后端分离文件上传</title>
    <link href="http://www.javaboy.org/2020/0309/springboot-vue-fastdfs.html"/>
    <id>http://www.javaboy.org/2020/0309/springboot-vue-fastdfs.html</id>
    <published>2020-03-09T08:54:49.000Z</published>
    <updated>2020-03-12T11:10:36.542Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring Boot 前后端分离环境下做文件上传，这个松哥之前在公众号上发过一篇文章来和大家介绍，但是在之前的文章中，为了省事，文件我是直接保存在本地临时目录下的，这带来了另外一个问题，就是项目重启之后，临时目录失效，之前上传的文件又访问不到了。</p><a id="more"></a><p>很显然在实际开发中我们不会这么搞！在生产环境中，我们可以搭建独立的文件服务器，结合 FastDFS 还可以搭建独立的分布式文件服务系统，这样文件管理服务器不仅方便管理还易于扩展，也解决了前面所说的临时目录失效的问题。</p><p>今天松哥想和大家聊一下在微人事中，我是如何通过 Spring Boot + Vue + FastDFS 来实现前后端分离文件上传的。</p><p>学习本文需要大家先搞定 FastDFS，如果大家对于 FastDFS 还不太熟悉，可以先看看松哥之前发的视频教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/onZmdgi9kZw0JdAtrNYmow" target="_blank" rel="noopener">听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</a></li></ul><p>如果大家搞定了 FastDFS ，就直接来看今天的文件上传吧：</p><iframe src="//player.bilibili.com/player.html?aid=94847558&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>好了，不知道小伙伴们有没有看懂呢？视频中的代码我已经提交到 GitHub 了：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>。赶紧试一把！如果大家对松哥录制的完整的微人事视频教程感兴趣，可以戳这里：<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程喜迎大结局，西交大的老师竟然都要来一套！</a></p><p>视频看完了，松哥再把理论也和大家捋一捋。</p><p>在 Vue.js 中，如果网络请求使用 axios ，并且使用了 ElementUI 库，那么一般来说，文件上传有两种不同的实现方案：</p><ol><li>通过 Ajax 实现文件上传</li><li>通过 ElementUI 里边的 Upload 组件实现文件上传</li></ol><p>两种方案，各有优缺点，我们分别来看。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先我们需要一点点准备工作，就是在后端提供一个文件上传接口，这是一个普通的 Spring Boot 项目，如下（视这里来个简单的服务端代码，视频中的代码大家可以从 GitHub 上获取）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/import"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">importData</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/upload"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    file.transferTo(<span class="hljs-keyword">new</span> File(folder,newName));</span><br><span class="line">    String url = req.getScheme() + <span class="hljs-string">"://"</span> + req.getServerName() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/upload"</span> + format + newName;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"上传成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的文件上传比较简单，上传的文件按照日期进行归类，使用 UUID 给文件重命名。</p><p><strong>这里为了简化代码，我省略掉了异常捕获，上传结果直接返回成功，后端代码大伙可根据自己的实际情况自行修改。</strong></p><h2 id="2-Ajax-上传"><a href="#2-Ajax-上传" class="headerlink" title="2.Ajax 上传"></a>2.Ajax 上传</h2><p>在 Vue 中，通过 Ajax 实现文件上传，方案和传统 Ajax 实现文件上传基本上是一致的，唯一不同的是查找元素的方式。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myfile"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"importData"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"el-icon-upload2"</span>&gt;</span>导入数据<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，首先提供一个文件导入 input 组件，再来一个导入按钮，在导入按钮的事件中来完成导入的逻辑。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">importData() &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> myfile = <span class="hljs-keyword">this</span>.$refs.myfile;</span><br><span class="line">  <span class="hljs-keyword">let</span> files = myfile.files;</span><br><span class="line">  <span class="hljs-keyword">let</span> file = files[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="hljs-string">"file"</span>, file);</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadFileRequest(<span class="hljs-string">"/system/basic/jl/import"</span>,formData).then(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (resp) &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(resp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段上传核心逻辑，解释如下：</p><ol><li>首先利用 Vue 中的 $refs 查找到存放文件的元素。</li><li>type 为 file 的 input 元素内部有一个 files 数组，里边存放了所有选择的 file，由于文件上传时，文件可以多选，因此这里拿到的 files 对象是一个数组。</li><li>从 files 对象中，获取自己要上传的文件，由于这里是单选，所以其实就是数组中的第一项。</li><li>构造一个 FormData ，用来存放上传的数据,FormData 不可以像 Java 中的 StringBuffer 使用链式配置。</li><li>构造好 FromData 后，就可以直接上传数据了，FormData 就是要上传的数据。</li><li>文件上传注意两点：1. 请求方法为 post，2. 设置 <code>Content-Type</code> 为  <code>multipart/form-data</code> 。</li></ol><p>这种文件上传方式，实际上就是传统的 Ajax 上传文件，和大家常见的 jQuery 中写法不同的是，这里元素查找的方式不一样（实际上元素查找也可以按照JavaScript 中原本的写法来实现），其他写法一模一样。这种方式是一个通用的方式，和使用哪一种前端框架无关。最后再和大家来看下封装的上传方法：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="hljs-string">'post'</span>,</span><br><span class="line">    url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这几步的配置后，前端就算上传完成了，可以进行文件上传了。</p><h2 id="3-使用-Upload-组件"><a href="#3-使用-Upload-组件" class="headerlink" title="3.使用 Upload 组件"></a>3.使用 Upload 组件</h2><p>如果使用 Upload ，则需要引入 ElementUI，所以一般建议，如果使用了 ElementUI 做 UI 控件的话，则可以考虑使用 Upload 组件来实现文件上传，如果没有使用 ElementUI 的话，则不建议使用 Upload 组件，至于其他的 UI 控件，各自都有自己的文件上传组件，具体使用可以参考各自文档。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">"display: inline"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:show-file-list</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-success</span>=<span class="hljs-string">"onSuccess"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"onError"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:before-upload</span>=<span class="hljs-string">"beforeUpload"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/system/basic/jl/import"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"!enabledUploadBtn"</span> <span class="hljs-attr">:icon</span>=<span class="hljs-string">"uploadBtnIcon"</span>&gt;</span>&#123;&#123;btnText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>show-file-list 表示是否展示上传文件列表，默认为 true，这里设置为不展示。</li><li>before-upload 表示上传之前的回调，可以在该方法中，做一些准备工作，例如展示一个进度条给用户 。</li><li>on-success 和 on-error 分别表示上传成功和失败时候的回调，可以在这两个方法中，给用户一个相应的提示，如果有进度条，还需要在这两个方法中关闭进度条。</li><li>action 指文件上传地址。</li><li>上传按钮的点击状态和图标都设置为变量 ，在文件上传过程中，修改上传按钮的点击状态为不可点击，同时修改图标为一个正在加载的图标 loading。</li><li>上传的文本也设为变量，默认上传 button 的文本是 <code>数据导入</code> ，当开始上传后，将找个 button 上的文本修改为 <code>正在导入</code>。</li></ol><p>相应的回调如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onSuccess(response, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">onError(err, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpload(file) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">false</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-loading'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'正在导入'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在文件开始上传时，修改上传按钮为不可点击，同时修改上传按钮的图标和文本。</li><li>文件上传成功或者失败时，修改上传按钮的状态为可以点击，同时恢复上传按钮的图标和文本。</li></ol><p>上传效果图如下：</p><p><img src="http://img.itboyhub.com/2020/03/springboot-vue-fastdfs-1.png" alt> </p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>两种上传方式各有优缺点：</p><ol><li>第一种方式最大的优势是通用，一招鲜吃遍天，到哪里都能用，但是对于上传过程的监控，进度条的展示等等逻辑都需要自己来实现。</li><li>第二种方式不够通用，因为它是 ElementUI 中的组件，得引入 ElementUI 才能使用，不过这种方式很明显有需多比较方便的回调，可以实现非常方便的处理常见的各种上传问题。</li><li>常规的上传需求第二种方式可以满足，但是如果要对上传的方法进行定制，则还是建议使用第一种上传方案。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Spring Boot 前后端分离环境下做文件上传，这个松哥之前在公众号上发过一篇文章来和大家介绍，但是在之前的文章中，为了省事，文件我是直接保存在本地临时目录下的，这带来了另外一个问题，就是项目重启之后，临时目录失效，之前上传的文件又访问不到了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 国际化踩坑指南</title>
    <link href="http://www.javaboy.org/2020/0305/springboot-i18n.html"/>
    <id>http://www.javaboy.org/2020/0305/springboot-i18n.html</id>
    <published>2020-03-05T02:19:10.000Z</published>
    <updated>2020-03-05T02:43:53.095Z</updated>
    
    <content type="html"><![CDATA[<p>国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。</p><a id="more"></a><p>在 Spring 中，就通过 AcceptHeaderLocaleResolver 对国际化提供了支持，开发者通过简单配置，就可以在项目中直接使用国际化功能了。</p><p>这一支持，在 Spring Boot 中得到进一步的简化，在 Spring Boot 中，我们也可以通过寥寥数行代码就能方便的实现国际化功能，接下来松哥就来和大家说一说 Spring Boot 中的国际化。</p><p>首先，需要给大家先说明一点，项目中的国际化我们往往需要多方面的支持，例如后端做国际化、前端页面也要做国际化，共同搭配，才能真正实现国际化的功能。本文我先来和各位小伙伴们介绍 Spring Boot 中的国际化，后面我们再来介绍 Vue 的国际化，最后，再把这两个结合应用到我们的 vhr 项目中，所以前后一共可能有三篇文章，本文是第一篇。</p><p><a href="https://mp.weixin.qq.com/s/bDiPhqPjEyCbXhmAx1btpg" target="_blank" rel="noopener">本文对应的视频教程链接</a></p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。</p><p>所以在 Spring Boot 中做国际化，这一块我们可以不用配置，直接就开搞。</p><p>首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-1.png" alt></p><ul><li>我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。</li><li>messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。</li></ul><p>四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容：</p><p>messages_zh_CN.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南一点雨</span><br></pre></td></tr></table></figure><p>messages_zh_TW.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南壹點雨</span><br></pre></td></tr></table></figure><p>messages_en_US.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=javaboy</span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。</p><blockquote><p>在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 <code>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration</code> 自动帮我们配置一个 MessageSource 实例。</p></blockquote><p>创建一个 HelloController ，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageSource.getMessage(<span class="hljs-string">"user.name"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。</p><p>接下来我们就可以直接去调用这个接口了。</p><p>默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-2.png" alt></p><p>小伙伴们看到，我在请求头中设置了 Accept-Language 为 zh-CN，所以拿到的就是简体中文；如果我设置了 zh-TW，就会拿到繁体中文：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-3.png" alt></p><p>是不是很 Easy？</p><h2 id="2-自定义切换"><a href="#2-自定义切换" class="headerlink" title="2.自定义切换"></a>2.自定义切换</h2><p>有的小伙伴觉得切换参数放在请求头里边好像不太方便，那么也可以自定义解析方式。例如参数可以当成普通参数放在地址栏上，通过如下配置可以实现我们的需求。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LocaleChangeInterceptor interceptor = <span class="hljs-keyword">new</span> LocaleChangeInterceptor();</span><br><span class="line">        interceptor.setParamName(<span class="hljs-string">"lang"</span>);</span><br><span class="line">        registry.addInterceptor(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="hljs-keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="hljs-keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。</p><p>另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。</p><p>好了，配置完成后，启动项目，访问方式如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-4.png?aa=123" alt></p><p>我们通过在请求中添加 lang 来指定当前环境信息。这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。</p><h2 id="3-其他自定义"><a href="#3-其他自定义" class="headerlink" title="3.其他自定义"></a>3.其他自定义</h2><p>默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-5.png" alt></p><p>但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n/messages</span><br></pre></td></tr></table></figure><p>另外还有一些编码格式的配置等，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.cache-duration=3600</span><br><span class="line">spring.messages.encoding=UTF-8</span><br><span class="line">spring.messages.fallback-to-system-locale=true</span><br></pre></td></tr></table></figure><p>spring.messages.cache-duration 表示 messages 文件的缓存失效时间，如果不配置则缓存一直有效。</p><p>spring.messages.fallback-to-system-locale 属性则略显神奇，网上竟然看不到一个明确的答案，后来翻了一会源码才看出端倪。</p><p>这个属性的作用在 <code>org.springframework.context.support.AbstractResourceBasedMessageSource#getDefaultLocale</code> 方法中生效：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Locale <span class="hljs-title">getDefaultLocale</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackToSystemLocale) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，在找不到当前系统对应的资源文件时，如果该属性为 true，则会默认查找当前系统对应的资源文件，否则就返回 null，返回 null 之后，最终又会调用到系统默认的 messages.properties 文件。</p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4.附录"></a>4.附录</h2><p>搜刮了一个语言简称表，分享给各位小伙伴：</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">简称</th></tr></thead><tbody><tr><td style="text-align:left">简体中文(中国)</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">繁体中文(中国台湾)</td><td style="text-align:left">zh_TW</td></tr><tr><td style="text-align:left">繁体中文(中国香港)</td><td style="text-align:left">zh_HK</td></tr><tr><td style="text-align:left">英语(中国香港)</td><td style="text-align:left">en_HK</td></tr><tr><td style="text-align:left">英语(美国)</td><td style="text-align:left">en_US</td></tr><tr><td style="text-align:left">英语(英国)</td><td style="text-align:left">en_GB</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en_WW</td></tr><tr><td style="text-align:left">英语(加拿大)</td><td style="text-align:left">en_CA</td></tr><tr><td style="text-align:left">英语(澳大利亚)</td><td style="text-align:left">en_AU</td></tr><tr><td style="text-align:left">英语(爱尔兰)</td><td style="text-align:left">en_IE</td></tr><tr><td style="text-align:left">英语(芬兰)</td><td style="text-align:left">en_FI</td></tr><tr><td style="text-align:left">芬兰语(芬兰)</td><td style="text-align:left">fi_FI</td></tr><tr><td style="text-align:left">英语(丹麦)</td><td style="text-align:left">en_DK</td></tr><tr><td style="text-align:left">丹麦语(丹麦)</td><td style="text-align:left">da_DK</td></tr><tr><td style="text-align:left">英语(以色列)</td><td style="text-align:left">en_IL</td></tr><tr><td style="text-align:left">希伯来语(以色列)</td><td style="text-align:left">he_IL</td></tr><tr><td style="text-align:left">英语(南非)</td><td style="text-align:left">en_ZA</td></tr><tr><td style="text-align:left">英语(印度)</td><td style="text-align:left">en_IN</td></tr><tr><td style="text-align:left">英语(挪威)</td><td style="text-align:left">en_NO</td></tr><tr><td style="text-align:left">英语(新加坡)</td><td style="text-align:left">en_SG</td></tr><tr><td style="text-align:left">英语(新西兰)</td><td style="text-align:left">en_NZ</td></tr><tr><td style="text-align:left">英语(印度尼西亚)</td><td style="text-align:left">en_ID</td></tr><tr><td style="text-align:left">英语(菲律宾)</td><td style="text-align:left">en_PH</td></tr><tr><td style="text-align:left">英语(泰国)</td><td style="text-align:left">en_TH</td></tr><tr><td style="text-align:left">英语(马来西亚)</td><td style="text-align:left">en_MY</td></tr><tr><td style="text-align:left">英语(阿拉伯)</td><td style="text-align:left">en_XA</td></tr><tr><td style="text-align:left">韩文(韩国)</td><td style="text-align:left">ko_KR</td></tr><tr><td style="text-align:left">日语(日本)</td><td style="text-align:left">ja_JP</td></tr><tr><td style="text-align:left">荷兰语(荷兰)</td><td style="text-align:left">nl_NL</td></tr><tr><td style="text-align:left">荷兰语(比利时)</td><td style="text-align:left">nl_BE</td></tr><tr><td style="text-align:left">葡萄牙语(葡萄牙)</td><td style="text-align:left">pt_PT</td></tr><tr><td style="text-align:left">葡萄牙语(巴西)</td><td style="text-align:left">pt_BR</td></tr><tr><td style="text-align:left">法语(法国)</td><td style="text-align:left">fr_FR</td></tr><tr><td style="text-align:left">法语(卢森堡)</td><td style="text-align:left">fr_LU</td></tr><tr><td style="text-align:left">法语(瑞士)</td><td style="text-align:left">fr_CH</td></tr><tr><td style="text-align:left">法语(比利时)</td><td style="text-align:left">fr_BE</td></tr><tr><td style="text-align:left">法语(加拿大)</td><td style="text-align:left">fr_CA</td></tr><tr><td style="text-align:left">西班牙语(拉丁美洲)</td><td style="text-align:left">es_LA</td></tr><tr><td style="text-align:left">西班牙语(西班牙)</td><td style="text-align:left">es_ES</td></tr><tr><td style="text-align:left">西班牙语(阿根廷)</td><td style="text-align:left">es_AR</td></tr><tr><td style="text-align:left">西班牙语(美国)</td><td style="text-align:left">es_US</td></tr><tr><td style="text-align:left">西班牙语(墨西哥)</td><td style="text-align:left">es_MX</td></tr><tr><td style="text-align:left">西班牙语(哥伦比亚)</td><td style="text-align:left">es_CO</td></tr><tr><td style="text-align:left">西班牙语(波多黎各)</td><td style="text-align:left">es_PR</td></tr><tr><td style="text-align:left">德语(德国)</td><td style="text-align:left">de_DE</td></tr><tr><td style="text-align:left">德语(奥地利)</td><td style="text-align:left">de_AT</td></tr><tr><td style="text-align:left">德语(瑞士)</td><td style="text-align:left">de_CH</td></tr><tr><td style="text-align:left">俄语(俄罗斯)</td><td style="text-align:left">ru_RU</td></tr><tr><td style="text-align:left">意大利语(意大利)</td><td style="text-align:left">it_IT</td></tr><tr><td style="text-align:left">希腊语(希腊)</td><td style="text-align:left">el_GR</td></tr><tr><td style="text-align:left">挪威语(挪威)</td><td style="text-align:left">no_NO</td></tr><tr><td style="text-align:left">匈牙利语(匈牙利)</td><td style="text-align:left">hu_HU</td></tr><tr><td style="text-align:left">土耳其语(土耳其)</td><td style="text-align:left">tr_TR</td></tr><tr><td style="text-align:left">捷克语(捷克共和国)</td><td style="text-align:left">cs_CZ</td></tr><tr><td style="text-align:left">斯洛文尼亚语</td><td style="text-align:left">sl_SL</td></tr><tr><td style="text-align:left">波兰语(波兰)</td><td style="text-align:left">pl_PL</td></tr><tr><td style="text-align:left">瑞典语(瑞典)</td><td style="text-align:left">sv_SE</td></tr><tr><td style="text-align:left">西班牙语(智利)</td><td style="text-align:left">es_CL</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="i18n" scheme="http://www.javaboy.org/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>写博客必备！手把手教大家搭建免费图床，真香！</title>
    <link href="http://www.javaboy.org/2020/0304/qiniuyun-picgo.html"/>
    <id>http://www.javaboy.org/2020/0304/qiniuyun-picgo.html</id>
    <published>2020-03-04T02:18:53.000Z</published>
    <updated>2020-03-05T02:44:23.358Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间松哥发了一篇文章，鼓励大家写博客多做积累（<a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a>），有小伙伴告诉松哥他已经开始实践了，感觉到自己的苦口婆心总算有了一点点作用还是蛮欣慰的。</p><a id="more"></a><p>今天想和大家分享一个写博客过程中经常遇到的技术性问题，就是博客图片存到哪里。<strong>因为松哥自己最近搞了一个免费的图床，感觉还是蛮香的，于是和大家伙分享下。</strong></p><h2 id="蛮荒时代"><a href="#蛮荒时代" class="headerlink" title="蛮荒时代"></a>蛮荒时代</h2><p>先说说我刚开始写博客的时候，就直接打开博客平台的后台编辑器开始写，写好之后保存发布，写的过程中可能需要上传图片，于是就做好图片上传，博客写好之后，本地啥都没剩下。过了很久，我想把曾经写的博客整理成一个系列，结果发现只能从网站上重新拷贝文档下来，down 下来的图片还都自动加上博客平台的水印，真是让人又气又恼。</p><p>后来就学乖了，博客一般我在本地用 vscode 写，需要的图片，都一一编号，按顺序摆放好，然后在 Markdown 中通过相对路径的方式引入，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-1.png" alt></p><p>写好之后，再拷贝到博客网站发表即可。这样，我本地就有一份存档，这也是为什么大家可以看到松哥整理的 274 页离线版 Spring Boot 教程，就是这个原因。这样有一天，如果我想对文章进行二次整理或者完善就会非常方便。</p><p>用 vscode 这样写当然没问题，但是也有很多小伙伴用的是一些笔记软件，印象笔记，有道笔记等等，如果用笔记软件的话，图片的引用就不会这么方便了，此时如果我们有自己的图床就会方便很多。</p><p>对于自己的图床，我就两方面的要求：</p><ul><li>稳定</li><li>图片编号有序</li></ul><p>稳定就不用多说了，图片编号有序，这个挺关键的，这关系到未来有一天你是否还能够方便的找到自己的图片，而免费图床都是用随机字符串做图片名的，这块不是很方便，所以就想着能不能自己搭建一个图床。</p><p>刚好之前听说七牛云有免费的 10G 空间可以用来搭建个人图床，一直没有机会尝试，这次就试了下，没想到整个过程还是蛮顺利的，于是记录下来和小伙伴们分享下。</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><p>搭建需要大家首先做两方面的准备工作：</p><ol><li>有一个自己的<strong>已备案</strong>域名，早期这个不是必须的，但是现在这个是必须的。当我们在七牛云上申请好存储之后，会生成一个临时的二级域名，这个二级域名有效期 1 个月，所以我们得提前准备好一个自己的域名。</li><li>准备一个七牛云账户，并且实名认证下，这个就不需要我多说了吧，网站注册+上传身份证认证，这算是基本操作了。</li></ol><p>好了，这两样准备好之后，我们就可以开始搭建我们的图床了。</p><p>首先在七牛云网站首页点击 <strong>管理控制台</strong> 进入到管理控制台页面，然后选择第一个对象存储，点击立即添加。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-2.png" alt></p><p>然后给新的存储空间取一个名字，选择合适的存储区域，由于我们是要搭建自己的图床，所以最后一项访问控制选择<strong>公开</strong>，切勿选错。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-3.png" alt></p><p>创建完成后，接下来，我们再来配置域名。</p><p>首先点击左边菜单栏的 CDN，然后再点击域名管理。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-4.png" alt></p><p>默认情况下，只有一个测试域名，我们点击上方的 <strong>添加域名</strong>，添加自己的域名进来，这里如果没有特殊需求，配置一下域名地址即可，其他都使用默认即可：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-5.png" alt></p><p>其他的选项，大家可以根据实际情况配置，我就不挨个说了，至少配置一个域名，后面就可以用了。配置完成之后，保存。</p><p>保存之后，这里会给你一个 CNAME，其实就是一个临时的二级域名：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-6.png" alt></p><p>把这个 CNAME 复制下来，然后打开自己的域名服务商控制台，添加一条 CNAME 解析记录，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-7.png" alt></p><p>这里的配置大家注意：</p><ul><li>由于一开始添加域名的时候，我们配置的是 img.javaboy.com，所以这里的主机记录就是 img，不要写错了</li><li>记录类型就是 CNAME，这个不能改</li><li>线路类型默认即可</li><li>记录值就是你复制的 CNAME</li></ul><p>其他都默认，配置完成之后，保存即可。</p><blockquote><p>那么这个域名配置是什么含义呢？我在这里给大家稍为科普一下。我们把图片上传到七牛云之后，肯定会生成一个访问路径，例如 <a href="http://abc-javaboy.qiniu.com/111.png，这个访问路径是有域名的，默认的域名就是七牛云给我们生成的一个临时二级域名，这个二级域名有效期" target="_blank" rel="noopener">http://abc-javaboy.qiniu.com/111.png，这个访问路径是有域名的，默认的域名就是七牛云给我们生成的一个临时二级域名，这个二级域名有效期</a> 1 个月，1 个月之后就会失效。所以，我们要配置自己的域名，例如 img.javaboy.com，但是当我访问 <a href="http://img.javaboy.com/111.png" target="_blank" rel="noopener">http://img.javaboy.com/111.png</a> 时，要让这个地址指向七牛云上去，怎么做呢？这个时候就要靠一条 CNAME 解析了，它可以把域名解析到别的域名上。</p></blockquote><p>OK，这些事情全部做完之后，等待一会，十分钟左右，在 <strong>空间管理-&gt;空间概览</strong> 里边，看到 CDN 加速域名的状态为成功时，我们的所有配置就算都 OK 了。</p><p>接下来点到 <strong>空间管理-&gt;空间概览</strong> ，点击文件上传，就可以上传文件了。文件上传成功后，点击右边的更多，就可以复制文件链接了。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-8.png" alt></p><p>整个操作过程还是比较 Easy 的，没有什么难度。</p><h2 id="PicGo-上传"><a href="#PicGo-上传" class="headerlink" title="PicGo 上传"></a>PicGo 上传</h2><p>每次需要上传图片的时候，都要打开七牛云后台，这显然有些麻烦，于是有人开发了不少好用的客户端工具，松哥经过各种踩坑之后，感觉 PicGo 比较好用，在 Mac/Windows 上都支持，挺方便的，所以采用这个来做文件上传。</p><p>PicGo 可以从 GitHub 上下载，根据自己的系统选择合适的版本下载：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a>。</p><p>下载安装，这个我就不用说了，普通软件安装。</p><p>安装好之后，在图床配置里边，配置一下七牛图床：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-9.png" alt></p><p>AccessKey、SecretKey 都可以从你的七牛后台的个人中心页面看到，直接复制过来即可。存储空间名就是你一开始创建的存储空间，访问地址则是你自己的域名，例如 <a href="http://img.javaboy.org。存储区域根据自己一开始选择的华南/华东/华北等，根据实际情况填写，但是这里注意填写区域简称：" target="_blank" rel="noopener">http://img.javaboy.org。存储区域根据自己一开始选择的华南/华东/华北等，根据实际情况填写，但是这里注意填写区域简称：</a></p><p><img src="http://img.itboyhub.com/2020/03/qiniu-10.png" alt></p><p>配置完成后，以后就可以把图片拖拽到上传区上传了，上传成功后会返回图片访问路径，这些就比较简单了，不再赘述。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-11.png" alt></p><p>好了，这就是今天和小伙伴们分享的免费搭建自己的图床，写博客的小伙伴，可以试试哦。真香。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间松哥发了一篇文章，鼓励大家写博客多做积累（&lt;a href=&quot;https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果你没写过博客，现在就是你写博客的最佳时机&lt;/a&gt;），有小伙伴告诉松哥他已经开始实践了，感觉到自己的苦口婆心总算有了一点点作用还是蛮欣慰的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.javaboy.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="七牛云" scheme="http://www.javaboy.org/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="PicGo" scheme="http://www.javaboy.org/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何添加登录验证码？松哥手把手教你给微人事添加登录验证码</title>
    <link href="http://www.javaboy.org/2020/0303/springsecurity-verifycode.html"/>
    <id>http://www.javaboy.org/2020/0303/springsecurity-verifycode.html</id>
    <published>2020-03-03T02:18:34.000Z</published>
    <updated>2020-03-05T02:45:28.781Z</updated>
    
    <content type="html"><![CDATA[<p>登录添加验证码是一个非常常见的需求，网上也有非常成熟的解决方案。在传统的登录流程中加入一个登录验证码也不是难事，但是如何在 Spring Security 中添加登录验证码，对于初学者来说还是一件蛮有挑战的事情，因为默认情况下，在 Spring Security 中我们并不需要自己写登录认证逻辑，只需要自己稍微配置一下就可以了，所以如果要添加登录验证码，就涉及到如何在 Spring Security 即有的认证体系中，加入自己的验证逻辑。</p><a id="more"></a><p>学习本文，需要大家对 Spring Security 的基本操作有一些了解，如果大家对于 Spring Security 的操作还不太熟悉，可以在公众号后台回复 springboot，获取松哥纯手敲的 274 页免费 Spring Boot 学习干货。</p><p>好了，那么接下来，我们就来看下我是如何通过自定义过滤器给微人事添加上登录验证码的。</p><p><a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">本文对应的视频教程链接</a></p><p>好了，不知道小伙伴们有没有看懂呢？视频中涉及到的所有代码我已经提交到 GitHub 上了：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>。如果小伙伴们对完整的微人事视频教程感兴趣，可以点击这里:<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程喜迎大结局，西交大的老师竟然都要来一套！</a></p><p>最后，还有一个去年写的关于验证码的笔记，小伙伴们也可以参考下。</p><h3 id="准备验证码"><a href="#准备验证码" class="headerlink" title="准备验证码"></a>准备验证码</h3><p>要有验证码，首先得先准备好验证码，本文采用 Java 自画的验证码，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 生成验证码的工具类</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;<span class="hljs-comment">// 生成验证码图片的宽度</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">50</span>;<span class="hljs-comment">// 生成验证码图片的高度</span></span><br><span class="line"><span class="hljs-keyword">private</span> String[] fontNames = &#123; <span class="hljs-string">"宋体"</span>, <span class="hljs-string">"楷体"</span>, <span class="hljs-string">"隶书"</span>, <span class="hljs-string">"微软雅黑"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">private</span> Color bgColor = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">// 定义验证码图片的背景颜色为白色</span></span><br><span class="line"><span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line"><span class="hljs-keyword">private</span> String codes = <span class="hljs-string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String text;<span class="hljs-comment">// 记录随机字符串</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随意颜色</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Color <span class="hljs-title">randomColor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> red = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> green = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> blue = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color(red, green, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随机字体</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Font <span class="hljs-title">randomFont</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">String name = fontNames[random.nextInt(fontNames.length)];</span><br><span class="line"><span class="hljs-keyword">int</span> style = random.nextInt(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> size = random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">24</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Font(name, style, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随机字符</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> <span class="hljs-title">randomChar</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> codes.charAt(random.nextInt(codes.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 创建一个空白的BufferedImage对象</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> BufferedImage <span class="hljs-title">createImage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line">g2.setColor(bgColor);<span class="hljs-comment">// 设置验证码图片的背景颜色</span></span><br><span class="line">g2.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);</span><br><span class="line"><span class="hljs-keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title">getImage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">BufferedImage image = createImage();</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line">StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">String s = randomChar() + <span class="hljs-string">""</span>;</span><br><span class="line">sb.append(s);</span><br><span class="line">g2.setColor(randomColor());</span><br><span class="line">g2.setFont(randomFont());</span><br><span class="line"><span class="hljs-keyword">float</span> x = i * width * <span class="hljs-number">1.0f</span> / <span class="hljs-number">4</span>;</span><br><span class="line">g2.drawString(s, x, height - <span class="hljs-number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.text = sb.toString();</span><br><span class="line">drawLine(image);</span><br><span class="line"><span class="hljs-keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 绘制干扰线</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> image</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(BufferedImage image)</span> </span>&#123;</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line"><span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x1 = random.nextInt(width);</span><br><span class="line"><span class="hljs-keyword">int</span> y1 = random.nextInt(height);</span><br><span class="line"><span class="hljs-keyword">int</span> x2 = random.nextInt(width);</span><br><span class="line"><span class="hljs-keyword">int</span> y2 = random.nextInt(height);</span><br><span class="line">g2.setColor(randomColor());</span><br><span class="line">g2.setStroke(<span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">1.5f</span>));</span><br><span class="line">g2.drawLine(x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(BufferedImage image, OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ImageIO.write(image, <span class="hljs-string">"JPEG"</span>, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类很常见，网上也有很多，就是画一个简单的验证码，通过流将验证码写到前端页面，提供验证码的 Controller 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCodeController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/vercode"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        VerifyCode vc = <span class="hljs-keyword">new</span> VerifyCode();</span><br><span class="line">        BufferedImage image = vc.getImage();</span><br><span class="line">        String text = vc.getText();</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        session.setAttribute(<span class="hljs-string">"index_code"</span>, text);</span><br><span class="line">        VerifyCode.output(image, resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 VerifyCode 对象，将生成的验证码字符保存到 session 中，然后通过流将图片写到前端，img 标签如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/vercode"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="http://img.itboyhub.com/2020/03/springsecurity-verifycode-1.png" alt></p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>在登陆页展示验证码这个就不需要我多说了，接下来我们来看看如何自定义验证码处理器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String defaultFilterProcessUrl = <span class="hljs-string">"/doLogin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"POST"</span>.equalsIgnoreCase(request.getMethod()) &amp;&amp; defaultFilterProcessUrl.equals(request.getServletPath())) &#123;</span><br><span class="line">            <span class="hljs-comment">// 验证码验证</span></span><br><span class="line">            String requestCaptcha = request.getParameter(<span class="hljs-string">"code"</span>);</span><br><span class="line">            String genCaptcha = (String) request.getSession().getAttribute(<span class="hljs-string">"index_code"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.isEmpty(requestCaptcha))</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码不能为空!"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (!genCaptcha.toLowerCase().equals(requestCaptcha.toLowerCase())) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码错误!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义过滤器继承自 GenericFilterBean，并实现其中的 doFilter 方法，在 doFilter 方法中，当请求方法是 POST，并且请求地址是 <code>/doLogin</code> 时，获取参数中的 code 字段值，该字段保存了用户从前端页面传来的验证码，然后获取 session 中保存的验证码，如果用户没有传来验证码，则抛出验证码不能为空异常，如果用户传入了验证码，则判断验证码是否正确，如果不正确则抛出异常，否则执行 <code>chain.doFilter(request, response);</code> 使请求继续向下走。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>最后在 Spring Security 的配置中，配置过滤器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴出了部分核心代码，即 <code>http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</code> ，如此之后，整个配置就算完成了。</p><p>接下来在登录中，就需要传入验证码了，如果不传或者传错，都会抛出异常，例如不传的话，抛出如下异常：</p><p><img src="http://img.itboyhub.com/2020/03/springsecurity-verifycode-2.png" alt></p><p>本文案例，我已经上传到 GitHub ，欢迎大家 star：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p><p>好了，本文就先说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;登录添加验证码是一个非常常见的需求，网上也有非常成熟的解决方案。在传统的登录流程中加入一个登录验证码也不是难事，但是如何在 Spring Security 中添加登录验证码，对于初学者来说还是一件蛮有挑战的事情，因为默认情况下，在 Spring Security 中我们并不需要自己写登录认证逻辑，只需要自己稍微配置一下就可以了，所以如果要添加登录验证码，就涉及到如何在 Spring Security 即有的认证体系中，加入自己的验证逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
</feed>
