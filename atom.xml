<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-07-29T13:31:41.567Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL8 主从复制踩坑指南</title>
    <link href="http://www.javaboy.org/2021/0729/mysql-master-slave.html"/>
    <id>http://www.javaboy.org/2021/0729/mysql-master-slave.html</id>
    <published>2021-07-29T13:30:50.000Z</published>
    <updated>2021-07-29T13:31:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>松哥之前发过视频和大家聊 MySQL 的主从搭建，还没看过的小伙伴可以看这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/R89aCCFvCvudLp6FUn2JjQ" target="_blank" rel="noopener">手把手教大家搭建 MySQL 主从复制</a></li></ul><p>不过那一次是基于 MySQL5.7 搭建的，最近工作需要，搭建了基于 MySQL8 的主从，和 MySQL5.7 的搭建还是有一些不同，于是稍微记录下。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我这里有一张简单的图向大伙展示 MySQL 主从的工作方式：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-1-20210128205201707.png" alt></p><p>这里，我们准备两台机器：</p><ul><li>主机：192.168.248.128</li><li>从机：192.168.248.139</li></ul><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>主机的配置就三个步骤，比较容易：</p><p><strong>1. 授权给从机服务器</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;192.168.248.139&apos; identified by &apos;123&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这里表示配置从机登录用户名为 rep1，密码为 123，并且必须从 192.168.248.139这个地址登录，登录成功之后可以操作任意库中的任意表。其中，如果不需要限制登录地址，可以将 IP 地址更换为一个 <code>%</code>。</p><blockquote><p>注意，在 MySQL8 里边，这块有一些变化。MySQL8 中用户创建和授权需要分开，不能像上面那样一步到位，具体方式如下：</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER `rep1`@`192.168.248.139` IDENTIFIED WITH caching_sha2_password BY &apos;javaboy.COM&apos;;</span><br><span class="line"></span><br><span class="line">GRANT Replication Slave ON *.* TO `rep1`@`192.168.248.139`;</span><br></pre></td></tr></table></figure><p><strong>2. 修改主库配置文件</strong></p><p>开启 binlog ，并设置 server-id ，每次修改配置文件后都要重启 MySQL 服务才会生效</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p><strong>这个配置文件位置也可能是 <code>/etc/mysql/my.cnf</code>，这个要看自己的系统和 MySQL 版本。</strong></p><p>修改的文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/var/lib/mysql/binlog</span><br><span class="line">server-id=128</span><br><span class="line">binlog-do-db = cmdb</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-2-20210128205207575.png" alt></p><ul><li>log-bin：同步的日志路径及文件名，一定注意这个目录要是 MySQL 有权限写入的（我这里是偷懒了，直接放在了下面那个datadir下面）。</li><li>binlog-do-db：要同步的数据库名，当从机连上主机后，只有这里配置的数据库才会被同步，其他的不会被同步。</li><li>server-id: MySQL 在主从环境下的唯一标志符，给个任意数字，注意不能和从机重复。</li></ul><p>配置完成后重启 MySQL 服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><strong>3. 查看主服务器当前二进制日志名和偏移量</strong></p><p>这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/01/mysql/3-3-20210128205212596.png" alt></p><p>至此，主机配置完成。  </p><h2 id="从机配置"><a href="#从机配置" class="headerlink" title="从机配置"></a>从机配置</h2><p>从机的配置也比较简单，我们一步一步来看：</p><p><strong>1. 在/etc/my.cnf 添加配置</strong></p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-4-20210128205217210.png" alt></p><p>注意从机这里只需要配置一下 server-id 即可。</p><p><strong>注意：如果从机是从主机复制来的，即我们通过复制 CentOS 虚拟机获取了 MySQL 实例 ，此时两个 MySQL 的 uuid 一样（正常安装是不会相同的），这时需要手动修改，修改位置在 <code>/var/lib/mysql/auto.cnf</code> ，注意随便修改这里几个字符即可，但也不可太过于随意，例如修改了 uuid 的长度。</strong></p><p><strong>2. 使用命令来配置从机</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120;</span><br></pre></td></tr></table></figure><p>这里配置了主机地址、端口以及从机登录主机的用户名和密码，注意最后两个参数要和 master 中的保持一致。</p><p>注意，由于 MySQL8 密码插件的问题，这个问题同样会给主从配置带来问题，所以在 MySQL8 配置主从上，上面这行命令需要添加 <code>get_master_public_key=1</code>，完整命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120,get_master_public_key=1;</span><br></pre></td></tr></table></figure><p><strong>3. 启动 slave 进程</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>启动之后查看从机状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/01/mysql/3-5-20210128205222293.png" alt></p><p><strong>4. 查看 slave 的状态</strong></p><p>主要是下面两项值都要为为 YES，则表示配置正确：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>至此，配置完成，主机创建库，添加数据，从机会自动同步。 </p><p>如果这两个有一个不为 YES ，表示主从环境搭建失败，此时可以阅读日志，查看出错的原因，再具体问题具体解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要和大伙说了 MySQL 主从环境搭建，并且提醒了关于 MySQL8 主从搭建时需要注意的几个问题，这几个步骤松哥反反复复操作过很多遍，小伙伴只要按照松哥的步骤一般来说都能成功，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;松哥之前发过视频和大家聊 MySQL 的主从搭建，还没看过的小伙伴可以看这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/R89aCCFvCvudLp6FUn2JjQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手把手教大家搭建 MySQL 主从复制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过那一次是基于 MySQL5.7 搭建的，最近工作需要，搭建了基于 MySQL8 的主从，和 MySQL5.7 的搭建还是有一些不同，于是稍微记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一个小小的决定，一个大大的福利！</title>
    <link href="http://www.javaboy.org/2021/0719/spring-security-video.html"/>
    <id>http://www.javaboy.org/2021/0719/spring-security-video.html</id>
    <published>2021-07-19T13:52:28.000Z</published>
    <updated>2021-07-28T14:05:40.751Z</updated>
    
    <content type="html"><![CDATA[<p>大事！</p><p>松哥又要开整免费视频教程了！</p><p>关注松哥公众号的小伙伴可能都知道，松哥今年三月份出版了新书《深入浅出 Spring Security》一书。这本书为什么叫这个名字呢？因为我在这本书中不仅和大家聊了 Spring Security 的基本用法，也和大家聊了 Spring Security 源码，从入门到源码，一步步循序渐进深入剖析，故得此名。</p><a id="more"></a><p>不过源码总是枯燥的，很多小伙伴不知该如何下手，松哥思忖良久，决定为这本书录制一套配套视频，最重要的是，这套视频将免费分发给大家！重要事情说三遍，<strong>免费！免费！免费！</strong></p><p>这套视频我将按照书的思路来讲解，基本上就按照书的章节来讲，一小节一小节的来，下图是书的目录，视频也差不多按照这个来：</p><p><img src="http://img.itboyhub.com/2021/02/20210309181928.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182027.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182056.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182135.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182207.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182236.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210309182305.png" alt></p><p>视频录制好之后，会在公众号上首发。</p><p>由于松哥也在上班，今年还在带团队，要负责部门间的各种协调，杂七杂八的事情加在一起，每天早上七点多起床，下班回到家都 11 点多了，所以录视频的时间真的很有限，不过松哥还是尽量争取每周至少发 2-3 集视频，然后周末我会将这些视频进行整理，再统一上传到 B 站供大家学习参考。</p><p>很多小伙伴看视频的时候，都希望作者也能把笔记分享出来，由于松哥这次录制的视频就是这本书的配套视频，因此书的内容就相当于笔记，松哥在视频中也就不再额外记笔记了，如果大家对笔记有刚需，可以买本书支持下（对笔记不刚需也可以支持下）：</p><!--商品--><p>说到这里，松哥也顺便再提一下我的 B 站账号，松哥之前在公号上发过很多视频教程，不过公众号有一个缺点就是视频不好整理，有的是成系列的视频，小伙伴们看完了如果没有收藏，后期可能就找不到了，其实松哥在公众号上发过的视频，最终都整理到 B 站了，只是有的时候比较忙，整理到 B 站的时间晚了一些而已。</p><p><img src="http://img.itboyhub.com/2021/02/20210715202142.png" alt></p><p><strong>B 站链接：<a href="https://space.bilibili.com/49484631/video" target="_blank" rel="noopener">https://space.bilibili.com/49484631/video</a></strong></p><p>记得三连呀！</p><p>好啦，今天即然是个好日子，松哥就再赠送 5 本签名书吧！三本《Spring Boot+Vue 全栈开发实战》和 两本《深入浅出 Spring Security》包邮到家！</p><p>两种参与方式：</p><ol><li><strong>公号后台回复</strong> 6，获取抽奖链接，抽《Spring Boot+Vue 全栈开发实战》（7月23开奖）。</li></ol><p><img src="http://img.itboyhub.com/2021/02/20210719175803.png" alt></p><ol start="2"><li>公号留言说说你 coding 生涯遇到的奇葩代码，松哥会从中选出两位幸运小伙伴，各赠送一本 《深入浅出 Spring Security》（7月23开奖）。</li></ol><p><img src="http://img.itboyhub.com/2021/02/20210719175704.png" alt></p><p>以上赠书，都是签名版的哦～</p><p>好啦，我就不废话了，视频这周就开搞！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大事！&lt;/p&gt;
&lt;p&gt;松哥又要开整免费视频教程了！&lt;/p&gt;
&lt;p&gt;关注松哥公众号的小伙伴可能都知道，松哥今年三月份出版了新书《深入浅出 Spring Security》一书。这本书为什么叫这个名字呢？因为我在这本书中不仅和大家聊了 Spring Security 的基本用法，也和大家聊了 Spring Security 源码，从入门到源码，一步步循序渐进深入剖析，故得此名。&lt;/p&gt;
    
    </summary>
    
      <category term="video" scheme="http://www.javaboy.org/categories/video/"/>
    
    
      <category term="video" scheme="http://www.javaboy.org/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中的共享表空间与独立表空间，用哪个好呢？</title>
    <link href="http://www.javaboy.org/2021/0714/mysql-table-space.html"/>
    <id>http://www.javaboy.org/2021/0714/mysql-table-space.html</id>
    <published>2021-07-14T13:51:29.000Z</published>
    <updated>2021-07-28T14:05:34.218Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面几篇文章和大家聊了 MySQL 中的 MyISAM 引擎，也聊了 MySQL 一些进阶配置，还没看过的小伙伴可以先看看哦：</p><ol><li><a href="https://mp.weixin.qq.com/s/fZ-jhSk-k8RBtyaEMOk09g" target="_blank" rel="noopener">是什么影响了 MySQL 的性能？</a></li><li><a href="https://mp.weixin.qq.com/s/fqLoKPhhkWN_OOhGjZKeQw" target="_blank" rel="noopener">CPU 以及内存从哪些方面影响 MySQL 性能？</a></li><li><a href="https://mp.weixin.qq.com/s/MBWnUFOKcFurenXmOaHUDg" target="_blank" rel="noopener">硬盘是如何影响数据库性能的？</a></li><li><a href="https://mp.weixin.qq.com/s/HdE5QiK5Qp3_sGd_cXABIg" target="_blank" rel="noopener">MySQL 体系架构简介</a></li><li><a href="https://mp.weixin.qq.com/s/HgLk46Me6f1c3iu8oUz95A" target="_blank" rel="noopener">MySQL 中的表级锁很差劲吗？</a></li><li><a href="https://mp.weixin.qq.com/s/z-d3OoJaqhY_H4bDgsXgrg" target="_blank" rel="noopener">这个 MySQL 索引选择性有点意思！</a></li><li><a href="https://mp.weixin.qq.com/s/E5WR3_0-pPsrdu76xiYW7A" target="_blank" rel="noopener">关于 MyISAM 引擎你可能不知道的三件事</a></li></ol><a id="more"></a><p>好啦，那我们今天就开始学习 MySQL 中另外一个非常重要的存储引擎 InnoDB 了。</p><p>要说 InnoDB，我们就不得不先来说说另外一个比较重要的话题表空间和共享表空间，这也是我们本文的主题。</p><h2 id="1-独立表空间与共享表空间"><a href="#1-独立表空间与共享表空间" class="headerlink" title="1.独立表空间与共享表空间"></a>1.独立表空间与共享表空间</h2><p>对于 InnoDB 存储引擎来说，它可以将每张表存放于独立的表空间，即 <code>tablename.ibd</code> 文件；也可以将数据存放于 <code>ibdata</code> 的共享表空间，一般命名是 <code>ibdataX</code>，后面的 X 是一个具体的数字。</p><p>我们先来体验看看这两种有什么区别。</p><p>首先我们执行如下代码可以查看是否开启了独立表空间：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'innodb_file_per_table'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210713192353.png" alt></p><p>可以看到，默认情况下，独立表空间是开启的。</p><p>这个时候我们来创建一个使用了 InnoDB 引擎的表，如下（默认存储引擎就是 InnoDB）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> book(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>));</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210713192512.png" alt></p><p>创建完成后，我们来到存放数据文件的目录下，可以看到如下文件：</p><p><img src="http://img.itboyhub.com/2021/02/20210713192756.png" alt></p><p>可以看到，当前表被存放在独立的 <code>book.ibd</code> 文件中。</p><blockquote><p>存放于独立表空间的表都将会以独立文件的方式来进行存储，每一个表都有一个 <code>.frm</code> 表描述文件（这个和 MyISAM 引擎一致），还有一个 <code>.ibd</code> 文件，这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。</p></blockquote><p>接下来我们执行如下代码，修改 <code>innodb_file_per_table</code> 的值为 OFF，即关闭独立表空间，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210713193520.png" alt></p><p>关闭之后，再来创建新表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> book2(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>));</span><br></pre></td></tr></table></figure><p>新表创建成功之后，此时我们再去表目录下查看文件，发现并没有一个名为 <code>book2.ibd</code> 的文件，说明此时的表已经存放于共享表空间了。</p><p>那么共享表空间的 ibdata1 文件又在哪里呢？其实就在 MySQL 存放数据库的目录下：</p><p><img src="http://img.itboyhub.com/2021/02/20210713194759.png" alt></p><p>我们可以通过如下命令查看 ibdata1 的默认大小：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'innodb_data_file_path'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210713194922.png" alt></p><p>可以看到，默认大小是 12M。</p><p><strong>需要注意的是，<code>innodb_file_per_table</code> 要在创建表之前修改，创建表之后再去修改，是不会影响已有的表结构的。</strong></p><h2 id="2-该用哪一个？"><a href="#2-该用哪一个？" class="headerlink" title="2.该用哪一个？"></a>2.该用哪一个？</h2><p>要搞明白要用哪一种表空间，我们得先明白两种不同表空间各自的特点。</p><h3 id="2-1-独立表空间"><a href="#2-1-独立表空间" class="headerlink" title="2.1 独立表空间"></a>2.1 独立表空间</h3><p><strong>优势</strong></p><ol><li>每张表都有自己独立的表空间。</li><li>每张表的数据和索引都会存储在自己的表空间中。</li><li>可以实现单表在不同的数据库中移动（因为每张表都有独立的数据表文件）。</li><li>空间可以回收（通过 optimize table 命令实现）。</li><li>无论怎么删除，表空间的碎片不会太严重影响系统性能。</li></ol><p><strong>缺点</strong></p><ol><li>单表增加过大。</li></ol><h3 id="2-2-共享表空间"><a href="#2-2-共享表空间" class="headerlink" title="2.2 共享表空间"></a>2.2 共享表空间</h3><p><strong>优势</strong></p><ol><li>可以将表空间分成多个文件存放到各个磁盘上（表空间文件大小不受表大小的限制，如一个表可以分布在不同的文件上）。</li><li>数据和文件放在一起方便管理。</li></ol><p><strong>缺点</strong></p><ol><li>所有的数据和索引存放到一个文件中，这将意味着有一个很大的文件存在（虽然可以把一个大文件分成多个小文件），但是多个表及索引在表空间中混合存储，这样当一个表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析、日志系统这类应用而言，最不适合用共享表空间（例如，当系统空间不够用的时候，我们希望通过删除一些无效数据来腾出来一些表空间，这个时候我们会发现，如果使用了共享表空间，即使无效数据删除了，表空间还是还是不会缩小）。</li><li>共享表空间管理会出现表空间分配后不能回缩的问题，当临时建立索引或者临时表导致表空间扩大后，就是删除相关的表也没办法回缩那部分空间了。</li><li>对于第二点存在的问题，一般使用 mysqldump 导出数据，然后删除共享表空间数据文件后，再重新导入。</li><li>由于一个文件中保存了多个表数据，所以并发操作时可能会产生 IO 瓶颈，所以需要频繁写入的场景并不适合共享表空间。</li></ol><p>经过以上的分析，相信小伙伴们已经明白了，在实际项目中，还是首选独立表空间比较好，事实上，从 MySQL5.6 开始，独立表空间就已经成为默认选项了。</p><h2 id="3-迁移"><a href="#3-迁移" class="headerlink" title="3.迁移"></a>3.迁移</h2><p>最后还有一个问题，如果一开始创建的是共享表空间，那么还能迁移到独立表空间吗？当然可以！参考如下四个步骤：</p><ol><li>使用 mysqldump 导出所有数据库表数据。</li><li>停止 MySQL 服务，修改 <code>innodb_file_per_table</code> 参数，并删除 InnoDB 相关文件（如果是主从结构，则可以从 Slave 上入手完成这些操作）。</li><li>重启 MySQL 服务，重建 InnoDB 共享表空间（此时里边就没有数据了）。</li><li>重新导入数据。</li></ol><p>好啦，今天就和小伙伴们聊一聊共享表空间和独立表空间，InnoDB 的其他玩法我们后面再继续介绍～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面几篇文章和大家聊了 MySQL 中的 MyISAM 引擎，也聊了 MySQL 一些进阶配置，还没看过的小伙伴可以先看看哦：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fZ-jhSk-k8RBtyaEMOk09g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;是什么影响了 MySQL 的性能？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fqLoKPhhkWN_OOhGjZKeQw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CPU 以及内存从哪些方面影响 MySQL 性能？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MBWnUFOKcFurenXmOaHUDg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;硬盘是如何影响数据库性能的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HdE5QiK5Qp3_sGd_cXABIg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 体系架构简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HgLk46Me6f1c3iu8oUz95A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 中的表级锁很差劲吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/z-d3OoJaqhY_H4bDgsXgrg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个 MySQL 索引选择性有点意思！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/E5WR3_0-pPsrdu76xiYW7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于 MyISAM 引擎你可能不知道的三件事&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于 MyISAM 引擎你可能不知道的三件事</title>
    <link href="http://www.javaboy.org/2021/0712/mysql-myisam.html"/>
    <id>http://www.javaboy.org/2021/0712/mysql-myisam.html</id>
    <published>2021-07-12T13:51:16.000Z</published>
    <updated>2021-07-28T14:05:28.916Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>存在即合理，虽然在互联网公司中 InnoDB 引擎使用较多，但是 MyISAM 引擎的特性自有它自己的使用场景，今天松哥就来和大家捋一捋 MyISAM，这也是我们 MySQL 进阶必经之路。</p><h2 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1.MyISAM"></a>1.MyISAM</h2><p>MyISAM 是 MySQL 的默认数据库引擎（5.5版之前），由早期的 ISAM 所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。最近几年，MySQL 逐渐使用 InnoDB 代替了 MyISAM，关于 InnoDB 和 MyISAM 的历史纠葛，松哥在上篇文章中（<a href="https://mp.weixin.qq.com/s/HdE5QiK5Qp3_sGd_cXABIg" target="_blank" rel="noopener">MySQL 体系架构简介</a>）已经和大家介绍过了，这里就不再赘述。</p><a id="more"></a><p>每一个使用 MyISAM 存储引擎的数据表，数据都会存放在两个文件中 <code>.MYD</code> 和 <code>.MYI</code>，例如我新建一个使用了 MyISAM 存储引擎的表，名为 user，然后我们找到 user 表的存放位置，可以看到如下三个文件：</p><p><img src="http://img.itboyhub.com/2021/02/20210706084113.png" alt></p><ul><li>user.frm：存储表结构信息，这个和 MyISAM 引擎没有关系。</li><li>user.MYD：存放表数据。</li><li>user.MYI：存放索引信息。</li></ul><p><strong>题外话，如何查看数据库文件位置？</strong></p><blockquote><p>执行命令 <code>show global variables like &quot;%datadir%&quot;;</code> 可以查看数据库文件位置。<br><img src="http://img.itboyhub.com/2021/02/20210706091617.png" alt></p></blockquote><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><p>那么 MyISAM 都有哪些特性呢？接下来我们就从如下几个方面来介绍下。</p><h3 id="2-1-锁级别"><a href="#2-1-锁级别" class="headerlink" title="2.1 锁级别"></a>2.1 锁级别</h3><p>基本上大家看到所有讲 MyISAM 和 InnoDB 区别的资料，都会提到这一点，因为这是它俩最为重要的区别，MyISAM 是表级锁（table-level locking），而 InnoDB 支持行级锁（row-level locking），也支持表级锁，但是默认情况下是行级锁。</p><ul><li>表级锁的特点是开销小，加锁快，不会出现死锁，但是锁定粒度较大，发生锁冲突的概率高，而且并发度也低。</li><li>行级锁的特点是开销大，加锁慢，有可能会出现死锁，但是它的锁定粒度小，发生锁冲突的概率低，并发度也高。</li></ul><p>根据锁的特点来看，表级锁更适合于查询操作（读写混合操作执行效率较低），而行级锁则更适合并发更新、并发查询的应用，因为我们今天的主角是 MyISAM，所以我们这里就先不讨论行级锁的问题，表级锁松哥在上篇文章中也已经介绍过了，这里就不再赘述。没看上篇的小伙伴可以参考：<a href="https://mp.weixin.qq.com/s/HgLk46Me6f1c3iu8oUz95A" target="_blank" rel="noopener">MySQL 中的表级锁很差劲吗？</a>。</p><h3 id="2-2-check-repair"><a href="#2-2-check-repair" class="headerlink" title="2.2 check/repair"></a>2.2 check/repair</h3><p>可以通过 check table 命令来查看 MyISAM 表是否损坏，也可以通过 repair table 命令来修复一个被损坏的 MyISAM 表。</p><p><img src="http://img.itboyhub.com/2021/02/20210706223057.png" alt></p><h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3 全文索引"></a>2.3 全文索引</h3><p>MyISAM 支持全文索引，曾经这是它非常重要的一个特性。因为从 MySQL5.6 开始，InnoDB 才支持全文索引，在这之前，官方的存储引擎只有 MyISAM 支持全文索引。</p><p>另外需要注意的是，MyISAM 引擎还可以建立前缀索引（InnoDB 也支持），所谓前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数。</p><p>关于前缀索引，松哥之前已经专门写过文章介绍过了：</p><ul><li><a href="https://mp.weixin.qq.com/s/z-d3OoJaqhY_H4bDgsXgrg" target="_blank" rel="noopener">这个 MySQL 索引选择性有点意思！</a></li></ul><h3 id="2-4-表压缩"><a href="#2-4-表压缩" class="headerlink" title="2.4 表压缩"></a>2.4 表压缩</h3><p>MyISAM 表支持数据压缩。</p><p>对于一些很大的只读表，我们可以对其进行压缩，这样可以有效节省磁盘 IO。MyISAM 表在压缩的时候是对单行数据进行压缩的，所以我们并不用担心在读取一行数据的时候会对表进行解压。</p><p>MyISAM 表压缩的命令是 myisampack，我们来看一个简单案例：</p><p>首先进入到数据库文件目录中查看当前的数据库文件：</p><p><img src="http://img.itboyhub.com/2021/02/20210708220950.png" alt></p><p>然后我们对 user.MYI 文件进行强制压缩：</p><p><img src="http://img.itboyhub.com/2021/02/20210708221544.png" alt></p><p>user.OLD 是压缩之前的文件备份，其他的是压缩后的文件，由于松哥这里的样例数据比较少，所以压缩之后的效果不是很明显（压缩后的文件反而变大了，如果数据量比较大，就不会出现这个问题）。</p><p>压缩完成后，我们再对数据表进行操作，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210708222232.png" alt></p><p>可以看到，只有查询操作是 OK 的，其他的增删改都是不可以的，因为压缩后的 user 表就是一个只读表。</p><h3 id="2-5-单表限制"><a href="#2-5-单表限制" class="headerlink" title="2.5 单表限制"></a>2.5 单表限制</h3><p>在 MySQL5.0 之前，使用 MyISAM 引擎的数据表，单表最大大小为 4G，如果我们存储的数据超过了 4G，就需要在创建表的时候，手动调整可存储的数据行数以及每行的数据大小。</p><p>创建表时我们可以通过如下方式修改这两个变量：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user2 (</span><br><span class="line"><span class="hljs-keyword">id</span> <span class="hljs-built_in">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> PRIMARY <span class="hljs-keyword">KEY</span>,</span><br><span class="line"><span class="hljs-keyword">name</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">18</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></span><br><span class="line">) MAX_ROWS = <span class="hljs-number">1000000000</span> AVG_ROW_LENGTH = <span class="hljs-number">32</span>;</span><br></pre></td></tr></table></figure><p>对于已存在的表，我们可以通过如下方法修改这两个变量：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user2 MAX_ROWS=<span class="hljs-number">1000000000</span> AVG_ROW_LENGTH=<span class="hljs-number">15000</span>;</span><br></pre></td></tr></table></figure><p>当然，这都是老黄历了！</p><p>在 MySQL5.0 之后，单表的大小限制变成了 256TB，这基本上够用了。</p><h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h2><ul><li>非事务型应用（MyISAM 不支持事务）</li><li>只读数据（可在表压缩之后使用）</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，几天就先和小伙伴们扯这么多～</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/123962424" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/123962424</a></li><li><a href="https://www.cnblogs.com/studyzy/p/4310653.html" target="_blank" rel="noopener">https://www.cnblogs.com/studyzy/p/4310653.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;存在即合理，虽然在互联网公司中 InnoDB 引擎使用较多，但是 MyISAM 引擎的特性自有它自己的使用场景，今天松哥就来和大家捋一捋 MyISAM，这也是我们 MySQL 进阶必经之路。&lt;/p&gt;
&lt;h2 id=&quot;1-MyISAM&quot;&gt;&lt;a href=&quot;#1-MyISAM&quot; class=&quot;headerlink&quot; title=&quot;1.MyISAM&quot;&gt;&lt;/a&gt;1.MyISAM&lt;/h2&gt;&lt;p&gt;MyISAM 是 MySQL 的默认数据库引擎（5.5版之前），由早期的 ISAM 所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。最近几年，MySQL 逐渐使用 InnoDB 代替了 MyISAM，关于 InnoDB 和 MyISAM 的历史纠葛，松哥在上篇文章中（&lt;a href=&quot;https://mp.weixin.qq.com/s/HdE5QiK5Qp3_sGd_cXABIg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 体系架构简介&lt;/a&gt;）已经和大家介绍过了，这里就不再赘述。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>这个 MySQL 索引选择性有点意思！</title>
    <link href="http://www.javaboy.org/2021/0708/mysql-index.html"/>
    <id>http://www.javaboy.org/2021/0708/mysql-index.html</id>
    <published>2021-07-08T13:51:01.000Z</published>
    <updated>2021-07-28T14:05:20.214Z</updated>
    
    <content type="html"><![CDATA[<p>索引小伙伴们肯定经常用！但是有一种前缀索引不知道大家有没有用过或者听说过？今天松哥就来和大家聊一聊 MySQL 里边的这个前缀索引。</p><h2 id="1-什么是前缀索引"><a href="#1-什么是前缀索引" class="headerlink" title="1.什么是前缀索引"></a>1.什么是前缀索引</h2><p>所谓前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数。</p><a id="more"></a><p>那么为什么不对整个字段建立索引呢？一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，前缀索引仅仅是选择一个字段的部分字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性。</p><p>这里又涉及到一个概念，什么是索引选择性？</p><h2 id="2-什么是索引选择性"><a href="#2-什么是索引选择性" class="headerlink" title="2.什么是索引选择性"></a>2.什么是索引选择性</h2><p>关于索引的选择性（Index Selectivity），它是指不重复的索引值（也称为基数 cardinality)和数据表的记录总数的比值，取值范围在 <code>[0,1]</code> 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</p><p>那有小伙伴要问了，是不是选择性越高的索引越好呢？当然不是！索引选择性最高为 1，如果索引选择性为 1，就是唯一索引了！这个时候虽然性能最好，但是也是最费空间的，这不符合我们创建前缀索引的初衷。</p><p>我们一开始之所以要创建前缀索引而不是唯一索引，<strong>就是希望能够在索引的性能和空间之间找到一个平衡</strong>，我们希望能够选择足够长的前缀以保证较高的选择性，但是又希望索引不要太过于占用存储空间。</p><p>那么我们该如何选择一个合适的索引选择性呢？索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数。</p><p>首先我们可以通过如下 SQL 得到全列选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> column_name) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>然后再通过如下 SQL 得到某一长度前缀的选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(column_name, prefix_length)) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>在上面这条 SQL 执行的时候，我们要注意选择合适的 prefix_length，直至计算结果约等于全列选择性的时候，就是最佳结果了。</p><h2 id="3-创建前缀索引"><a href="#3-创建前缀索引" class="headerlink" title="3.创建前缀索引"></a>3.创建前缀索引</h2><p>举个例子，我们来创建一个前缀索引看看。</p><p>松哥这里使用的数据样例是 MySQL 自己提供的数据样例，SQL 脚本下载链接：<a href="https://downloads.mysql.com/docs/world_x-db.zip。" target="_blank" rel="noopener">https://downloads.mysql.com/docs/world_x-db.zip。</a></p><p>以这里的 countrylanguage 表为例，我们首先来看 Language 全列选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">Language</span>) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> countrylanguage;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210707235858.png" alt></p><p>然后再来看前缀为 8 的选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-keyword">Language</span>, <span class="hljs-number">8</span>)) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> countrylanguage;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210707235830.png" alt></p><p>感觉似乎差不多，就是它了。</p><p>接下来我们为其创建前缀索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> countrylanguage <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span> Language_index(<span class="hljs-keyword">Language</span>(<span class="hljs-number">10</span>));</span><br></pre></td></tr></table></figure><p>查看刚刚创建的前缀索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> countrylanguage;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210708000441.png" alt></p><p>接下来我们分析查询语句中是否用到该索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> countrylanguage <span class="hljs-keyword">where</span> <span class="hljs-keyword">Language</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'Zu%'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210708000736.png" alt></p><p>可以看到，这个前缀索引已经用上了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就先聊这么多，剩下的我们以后再扯吧～</p><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/dhrome/article/details/72853153" target="_blank" rel="noopener">https://blog.csdn.net/dhrome/article/details/72853153</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引小伙伴们肯定经常用！但是有一种前缀索引不知道大家有没有用过或者听说过？今天松哥就来和大家聊一聊 MySQL 里边的这个前缀索引。&lt;/p&gt;
&lt;h2 id=&quot;1-什么是前缀索引&quot;&gt;&lt;a href=&quot;#1-什么是前缀索引&quot; class=&quot;headerlink&quot; title=&quot;1.什么是前缀索引&quot;&gt;&lt;/a&gt;1.什么是前缀索引&lt;/h2&gt;&lt;p&gt;所谓前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中的表级锁很差劲吗？</title>
    <link href="http://www.javaboy.org/2021/0707/mysql-lock.html"/>
    <id>http://www.javaboy.org/2021/0707/mysql-lock.html</id>
    <published>2021-07-07T13:50:46.000Z</published>
    <updated>2021-07-28T14:05:13.333Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>当然不是！</p><p>其实本来今天是要和大家聊一聊 MyISAM 引擎的，结果在写的过程中，又发现锁这个话题可以单独写一篇，于是就有了今天的文章。</p><p>说到 MyISAM 和 InnoDB 的区别，很多人都知道，区别在于一个是表锁一个是行锁，那么小伙伴们有没有想过，表锁和行锁有什么区别？各自又有哪些玩法？今天松哥就来和大家聊聊这个话题。</p><a id="more"></a><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><p>我们先来大致说一下 MySQL 中的锁。</p><p>当多个事务或者多个进程访问同一个资源的时候，为了保证数据的一致性，就需要用到 MySQL 锁机制，从锁定资源的角度来看，MySQL 中的锁大致上可以分为三种：</p><ul><li>表级锁（table-level locking）：表级锁的特点是开销小，加锁快，不会出现死锁，但是锁定粒度较大，发生锁冲突的概率高，而且并发度也低。</li><li>行级锁（row-level locking）：行级锁的特点是开销大，加锁慢，有可能会出现死锁，但是它的锁定粒度小，发生锁冲突的概率低，并发度也高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>虽然理论上有三种锁，但是对于在坐的各位小伙伴包括松哥而言，我们日常开发接触最多的还是前两种，就是表级锁和行级锁。</p><p>在 MySQL 中，MyISAM 引擎是表级锁，而 InnoDB 引擎则支持行级锁，不过需要注意，<strong>其实 InnoDB 也支持表级锁</strong>，只不过默认情况下是行级锁。</p><h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h2><p>MySQL 的表级锁有两种模式：</p><ul><li>表共享读锁（Table Read Lock）。</li><li>表独占写锁（Table Write Lock）。</li></ul><p>MyISAM 引擎在执行 select 时会自动给相关表加读锁，在执行 update、delete 和 insert 时会自动给相关表加写锁。</p><h3 id="2-1-表共享读锁"><a href="#2-1-表共享读锁" class="headerlink" title="2.1 表共享读锁"></a>2.1 表共享读锁</h3><p>我们先来看表共享读锁，加了共享读锁的表，不会阻塞其他 session 的读请求，但是会阻塞其他 session 的写请求。</p><p>我们来演示一下这个效果。</p><blockquote><p>在下面的案例中，我们会准备两个窗口，代表两个 session。</p></blockquote><p>首先我们新建一张表，选择 MyISAM 作为存储引擎，DDL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=MyISAM <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>添加一条测试数据：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span>(<span class="hljs-string">'javaboy'</span>);</span><br></pre></td></tr></table></figure><p>然后我们在两个命令行窗口分别登录 mysql，模拟出两个 session。</p><p>首先在第一个窗口为表添加读锁，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">read</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706140853.png" alt></p><p>然后在第二个窗口去读取数据：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706141018.png" alt></p><p>可以发现，是可以正常读取的。</p><p>然后我们尝试在第二个窗口写入一条数据：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-keyword">name</span>) <span class="hljs-keyword">values</span>(<span class="hljs-string">'itboyhub'</span>);</span><br></pre></td></tr></table></figure><p>这条写入语句会 <code>卡住</code>，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706141231.png" alt></p><p>卡住的原因是因为 user 表目前被上了共享读锁，这个时候需要我们去到第一个窗口中，解除表的锁定，这个时候第二个窗口中的这条插入 sql 就可以执行了。如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">unlock</span> <span class="hljs-keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706141541.png" alt></p><p>当这条 SQL 完毕后，第二个窗口中的插入语句立马就执行了。</p><p>如下是窗口2的截图：</p><p><img src="http://img.itboyhub.com/2021/02/20210706141720.png" alt></p><p>可以看到，加了共享读锁的表，不会阻塞其他 session 的读（select）请求，但是会阻塞其他 session 的写（insert、update、delete）请求。</p><p>需要注意的是，如果在同一条 SQL 中，同一个表名出线了 N 次，该表就要锁定 N 次，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706142825.png" alt></p><p><strong>思考：</strong></p><p>我们在窗口 1 中给 user 表加了锁，那么在窗口 1 中是否可以对 user 表执行 insert/update/delete 等写操作呢？评论区 show 出你的答案～</p><h3 id="2-2-表独占写锁"><a href="#2-2-表独占写锁" class="headerlink" title="2.2 表独占写锁"></a>2.2 表独占写锁</h3><p>这个独占写锁就是大家锁所熟知的排他锁，它会阻塞其他进程对同一表的读写操作，只有当当前锁释放后，才会执行其他进程的读写操作。</p><p>我们来演示一下这个过程。</p><p>还是两个窗口，首先我们我们在第一个窗口中执行锁表操作：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> write;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706144731.png" alt></p><p>然后去第二个窗口中做查询操作，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706144817.png" alt></p><p>可以看到，由于是排他锁，所以查询操作也被阻塞了。此时需要在窗口 1 中解除表的锁定，窗口 2 中的查询操作才会继续执行下去。</p><p><img src="http://img.itboyhub.com/2021/02/20210706144953.png" alt></p><p>这就是表独占写锁，也就是排他锁。</p><p>在 MyISAM 存储引擎中，会自动为 SELECT 语句加上共享锁，为 update/delete/insert 操作加上排他锁。</p><h3 id="2-3-concurrent-insert"><a href="#2-3-concurrent-insert" class="headerlink" title="2.3 concurrent_insert"></a>2.3 concurrent_insert</h3><p>前面我们讲的是表级锁的两种基本模式，在具体的使用过程中，我们还可以通过 concurrent_insert 去配置一些并发行为。</p><p>concurrent_insert 有三种不同的取值：</p><ul><li>NEVER：加了读锁之后，不允许其他 session 并发插入。</li><li>AUTO：加了读锁之后，如果表里没有删除过数据，其他 session 就可以并发插入。</li><li>ALWAYS：加了读锁之后，允许其他 session 并发插入。</li></ul><blockquote><p>需要注意的是，在 MySQL5.5.3 之前，NEVER、AUTO 以及 ALWAYS 分别使用 0、1、2 代替。</p></blockquote><p>通过 <code>show global variables like &#39;%concurrent_insert%&#39;</code> 命令我们可以查看当前数据库中 <code>concurrent_insert</code> 的取值，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706150234.png" alt></p><p>可以看到，数据库中默认的 concurrent_insert 取值为 AUTO。有小伙伴可能会说，啥？AUTO？那为啥我在 2.1 小结中，当表加了读锁之后，其他 session 无法插入数据呢？这其实跟加锁方式有关，我们一起来看下。</p><p>还是两个窗口，首先我们在第一个窗口中为表添加读锁，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">local</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706150957.png" alt></p><p>可以看到，<strong>最后多了一个 local</strong>，这就是关键。</p><p>接下来我们在窗口 2 中去尝试读写操作，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706151200.png" alt></p><p>从图中可以看到，读写操作都可以顺利执行。</p><p>但是这个时候，如果我们去窗口 1 中执行查询，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706151315.png" alt></p><p>可以看到，这里并看不到窗口 2 中刚刚添加的那条数据，换句话说，窗口 2 中添加的数据对窗口 1 是不可以见的，必须等窗口 1 中的锁释放之后，才可以看到窗口 2 中添加的数据。</p><p>如下图，释放锁之后，就可以看到另外一个窗口添加进来的数据了：</p><p><img src="http://img.itboyhub.com/2021/02/20210706151532.png" alt></p><p>这是我给大家演示的默认的 concurrent_insert 的行为，大家也可以通过如下 SQL 修改该值：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> concurrent_insert = <span class="hljs-keyword">ALWAYS</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706152108.png" alt></p><h3 id="2-4-锁的优先级"><a href="#2-4-锁的优先级" class="headerlink" title="2.4 锁的优先级"></a>2.4 锁的优先级</h3><p>在 MyISAM 中，默认情况下，写锁的优先级要高，不过开发者也可以自行调整这个默认锁的优先级。</p><blockquote><p>话说回来，由于 MyISAM 是表锁，所以不建议用在需要频繁更新的场景下，否则可能会造成长时间的锁等待。所以下面的优先级调整，仅仅作为技术层面的探讨。</p></blockquote><p><strong>修改 SQL 优先级</strong></p><p>首先我们可以在执行 SQL 的时候，顺便修改其优先级：</p><p>例如执行 select 的时候可以使用 HIGH_PRIORITY 来提高该语句的优先级，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210706154850.png" alt></p><p>在执行 delete/update/insert 等操作的时候，可以使用 LOW_PRIORITY 来降低其优先级，以便让读取操作先执行：</p><p><img src="http://img.itboyhub.com/2021/02/20210706155136.png" alt></p><p>当然我们也可以通过如下 SQL 让所有支持 LOW_PRIORITY 选项的语句都默认地按照低优先级来处理。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span> LOW_PRIORITY_UPDATES = <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706155402.png" alt></p><p><strong>修改写锁上限</strong></p><p>我们可以修改 MAX_WRITE_LOCK_COUNT 的值，该变量默认值如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210706155623.png" alt></p><p>这个值表示当一个表的写锁数量达到给定的值后，就降低写锁的优先级，让读锁有机会执行。如果有需要，我们可以自行调整这个值，调整方式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-keyword">GLOBAL</span> MAX_WRITE_LOCK_COUNT=<span class="hljs-number">1024</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210706181318.png" alt></p><h2 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h2><p>行级锁松哥留到讲 InnoDB 的时候再和大家聊，今天我们就先扯这么多～</p><p>参考资料：</p><p>1.<a href="https://database.51cto.com/art/201910/604421.htm" target="_blank" rel="noopener">https://database.51cto.com/art/201910/604421.htm</a><br>2.<a href="https://zhuanlan.zhihu.com/p/123962424" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/123962424</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;当然不是！&lt;/p&gt;
&lt;p&gt;其实本来今天是要和大家聊一聊 MyISAM 引擎的，结果在写的过程中，又发现锁这个话题可以单独写一篇，于是就有了今天的文章。&lt;/p&gt;
&lt;p&gt;说到 MyISAM 和 InnoDB 的区别，很多人都知道，区别在于一个是表锁一个是行锁，那么小伙伴们有没有想过，表锁和行锁有什么区别？各自又有哪些玩法？今天松哥就来和大家聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 体系架构简介</title>
    <link href="http://www.javaboy.org/2021/0705/mysql-architecture.html"/>
    <id>http://www.javaboy.org/2021/0705/mysql-architecture.html</id>
    <published>2021-07-05T13:50:33.000Z</published>
    <updated>2021-07-28T14:05:07.721Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面三篇文章我们一起分析了外部环境对 MySQL 性能的影响，不过起决定作用的还是 MySQL 自身，今天我们就来看看 MySQL 体系架构，看看这个数据库到底是怎么组成的。</p><p>MySQL 是一个典型的 C/S 架构应用程序，MySQL Server 提供数据库服务，完成客户端的请求和操作，Client 则负责连接到 Server。很多初学者并不太容易区分出 MySQL Server 和 Client，因为当我们安装完 MySQL 之后，默认情况下 Server 和 Client 就都具备了，我们在命令行连接并登录 MySQL 服务，这个其实就是由 Client 提供的服务。MySQL 和其他关系型数据库不一样的地方在于它的弹性以及可以通过插件形式提供不同种类的存储引擎，MySQL 请求处理过程会根据不同的存储引擎发生变化，这是它的特色。</p><a id="more"></a><h2 id="1-MySQL-存储引擎"><a href="#1-MySQL-存储引擎" class="headerlink" title="1.MySQL 存储引擎"></a>1.MySQL 存储引擎</h2><p>这里我主要和大家介绍下 MySQL 存储引擎的历史，至于每一个存储引擎的特点，松哥将在后面的文章中和大家详细介绍。</p><p>MySQL 从设计之初，存储引擎就是可插拔的，允许公司或者个人按照自己的需求定义自己的存储引擎（当然，普通的公司或者个人其实是没有这个实力的）。MySQL 自研的使用较广的存储引擎是 MyISAM ，MyISAM 支持表锁，不支持行锁，所以在处理高并发写操作时效率要低一些，另外 MyISAM 也不支持外键（虽然现在实际项目中外键已经用的比较少了）。</p><p>虽然 MyISAM 看起来有些简陋，但这并不影响 MySQL 的流行，这就不得不说 MySQL 中另外一个大名鼎鼎的存储引擎 InnoDB 了。</p><p>InnoDB 存储引擎是由一家位于芬兰赫尔辛基的名为 Innobase Oy 的公司开发的，InnoDB 存储引擎的历史甚至比 MySQL 还要悠久。可能会有小伙伴决定奇怪，插件竟然比起宿主还要历史悠久？</p><p>InnoDB 刚刚开发的时侯，就是作为一个完整的数据库来开发的，因此功能很完备。开发出来之后，创始人是想将这个数据库卖掉的，但是没有找到买家。</p><p>后来 MySQL2.0 推出后，这种可插拔的存储引擎吸引了 Innobase Oy 公司创始人 Heikki Tuuri 的注意，在和 MySQL 沟通之后，决定将 InnoDB 作为一个存储引擎引入到 MySQL 中（这就是为什么 InnoDB 比 MySQL 还历史悠久的原因），MySQL 虽然支持 InnoDB ，但是实际上还是主推自家的 MyISAM。</p><p>但是 InnoDB 实在太优秀了，最终在 2006 年的时侯，成功吸引到大魔王 Oracle 的注意，大手一挥，就把 InnoDB 收购了。</p><p>MySQL 主推自家的 MyISAM ，日子过得也很惨淡，最终在 2008 年被 sun 公司以 10 亿美元拿下，这个操作巩固了 sun 在开源领域的领袖地位，可是一直以来 sun 公司的变现能力都比较弱，最终 sun 自己在 2009 年被 Oracle 收入囊中。</p><p>Oracle 收购 sun 之后，InnoDB 和 MySQL 就都成了 Oracle 的产品了，这下整合就变得非常容易了，在后来发布的版本中，InnoDB 慢慢就成为了 MySQL 的默认存储引擎。在最新的 MySQL8 中，元数据表也使用了 InnoDB 作为存储引擎。</p><p>InnoDB 存储引擎主要有如下特点：</p><ol><li>支持事务</li><li>支持 4 个级别的事务隔离</li><li>支持多版本读</li><li>支持行级锁</li><li>读写阻塞与事务隔离级别相关</li><li>支持缓存，既能缓存索引，也能缓存数据</li><li>整个表和主键以 Cluster 方式存储，组成一颗平衡树</li></ol><p>当然也不是说 InnoDB 一定就是好的，在实际开发中，还是要根据具体的场景来选择到底是使用 InnoDB 还是 MyISAM 。</p><p>MyIASM（该引擎在 5.5 前的 MySQL 数据库中为默认存储引擎）特点：</p><ol><li>MyISAM 没有提供对数据库事务的支持</li><li>不支持行级锁和外键</li><li>由于 2，导致当执行 INSERT 插入或 UPDATE 更新语句时，即执行写操作需要锁定整个表，所以会导致效率降低</li><li>MyISAM 保存了表的行数，当执行 <code>SELECT COUNT(*) FROM TABLE</code> 时，可以直接读取相关值，不用全表扫描，速度快。</li></ol><p>两者区别：</p><ol><li>MyISAM 是非事务安全的，而 InnoDB 是事务安全的</li><li>MyISAM 锁的粒度是表级的，而 InnoDB 支持行级锁</li><li>MyISAM 支持全文类型索引，而 InnoDB 在 MySQL5.6 之前不支持全文索引，从 MySQL5.6 之后开始支持 FULLTEXT 索引了（<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-nutshell.html）。" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/mysql-nutshell.html）。</a></li></ol><p>使用场景比较：</p><ol><li>如果要执行大量 select 操作，应该选择 MyISAM</li><li>如果要执行大量 insert 和 update 操作，应该选择 InnoDB</li><li>大尺寸的数据集趋向于选择 InnoDB 引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB 可以利用事务日志进行数据恢复，这会比较快。主键查询在 InnoDB 引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题。</li></ol><p>相对来说，InnoDB 在互联网公司使用更多一些。</p><p>这是我们对 MySQL 存储引擎的一个简略介绍，后面松哥会专门写文章来详细介绍每一种存储引擎的特点，欢迎大家一起来讨论。</p><h2 id="2-MySQL-架构"><a href="#2-MySQL-架构" class="headerlink" title="2.MySQL 架构"></a>2.MySQL 架构</h2><p>接下来我们再来看看 MySQL 的软件架构（图片源自网络）。</p><p><img src="http://img.itboyhub.com/2021/02/20210701192237.png" alt></p><p>从上图我们可以大概看出来，MySQL 架构大致上可以分为三层：</p><ol><li>客户端（应用层）</li><li>服务层</li><li>存储引擎层</li></ol><p>我们分别来看。</p><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1 客户端"></a>2.1 客户端</h3><p>基本上所有的 C/S 架构的程序都有一个客户端层，这一层主要包含如下三方面的内容：</p><ul><li>连接处理：当一个客户端向服务端发送连接请求后，MySQL Server 会从线程池中分配一个线程来和客户端进行连接，以后该客户端的请求都会被分配到该线程上。MySQL Server 为了提高性能，提供了线程池，减少了创建线程和释放线程所花费的时间。主流的程序设计语言都可以使用各自的 API 来与 MySQL 建立连接。</li><li>用户认证：当客户端向 MySQL 服务端发起连接请求后，MySQL Server 会对发起连接的用户进行认证处理，MySQL 认证依据是: 用户名，客户端主机地址和用户密码。</li><li>用户鉴权：当客户连接到 MySQL Server 后，MySQL Server 会根据用户的权限来判断用户具体可执行哪些操作。</li></ul><h3 id="2-2-服务层"><a href="#2-2-服务层" class="headerlink" title="2.2 服务层"></a>2.2 服务层</h3><p>MySQL 服务层的东西主要有六方面，我们来逐个分析。</p><h4 id="2-2-1-系统管理和控制工具"><a href="#2-2-1-系统管理和控制工具" class="headerlink" title="2.2.1 系统管理和控制工具"></a>2.2.1 系统管理和控制工具</h4><ul><li>数据库备份和恢复</li><li>数据库安全管理，如用户及权限管理</li><li>数据库复制管理</li><li>数据库集群管理</li><li>数据库分区，分库，分表管理</li><li>数据库元数据管理</li></ul><h4 id="2-2-2-连接池"><a href="#2-2-2-连接池" class="headerlink" title="2.2.2 连接池"></a>2.2.2 连接池</h4><p>这个前面已经提到过，连接池负责存储和管理客户端与数据库的连接，一个线程管理一个连接。</p><h4 id="2-2-3-SQL-接口"><a href="#2-2-3-SQL-接口" class="headerlink" title="2.2.3 SQL 接口"></a>2.2.3 SQL 接口</h4><p>SQL 接口用来接受客户端发送来的各种 SQL 命令，并且返回用户需要的查询结果。</p><p>如：</p><ul><li>DDL</li><li>DML</li><li>存储过程</li><li>视图</li><li>触发器</li></ul><p>等都在这里被处理。</p><h4 id="2-2-4-解析器"><a href="#2-2-4-解析器" class="headerlink" title="2.2.4 解析器"></a>2.2.4 解析器</h4><p>解析器的作用主要是解析查询语句，将客户端请求的 SQL 解析生成一个“解析树”，然后根据 MySQL 的语法规则检查解析树是否合法，如果语句语法有错误，则返回相应的错误信息。</p><p>语法检查通过后，解析器会查询缓存，如果缓存中有对应的语句，就直接返回结果不进行接下来的优化执行操作。</p><h4 id="2-2-5-查询优化器"><a href="#2-2-5-查询优化器" class="headerlink" title="2.2.5 查询优化器"></a>2.2.5 查询优化器</h4><p>看名字就知道，这一步主要在解析器完成解析并对 SQL 语法进行检查之后，对查询语句进行优化，主要的优化方式包括选择合适的索引以及数据读取方式。</p><h4 id="2-2-6-缓存"><a href="#2-2-6-缓存" class="headerlink" title="2.2.6 缓存"></a>2.2.6 缓存</h4><p>包括全局和引擎特定的缓存，提高查询的效率。如果查询缓存中有命中的查询结果，则查询语句就可以从缓存中取数据，无须再通过解析和执行。这个缓存机制是由一系列小缓存组成，如表缓存、记录缓存、key 缓存、权限缓存等。</p><h3 id="2-3-存储引擎层"><a href="#2-3-存储引擎层" class="headerlink" title="2.3 存储引擎层"></a>2.3 存储引擎层</h3><p>存储引擎负责 MySQL 中数据的存储与提取，与底层系统文件进行交互。</p><p>MySQL 存储引擎是可插拔的，服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异。现在有很多种存储引擎，各有各的特点，最常见的是 MyISAM 和 InnoDB。</p><p>需要注意的是，MySQL 存储引擎是针对数据表而不是针对数据库，换句话说，在同一个数据库中，我们可以同时使用多种不同的存储引擎（技术上可以，实际不推荐）。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>MySQL 的这种分层设计为我们屏蔽了很多底层的东西，例如存储引擎的具体工作机制很多时候对开发工程师而言就是透明的，我们不需要关系 InnoDB 怎么工作的，写好自己的 SQL 就行（个别存储引擎支持的 SQL 也有差异，这个另论），这样对开发工程师来说是更加友好了。</p><p>好啦，今天就和小伙伴们先扯这么多～</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/43736857" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43736857</a></li><li><a href="https://juejin.cn/post/6857688351168954376" target="_blank" rel="noopener">https://juejin.cn/post/6857688351168954376</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面三篇文章我们一起分析了外部环境对 MySQL 性能的影响，不过起决定作用的还是 MySQL 自身，今天我们就来看看 MySQL 体系架构，看看这个数据库到底是怎么组成的。&lt;/p&gt;
&lt;p&gt;MySQL 是一个典型的 C/S 架构应用程序，MySQL Server 提供数据库服务，完成客户端的请求和操作，Client 则负责连接到 Server。很多初学者并不太容易区分出 MySQL Server 和 Client，因为当我们安装完 MySQL 之后，默认情况下 Server 和 Client 就都具备了，我们在命令行连接并登录 MySQL 服务，这个其实就是由 Client 提供的服务。MySQL 和其他关系型数据库不一样的地方在于它的弹性以及可以通过插件形式提供不同种类的存储引擎，MySQL 请求处理过程会根据不同的存储引擎发生变化，这是它的特色。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>硬盘是如何影响数据库性能的？</title>
    <link href="http://www.javaboy.org/2021/0701/mysql-ssd.html"/>
    <id>http://www.javaboy.org/2021/0701/mysql-ssd.html</id>
    <published>2021-07-01T13:50:19.000Z</published>
    <updated>2021-07-28T14:05:01.639Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥和大家聊了 CPU 和内存对于数据库性能的影响，但是大家想想，无论如何，数据最终都是要存入硬盘中的，所以硬盘肯定也会影响到数据库的性能，那么硬盘到底是如何影响数据库性能的，今天我们就来简单聊聊。</p><p>硬盘的使用，有四个不同的方向：</p><ol><li>传统的机械硬盘。</li><li>使用 RAID 增强机械硬盘性能。</li><li>使用固态存储 SSD。</li><li>使用网络存储 NAS 和 SAN。</li></ol><p>接下来我们就针对这四个方向逐一进行分析。</p><a id="more"></a><h2 id="1-机械硬盘"><a href="#1-机械硬盘" class="headerlink" title="1.机械硬盘"></a>1.机械硬盘</h2><p>这是最为常见的一种硬盘。松哥刚上大学那会，买笔记本电脑，基本上都是这种机械硬盘。不过现在小伙伴们买电脑，应该很多都是固态硬盘了。机械硬盘的特点就是便宜、单盘存储空间较大，不过问题也很明显，那就是读写较慢，相比于内存每秒 10GB 以上的数据传输，机械硬盘的数据真的慢的可怜。我刚毕业的时候，有一段时间特别想买 Mac，特别纠结。后来把我的 Windows 笔记本的机械硬盘换成了固态硬盘，开机可以秒开了，才把买 Mac 的想法掐灭了（一灭就是三年，三年后还是入手了 Mac）。</p><p>现在主流的机械硬盘基本上都是 7200 转的 SATA 硬盘，在全速运转并且是顺序读写的情况下，性能也就是 150MB～160MB/s 左右；如果涉及到数据库读写等随机性较强的 IO 操作，这个性能还要再下降。</p><p>传统的机械硬盘在读写数据的时候，有三个步骤：</p><ol><li>寻道：磁头定位到数据所在的磁道上，这是一个非常耗时的操作。目前 SATA 硬盘的平均寻道时间一般为 8~10 ms。</li><li>旋转延迟：到了特定的磁道之后，硬盘盘片需要旋转，以便要读写的扇区能够和磁头吻合。7200 转的硬盘，旋转一周的时间为 1000/120=8.33 毫秒，平均旋转延时则为 4.17 毫秒左右。</li><li>数据传输：磁头定位到需要读取的扇区之后，开始传输数据。假设硬盘顺序读取的平均速度为 150MB/s，则读取 4KB 的数据需要 <code>4KB*1000/(150*1024KB)=0.026</code> 毫秒，此值几乎可以忽略不计。读取 1MB 的数据需要 <code>1MB*1000/(150MB)=6.67</code> 毫秒，可见读取大块数据时，其真正用来读取数据的时间一般也小于寻道时间和旋转延时的和。</li></ol><p>上面三个步骤所耗费的时间，也就是数据读取的时间。</p><p>那么该如何选择磁盘呢？我们应该从如下几个方面来考虑：</p><ol><li>单盘容量尽量大。</li><li>数据传输速度尽量快，这个取决于磁盘主轴转动速度，以及数据存储在磁盘表面的密度，一般来说，这个并不会成为我们的瓶颈。</li><li>访问时间尽量够快。</li><li>主轴转速尽量快，根据上面的介绍，磁盘的转速会影响到数据的访问时间和读取时间。</li><li>还有一个就是磁盘的物理尺寸。这个也好理解，磁盘越小，数据读取速度肯定越快。不过一般来说，磁盘越小，意味着存储空间可能也会变小，这就和第一点相悖了，在实际选择中需要权衡。</li></ol><h2 id="2-RAID"><a href="#2-RAID" class="headerlink" title="2.RAID"></a>2.RAID</h2><p>独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），以前也叫廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。RAID 利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或实现数据冗余，或是两者同时提升。</p><p>在具体运行中，RAID 层级不同，资料也会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID0、RAID1、RAID5、RAID6、RAID7、RAID01、RAID10、RAID50、RAID60，每种层级都有其理论上的优缺点，不同的层级在数据冗余和性能提升两个目标间获取平衡。</p><p>简单来说，RAID 把多个硬盘组合成为一个逻辑硬盘，因此，操作系统只会把它当作一个实体硬盘。RAID 常被用在服务器电脑上，并且常使用完全相同的硬盘作为组合，由于硬盘价格的不断下降同时 RAID 功能更加有效地与主板集成，这使得 RAID 成为普通用户的一个选择，特别是需要大容量存储空间的工作使用 RAID 就特别合适，如：视频与音频制作。</p><p>我们来看看几个常见的 RAID 层级：</p><p><strong>RAID0</strong></p><p>RAID0 亦称为数据条带，它将两个以上的磁盘并联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID0 的速度是最快的（想当于可以同时读取两个磁盘）。但是 RAID0 既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失，RAID0 也是实现成本最低的 RAID 模式。在一些不担心数据丢失的场景下（例如数据备份），可以使用 RAID0。</p><p><strong>RAID1</strong></p><p>两组以上的 N 个磁盘相互作镜像，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，与 RAID 0 相同，另外写入速度有微小的降低（因为要写到两个磁盘上去）。RAID1 只要一个磁盘正常即可维持运作，可靠性最高。</p><p>其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据，当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以 RAID 1 的数据安全性在所有的 RAID 级别上来说是最好的。但无论用多少磁盘做 RAID 1，仅算一个磁盘的容量，所以它又是所有 RAID 中磁盘利用率最低的一个级别。RAID 1 可以在不影响性能的前提下，最大限度保证系统的可靠性和可修复性。</p><p>如果用两个不同大小的磁盘建 RAID 1，可用空间为较小的那个磁盘，较大的磁盘多出来的空间也可以分割成一个区来使用，不会造成浪费。</p><p><strong>RAID5</strong></p><p>RAID5 也称之为分布式奇偶校验磁盘阵列，这种方式通过分布式奇偶校验块把数据分散到多个磁盘上，这样如果任何一个盘数据丢失，都可以从奇偶数据校验块中重建。但是如果是两个盘的数据丢失，则整个数据卷就无法恢复了。</p><p><strong>RAID10</strong></p><p>RAID 10 是先分割数据再镜像。首先将所有硬盘分为两组，先对磁盘做 RAID1，然后再对两组 RAID1 的磁盘做 RAID 0，所以它的读写性能都比较好。</p><p>RAID 01 则是跟 RAID 10 的程序相反，先对磁盘做 RAID0，再做 RAID 1。</p><p>当 RAID 10 有一个硬盘受损，其余硬盘会继续运作，而 RAID 01 只要有一个硬盘受损，同组 RAID 0 的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。因此，RAID 10 比 RAID 01 常用，零售主板绝大部分支持 RAID 0/1/5/10，但不支持 RAID 01。</p><p>那么选哪种呢？下面这张表比较了不同 RAID 层级各自的特点：</p><p><img src="http://img.itboyhub.com/2021/02/20210629230700.png" alt></p><h2 id="3-固态硬盘"><a href="#3-固态硬盘" class="headerlink" title="3.固态硬盘"></a>3.固态硬盘</h2><p>固态硬盘不需要多说，相比于传统的机械硬盘有如下三个优势：</p><ol><li>没有机械结构，不怕震动（震动有可能让磁头撞到碟片上划花碟片导致损坏）。</li><li>没有寻道过程，因此读写文件的延迟更低。</li><li>连续读写文件的速度一般比机械硬盘快。</li></ol><p>目前SSD的主流接口分为，SATA 3.0、M.2、PCI-E 三种，U.2 和 mSATA 目前并不多见。</p><p>SATA 和 M.2 或 PCI-E 的主要区别在于二者采用不同的通道：PCI-E 通道的汽车就像是在高速上行驶，而 SATA 通道的汽车就像是在崎岖山路上行驶，你说哪个速度快？</p><p>下面这张表格描述了不同接口的传输速率：</p><p><img src="http://img.itboyhub.com/2021/02/20210630154605.png" alt></p><p>相比于机械硬盘，固态硬盘具有更好的随机读写功能，顺序读写其实机械硬盘也不差，但是随机读写就会差很多，而数据库操作中，随机读写又很重要，所以固态硬盘的优势明显。</p><h2 id="4-网络存储"><a href="#4-网络存储" class="headerlink" title="4.网络存储"></a>4.网络存储</h2><p>网络存储其实不太适合存储数据库文件，光是网络延迟就够令人崩溃了。不过如果想存放数据库备份文件，倒是可以用网络存储。另外就是需要注意数据库服务器的带宽要够用，别上面的东西整了一大堆，最后服务器带宽 128KB。。。</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/19592076" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19592076</a></li><li><a href="https://ssd.zol.com.cn/676/6766649_all.html" target="_blank" rel="noopener">https://ssd.zol.com.cn/676/6766649_all.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥和大家聊了 CPU 和内存对于数据库性能的影响，但是大家想想，无论如何，数据最终都是要存入硬盘中的，所以硬盘肯定也会影响到数据库的性能，那么硬盘到底是如何影响数据库性能的，今天我们就来简单聊聊。&lt;/p&gt;
&lt;p&gt;硬盘的使用，有四个不同的方向：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统的机械硬盘。&lt;/li&gt;
&lt;li&gt;使用 RAID 增强机械硬盘性能。&lt;/li&gt;
&lt;li&gt;使用固态存储 SSD。&lt;/li&gt;
&lt;li&gt;使用网络存储 NAS 和 SAN。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们就针对这四个方向逐一进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CPU 以及内存从哪些方面影响 MySQL 性能？</title>
    <link href="http://www.javaboy.org/2021/0630/mysql-cpu-memory.html"/>
    <id>http://www.javaboy.org/2021/0630/mysql-cpu-memory.html</id>
    <published>2021-06-30T13:50:06.000Z</published>
    <updated>2021-07-28T14:04:54.740Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>影响 MySQL 性能的因素很多，今天咱们来看看 CPU 和内存是如何影响 MySQL 性能的，以及我们在购买服务器的时候，该如何挑选这些配置。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>在挑选数据库服务器的时候，是买多核 CPU 还是高主频 CPU？相信有小伙伴可能遇到过类似的问题，作为开发工程师，公司负责采购的小伙伴可能会向我们抛出上面这个问题，那么该如何回答呢？</p><a id="more"></a><p>有人说我既要多核又要高主频，抱歉，很多时候公司的预算都是有限的，没法做到鱼与熊掌兼得。这个时候我们就需要了解一点 MySQL 的运行机制了，根据 MySQL 的运行机制来确定到底该选什么样的 CPU！</p><p>首先我们要看我们的应用是不是 CPU 密集型，即是不是计算密集型。如果是 CPU 密集型应用，那么我们要加快 SQL 语句的处理速度，这个时候 CPU 的频率显然就比核数重要了。另外，MySQL 不支持多 CPU 对同一 SQL 并发处理，也就是说，不管 CPU 多强或多弱，我们只能用一个 CPU 核心来处理这一条 SQL，多个 CPU 对提高一个 SQL 的处理效率是没有帮助的。</p><p>如果我们要提高系统的并发量，这个时候就要考虑 CPU 的核数问题了。多个 CPU 虽然无法提高一条 SQL 的执行效率，但是可以提高 SQL 的并发量，在同一时间，一个 CPU 可以处理一条 SQL，那么要是有 10 个 CPU 就可以同时处理 10 条 SQL，这样就可以有效提高 QPS。</p><p>现在小伙伴们出去找工作，很多互联网公司都是用的 MySQL，这种互联网应用最大的特征就是高并发，那么毫无疑问，对于这种应用，我们应该考虑多核 CPU。</p><p>老版本的 MySQL 对于多核 CPU 的支持并不完美，所以如果我们选择多核 CPU，应该考虑使用目前最新版的 MySQL，最新版的 MySQL 对多核 CPU 的支持更加流畅。</p><p>另外大家还需要注意不要在 64 位的 CPU 上运行 32 位的服务器。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存的磁盘 IO 肯定是大于硬盘的，所以如果能将数据缓存在内存中，这样就不用每次去硬盘中读取数据了，这样的话，数据库的效率必然还要再提升一个台阶。</p><p>内存对数据库性能的影响有两方面：</p><ol><li>读取效率，从内存中读取数据肯定比从硬盘中读取数据要快。</li><li>写入效率，当内存比较大的时候，我们需要往硬盘中写数据的时候，就不用每次都写，可以先缓存着，攒够了再一次性写入（延缓写入）。</li></ol><p>不过我们也不能盲目的加内存，还是要在了解 MySQL 运行机制的前提下，合理加内存。</p><p>以常见的 MyISAM 和 InnoDB 存储引擎为例：</p><ul><li>MyISAM 会将索引存入缓存，而数据存储交由操作系统处理。</li><li>InnoDB 会同时在内存中缓存数据和索引，从而提高数据库的运行效率。</li></ul><p>所以，如果我们选择不同的存储引擎，对内存的要求也是不一样的。</p><p>另一方面需要注意，生产服务器的内存一般都比较大，如果服务器的内存是 128G，数据库文件只有 50G，此时发现数据库运行很慢，那么很明显，这个时候加内存肯定是无法解决问题的，还是要具体问题具体分析。</p><p>另外在选择内存时选择服务器主板支持的最大内存频率，尽量不要选择不同品牌的内存混用；如果需要多个内存条，要确保不同内存条的频率、电压、校验技术、型号等相同，同时单个内存条容量也要尽可能大（不过话说回来，如果购买云服务器，可能并不需要考虑这些）。</p><p>好啦，今天就和小伙伴们随便扯一扯，当然影响 MySQL 性能的还有其他因素，咱们后面接着聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;影响 MySQL 性能的因素很多，今天咱们来看看 CPU 和内存是如何影响 MySQL 性能的，以及我们在购买服务器的时候，该如何挑选这些配置。&lt;/p&gt;
&lt;h2 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h2&gt;&lt;p&gt;在挑选数据库服务器的时候，是买多核 CPU 还是高主频 CPU？相信有小伙伴可能遇到过类似的问题，作为开发工程师，公司负责采购的小伙伴可能会向我们抛出上面这个问题，那么该如何回答呢？&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>是什么影响了 MySQL 的性能？</title>
    <link href="http://www.javaboy.org/2021/0628/mysql-performance.html"/>
    <id>http://www.javaboy.org/2021/0628/mysql-performance.html</id>
    <published>2021-06-28T13:49:54.000Z</published>
    <updated>2021-07-28T14:04:48.691Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>松哥有两个小伙伴最近在帮人改造一个系统，对方原本的系统是一个用 Java GUI 做的桌面应用，现在要用 Spring Boot 改造成一个 Web 应用。原本的应用在 Mac 上运行的时候非常丝滑，但是在 Windows 上运行的时候，就特别卡。经过分析之后，发现是因为数据库中数据量过大导致每一次的查询都非常缓慢。</p><a id="more"></a><p>为了解决这一问题，他们特地来咨询了松哥，我也趁此机会整理了一下数据库优化的基本操作，形成了几篇文章，接下来就和小伙伴们逐一分享。</p><p>今天我们主要来看下，到底是什么影响了数据库的性能？找到问题的原因，才能解决问题。</p><p>整体上来说，影响数据库性能的因素，我们可以归为以下几个方面：</p><ol><li>SQL 脚本</li><li>数据库服务器配置</li><li>网卡流量</li><li>磁盘 IO</li><li>大表操作</li><li>大事务操作</li><li>存储引擎</li><li>数据库参数配置</li></ol><p>接下来我们就从这几个方面来逐一进行说明。</p><h2 id="1-SQL-脚本"><a href="#1-SQL-脚本" class="headerlink" title="1. SQL 脚本"></a>1. SQL 脚本</h2><p>SQL 脚本会影响到 MySQL 的执行效率，这个大家都懂，面试八股文中常见问题之一。其实也不是面试官故意爱考这个问题，只是这个东西太重要了，根据松哥的经验，80% 的数据库问题，都是由慢 SQL 导致的，都可以通过 SQL 优化来解决，所以 SQL 优化技能对于开发者而言就非常重要了（有条件的公司也可以聘请 DBA，但是大部分公司是没有 DBA 的），这也是为什么我们在面试时经常会遇到 SQL 优化的原因。</p><p>那么慢 SQL 究竟会带来哪些风险呢？</p><p><strong>超高的 QPS 和 TPS</strong></p><p>可能有人还不清楚什么是 QPS 和 TPS，因此我们这里先对这两个做一个简单介绍。</p><ul><li>TPS：英文全称是 Transactions Per Second，即服务器每秒处理的事务数。TPS 包括一条消息入和一条消息出，加上一次用户数据库访问。这里涉及到一个概念，就是事务。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</li><li>QPS：英文全称是 Queries Per Second，即每秒查询率。QPS 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。举个例子：假设数据库处理一条 SQL 需要 10ms，那么 1s 就可以处理 100 条 SQL，那么我们说它 <code>QPS&lt;=100</code>；假设数据库处理一条 SQL 需要 100ms，那么 1s 就可以处理 10 条 SQL，那么我们说它 <code>QPS&lt;=10</code>。</li></ul><p>我们常用 QPS 和 TPS 来衡量 SQL 的处理效率。</p><p><strong>数据库连接被占满</strong></p><p>这个好理解，数据库的连接数必然是有限的，在 MySQL 中，我们可以通过 max_connections 来设置数据库的连接数（这个值默认是 100，生产环境下这个值可以适当调大）。慢 SQL 由于处理时间较长，因此占用数据库连接的时间也较长，在高并发环境下这样就容易导致数据库连接被占满。</p><p><strong>超高的 CPU 使用率</strong></p><p>慢 SQL 还会导致超高的 CPU 使用率，超高的 CPU 使用率会导致 CPU 资源耗尽进而出现宕机。</p><p>慢 SQL 真的危害很大！</p><h2 id="2-数据库服务器配置"><a href="#2-数据库服务器配置" class="headerlink" title="2.数据库服务器配置"></a>2.数据库服务器配置</h2><p>这个应该好理解，不需要我多说吧。</p><p>服务器的硬件如 CPU、内存、磁盘 IO 等都会影响到 MySQL 性能，操作系统也会影响到 MySQL 性能。</p><h2 id="3-网卡流量"><a href="#3-网卡流量" class="headerlink" title="3.网卡流量"></a>3.网卡流量</h2><p>网卡流量当然也会影响数据库。网卡 IO 被占满了一样也是没法操作数据库，那么如何避免这一情况呢？</p><ul><li>减少从服务器的数量，因为从服务器需要从主服务器同步数据，会占用网卡 IO（当然是在合理的范围内减少从服务器的数量）。</li><li>数据分级缓存，避免突然的缓存失效对数据库形成冲击。</li><li>避免 <code>select *</code>，不仅浪费时间，还浪费网络流量。</li><li>分离业务网络和服务器网络。</li></ul><h2 id="4-磁盘-IO"><a href="#4-磁盘-IO" class="headerlink" title="4.磁盘 IO"></a>4.磁盘 IO</h2><p>磁盘 IO 对数据库性能的影响也是显而易见的，因为数据库无论怎么管理数据，最终都是要存入到硬盘中的，所以磁盘 IO 对数据库的影响也就非常重要了。但是这个问题的解决，就只能使用更好更快的磁盘设备，例如 SSD。</p><p>另外，我们日常可能都会有一些定时的磁盘维护计划，在一些高并发场景下（如促销、618，双11等），我们就需要调整磁盘维护计划，避免在这些时候进行磁盘维护。同时一些大量消耗磁盘 IO 的工作如备份也需要在这个时候调整一下，例如原本在主库上做的数据备份工作，在大促期间可以放到从库上面做。</p><h2 id="5-大表操作"><a href="#5-大表操作" class="headerlink" title="5.大表操作"></a>5.大表操作</h2><p>大表操作也会影响到数据库性能，那么什么样的表就算大表呢？</p><p>大表没有统一的标准，还是要结合具体的业务场景来定。</p><p>我举一个比较常规的例子：</p><ul><li>数据表中的行数超过千万行。</li><li>数据表文件超过 10G。</li></ul><p>当然，上面这个定义并不是绝对的，如果是一个操作日志表，日志表一般只会涉及到插入和简单的查询，基本上不会有 delete 和 update，那么对于这种表，即使超过了千万行，也并不会影响我们的业务。但是如果是订单表等业务表，超过千万行就要小心了。</p><p>大表究竟会带来哪些问题呢？</p><ol><li>慢查询：毕竟数据量大了，想要过滤出自己想要的数据，肯定费时间。从上千万上亿条数据中找出自己想要的数据，也会产生大量的磁盘 IO。</li><li>DDL 操作恐怖：在大表上进行表定义操作也是一件非常恐怖的事情，例如建立索引、添加/删除 字段，想想都可怕。在 MySQL5.5（不含） 之前，建立索引是会锁表的，从 MySQL5.5（含） 开始，建立索引虽然不会锁表，但是会引起主从延迟（因为要在主库上操作完成之后，再将操作日志传到从库，然后完成同步）。</li></ol><p>这就是大表所带来的问题，一般来说，我们有两种常见的解决思路：</p><ul><li>分库分表</li><li>历史数据归档</li></ul><p>至于什么时候用分库分表，什么时候用历史数据归档，这个松哥在以后的文章中再和大家介绍。</p><h2 id="6-大事务操作"><a href="#6-大事务操作" class="headerlink" title="6.大事务操作"></a>6.大事务操作</h2><p>一些运行时间比较长，涉及到数据比较多的事务，我们可以称之为大事务。大事务会锁定很多条数据进行处理，这样就容易造成大量的阻塞和锁超时，并且一旦出错发生回滚，回滚所需要的时间也会比较长，而且在回滚期间数据依然处于被锁的状态。</p><p>同时，由于大事务耗时较长，需要等到主库事务执行完毕后，将操作日志写入 binlog，然后从库读取 binlog 进行同步，这样势必会导致主从延迟。</p><p>解决大事务，两个思路：</p><ol><li>避免一次性处理太多数据。</li><li>移除事务中不必要的 SELECT 操作。</li></ol><p>具体的操作方式，我们将在以后的文章中介绍。</p><h2 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7.存储引擎"></a>7.存储引擎</h2><p>使用 MySQL 我们可以选择不同的存储引擎，不同的存储引擎特点不同，最终对数据库的影响也不同。例如 MySQL 中常见的 MyISAM、InnoDB 等存储引擎。</p><p>MyISAM 不支持事务，而且是表级锁；InnoDB 是事务级存储引擎，支持行级锁，也支持事务的 ACID 特性。</p><p>那么是不是说 InnoDB 就一定比 MyISAM 好呢？也不一定！这个还是要看具体的使用场景。</p><h2 id="8-数据库参数配置"><a href="#8-数据库参数配置" class="headerlink" title="8.数据库参数配置"></a>8.数据库参数配置</h2><p>大家都知道数据库有很多配置参数，我们在数据库优化时可对其进行配置，例如前面所说的 max_connections。这些参数中，有的参数对数据库的性能影响较大，有的则影响较小，这个我们在以后的文章中再和大家详细讨论。</p><p>好啦，今天主要和小伙伴们探讨了在我们日常开发中，到底有哪些东西会影响数据库的性能！至于具体的解决方案，松哥将在接下来的文章中和大家细聊。</p><p>虽然我们不是专业的 DBA，但是从小伙伴们的面试经历来看，数据库优化显然也不能一窍不通。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;松哥有两个小伙伴最近在帮人改造一个系统，对方原本的系统是一个用 Java GUI 做的桌面应用，现在要用 Spring Boot 改造成一个 Web 应用。原本的应用在 Mac 上运行的时候非常丝滑，但是在 Windows 上运行的时候，就特别卡。经过分析之后，发现是因为数据库中数据量过大导致每一次的查询都非常缓慢。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 和 Spring Security 会碰出哪些火花？</title>
    <link href="http://www.javaboy.org/2021/0625/webflux-spring-security.html"/>
    <id>http://www.javaboy.org/2021/0625/webflux-spring-security.html</id>
    <published>2021-06-25T13:49:24.000Z</published>
    <updated>2021-07-28T14:04:43.143Z</updated>
    
    <content type="html"><![CDATA[<p>WebFlux 系列松哥已经连着写了十几篇了，Spring Security 系列之前更是发了 68 篇（公号后台回复 ss 获取系列教程），不过之前这两个教程都是分开讲的，还没有把这两个融合到一起讲过。</p><p>随着 WebFlux 的发展，我们有必要来了解下在响应式编程中如何使用 Spring Security。今天松哥就通过一个简单的案例来和大家分享下如何在 WebFlux 中使用 Spring Security。</p><a id="more"></a><h2 id="1-基于内存的使用"><a href="#1-基于内存的使用" class="headerlink" title="1.基于内存的使用"></a>1.基于内存的使用</h2><p>先来看一个简单的，就是把用户信息保存在内存中。</p><p>首先我们来创建一个新的项目，引入 WebFlux 和 Spring Security 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210617214400.png" alt></p><p>项目创建成功后，我们添加一个接口，用来获取登录用户信息，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Principal&gt; <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(Mono&lt;Principal&gt; principal)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们的返回值是 <code>Mono&lt;Principal&gt;</code>，接口的参数也是支持 <code>Mono&lt;Principal&gt;</code> 的。</p><p>这就可以了，接下来我们启动项目，在启动的过程中，控制台就会打印出默认的用户密码，拿着默认的用户密码以及默认用户名 user 去登录，登录完成后就可以访问 <code>/user</code> 接口了，这个过程和普通的 Spring Security 用法并没有什么差异，所以我就不多说了，如果大家对普通的 Spring Security 用法还不熟悉，也可以看看松哥的新书《深入浅出 Spring Security》。</p><p>如果我们想配置基于内存的用户信息，该怎么配置呢？添加如下配置类即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">MapReactiveUserDetailsService <span class="hljs-title">mapReactiveUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        UserDetails ud1 = User.withUsername(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"&#123;noop&#125;123"</span>)</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        UserDetails ud2 = User.withUsername(<span class="hljs-string">"zhangsan"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"&#123;noop&#125;123"</span>)</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MapReactiveUserDetailsService(ud1, ud2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要提供一个 MapReactiveUserDetailsService 实例即可。</p><p>MapReactiveUserDetailsService 实现了 ReactiveUserDetailsService 接口，ReactiveUserDetailsService 接口其实就跟我们以前的 UserDetailsService 接口的作用差不多；而 MapReactiveUserDetailsService 则类似于我们以前的 InMemoryUserDetailsManager，都是基于内存来管理用户的，理解了这一层，剩下的东西就好懂了。</p><p>我们在 MapReactiveUserDetailsService 中提供两个用户对象即可。</p><p>最后启动项目，此时 IDEA 控制台就不会输出默认生成的密码了，这个时候我们就可以直接使用 admin/123 或者 user/123 来进行登录了。</p><h2 id="2-基于数据库的使用"><a href="#2-基于数据库的使用" class="headerlink" title="2.基于数据库的使用"></a>2.基于数据库的使用</h2><p>第一小节我们是在内存中配置用户，真正到了开发中我们还是需要从数据库中读取用户数据，所以接下来我们再来看一个基于数据库的配置。</p><p>首先我们先来大概看一眼数据库：</p><p><img src="http://img.itboyhub.com/2021/02/20210617220715.png" alt></p><p>首先我们创建项目，这个时候要添加的依赖就比较多，除了 WebFlux 和 Spring Security 之外，还有 R2DBC 以及 MySQL 驱动，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210617220537.png" alt></p><p>项目创建成功之后，在 application.properties 中配置数据库基本信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.r2dbc.url=r2dbcs:mysql://localhost:3306/test01</span><br><span class="line">spring.r2dbc.username=root</span><br><span class="line">spring.r2dbc.password=123</span><br></pre></td></tr></table></figure><p>如此之后，我们的准备工作就算完成了。</p><p>接下来我们创建 User 的实体类，老规矩，User 类需要实现 UserDetails 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建 UserRepository：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveCrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">Mono&lt;UserDetails&gt; <span class="hljs-title">findUserByUsername</span><span class="hljs-params">(@Param(<span class="hljs-string">"username"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了一个 findUserByUsername 方法，用来根据用户名查找用户对象。</p><p>接下来定义 UserService，这次需要我们自己实现 ReactiveUserDetailsService 接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReactiveUserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;UserDetails&gt; <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userRepository.findUserByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService 实现了 ReactiveUserDetailsService 接口，并重写了 findByUsername 方法，这个类似于我们之前重写 UserDetailsService#loadUserByUsername 方法。</p><p>这里记得将 UserService 注册到 Spring 容器中，接下来就不需要额外的工作了。</p><p>配置完成了。</p><p>接下来我们启动项目，此时就可以通过数据库中的用户进行登录了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天就通过两个简单的小案例，带领小伙伴们体验下 WebFlux+Spring Security 的用法，当然这里还有很多使用细节，在接下来的文章中松哥再和大家一一介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebFlux 系列松哥已经连着写了十几篇了，Spring Security 系列之前更是发了 68 篇（公号后台回复 ss 获取系列教程），不过之前这两个教程都是分开讲的，还没有把这两个融合到一起讲过。&lt;/p&gt;
&lt;p&gt;随着 WebFlux 的发展，我们有必要来了解下在响应式编程中如何使用 Spring Security。今天松哥就通过一个简单的案例来和大家分享下如何在 WebFlux 中使用 Spring Security。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 操作 MySQL 是种什么体验？</title>
    <link href="http://www.javaboy.org/2021/0622/webflux-mysql.html"/>
    <id>http://www.javaboy.org/2021/0622/webflux-mysql.html</id>
    <published>2021-06-22T13:47:37.000Z</published>
    <updated>2021-07-28T14:04:35.762Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉中，我们的 WebFlux 系列已经整到第 11 篇啦。如果小伙伴们还没看过前面的文章，记得先看一下哦，这有助于理解本文。</p><ol><li><a href="https://mp.weixin.qq.com/s/zJgB5_pRvj2Al1zaK51c1g" target="_blank" rel="noopener">挖一个大坑，WebFlux 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a></li><li><a href="https://mp.weixin.qq.com/s/QZYcQFJDxTw0V-E0DTNOIw" target="_blank" rel="noopener">WebFlux 前置知识（二）</a></li><li><a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a></li><li><a href="https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA" target="_blank" rel="noopener">WebFlux 前置知识（四）</a></li><li><a href="https://mp.weixin.qq.com/s/zgrPg9DM9OkPMs8XI-PiMA" target="_blank" rel="noopener">异步 Servlet 都不懂，谈何 WebFlux？</a></li><li><a href="https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw" target="_blank" rel="noopener">WebFlux 初体验</a></li><li><a href="https://mp.weixin.qq.com/s/HzZ-Q01dwJzSZTKzyAQfdg" target="_blank" rel="noopener">服务端主动推送数据，除了 WebSocket 你还能想到啥？</a></li><li><a href="https://mp.weixin.qq.com/s/KUDS8ss6BRIkMW_wjCe_Yg" target="_blank" rel="noopener">用 WebFlux 写个 CURD 是什么体验？</a></li><li><a href="https://mp.weixin.qq.com/s/-26PoTL2KPXmzz6NG8EhuQ" target="_blank" rel="noopener">WebFlux 中的请求地址路由怎么玩？</a></li></ol><p>好啦，开始今天的正文。</p><a id="more"></a><p>前面我们用 WebFlux 已经写了一个 CURD 了，不过数据库用的是 MongoDB。很多人对 WebFlux 持怀疑态度，包括松哥之前发文章的时候，还有人在说不能连接 MySQL 的 WebFlux 是没有任何意义的！这句话没错，但是我们也要看到 WebFlux 正处于一个高速发展的时期，所有不可能的事情都会变得可能，所有以前没有的功能以后都会有，WebFlux 的变化速度是肉眼可见的。</p><p>比如我们今天要介绍的 R2DBC 就能在一定程度上打消一些人的疑虑，虽然这个工具还不是特别完美，但是我们看到了 WebFlux 在努力解决这些存在的问题，我们也有理由相信 WebFlux 未来会越来越好。</p><p>好啦，不吹了，还是来看点实际的东西吧。</p><h2 id="1-什么是-R2DBC？"><a href="#1-什么是-R2DBC？" class="headerlink" title="1.什么是 R2DBC？"></a>1.什么是 R2DBC？</h2><p>首先大家要知道，我们最常使用的 JDBC 其实是同步的，而我们使用 WebFlux 的目的是为了通过异步的方式来提高服务端的响应效率，WebFlux 虽然实现了异步，但是由于 JDBC 还是同步的，而大部分应用都是离不开数据库的，所以其实效率本质上还是没有提升。</p><p>那么怎么办呢？有没有异步的 JDBC 呢？有！</p><p>目前市面上异步 JDBC 主要是两种：</p><ul><li>ADAB：ADBA 是 Oracle 主导的 Java 异步数据库访问的标准 API，它将会集成于未来的 Java 标准发行版中。但是目前发展比较慢，只提供 OpenJDK 的沙盒特性供开发者研究之用。</li><li>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，不过现在 MySQL 也加入进来了，这是一个极大的利好。目前 R2DBC 的最新版本是 0.9.0.RELEASE。</li></ul><p><strong>需要注意的是，这两个都不是对原来 JDBC 的补充，都是打算重新去设计数据库访问方案！</strong></p><p>好了，现在大家对 R2DBC 有一个基本的认知了，接下来我们就通过一个简单的例子，我们一起来体验一把如何通过 R2DBC 来操作 MySQL 数据库。</p><h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2.代码实践"></a>2.代码实践</h2><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>首先我们来创建一个 Spring Boot 项目，引入 WebFlux 和 R2DBC 依赖，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210610205244.png" alt></p><p>项目创建成功后，pom.xml 文件中会自动加入 R2DBC 相关的依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-r2dbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>dev.miku<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>r2dbc-mysql<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们在 application.properties 中配置数据库的连接信息，注意这次的配置和之前的有些不同：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.r2dbc.url=r2dbcs:mysql://localhost:3306/test01</span><br><span class="line">spring.r2dbc.username=root</span><br><span class="line">spring.r2dbc.password=123</span><br></pre></td></tr></table></figure><p>配置文件除了属性的 key 不同之外，数据库的连接协议也从 jdbc 变为 r2dbc 了。</p><p>OK，如此，我们的准备工作就算完成了。</p><h3 id="2-2-数据库脚本"><a href="#2-2-数据库脚本" class="headerlink" title="2.2 数据库脚本"></a>2.2 数据库脚本</h3><p>我们准备一个简单的数据表，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210615230234.png" alt></p><p>这个脚本很简单，应该不用我提供了吧。</p><h3 id="2-3-CURD"><a href="#2-3-CURD" class="headerlink" title="2.3 CURD"></a>2.3 CURD</h3><p>我们首先来提供一个实体类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要一个 UserRepository 接口，这个接口直接继承自 ReactiveCrudRepository 即可，这跟之前 MongoDB 的玩法比较类似。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveCrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来定义 User 表的处理器，这个也跟之前 MongoDB 中的差不多，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Long.parseLong;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.notFound;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(userRepository.findAll(), User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">addUser</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(userRepository.saveAll(serverRequest.bodyToMono(User.class)), User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">deleteUser</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userRepository.findById(parseLong(serverRequest.pathVariable(<span class="hljs-string">"id"</span>)))</span><br><span class="line">                .flatMap(user -&gt; userRepository.delete(user).then(ok().build()))</span><br><span class="line">                .switchIfEmpty(notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再来配置请求地址路由，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RouterFunction&lt;ServerResponse&gt; <span class="hljs-title">userRouterFunction</span><span class="hljs-params">(UserHandler userHandler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> RouterFunctions.nest(RequestPredicates.path(<span class="hljs-string">"/user"</span>),</span><br><span class="line">                RouterFunctions.route(RequestPredicates.GET(<span class="hljs-string">"/"</span>), userHandler::getAllUsers)</span><br><span class="line">                        .andRoute(RequestPredicates.POST(<span class="hljs-string">"/"</span>), userHandler::addUser)</span><br><span class="line">                        .andRoute(RequestPredicates.DELETE(<span class="hljs-string">"/&#123;id&#125;"</span>), userHandler::deleteUser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块其实都没啥好说的，如果大家感到困惑，可以参考我们前两篇文章中的讲解。</p><ul><li><a href>用 WebFlux 写个 CURD 是什么体验？</a></li><li><a href>WebFlux 中的请求地址路由怎么玩？</a></li></ul><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>最后我们来简单测试下。</p><p><strong>查询：</strong></p><p><img src="http://img.itboyhub.com/2021/02/20210615231525.png" alt></p><p><strong>添加：</strong></p><p><img src="http://img.itboyhub.com/2021/02/20210615231619.png" alt></p><p><strong>更新：</strong></p><p><img src="http://img.itboyhub.com/2021/02/20210615231715.png" alt></p><p>有 id 并且 id 已经存在，默认就是更新。</p><p><strong>删除：</strong></p><p>删除成功响应 200：</p><p><img src="http://img.itboyhub.com/2021/02/20210615231814.png" alt="删除成功响应 200"></p><p>删除失败响应 404：</p><p><img src="http://img.itboyhub.com/2021/02/20210615231925.png" alt="删除失败响应 404"></p><p>好啦，这就是一个简单的 WebFlux 操作关系型数据库的案例，关于 WebFlux 的更多其他用法，跟随松哥一起来慢慢解剖吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉中，我们的 WebFlux 系列已经整到第 11 篇啦。如果小伙伴们还没看过前面的文章，记得先看一下哦，这有助于理解本文。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/zJgB5_pRvj2Al1zaK51c1g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;挖一个大坑，WebFlux 开搞！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 前置知识（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QZYcQFJDxTw0V-E0DTNOIw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 前置知识（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 前置知识（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 前置知识（四）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/zgrPg9DM9OkPMs8XI-PiMA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;异步 Servlet 都不懂，谈何 WebFlux？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HzZ-Q01dwJzSZTKzyAQfdg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;服务端主动推送数据，除了 WebSocket 你还能想到啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KUDS8ss6BRIkMW_wjCe_Yg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用 WebFlux 写个 CURD 是什么体验？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-26PoTL2KPXmzz6NG8EhuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebFlux 中的请求地址路由怎么玩？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好啦，开始今天的正文。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 中的请求地址路由怎么玩？</title>
    <link href="http://www.javaboy.org/2021/0618/webflux-router-function.html"/>
    <id>http://www.javaboy.org/2021/0618/webflux-router-function.html</id>
    <published>2021-06-18T13:32:16.000Z</published>
    <updated>2021-06-21T13:41:19.580Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在 SpringMVC 中，我们可以通过如下一些注解来控制请求 URL 和处理器之间的映射关系：</p><a id="more"></a><ul><li>@RequestMapping</li><li>@GetMapping</li><li>@PostMapping</li><li>@DeleteMapping</li><li>@PutMapping</li></ul><p>这些注解我们在 WebFlux 中依然还可以继续使用，不过 WebFlux 也提供了自己的方案–Router。</p><p>今天我们就一起来学习下 Router 的用法。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>首先我们还是先来新建一个 WebFlux 项目，选择的依赖也和之前的一样，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210607190224.png" alt></p><p>这里我们还是基于 MongoDB 来做。</p><p>创建完成后，在 application.properties 中配置一下 MongoDB，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.port=27017</span><br><span class="line">spring.data.mongodb.host=127.0.0.1</span><br><span class="line">spring.data.mongodb.username=madmin</span><br><span class="line">spring.data.mongodb.password=m123</span><br><span class="line">spring.data.mongodb.database=test</span><br><span class="line">spring.data.mongodb.authentication-database=admin</span><br></pre></td></tr></table></figure><p>如此，我们的准备工作就算完成了。</p><h2 id="2-MongoDB-的准备工作"><a href="#2-MongoDB-的准备工作" class="headerlink" title="2.MongoDB 的准备工作"></a>2.MongoDB 的准备工作</h2><p>接下来我们再为 MongoDB 的使用做一些准备工作。</p><p>首先我们需要一个实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Document</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要一个 Repository，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonRepository</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">Person</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 PersonRepository 的内容很简单，就继承自 ReactiveMongoRepository 即可，和上篇文章中介绍的也基本一致，松哥不再赘述。</p><h2 id="3-开发处理器"><a href="#3-开发处理器" class="headerlink" title="3.开发处理器"></a>3.开发处理器</h2><p>接下来我们来开个一个 Person 的处理器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">addPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.saveAll(serverRequest.bodyToMono(Person.class)), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">deletePerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> personRepository.findById(Long.parseLong(serverRequest.pathVariable(<span class="hljs-string">"id"</span>)))</span><br><span class="line">                .flatMap(p -&gt; personRepository.delete(p).then(ServerResponse.ok().build()))</span><br><span class="line">                .switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">getAllPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.findAll(), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个处理器，松哥有话说：</p><ol><li>首先这个处理器我们需要将其注入到 Spring 容器中，注入时作为一个普通组件注入即可。</li><li>所有方法的返回值类型都是 <code>Mono&lt;ServerResponse&gt;</code>，参数类型都是 ServerRequest，因为一会配置 Router 时涉及到的 HandlerFunction 里边就是这样定义的，换句话说，我们这里定义的每一个方法都满足 HandlerFunction 函数式接口。</li><li>addPerson 方法中，首先调用 ServerResponse.ok() 方法设置响应状态码为 200，然后调用 contentType 设置响应的 MediaType，最后调用 body 方法设置响应内容。</li><li>deletePerson 中，先查询要删除的数据，然后再删除即可。</li></ol><p>上面的写法有点臃肿，一些静态方法我们可以直接使用静态导入，这样代码看起来更清爽一些，修改后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Long.parseLong;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.notFound;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">addPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.saveAll(serverRequest.bodyToMono(Person.class)), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">deletePerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> personRepository.findById(parseLong(serverRequest.pathVariable(<span class="hljs-string">"id"</span>)))</span><br><span class="line">                .flatMap(p -&gt; personRepository.delete(p).then(ok().build()))</span><br><span class="line">                .switchIfEmpty(notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">getAllPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.findAll(), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码看起来简洁一些了，上面多了一些静态导入。我们在网上看别人写的响应式代码，大部分也都是上来就 <code>ok()...</code>。</p><h2 id="4-配置路由"><a href="#4-配置路由" class="headerlink" title="4.配置路由"></a>4.配置路由</h2><p>接下来我们来配置路由，就是将请求的 URL 地址和这些处理器之间关联起来，配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RouterFunction&lt;ServerResponse&gt; <span class="hljs-title">personRouter</span><span class="hljs-params">(PersonHandler personHandler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> RouterFunctions</span><br><span class="line">                .nest(RequestPredicates.path(<span class="hljs-string">"/person"</span>), </span><br><span class="line">                        RouterFunctions.route(RequestPredicates.POST(<span class="hljs-string">"/"</span>), personHandler::addPerson)</span><br><span class="line">                                .andRoute(RequestPredicates.GET(<span class="hljs-string">"/"</span>), personHandler::getAllPerson)</span><br><span class="line">                                .andRoute(RequestPredicates.DELETE(<span class="hljs-string">"/&#123;id&#125;"</span>), personHandler::deletePerson));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类是这样：</p><ol><li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理（如果 DispatcherServlet 不熟悉的话，可以在公众号后台回复 <code>springmvc源码</code> 查看松哥之前关于 SpringMVC 源码分析的系列文章）。</li><li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li><li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li><li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li><li>通过 addRoute 方法可以配置多个路由策略。</li></ol><p>OK，如此，我们的配置工作就算完成了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们来进行简单的测试。</p><p>我们一共有三个接口可以测试，先来看添加数据：</p><p><img src="http://img.itboyhub.com/2021/02/20210609214828.png" alt></p><p>这个添加接口其实也可以实现修改，如果添加的数据已经存在就会自动修改，不存在就添加（根据 id 判断数据是否存在）。</p><p>再来看删除数据：</p><p>如果删除的数据不存在，就会响应 404，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210609214937.png" alt></p><p>如果删除的数据存在，则会响应 200:</p><p><img src="http://img.itboyhub.com/2021/02/20210609215030.png" alt></p><p>最后再来看查询的接口：</p><p><img src="http://img.itboyhub.com/2021/02/20210609215058.png" alt></p><p>如此，我们的 CURD 都 OK 啦。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天通过一篇简单的文章和大家分享了 WebFlux 中的 RouterFunction，不知道小伙伴们学废没？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在 SpringMVC 中，我们可以通过如下一些注解来控制请求 URL 和处理器之间的映射关系：&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>用 WebFlux 写个 CURD 是什么体验？</title>
    <link href="http://www.javaboy.org/2021/0617/webflux-crud.html"/>
    <id>http://www.javaboy.org/2021/0617/webflux-crud.html</id>
    <published>2021-06-17T13:32:03.000Z</published>
    <updated>2021-06-21T13:41:01.471Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们继续来搞 WebFlux！</p><a id="more"></a><p>WebFlux 最为人所诟病的是数据库的支持问题，毕竟数据是一个应用的生命，我们接触的大部分应用程序都是有数据库的，而 WebFlux 在这一方面的支持行一直比较弱，这也是大家总是吐槽它的原因。</p><p>不过从 Spring5 开始，这一问题得到了一定程度的缓解。</p><p>Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，不过现在 MySQL 也加入进来了，这是一个极大的利好。目前 R2DBC 的最新版本是 0.9.0.RELEASE。</p><p>松哥在接下来的文章中将会和大家演示 R2DBC 的用法，但是今天我们还是先来看看 WebFlux+MongoDB 的用法，毕竟这是 WebFlux 较早支持的数据库之一，各种 API 都比较成熟，我们一步一步来。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>方便起见，我们这里就直接创建 Spring Boot 项目，首先创建一个 Spring Boot 项目，引入 MongoDB 依赖和 WebFlux 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210607190224.png" alt></p><p>注意我们这里选择的 MongoDB 依赖是 Spring Data Reactive MongoDB，千万别选错了。</p><p>项目创建完成后，我们先在 application.properties 中对 MongoDB 进行简单配置，如下（如果小伙伴们尚不熟悉 MongoDB 的操作，可以在公众号底部菜单找到松哥原创的 MongoDB 教程）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.port=27017</span><br><span class="line">spring.data.mongodb.host=127.0.0.1</span><br><span class="line">spring.data.mongodb.username=madmin</span><br><span class="line">spring.data.mongodb.password=m123</span><br><span class="line">spring.data.mongodb.database=test</span><br><span class="line">spring.data.mongodb.authentication-database=admin</span><br></pre></td></tr></table></figure><p>多说一句，在之前的 Spring Boot 视频教程中，松哥对 MongoDB 也有过介绍，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>。</p><p>配置完 MongoDB 后，我们的准备工作就算完成了。</p><h2 id="2-实体类与-Dao"><a href="#2-实体类与-Dao" class="headerlink" title="2.实体类与 Dao"></a>2.实体类与 Dao</h2><p>接下来我们需要准备一个操作的实体类，这些都是 JPA 的基本操作，松哥就不再赘述，如果小伙伴们不熟悉的话，可以公号后台回复 666 查看原创的 Spring Boot 教程，里边有涉及到，实体类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Document</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再提供一个实体类操作的接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义一个空的接口继承自 ReactiveMongoRepository，里边什么都不用写，这套路就和松哥之前视频中介绍的 JPA 的用法如出一辙（毕竟都是 Spring Data 家族），所以这块就没啥好说的，不赘述。</p><h2 id="3-测试接口"><a href="#3-测试接口" class="headerlink" title="3.测试接口"></a>3.测试接口</h2><p>接下来我们来看看测试接口。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><p>首先我们来看看添加数据。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;User&gt; <span class="hljs-title">addUser</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成后，返回刚刚添加成功的对象。save 方法的返回值就是 Mono。</p><p>我们来看看测试效果：</p><p><img src="http://img.itboyhub.com/2021/02/20210607193023.png" alt></p><h3 id="3-2-查询"><a href="#3-2-查询" class="headerlink" title="3.2 查询"></a>3.2 查询</h3><p>再来看看查询效果：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/stream/all"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">streamGetAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供了两个查询接口，一个就是返回 Flux，里边包含多个对象，还有一个我设置了响应的 Content-Type 为 text/event-stream，通过响应式流返回数据，具体参见【<a href>服务端推送数据，除了 WebSocket 你还能想到啥？</a>】一文。</p><p>我们来看看查询效果：</p><p><img src="http://img.itboyhub.com/2021/02/20210607194429.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/20210607194357.png" alt></p><p>可以看到两种不同的查询方式返回的数据格式也有差异。前者是以数组形式一次性返回数据，后者是以 SSE 的形式多次返回数据。</p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><p>再来看看删除。</p><p>按照 RESTful 规范，如果删除成功请求响应码就是 200，如果删除失败请求响应码就是 404，因此，我们开发出来的接口如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(<span class="hljs-meta">@PathVariable</span> String id) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findById(id)</span><br><span class="line">            .flatMap(user -&gt; userDao.delete(user).then(Mono.just(<span class="hljs-keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.OK))))</span><br><span class="line">            .defaultIfEmpty(<span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从数据库中查询出相关的数据，然后调用 flatMap，在 flatMap 中对数据进行删除处理，删除完成后，给出一个 200 的响应码，如果查询的时候没有查询到数据，就给一个 404 响应码。</p><p>可以看到，删除成功后，响应码为 200：</p><p><img src="http://img.itboyhub.com/2021/02/20210607195743.png" alt></p><p>删除失败后，响应码为 404：</p><p><img src="http://img.itboyhub.com/2021/02/20210607195814.png" alt></p><h3 id="3-4-修改"><a href="#3-4-修改" class="headerlink" title="3.4 修改"></a>3.4 修改</h3><p>再来看看修改，和前面的删除类似，先查询，再修改：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; updateUser(<span class="hljs-meta">@RequestBody</span> User user) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findById(user.getId())</span><br><span class="line">            .flatMap(u -&gt; userDao.save(user))</span><br><span class="line">            .map(u-&gt;<span class="hljs-keyword">new</span> ResponseEntity&lt;User&gt;(u,HttpStatus.OK))</span><br><span class="line">            .defaultIfEmpty(<span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210607201936.png" alt></p><p>如果修改的数据不存在的话，就会给出一个 404 响应：</p><p><img src="http://img.itboyhub.com/2021/02/20210607202007.png" alt></p><h3 id="3-5-自定义查询方法"><a href="#3-5-自定义查询方法" class="headerlink" title="3.5 自定义查询方法"></a>3.5 自定义查询方法</h3><p>松哥之前的 Spring Data Jpa 中讲的一些查询 API，这里同样是适用的（公号后台回复 666 获取之前的教程）。</p><p>例如我们可以在 UserDao 中自定义一个查询方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">Flux&lt;User&gt; <span class="hljs-title">findUserByUsernameContaining</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加一个接口调用该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/byname"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">getUserByName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findUserByUsernameContaining(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样该接口就可以查询名字中包含某关键字的所有用户了。</p><p>其他关于 JPA 的用法这里都是适用的，因为在之前的文章中讲过，松哥这里就不再赘述了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天我们就用 WebFlux 写了一个简单的 CURD，大家先来感受下 WebFlux 的基本用法，后面的文章松哥将和大家分享 WebFlux 如何连接关系型数据库，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们继续来搞 WebFlux！&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>服务端主动推送数据，除了 WebSocket 你还能想到啥？</title>
    <link href="http://www.javaboy.org/2021/0611/sse.html"/>
    <id>http://www.javaboy.org/2021/0611/sse.html</id>
    <published>2021-06-11T13:31:50.000Z</published>
    <updated>2021-06-21T13:41:57.502Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在<a href="https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家分享了 WebFlux 的基本用法，小伙伴们已经了解到使用 WebFlux 我们的返回值可以是 Mono 也可以是 Flux，如果是 Flux，由于 Flux 中包含多个元素，所以我们需要设置响应的 Content-Type 为 <code>text/event-stream</code>。考虑到很多小伙伴还没用过 <code>text/event-stream</code>，所以今天松哥再撸一篇文章来和大家聊聊 <code>text/event-stream</code>。</p><a id="more"></a><h2 id="1-SSE"><a href="#1-SSE" class="headerlink" title="1.SSE"></a>1.SSE</h2><p>首先我们来看一个概念叫做 SSE。</p><p>SSE 全称是 Server-Sent Events，它的作用和 WebSocket 的作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息，不同的是，WebSocket 是一种全双工通信协议，而 SSE 则是一种单工通信协议，即使用 SSE 只能服务器向浏览器推送信息流，浏览器如果向服务器发送信息，就是一个普通的 HTTP 请求。</p><p>使用 SSE，当服务端给客户端响应的时候，他不是发送一个一次性数据包，而是会发送一个数据流，这个时候客户端的连接不会关闭，会一直等待服务端发送过来的数据流，我们常见的视频播放其实就是这样的例子。</p><p>SSE 和 WebSocket 主要有如下区别：</p><ul><li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li><li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li><li>SSE 默认支持断线重连，WebSocket 需要自己实现。</li><li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li><li>SSE 支持自定义发送的消息类型。</li></ul><p>说了这么多，可能大家还是有点懵，接下来松哥通过一个简单的例子来向大家展示 SSE 的用法。</p><h2 id="2-开发服务端"><a href="#2-开发服务端" class="headerlink" title="2.开发服务端"></a>2.开发服务端</h2><p>根据第一小节的描述，大家也能看出来，SSE 其实和框架没有关系，所以这里松哥就创建一个普通的 Java Web 项目，用最最基本的 Servlet 来向大家演示 SSE 的功能。</p><p>首先我们创建一个 SseServlet，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i+<span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往出写 10 条数据，每写一条就睡眠 1 秒钟。代码并不难，但是这里有几个细节需要注意下：</p><ol><li>响应的 Content-Type 记得设置为 <code>text/event-stream</code>，这是关键。</li><li>每一次发送的信息，由若干个 message 组成，每个 message 之间用 <code>\n\n</code> 分隔，每个 message 内部由若干行组成。在上面的案例中，每一个 for 循环中就是发送一个 message。</li><li>每一行的数据格式是 ：<code>[field]: value\n</code>。field 有四种不同取值：<ul><li>data：data 用来表示数据内容，就像我们上面的例子。</li><li>id：id 相当于是每一条数据的唯一编号，浏览器用 <code>lastEventId</code> 属性读取这个值。一旦连接断线，浏览器会发送一个 <code>HTTP</code> 头，里面包含一个特殊的 <code>Last-Event-ID</code> 头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</li><li>event：<code>event</code> 字段表示自定义的事件类型，默认是 <code>message</code> 事件。</li><li>retry：服务器可以用 <code>retry</code> 字段，指定浏览器重新发起连接的时间间隔。</li></ul></li></ol><p>开发完成后，我们启动服务端访问 /sse 接口来看看效果：</p><p><img src="http://img.itboyhub.com/2021/02/6-3.gif" alt></p><p>可以看到，客户端每隔 1 秒就能收到服务端的数据。</p><h2 id="3-开发客户端"><a href="#3-开发客户端" class="headerlink" title="3.开发客户端"></a>3.开发客户端</h2><p>前面是一个服务端的案例，接下来我们来看看客户端的案例，新建一个 html 页面，添加如下 js：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>)</span><br><span class="line">&#125;;</span><br><span class="line">es.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br><span class="line">es.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上面这段代码：</p><ol><li>首先新建一个 EventSource 对象，参数就是服务端的地址。它还有一个可选的参数，可选参数重可以描述是否将 Cookie 一起发送出去 <code>var es = new EventSource(&quot;/es&quot;, { withCredentials: true });</code>（可在跨域时使用该参数）。</li><li>当建立连接后，就会触发 <code>onopen</code> 函数，当收到服务端发送来的消息，就会触发 <code>onmessage</code> 函数，当连接出错的时候，就会触发 <code>onerror</code> 函数。</li><li><code>es.close</code> 表示关闭 SSE 连接。</li></ol><p>这三种类型的事件，我们还可以通过如下方式来定义：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.addEventListener(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"message"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果与上面的一致，我们来看看运行效果图：</p><p><img src="http://img.itboyhub.com/2021/02/6-4.gif" alt></p><p>消息接收完后，会触发 onerror 事件，此时我们可以关闭 SSE 连接，<strong>否则就会从头开始继续接收数据</strong>。</p><h2 id="4-自定义事件"><a href="#4-自定义事件" class="headerlink" title="4.自定义事件"></a>4.自定义事件</h2><p>我们也可以自定义 SSE 事件。</p><p>先来看服务端如何自定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"event:javaboy\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i + <span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在每一行消息之前添加 <code>out.write(&quot;event:javaboy\n&quot;);</code> 表示自定义事件类型，当然我们也可以添加事件 id，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"event:javaboy\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"id:"</span> + i + <span class="hljs-string">"\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i + <span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端定义完成后，接下来我们再来看看前端该如何接收数据：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.addEventListener(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"javaboy"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data, e.lastEventId, e);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时在 addEventListener 方法中，输入自定义的事件名称，然后在回调函数中处理事件。</p><p>可以通过 <code>e.lastEventId</code> 访问到消息的 id。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要通过几个简单的例子向大家展示 <code>text/event-stream</code> 以及 SSE 相关的知识点，相信大家在学完之后对 WebFlux 中返回值为 Flux 的接口会有更深的理解，读完本文，再去看昨天的文章【<a href="https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw" target="_blank" rel="noopener">WebFlux 初体验</a>】，应该会更香。</p><p>参考资料：<a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;中，松哥和大家分享了 WebFlux 的基本用法，小伙伴们已经了解到使用 WebFlux 我们的返回值可以是 Mono 也可以是 Flux，如果是 Flux，由于 Flux 中包含多个元素，所以我们需要设置响应的 Content-Type 为 &lt;code&gt;text/event-stream&lt;/code&gt;。考虑到很多小伙伴还没用过 &lt;code&gt;text/event-stream&lt;/code&gt;，所以今天松哥再撸一篇文章来和大家聊聊 &lt;code&gt;text/event-stream&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 初体验</title>
    <link href="http://www.javaboy.org/2021/0608/webflux-starter.html"/>
    <id>http://www.javaboy.org/2021/0608/webflux-starter.html</id>
    <published>2021-06-08T13:31:33.000Z</published>
    <updated>2021-06-21T13:41:51.668Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面铺垫了五篇啦，是时候请出主角了。</p><a id="more"></a><p>今天我们就先来一个简单的案例大伙体验一把 WebFlux。</p><h2 id="1-什么是-WebFlux"><a href="#1-什么是-WebFlux" class="headerlink" title="1.什么是 WebFlux"></a>1.什么是 WebFlux</h2><p>首先我们来看看什么是 WebFlux，Spring 官网上有一张经典的对比图：</p><p><img src="http://img.itboyhub.com/2021/02/20210607202806.png" alt></p><p>看着这张图，我们来仔细分析下传统的 SpringMVC 和 WebFlux 之间的区别。</p><p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问，所以 Spring WebFlux 可以有效提升系统的吞吐量和伸缩性，特别是在一些 IO 密集型应用中，Spring WebFlux 的优势明显。例如微服务网关 Spring Cloud Gateway 就使用了 WebFlux，这样可以有效提升网管对下游服务的吞吐量。</p><p><strong>不过需要注意的是，接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</strong></p><p>WebFlux 底层使用 Netty 容器，这点也和我们传统的 SpringMVC 不一样，不过默认端口都是 8080。WebFlux 另外也提供了对 Jetty 以及 Undertow 等容器的支持，具体使用方式和之前松哥 Spring Boot 系列中讲的一样，大家直接在 pom.xml 文件中添加相关的依赖即可。</p><p>不过需要注意的是，必须是 Servlet3.1+ 容器，如 Tomcat、Jetty，或者是非 Servlet 容器，如 Netty 和 Undertow。</p><h2 id="2-什么是-Reactor"><a href="#2-什么是-Reactor" class="headerlink" title="2.什么是 Reactor"></a>2.什么是 Reactor</h2><p>接下来还有一个概念需要和大家介绍，那就是 Reactor。</p><p>Spring Reactor 是 Pivotal 团队基于反应式编程实现的一种方案，这是一种非阻塞，并且由事件驱动的编程方案，它使用函数式编程实现。关于函数式编程，大家可以回顾松哥本系列前面的文章：<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>。</p><p>Reactor 是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”，它可以直接与 Java8 的函数式 API 直接集成，例如 CompletableFuture、各种 Stream 等。</p><p>Reactor 还提供了异步序列 API <strong>Flux</strong>（用于 N 个元素）和 <strong>Mono</strong>（用于 0|1 个元素），并完全遵循和实现了“响应式扩展规范”（Reactive Extensions Specification）。</p><p>换句话说，大家可以把 Reactor 理解为 Java8 中的 Stream（参见<a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a>）+ Java9 中的 Reactive Stream（参见<a href="https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA" target="_blank" rel="noopener">WebFlux 前置知识（四）</a>）。</p><p>上面说了这么多，大家最重要是要记住 Flux 和 Mono，因为这两个东西我们在后面会反复用到。</p><ul><li>Mono：实现发布者 Publisher<t>，并返回 0 或 1 个元素。</t></li><li>Flux：实现发布者 Publisher<t>，并返回 N 个元素。</t></li></ul><p>记住关键字，他俩都是发布者 Publisher<t>。</t></p><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><p>为了演示方便，松哥这里就直接采用 Spring Boot 工程了，首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210602192117.png" alt></p><p>添加上这一个依赖就 OK 了。</p><p>这个时候创建好的 Spring Boot 项目，底层容器是 Netty 而不是我们之前广泛使用的 Tomcat 了。</p><h3 id="3-1-Mono"><a href="#3-1-Mono" class="headerlink" title="3.1 Mono"></a>3.1 Mono</h3><p>项目创建成功后，我们可以先来体验一把 Mono 的功能，添加如下 Controller 进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">"hello2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 /hello 接口就是一个普通的 SpringMVC 中的接口，这个在这里也是支持的。后面的 /hello2 接口返回值则是一个 Mono<string> 对象。</string></p><p>接下来启动项目，然后我们就可以愉快的访问 /hello 和 /hello2 接口了。</p><p>有人可能会说这么写的意义何在呢？</p><p>上面这个例子确实看不出来意义，我们对上面的代码进行一个改进：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String helloStr = getHelloStr();</span><br><span class="line">        System.out.println(<span class="hljs-string">"普通接口耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="hljs-keyword">return</span> helloStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Mono&lt;String&gt; hello2 = Mono.fromSupplier(() -&gt; getHelloStr());</span><br><span class="line">        System.out.println(<span class="hljs-string">"WebFlux 接口耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="hljs-keyword">return</span> hello2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHelloStr</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们单独抽取出来一个方法 getHelloStr，在这个方法中，我们首先睡眠两秒钟，然后返回一个字符串，最后在接口中调用该方法获取返回的字符串。</p><p>需要注意的是，此时的 Mono<string> 是通过 Mono.fromSupplier 方法获取。</string></p><p>接下来启动项目，我们再次访问这两个接口，打印出来的日志信息如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210603210325.png" alt></p><p>可以看到：</p><ol><li>在普通接口中，请求会被阻塞，所以最终打印出来耗时 2001 毫秒。</li><li>在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li></ol><p>这下大家看到差异了吧！这比异步 Servlet 方便多了吧！</p><h3 id="3-2-Flux"><a href="#3-2-Flux" class="headerlink" title="3.2 Flux"></a>3.2 Flux</h3><p>Flux 是我们在 WebFlux 中常用的另外一种返回数据格式，我们一起来看下它的一个简单案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/flux"</span>,produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;String&gt; <span class="hljs-title">flux</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Flux&lt;String&gt; flux = Flux.fromArray(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"javaboy"</span>,<span class="hljs-string">"itboyhub"</span>,<span class="hljs-string">"www.javaboy.org"</span>,<span class="hljs-string">"itboyhub.com"</span>&#125;).map(s -&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"my-&gt;data-&gt;"</span> + s;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> flux;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flux 也是一个 Publisher，它可以由一个数组产生，上面的代码也都是基本的 Stream 操作，松哥就不再赘述了，不熟悉的小伙伴可以查看<a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a>。</p><p>需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即 <code>text/event-stream</code>。</p><p>启动后，在浏览器端访问，我们来看看结果：</p><p><img src="http://img.itboyhub.com/2021/02/6-2.gif" alt></p><p><strong>text/event-stream</strong></p><p>我们日常开发中，返回的 Content-Type 基本都是 <code>application/json</code> 或者 <code>text/html</code>，很少会用到 text/event-stream，这其实也是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别，这个松哥下次专门撸一篇文章和大家介绍，这里就先不展开了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天我们就先通过一个简单的案例和大家展示一下 WebFlux 的基本用法，当然这里还涉及到很多细节，松哥后面继续撸文章和大家介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面铺垫了五篇啦，是时候请出主角了。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>我要吐槽下跨平台</title>
    <link href="http://www.javaboy.org/2021/0606/platform.html"/>
    <id>http://www.javaboy.org/2021/0606/platform.html</id>
    <published>2021-06-06T13:32:44.000Z</published>
    <updated>2021-06-21T13:42:04.944Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作原因，接触了一点 uni-app，老实说，体验很不好，当然这不一定是 uni-app 的问题，跨平台这个需求本身就有点扯淡。</p><a id="more"></a><p>松哥接触跨平台的时间还是蛮早的，而且因为毕业后有一段时间在做移动端开发，而跨平台这种事本身就是移动端最火热，所以今天就来随便聊聊我曾经接触过的几种跨平台方案。</p><p>2012 年还在学校的时候，当时接触到的第一种跨平台方案就是 jQuery Mobile，那个年代 jQuery 是前端领域妥妥的当红小生，火热程度不亚于今天的 Vue。jQuery 官方顺势推出了 jQuery Mobile，用来支持移动端的开发。这种方案说白了就是开发基于浏览器的应用，然后在手机的浏览器上面跑。塞班、Windows Phone、Android、iOS 等都支持。但是实际上开发出来的 App，在塞班和 Windows Phone 上面的显示效果惨不忍睹。在低端 Android 手机上运行特别卡，点一下反应半天，就像浏览器网页一样慢，在三四千块的 Android 手机上或者 iPhone、iPad 上运行效果就很棒了，甚至有种原生 App 的错觉。</p><p>但是这种方案显然不是一个很好的跨平台方案，无法解决低端机上的运行效率问题，所以我一直好奇这种方案有没有商用价值？我刚刚打开 jQuery 的官网瞅了一眼，jQuery Mobile 还在，不知道小伙伴们在公司项目中有没有用过这种方案，欢迎留言说说。</p><p><img src="http://img.itboyhub.com/2021/02/20210526212556.png" alt></p><p>jQuery Mobile 是我接触的第一种跨平台方案，当时就是不懂 Android 开发，也不懂 iOS 开发，但是又想搞移动端应用，没办法就只能用 jQuery Mobile 搞了。虽然这种方案一点都不完美，但是却让我明白了跨平台的意义，多个平台同时存在时，就会一直有跨平台的需求，我们总想一套代码，运行多个平台。就像我们 Java，<code>Write once, run anywhere</code>。</p><p>当然用 jQuery Mobile 时候，还有一些配套工具如 PhoneGap、Cordova 等，这些就不一一说了。</p><p>大学刚毕业的时候，我在做 Android 开发，那一段时间接触了 RN（React Native），自己也上手学了一段时间，对 RN 整体的感觉就是运行效率比 jQuery Mobile 强多了，不过对于一个非专业前端来说，RN 上手也比 jQuery Mobile 难一些。不过 RN 我没搞太久，后来就去做 Java 了，从此很少关注移动端的东西。</p><p>不过作为一个称职的程序员，折腾是人生第一要义。搞 Java 后端开发没多久后，又玩起了小程序，现在除了微信有小程序，百度、支付宝、字节、QQ、360 等都有自己的小程序，于是大家又开始琢磨跨平台了，目前看起来比较火的似乎就是 uni-app 了。</p><p>我第一次了解到这个东西应该是在 2018 年的时候，当时我想趁着工作不忙学点东西，在晚上闲逛的时候看到了这个项目，当时感觉还是一个很小的项目，GitHub 上的 star 才 100 多，现在都 3W+ 了。不过因为之前搞移动端跨平台留下的阴影，我对这种跨平台方案都提不起兴趣，感觉都是牛皮吹的大，实际效果很有限。所以很长一段时间没，对 uni-app 的认知也只是停留在了解。</p><p>最近因为工作原因，没办法，接触了 uni-app，果然跟我想的差不多。真的很难做到 <code>Write once, run anywhere</code>，一些兼容性问题还是要特殊处理。而且这个框架还和 HBuilder 这个开发工具深度绑定，用这个工具开发就很方便，项目创建也要快很多。但是如果用 cli 命令行，那体验感就迅速下跌。而且按照官方给的模版创建出来的项目，刚打开后控制台就报错也让我很郁闷，这对新手来说是相当不友好的。</p><p>在这些问题里边我觉得最主要的还是兼容问题很难处理，无法真正做到 <code>Write once, run anywhere</code>，无法做到这一点，这个框架的意义就大打折扣了。</p><p>即使做纯粹的原生开发，都不可避免的遇到兼容问题，更不用说这种跨平台开发，兼容性问题只会多不会少。我也专门去问了身边的前端同事，他说其实还是有公司在用 uni-app，但是不多。</p><p>小伙伴们有没有用过一些跨平台的框架或者工具，欢迎留言说说你的使用感受～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作原因，接触了一点 uni-app，老实说，体验很不好，当然这不一定是 uni-app 的问题，跨平台这个需求本身就有点扯淡。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Platform" scheme="http://www.javaboy.org/tags/Platform/"/>
    
  </entry>
  
  <entry>
    <title>异步 Servlet 都不懂，谈何 WebFlux？</title>
    <link href="http://www.javaboy.org/2021/0602/webflux-async-servlet.html"/>
    <id>http://www.javaboy.org/2021/0602/webflux-async-servlet.html</id>
    <published>2021-06-02T13:31:19.000Z</published>
    <updated>2021-06-21T13:41:45.909Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常使用的 SpringMVC，基本上都不是异步 Servlet，而学习 WebFlux，异步 Servlet 是基础，因此松哥还是花点时间来和大家聊一聊什么是异步 Servlet，这有助于大家理解我们为什么需要 WebFlux。</p><a id="more"></a><h2 id="1-什么是异步-Servlet"><a href="#1-什么是异步-Servlet" class="headerlink" title="1.什么是异步 Servlet"></a>1.什么是异步 Servlet</h2><p>先来说说什么是非异步 Servlet。</p><p>在 Servlet3.0 之前，Servlet 采用 Thread-Per-Request 的方式处理 Http 请求，即每一次请求都是由某一个线程从头到尾负责处理。</p><p>如果一个请求需要进行 IO 操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待 IO 操作完成， 而 IO 操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，如果并发量很大的话，那肯定会造性能问题。</p><p>传统的 MVC 框架如 SpringMVC 也无法摆脱 Servlet 的桎梏，原因很简单，他们都是基于 Servlet 来实现的。如 SpringMVC 中大家所熟知的 DispatcherServlet（如果大家对于 SpringMVC 的原理不太理解，可以查看松哥之前的系列文章<a href="https://mp.weixin.qq.com/s/ldMcUawOtba8CgPgQtTIaA" target="_blank" rel="noopener">SpringMVC源码解读系列，20 篇干货完美收官！</a>）。</p><p>为了解决这一问题，Servlet3.0 中引入了异步 Servlet，然后在 Servlet3.1 中又引入了非阻塞 IO 来进一步增强异步处理的性能。</p><p>在正式开整 WebFlux 之前，我们先来了解下异步 Servlet 的一些基本玩法。</p><h2 id="2-版本关系"><a href="#2-版本关系" class="headerlink" title="2.版本关系"></a>2.版本关系</h2><p>我们要先看看 Servlet 和 Tomcat 之间的对应关系，毕竟异步 Servlet 这种事，用错了 Tomcat 版本可能就不支持了。</p><p>下图来自 Tomcat 官网（<a href="http://tomcat.apache.org/whichversion.html）：" target="_blank" rel="noopener">http://tomcat.apache.org/whichversion.html）：</a></p><p><img src="http://img.itboyhub.com/2021/02/20210601185454.png" alt></p><p>从上图我们可以看出，Servlet3.0 对应的 Tomcat 版本是 7.0.x，Servlet3.1 对应的 Tomcat 版本是 8.0.x。</p><p>换句话说，如果我们要使用异步 Servlet，Tomcat 至少要 7.0 以上的版本；如果你还想体验一把非阻塞 IO，那么 Tomcat 至少要 8.0 以上。</p><p>接下来的案例小伙伴们记得选好自己本地的 Tomcat 版本。</p><h2 id="3-基本玩法"><a href="#3-基本玩法" class="headerlink" title="3.基本玩法"></a>3.基本玩法</h2><p>先来看一个大家熟悉的同步 Servlet：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sync"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        printLog(request, response);</span><br><span class="line">        System.out.println(<span class="hljs-string">"总耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(<span class="hljs-string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Servlet 大家再熟悉不过了。</p><p>前端请求到达后，我们调用 printLog 方法做一些处理，同时把 doGet 方法执行耗时打印出来。</p><p>在 printLog 中，我们先休息 3s，然后给前端返回一个字符串给前端。</p><p>前端发送请求，最终 doGet 方法中耗时 3001 毫秒。</p><p>这是我们大家熟知的同步 Servlet。在整个请求处理过程中，请求会一直占用 Servlet 线程，直到一个请求处理完毕这个线程才会被释放。</p><p>接下来我们对其稍微进行改造，使之变为一个异步 Servlet。</p><p>有人可能会说，异步有何难？直接把 printLog 方法扔到子线程里边去执行不就行了？但是这样会有另外一个问题，子线程里边没有办法通过 HttpServletResponse 直接返回数据，所以我们一定需要 Servlet 的异步支持，有了异步支持，才可以在子线程中返回数据。</p><p>我们来看改造后的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/async"</span>,asyncSupported = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; printLog(asyncContext,asyncContext.getRequest(),asyncContext.getResponse()));</span><br><span class="line">        System.out.println(<span class="hljs-string">"总耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(AsyncContext asyncContext, ServletRequest request, ServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">            response.getWriter().write(<span class="hljs-string">"ok"</span>);</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改造主要有如下几方面：</p><ol><li>@WebServlet 注解上添加 asyncSupported 属性，开启异步支持。</li><li>调用 request.startAsync(); 方法开启异步上下文。</li><li>通过 JDK8 中的 CompletableFuture.runAsync 方法来启动一个子线程（当然也可以自己 new 一个子线程）。</li><li>调用 printLog 方法时的 request 和 response 重新构造，直接从 asyncContext 中获取，注意，这点是【关键】。</li><li>在 printLog 方法中，方法执行完成后，调用 asyncContext.complete() 方法通知异步上下文请求处理完毕。</li></ol><p>经过上面的改造之后，现在的控制台打印出来的总耗时几乎可以忽略不计了。</p><p>也就是说，<strong>有了异步 Servlet 之后，后台 Servlet 的线程会被及时释放，释放之后又可以去接收新的请求，进而提高应用的并发能力。</strong></p><p>第一次接触异步 Servlet 的小伙伴可能会有一个误解，以为用了异步 Servlet 后，前端的响应就会加快。这个怎么说呢？后台的并发能力提高了，前端的响应速度自然会提高，但是我们一两个简单的请求是很难看出这种提高的。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和大家分享一下异步 Servlet，作为 WebFlux 的一个前奏。至此，我们的 WebFlux 前奏已经更新了五篇了，即将进入 WebFlux 的殿堂。</p><p>前四篇前置知识传送门：</p><ol><li><a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a></li><li><a href="https://mp.weixin.qq.com/s/QZYcQFJDxTw0V-E0DTNOIw" target="_blank" rel="noopener">WebFlux 前置知识（二）</a></li><li><a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a></li><li><a href="https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA" target="_blank" rel="noopener">WebFlux 前置知识（四）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们日常使用的 SpringMVC，基本上都不是异步 Servlet，而学习 WebFlux，异步 Servlet 是基础，因此松哥还是花点时间来和大家聊一聊什么是异步 Servlet，这有助于大家理解我们为什么需要 WebFlux。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（四）</title>
    <link href="http://www.javaboy.org/2021/0601/webflux-publisher-subscriber.html"/>
    <id>http://www.javaboy.org/2021/0601/webflux-publisher-subscriber.html</id>
    <published>2021-06-01T13:31:01.000Z</published>
    <updated>2021-06-21T13:41:37.895Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Backpressure"><a href="#1-Backpressure" class="headerlink" title="1.Backpressure"></a>1.Backpressure</h2><p>Backpressure 在国内被翻译成背压，这个翻译在网上被很多人吐槽，我觉得大家的吐槽是有道理的，背压单纯从字面上确实看不出来有什么意思。所以松哥这里直接用英文 Backpressure 吧。</p><a id="more"></a><p>Backpressure 是一种现象：当数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure。</p><p>换句话说，上游生产数据，生产完成后通过管道将数据传到下游，下游消费数据，当下游消费速度小于上游数据生产速度时，数据在管道中积压会对上游形成一个压力，这就是 Backpressure，从这个角度来说，Backpressure 翻译成反压、回压似乎更合理一些。</p><p>Backpressure 会出现在有 Buffer 上限的系统中，当出现 Buffer 溢出的时候，就会有 Backpressure，对于 Backpressure，它的应对措施只有一个：丢弃新事件。那么什么是 Buffer 溢出呢？例如我的服务器可以同时处理 2000 个用户请求，那么我就把请求上限设置为 2000，这个 2000 就是我的 Buffer，当超出 2000 的时候，就产生了 Backpressure。</p><h2 id="2-Flow-API"><a href="#2-Flow-API" class="headerlink" title="2.Flow API"></a>2.Flow API</h2><p>JDK9 中推出了 Flow API，用以支持 Reactive Programming，即响应式编程。</p><p>在响应式编程中，会有一个数据发布者 Publisher 和数据订阅者 Subscriber，Subscriber 接收 Publisher 发布的数据并进行消费，在 Subscriber 和 Publisher 之间还存在一个 Processor，类似于一个过滤器，可以对数据进行中间处理。</p><p><img src="http://img.itboyhub.com/2021/02/20210527210826.png" alt></p><p>JDK9 中提供了 Flow API 用以支持响应式编程，另外 RxJava 和 Reactor 等框架也提供了相关的实现。</p><p>我们来看看 JDK9 中的 Flow 类：</p><p><img src="http://img.itboyhub.com/2021/02/20210527202428.png" alt></p><p>非常简洁，基本上就是按照 Reactive Programming 的设计来的：</p><p><strong>Publisher</strong></p><p>Publisher 为数据发布者，这是一个函数式接口，里边只有一个方法，通过这个方法将数据发布出去，Publisher 的定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Publisher</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Subscriber</strong></p><p>Subscriber 为数据订阅者，这个里边有四个方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subscriber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T item)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onSubscribe：这个是订阅成功的回调方法，用于初始化 Subscription，并且表明可以开始接收订阅数据了。</li><li>onNext：接收下一项订阅数据的回调方法。</li><li>onError：在 Publisher 或 Subcriber 遇到不可恢复的错误时调用此方法，之后 Subscription 不会再调用 Subscriber 其他的方法。</li><li>onComplete：当接收完所有订阅数据，并且发布者已经关闭后会回调这个方法。</li></ul><p><strong>Subscription</strong></p><p>Subscription 为发布者和订阅者之间的订阅关系，用来控制消息的消费，这个里边有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>request：这个方法用来向数据发布者请求 n 个数据。</li><li>cancel：取消消息订阅，订阅者将不再接收数据。</li></ul><p><strong>Processor</strong></p><p>Processor 是一个空接口，不过它同时继承了 Publisher 和 Subscriber，所以它既能发布数据也能订阅数据，因此我们可以通过 Processor 来完成一些数据转换的功能，先接收数据进行处理，处理完成后再将数据发布出去，这个也有点类似于我们 JavaEE 中的过滤器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processor</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Subscriber</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Publisher</span>&lt;<span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-消息订阅初体验"><a href="#2-1-消息订阅初体验" class="headerlink" title="2.1 消息订阅初体验"></a>2.1 消息订阅初体验</h3><p>我们通过如下一段代码体验一下消息的订阅与发布：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="hljs-comment">//配置发布者和订阅者</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-comment">//发送数据</span></span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>松哥稍微解释一下上面这段代码：</p><ol><li>首先创建一个 SubmissionPublisher 对象作为消息发布者。</li><li>接下来创建 Flow.Subscriber 对象作为消息订阅者，实现消息订阅者里边的四个方法，分别进行处理。</li><li>为 publisher 配置上 subscriber。</li><li>发送消息。</li><li>消息发送完成后关闭 publisher。</li><li>最后是让程序不要停止，观察消息订阅者打印情况。</li></ol><h3 id="2-2-模拟-Backpressure"><a href="#2-2-模拟-Backpressure" class="headerlink" title="2.2 模拟 Backpressure"></a>2.2 模拟 Backpressure</h3><p>Backpressure 问题在 Flow API 中得到了很好的解决。Subscriber 会将 Publisher 发布的数据缓存在 Subscription 中，其长度默认为256，相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flow</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">defaultBufferSize</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> DEFAULT_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦超出这个数据量，publisher 就会降低数据发送速度。</p><p>我们对上面的案例进行修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"i---------&gt;"</span> + i);</span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共修改了三个地方：</p><ol><li>Subscriber#onNext 方法中，每次休息两秒再处理下一条数据。</li><li>发布数据时，一共发布 500 条数据。</li><li>打印数据发布的日志。</li></ol><p>修改完成后，我们再次启动项目，观察控制台输出：</p><p><img src="http://img.itboyhub.com/2021/02/6jkfdajfklsdjfk-1.gif" alt></p><p>可以看到，生产者先是一股脑生产了 257 条数据（hello0 在一开始就被消费了，所以缓存中实际上是 256 条），消息则是一条一条的来，由于消费的速度比较慢，所以当缓存中的数据超过 256 条之后，接下来都是消费一条，再发送一条。</p><h3 id="2-3-数据处理"><a href="#2-3-数据处理" class="headerlink" title="2.3 数据处理"></a>2.3 数据处理</h3><p><code>Flow.Processor</code> 可以像过滤器一样，对数据进行预处理，数据从 publisher 出来之后，先进入 <code>Flow.Processor</code> 中进行预处理，然后再进入 Subscriber。</p><p>修改后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SubmissionPublisher</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Flow</span>.<span class="hljs-title">Processor</span>&lt;<span class="hljs-title">String</span>,<span class="hljs-title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.submit(<span class="hljs-string">"【这是一条被处理过的数据】"</span> + item);</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line">        DataFilter dataFilter = <span class="hljs-keyword">new</span> DataFilter();</span><br><span class="line">        publisher.subscribe(dataFilter);</span><br><span class="line"></span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dataFilter.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"发送消息 i---------&gt;"</span> + i);</span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单起见，我这里创建了一个局部内部类 DataFilter，DataFilter 继承自 SubmissionPublisher 并实现了 Flow.Processor 接口，由于 DataFilter 继承自 SubmissionPublisher，所以它也兼具 SubmissionPublisher 的功能。</p><p>在 DataFilter 中完成消息的处理并重新发送出去。接下来定义 publisher，让 dataFilter 作为其订阅者，再定义新的订阅者，作为 dataFilter 的订阅者。</p><p>最终运行效果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210529131117.png" alt></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就是今天和大家介绍的 Java9 中的 Reactive Stream，那么至此，我们的 WebFlux 前置知识差不多告一段落了，下篇文章开始，正式开整 WebFlux。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-Backpressure&quot;&gt;&lt;a href=&quot;#1-Backpressure&quot; class=&quot;headerlink&quot; title=&quot;1.Backpressure&quot;&gt;&lt;/a&gt;1.Backpressure&lt;/h2&gt;&lt;p&gt;Backpressure 在国内被翻译成背压，这个翻译在网上被很多人吐槽，我觉得大家的吐槽是有道理的，背压单纯从字面上确实看不出来有什么意思。所以松哥这里直接用英文 Backpressure 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（三）</title>
    <link href="http://www.javaboy.org/2021/0527/webflux-stream.html"/>
    <id>http://www.javaboy.org/2021/0527/webflux-stream.html</id>
    <published>2021-05-27T13:30:33.000Z</published>
    <updated>2021-06-21T13:41:28.371Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Stream 流式 API 也是 JDK8 开始引入的 API，用过的小伙伴都说爽，没用过的小伙伴则感到一脸懵逼。现在 JDK 已经到 16 了，可能很多人还不熟悉 Stream 流操作，这次趁着讲 WebFlux，松哥也来和大家一起回顾一下 Stream 流操作。</p><a id="more"></a><p>老实说，松哥在日常工作中，有时候刚好碰上了也会用 Stream 流，用着确实很爽，代码简洁，而且看起来高大上，确实是一个不错的东西。不过组里有很多人其实并不太熟悉 Stream 操作，所以也就没有去强行推广，但是作为一个合格的程序员，还是很有必要去学习一下 Stream 流操作的。</p><h2 id="1-Stream-流简介"><a href="#1-Stream-流简介" class="headerlink" title="1.Stream 流简介"></a>1.Stream 流简介</h2><p>说到 Stream，大家可能很容易想到 Java IO 中的各种流操作，名字看起来很像，但这其实是两个完全不同的东西。</p><p>Java8 中的 Stream 不存储数据，它通过函数式编程模式来对集合进行链状流式操作。</p><h2 id="2-基本玩法"><a href="#2-基本玩法" class="headerlink" title="2.基本玩法"></a>2.基本玩法</h2><p>先来个简单的例子感受下 Stream 的操作。</p><p>例如我有一个数组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>现在想给这个数组求平均数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span> asDouble = IntStream.of(arr).average().getAsDouble();</span><br></pre></td></tr></table></figure><p>一行代码搞定，首先调用 IntStream.of 方法获取流对象，然后调用 average 方法计算平均数，再调用 getAsDouble 方法获取结果。全程都是方法调用，不用自己写求平均数的逻辑。</p><p>再比如求和，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> sum = IntStream.of(arr).sum();</span><br></pre></td></tr></table></figure><p>也是直接调用 sum 方法即可。</p><p>而且我们还可以在流中对数据进行二次加工，例如给数组中的每个元素先求平方再求和：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">double</span> sum = DoubleStream.of(arr).map(i -&gt; Math.pow(i, <span class="hljs-number">2</span>)).sum();</span><br></pre></td></tr></table></figure><p>先在 Map 中对每一个元素求平方，然后再求和。</p><p>这里就能涉及到两个概念：</p><ul><li>中间操作</li><li>终止操作</li></ul><p>所谓中间操作，就是中途求平方的操作，所谓终止操作就是最终计算出结果的操作，只要方法的返回值不是一个 Stream，那就是终止操作，否则就是中间操作。</p><h2 id="3-Stream-的创建"><a href="#3-Stream-的创建" class="headerlink" title="3.Stream 的创建"></a>3.Stream 的创建</h2><p>获取一个流的方式多种多样，最常见的就是从集合或者数组中获取一个流，当然我们也可以直接自己创建一个流出来。</p><p>一起来看下。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>List 集合或者 Set 集合都可以直接搞一个流出来，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s1 = list.stream();</span><br><span class="line">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s2 = set.stream();</span><br></pre></td></tr></table></figure><p>集合中直接调用 stream 方法就可以获取到流。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>通过数组获取流的方式也很简单，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="数字-Stream"><a href="#数字-Stream" class="headerlink" title="数字 Stream"></a>数字 Stream</h3><p>也可以直接利用 IntStream、LongStream 等对象创建一个数字 Stream，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream s1 = IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">DoubleStream s2 = DoubleStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">LongStream s3 = LongStream.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">3L</span>);</span><br></pre></td></tr></table></figure><h3 id="自己创建"><a href="#自己创建" class="headerlink" title="自己创建"></a>自己创建</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; random.nextInt(<span class="hljs-number">100</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.generate(supplier).limit(<span class="hljs-number">5</span>);</span><br></pre></td></tr></table></figure><p>调用  Stream.generate 方法可以自己创建一个流，自己创建的时候需要提供一个 Supplier，通过调用 Supplier 中的 get 方法自动获取到元素。</p><p>无论哪种创建方式，大家需要明白的是，Stream 并不会保存数据，它只会对数据进行加工。</p><h2 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4.Stream 的中间操作"></a>4.Stream 的中间操作</h2><p>中间操作可以分为两大类：</p><ul><li>map 或者 filter 会从输入流中获取每一个元素，并且在输出流中得到一个结果，这些操作没有内部状态，称为无状态操作。</li><li>reduce、sum、max 这些操作都需要内部状态来累计计算结果，所以称为有状态操作。</li></ul><p>分别来看下：</p><p><strong>无状态操作</strong></p><ul><li>map/mapToXxx</li><li>flatMap/flatMapToXxx</li><li>filter</li><li>peek</li></ul><p><strong>有状态操作</strong></p><ul><li>distinct</li><li>sorted</li><li>limit/skip</li></ul><p><strong>map</strong></p><p>Stream.map() 是 Stream 中最常用的一个转换方法，可以把一个 Stream 对象转为另外一个 Stream 对象。map 方法所接收的参数就是一个 Function 对象，松哥在前面文章中和大家介绍过 Function 对象了，就是有输入有输出（参见<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>），了解了 map 的参数，那么 map 的功能就很明白了，就是对数据进行二次加工。</p><p>举个栗子，例如把一个字符串数组转为数字：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; s1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s1.map(i -&gt; Integer.valueOf(i));</span><br></pre></td></tr></table></figure><p>再比如一个数字流，给所有的元素乘 2，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(i -&gt; <span class="hljs-number">2</span> * i).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>最后的 forEach 就是将元素打印出来。</p><p>JDK 中也提供了一些现成的格式转换，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210522200906.png" alt></p><p>这样可以直接将元素转为 Double、Long、Obj 等类型，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; s1 = Arrays.stream(arr);</span><br><span class="line">s1.mapToLong(i -&gt; Long.parseLong(i)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong></p><p>flatMap 可以把 Stream 中的每个元素都映射为一个 Stream，然后再把这多个 Stream 合并为一个 Stream。</p><p>例如如下代码，返回的 Stream 中的元素是数组：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer[]&gt; s = Stream.of(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>通过 flatMap 我们可以将 Stream 中的元素变为 Integer：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;).flatMap( i -&gt; Arrays.stream(i));</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>filter</strong></p><p>filter 操作会对一个 Stream 中的所有元素一一进行判断，不满足条件的就被过滤掉了，剩下的满足条件的元素就构成了一个新的 Stream。</p><p>例如要找到数组中所有大于 3 的元素，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).filter(i -&gt; i &gt; <span class="hljs-number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>filter 方法接收的参数是 Predicate 接口函数，关于 Predicate 接口函数，大家可以参考<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>）一文。</p><p><strong>peek</strong></p><p>peek 的入参是 Consumer，没有返回值，因此当我们要对元素内部进行处理时，使用 peek 是比较合适的，这个时候可以不用 map（map 的入参是 Function，它是有返回值的）。peek 方法本身会继续返回流，可以对数据继续进行处理。</p><p>举个简单的数据转换的例子吧（最终返回的数据并不会被转换）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).filter(i -&gt; i &gt; <span class="hljs-number">3</span>).peek(String::valueOf).forEach(i-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><blockquote><p>peek 方法的感觉就像数据中途被消费了一次。</p></blockquote><p><strong>distinct</strong></p><p>这个是去重。由于去重操作需要获取到其他元素的值（比较之后才知道是否重复），所以这个是有状态操作。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>sorted</strong></p><p>sorted 是排序，因为也需要知道其他元素的值，然后才能去重，所以这个也是有状态操作，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).distinct().sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>limit/skip</strong></p><p>limit 和 skip 配合操作有点像数据库中的分页，skip 表示跳过 n 个元素，limit 表示取出 n 个元素。例如下面这个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>).stream().skip(<span class="hljs-number">2</span>).limit(<span class="hljs-number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这个会跳过 A 和 B，最终打印出 C D E。这也是一种有状态操作。</p><h2 id="5-Stream-终止操作"><a href="#5-Stream-终止操作" class="headerlink" title="5.Stream 终止操作"></a>5.Stream 终止操作</h2><p>终止操作就是最终计算出结果的操作，只要方法的返回值不是一个 Stream，那就是终止操作，否则就是中间操作。</p><p>终止操作又分为两类：</p><ul><li>短路操作：不用处理全部元素就可以返回结果。</li><li>非短路操作：必须处理所有元素才能得到最终结果。</li></ul><p>各自都包含哪些操作，我们分别来看下：</p><p><strong>非短路操作</strong></p><ul><li>forEach/forEachOrdered</li><li>collect/toArray</li><li>reduce</li><li>min/max/count</li></ul><p><strong>短路操作</strong></p><ul><li>findFirst/findAny</li><li>allMatch/anyMatch/noneMatch</li></ul><p><strong>forEach/forEachOrdered</strong></p><p>forEach 和 forEachOrdered 都是接收一个 Consumer 类型的参数，完成对参数的消费，不同的是，在并行流中，forEachOrdered 会保证执行顺序。</p><p>例如如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;</span><br><span class="line">Arrays.stream(arr).parallel().forEach(System.out::println);</span><br><span class="line">Arrays.stream(arr).parallel().forEachOrdered(System.out::println);</span><br></pre></td></tr></table></figure><p>前者打印出来的顺序不一定是 123456789，后者一定是。</p><p><strong>collect/toArray</strong></p><p>这两个都是收集器，可以将执行结果转为一个 List 集合或者一个数组：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter(p -&gt; p &gt; <span class="hljs-number">2</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>reduce</strong></p><p>reduce 是 Stream 的一个聚合方法，它可以把一个 Stream 的所有元素按照聚合函数聚合成一个结果。reduce 方法传入的对象是BinaryOperator 接口，它定义了一个apply 方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果。</p><p>举个简单的例子，数组求和，当然可以直接调用 sum 计算，我们这里也可以调用 reduce 来实现，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduce((i, j) -&gt; i + j);</span><br><span class="line">System.out.println(optional.orElse(-<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>reduce 的参数是 BinaryOperator，这个接收两个参数，第一个参数是之前计算的结果，第二个参数是本次参与计算的元素，两者累加求和。</p><p>再比如给一段话中间加上.，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; s = Stream.of(<span class="hljs-string">"wwwjavaboyorg"</span>.split(<span class="hljs-string">""</span>)).reduce((i, j) -&gt; i + <span class="hljs-string">"."</span> + j);</span><br><span class="line">System.out.println(s.orElse(<span class="hljs-string">""</span>));</span><br></pre></td></tr></table></figure><p>最终执行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.w.w.j.a.v.a.b.o.y.o.r.g</span><br></pre></td></tr></table></figure><p><strong>min/max/count</strong></p><p>这个就比较简单了，就是求最大值最小值，统计总个数，如下表示统计总个数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">long</span> count = s.count();</span><br><span class="line">System.out.println(<span class="hljs-string">"count = "</span> + count);</span><br></pre></td></tr></table></figure><p>如下表示统计最小值：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">Optional&lt;Integer&gt; min = s.min(Comparator.comparingInt(i -&gt; i));</span><br><span class="line">System.out.println(<span class="hljs-string">"min.get() = "</span> + min.get());</span><br></pre></td></tr></table></figure><p><strong>findFirst/findAny</strong></p><p>这两个就是返回流中的第一个、任意一个元素，findAny 要在并行流中测试才有效果，举个栗子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">    Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).parallel().findFirst();</span><br><span class="line">    System.out.println(<span class="hljs-string">"first.get() = "</span> + first.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="hljs-string">"============="</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">    Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).parallel().findAny();</span><br><span class="line">    System.out.println(<span class="hljs-string">"first.get() = "</span> + first.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>allMatch/anyMatch/noneMatch</strong></p><p>allMatch、anyMatch、noneMatch 用来判断所有元素、任意元素或者没有元素满足给定的条件。这三个方法的参数都是一个 Predicate 接口函数。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">boolean</span> b = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).allMatch(i -&gt; i &gt; <span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br></pre></td></tr></table></figure><h2 id="6-并行流"><a href="#6-并行流" class="headerlink" title="6.并行流"></a>6.并行流</h2><p>通常情况下，对 Stream 的元素进行处理是单线程的，即一个一个元素进行处理。有时候我们希望可以并行处理 Stream 元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p><p>把一个普通 Stream 转换为可以并行处理的 Stream 非常简单，只需要用 parallel 方法进行转换：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Random().ints().limit(<span class="hljs-number">50</span>).parallel().forEach(i-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"---&gt;"</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样数据在后台就是并行打印的。</p><h2 id="7-收集器"><a href="#7-收集器" class="headerlink" title="7.收集器"></a>7.收集器</h2><p>收集器可以将计算结果重新整理收集到一个集合中，这个集合可以是一个 List/Set 获取其他，并且还可以在收集的过程中对数据进行处理。</p><p>例如我有一个 users 集合，里边保存了用户数据，用户有 username、age 以及 gender 三个属性，如下代码分别表示：</p><ul><li>提取出用户对象中的 age 属性组成新的集合并返回。</li><li>提取出用户对象中的 username 属性组成新的集合并返回。</li><li>提取出用户对象中的 gender 属性组成新的集合并返回（这里是一个 Set 集合，所以会自动去重）。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ages = users.stream().map(User::getAge).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"ages = "</span> + ages);</span><br><span class="line">List&lt;String&gt; usernames = users.stream().map(User::getUsername).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"usernames = "</span> + usernames);</span><br><span class="line">Set&lt;String&gt; genders = users.stream().map(User::getGender).collect(Collectors.toSet());</span><br><span class="line">System.out.println(<span class="hljs-string">"genders = "</span> + genders);</span><br></pre></td></tr></table></figure><p><code>Collectors.toList()</code> 最终返回的是 ArrayList，<code>Collectors.toSet()</code> 最终返回的是 HashSet。</p><p>如果我们想返回一个 Vector 或者 TreeSet，也是可以的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ages = users.stream().map(User::getAge).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"ages = "</span> + ages);</span><br><span class="line">List&lt;String&gt; usernames = users.stream().map(User::getUsername).collect(Collectors.toCollection(Vector::<span class="hljs-keyword">new</span>));</span><br><span class="line">System.out.println(<span class="hljs-string">"usernames = "</span> + usernames);</span><br><span class="line">TreeSet&lt;String&gt; genders = users.stream().map(User::getGender).collect(Collectors.toCollection(TreeSet::<span class="hljs-keyword">new</span>));</span><br><span class="line">System.out.println(<span class="hljs-string">"genders = "</span> + genders);</span><br></pre></td></tr></table></figure><p>也可以获取某一个字段的统计信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageStatistics = users.stream().collect(Collectors.summarizingInt(User::getAge));</span><br><span class="line">System.out.println(<span class="hljs-string">"ageStatistics = "</span> + ageStatistics);</span><br></pre></td></tr></table></figure><p>这个统计信息中包含：总和、最小值、平均值以及最大值等：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ageStatistics = IntSummaryStatistics&#123;count=<span class="hljs-number">20</span>, sum=<span class="hljs-number">1222</span>, min=<span class="hljs-number">9</span>, average=<span class="hljs-number">61.100000</span>, max=<span class="hljs-number">96</span>&#125;</span><br></pre></td></tr></table></figure><p>还可以对数据进行分块，将男女不同性别统计出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;User&gt;&gt; map = users.stream().collect(Collectors.partitioningBy(u -&gt; u.getGender().equals(<span class="hljs-string">"男"</span>)));</span><br><span class="line">System.out.println(<span class="hljs-string">"map = "</span> + map);</span><br></pre></td></tr></table></figure><p>也可以按照性别对数据进行分组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;User&gt;&gt; map2 = users.stream().collect(Collectors.groupingBy(User::getGender));</span><br><span class="line">System.out.println(<span class="hljs-string">"map2 = "</span> + map2);</span><br></pre></td></tr></table></figure><p>分组后，Map 中的 key 就是性别；分块后，Map 中的 key 就是 true/false。</p><p>再比如统计男女的人数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; map2 = users.stream().collect(Collectors.groupingBy(User::getGender,Collectors.counting()));</span><br><span class="line">System.out.println(<span class="hljs-string">"map2 = "</span> + map2);</span><br></pre></td></tr></table></figure><p>好啦，今天我们就先聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Stream 流式 API 也是 JDK8 开始引入的 API，用过的小伙伴都说爽，没用过的小伙伴则感到一脸懵逼。现在 JDK 已经到 16 了，可能很多人还不熟悉 Stream 流操作，这次趁着讲 WebFlux，松哥也来和大家一起回顾一下 Stream 流操作。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
</feed>
